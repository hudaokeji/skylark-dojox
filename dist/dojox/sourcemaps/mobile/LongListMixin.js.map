{"version":3,"sources":["mobile/LongListMixin.js"],"names":["define","array","lang","declare","has","domConstruct","domGeometry","registry","dm","viewRegistry","pageSize","maxPages","unloadPages","startup","this","_started","inherited","arguments","editable","_sv","getEnclosingScrollable","domNode","_items","getChildren","_clearItems","containerNode","create","connect","hitch","_loadItems","_topDiv","_bottomDiv","_reloadItems","toPos","sv","h","getDim","d","cury","getPos","y","posy","visibleYMin","Math","min","visibleYMax","max","_loadedYMin","_addBefore","_loadedYMax","_addAfter","_firstIndex","_lastIndex","style","height","c","forEach","findWidgets","item","removeChild","i","count","oldBox","getMarginBox","place","newBox","_adjustTopDiv","toRemove","_adjustBottomDiv","length","_childrenChanged","_qs_timer","defer","resize","addChild","widget","insertIndex","splice","push","indexOf","slice","_getSiblingOfChild","child","dir","index","generateList","items","append","destroyRecursive"],"mappings":"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","file":"../../mobile/LongListMixin.js","sourcesContent":["define([ \"dojo/_base/array\",\r\n         \"dojo/_base/lang\",\r\n         \"dojo/_base/declare\",\r\n         \"dojo/sniff\",\r\n         \"dojo/dom-construct\",\r\n         \"dojo/dom-geometry\",\r\n         \"dijit/registry\",\r\n         \"./common\",\r\n         \"./viewRegistry\" ],\r\n\t\tfunction(array, lang, declare, has, domConstruct, domGeometry, registry, dm, viewRegistry){\r\n\r\n\t// module:\r\n\t//\t\tdojox/mobile/LongListMixin\r\n\t// summary:\r\n\t//\t\tA mixin that enhances performance of long lists contained in scrollable views.\r\n\r\n\treturn declare(\"dojox.mobile.LongListMixin\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tThis mixin enhances performance of very long lists contained in scrollable views.\r\n\t\t// description:\r\n\t\t//\t\tLongListMixin enhances a list contained in a ScrollableView\r\n\t\t//\t\tso that only a subset of the list items are actually contained in the DOM\r\n\t\t//\t\tat any given time. \r\n\t\t//\t\tThe parent must be a ScrollableView or another scrollable component\r\n\t\t//\t\tthat inherits from the dojox.mobile.scrollable mixin, otherwise the mixin has\r\n\t\t//\t\tno effect. Also, editable lists are not yet supported, so lazy scrolling is\r\n\t\t//\t\tdisabled if the list's 'editable' attribute is true.\r\n\t\t//\t\tIf this mixin is used, list items must be added, removed or reordered exclusively\r\n\t\t//\t\tusing the addChild and removeChild methods of the list. If the DOM is modified\r\n\t\t//\t\tdirectly (for example using list.containerNode.appendChild(...)), the list\r\n\t\t//\t\twill not behave correctly.\r\n\t\t\r\n\t\t// pageSize: int\r\n\t\t//\t\tItems are loaded in the DOM by chunks of this size.\r\n\t\tpageSize: 20,\r\n\t\t\r\n\t\t// maxPages: int\r\n\t\t//\t\tWhen this limit is reached, previous pages will be unloaded.\r\n\t\tmaxPages: 5,\r\n\t\t\r\n\t\t// unloadPages: int\r\n\t\t//\t\tNumber of pages that will be unloaded when maxPages is reached.\r\n\t\tunloadPages: 1,\r\n\t\t\r\n\t\tstartup : function(){\r\n\t\t\tif(this._started){ return; }\r\n\t\t\t\r\n\t\t\tthis.inherited(arguments);\r\n\r\n\t\t\tif(!this.editable){\r\n\r\n\t\t\t\tthis._sv = viewRegistry.getEnclosingScrollable(this.domNode);\r\n\r\n\t\t\t\tif(this._sv){\r\n\r\n\t\t\t\t\t// Get all children already added (e.g. through markup) and initialize _items\r\n\t\t\t\t\tthis._items = this.getChildren();\r\n\r\n\t\t\t\t\t// remove all existing items from the old container node\r\n\t\t\t\t\tthis._clearItems();\r\n\r\n\t\t\t\t\tthis.containerNode = domConstruct.create(\"div\", null, this.domNode);\r\n\r\n\t\t\t\t\t// listen to scrollTo and slideTo from the parent scrollable object\r\n\r\n\t\t\t\t\tthis.connect(this._sv, \"scrollTo\", lang.hitch(this, this._loadItems), true);\r\n\t\t\t\t\tthis.connect(this._sv, \"slideTo\", lang.hitch(this, this._loadItems), true);\r\n\r\n\t\t\t\t\t// The _topDiv and _bottomDiv elements are place holders for the items\r\n\t\t\t\t\t// that are not actually in the DOM at the top and bottom of the list.\r\n\r\n\t\t\t\t\tthis._topDiv = domConstruct.create(\"div\", null, this.domNode, \"first\");\r\n\t\t\t\t\tthis._bottomDiv = domConstruct.create(\"div\", null, this.domNode, \"last\");\r\n\r\n\t\t\t\t\tthis._reloadItems();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t_loadItems : function(toPos){\r\n\t\t\t// summary:\tAdds and removes items to/from the DOM when the list is scrolled.\r\n\t\t\t\r\n\t\t\tvar sv = this._sv; \t\t\t// ScrollableView\r\n\t\t\tvar h = sv.getDim().d.h;\r\n\t\t\tif(h <= 0){ return; } \t\t\t// view is hidden\r\n\r\n\t\t\tvar cury = -sv.getPos().y; // current y scroll position\r\n\t\t\tvar posy = toPos ? -toPos.y : cury;\r\n\r\n\t\t\t// get minimum and maximum visible y positions:\r\n\t\t\t// we use the largest area including both the current and new position\r\n\t\t\t// so that all items will be visible during slideTo animations\r\n\t\t\tvar visibleYMin = Math.min(cury, posy),\r\n\t\t\t\tvisibleYMax = Math.max(cury, posy) + h;\r\n\t\t\t\r\n\t\t\t// add pages at top and bottom as required to fill the visible area\r\n\t\t\twhile(this._loadedYMin > visibleYMin && this._addBefore()){ }\r\n\t\t\twhile(this._loadedYMax < visibleYMax && this._addAfter()){ }\r\n\t\t},\r\n\t\t\r\n\t\t_reloadItems: function(){\r\n\t\t\t// summary:\tResets the internal state and reloads items according to the current scroll position.\r\n\r\n\t\t\t// remove all loaded items\r\n\t\t\tthis._clearItems();\r\n\t\t\t\r\n\t\t\t// reset internal state\r\n\t\t\tthis._loadedYMin = this._loadedYMax = 0;\r\n\t\t\tthis._firstIndex = 0;\r\n\t\t\tthis._lastIndex = -1;\r\n\t\t\tthis._topDiv.style.height = \"0px\";\r\n\t\t\t\r\n\t\t\tthis._loadItems();\r\n\t\t},\r\n\t\t\r\n\t\t_clearItems: function(){\r\n\t\t\t// summary: Removes all currently loaded items.\r\n\t\t\tvar c = this.containerNode;\r\n\t\t\tarray.forEach(registry.findWidgets(c), function(item){\r\n\t\t\t\tc.removeChild(item.domNode);\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t_addBefore: function(){\r\n\t\t\t// summary:\tLoads pages of items before the currently visible items to fill the visible area.\r\n\t\t\t\r\n\t\t\tvar i, count;\r\n\t\t\t\r\n\t\t\tvar oldBox = domGeometry.getMarginBox(this.containerNode);\r\n\t\t\t\r\n\t\t\tfor(count = 0, i = this._firstIndex-1; count < this.pageSize && i >= 0; count++, i--){\r\n\t\t\t\tvar item = this._items[i];\r\n\t\t\t\tdomConstruct.place(item.domNode, this.containerNode, \"first\");\r\n\t\t\t\tif(!item._started){\r\n\t\t\t\t\titem.startup();\r\n\t\t\t\t}\r\n\t\t\t\tthis._firstIndex = i;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar newBox = domGeometry.getMarginBox(this.containerNode);\r\n\r\n\t\t\tthis._adjustTopDiv(oldBox, newBox);\r\n\t\t\t\r\n\t\t\tif(this._lastIndex - this._firstIndex >= this.maxPages*this.pageSize){\r\n\t\t\t\tvar toRemove = this.unloadPages*this.pageSize;\r\n\t\t\t\tfor(i = 0; i < toRemove; i++){\r\n\t\t\t\t\tthis.containerNode.removeChild(this._items[this._lastIndex - i].domNode);\r\n\t\t\t\t}\r\n\t\t\t\tthis._lastIndex -= toRemove;\r\n\t\t\t\t\r\n\t\t\t\tnewBox = domGeometry.getMarginBox(this.containerNode);\r\n\t\t\t}\r\n\r\n\t\t\tthis._adjustBottomDiv(newBox);\r\n\t\t\t\r\n\t\t\treturn count == this.pageSize;\r\n\t\t},\r\n\t\t\r\n\t\t_addAfter: function(){\r\n\t\t\t// summary:\tLoads pages of items after the currently visible items to fill the visible area.\r\n\t\t\t\r\n\t\t\tvar i, count;\r\n\t\t\t\r\n\t\t\tvar oldBox = null;\r\n\t\t\t\r\n\t\t\tfor(count = 0, i = this._lastIndex+1; count < this.pageSize && i < this._items.length; count++, i++){\r\n\t\t\t\tvar item = this._items[i];\r\n\t\t\t\tdomConstruct.place(item.domNode, this.containerNode);\r\n\t\t\t\tif(!item._started){\r\n\t\t\t\t\titem.startup();\r\n\t\t\t\t}\r\n\t\t\t\tthis._lastIndex = i;\r\n\t\t\t}\r\n\t\t\tif(this._lastIndex - this._firstIndex >= this.maxPages*this.pageSize){\r\n\t\t\t\toldBox = domGeometry.getMarginBox(this.containerNode);\r\n\t\t\t\tvar toRemove = this.unloadPages*this.pageSize;\r\n\t\t\t\tfor(i = 0; i < toRemove; i++){\r\n\t\t\t\t\tthis.containerNode.removeChild(this._items[this._firstIndex + i].domNode);\r\n\t\t\t\t}\r\n\t\t\t\tthis._firstIndex += toRemove;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar newBox = domGeometry.getMarginBox(this.containerNode);\r\n\r\n\t\t\tif(oldBox){\r\n\t\t\t\tthis._adjustTopDiv(oldBox, newBox);\r\n\t\t\t}\r\n\t\t\tthis._adjustBottomDiv(newBox);\r\n\r\n\t\t\treturn count == this.pageSize;\r\n\t\t},\r\n\t\t\r\n\t\t_adjustTopDiv: function(oldBox, newBox){\r\n\t\t\t// summary:\tAdjusts the height of the top filler div after items have been added/removed.\r\n\t\t\t\r\n\t\t\tthis._loadedYMin -= newBox.h - oldBox.h;\r\n\t\t\tthis._topDiv.style.height = this._loadedYMin + \"px\";\r\n\t\t},\r\n\t\t\r\n\t\t_adjustBottomDiv: function(newBox){\r\n\t\t\t// summary:\tAdjusts the height of the bottom filler div after items have been added/removed.\r\n\t\t\t\r\n\t\t\t// the total height is an estimate based on the average height of the already loaded items\r\n\t\t\tvar h = this._lastIndex > 0 ? (this._loadedYMin + newBox.h) / this._lastIndex : 0;\r\n\t\t\th *= this._items.length - 1 - this._lastIndex;\r\n\t\t\tthis._bottomDiv.style.height = h + \"px\";\r\n\t\t\tthis._loadedYMax = this._loadedYMin + newBox.h;\r\n\t\t},\r\n\t\t\r\n\t\t_childrenChanged : function(){\r\n\t\t\t// summary: Called by addChild/removeChild, updates the loaded items.\r\n\t\t\t\r\n\t\t\t// Whenever an item is added or removed, this may impact the loaded items,\r\n\t\t\t// so we have to clear all loaded items and recompute them. We cannot afford \r\n\t\t\t// to do this on every add/remove, so we use a timer to batch these updates.\r\n\t\t\t// There would probably be a way to update the loaded items on the fly\r\n\t\t\t// in add/removeChild, but at the cost of much more code...\r\n\t\t\tif(!this._qs_timer){\r\n\t\t\t\tthis._qs_timer = this.defer(function(){\r\n\t\t\t\t\tdelete this._qs_timer;\r\n\t\t\t\t\tthis._reloadItems();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tresize: function(){\r\n\t\t\t// summary: Loads/unloads items to fit the new size\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tif(this._items){\r\n\t\t\t\tthis._loadItems();\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t// The rest of the methods are overrides of _Container and _WidgetBase.\r\n\t\t// We must override them because children are not all added to the DOM tree\r\n\t\t// under the list node, only a subset of them will really be in the DOM,\r\n\t\t// but we still want the list to look as if all children were there.\r\n\r\n\t\taddChild : function(/* dijit._Widget */widget, /* int? */insertIndex){\r\n\t\t\t// summary: Overrides dijit._Container\r\n\t\t\tif(this._items){\r\n\t\t\t\tif( typeof insertIndex == \"number\"){\r\n\t\t\t\t\tthis._items.splice(insertIndex, 0, widget);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis._items.push(widget);\r\n\t\t\t\t}\r\n\t\t\t\tthis._childrenChanged();\r\n\t\t\t}else{\r\n\t\t\t\tthis.inherited(arguments);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tremoveChild : function(/* Widget|int */widget){\r\n\t\t\t// summary: Overrides dijit._Container\r\n\t\t\tif(this._items){\r\n\t\t\t\tthis._items.splice(typeof widget == \"number\" ? widget : this._items.indexOf(widget), 1);\r\n\t\t\t\tthis._childrenChanged();\r\n\t\t\t}else{\r\n\t\t\t\tthis.inherited(arguments);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetChildren : function(){\r\n\t\t\t// summary: Overrides dijit._WidgetBase\r\n\t\t\tif(this._items){\r\n\t\t\t\treturn this._items.slice(0);\r\n\t\t\t}else{\r\n\t\t\t\treturn this.inherited(arguments);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_getSiblingOfChild : function(/* dijit._Widget */child, /* int */dir){\r\n\t\t\t// summary: Overrides dijit._Container\r\n\r\n\t\t\tif(this._items){\r\n\t\t\t\tvar index = this._items.indexOf(child);\r\n\t\t\t\tif(index >= 0){\r\n\t\t\t\t\tindex = dir > 0 ? index++ : index--;\r\n\t\t\t\t}\r\n\t\t\t\treturn this._items[index];\r\n\t\t\t}else{\r\n\t\t\t\treturn this.inherited(arguments);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tgenerateList: function(/*Array*/items){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverrides dojox.mobile._StoreListMixin when the list is a store list.\r\n\t\t\t\r\n\t\t\tif(this._items && !this.append){\r\n\t\t\t\t// _StoreListMixin calls destroyRecursive to delete existing items, not removeChild,\r\n\t\t\t\t// so we must remove all logical items (i.e. clear _items) before reloading the store.\r\n\t\t\t\t// And since the superclass destroys all children returned by getChildren(), and\r\n\t\t\t\t// this would actually return no children because _items is now empty, we must\r\n\t\t\t\t// destroy all children manually first.\r\n\t\t\t\tarray.forEach(this.getChildren(), function(child){\r\n\t\t\t\t\tchild.destroyRecursive();\r\n\t\t\t\t});\r\n\t\t\t\tthis._items = [];\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t}\r\n\t});\r\n});\r\n"]}