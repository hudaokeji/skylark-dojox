{"version":3,"sources":["mobile/app/_FormWidget.js"],"names":["dojo","provide","experimental","require","declare","dijit","_WidgetBase","name","alt","value","type","disabled","intermediateChanges","scrollOnFocus","attributeMap","delegate","prototype","id","title","postMixInProperties","this","nameAttrSetting","replace","inherited","arguments","postCreate","connect","domNode","_setDisabledAttr","attr","focusNode","valueNode","_onFocus","e","window","scrollIntoView","isFocusable","readOnly","style","focus","compare","val1","val2","isNaN","onChange","newValue","_onChangeActive","_handleOnChange","priorityChange","_lastValue","undefined","_lastValueReported","_resetValue","_onChangeHandle","clearTimeout","setTimeout","hitch","create","destroy","_onMouseDown","mouseUpConnector","body","disconnect","selectInputText","element","start","stop","_window","global","doc","byId","length","setSelectionRange","dojox","mobile","app","_FormWidget","_setReadOnlyAttr","_setValueAttr","_getValueAttr","undo","reset","_hasBeenBlurred"],"mappings":"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","file":"../../../mobile/app/_FormWidget.js","sourcesContent":["dojo.provide(\"dojox.mobile.app._FormWidget\");\r\ndojo.experimental(\"dojox.mobile.app._FormWidget\");\r\n\r\ndojo.require(\"dojo.window\");\r\n\r\ndojo.require(\"dijit._WidgetBase\");\r\ndojo.require(\"dijit.focus\");\t// dijit.focus()\r\n\r\ndojo.declare(\"dojox.mobile.app._FormWidget\", dijit._WidgetBase, {\r\n\t// summary:\r\n\t//\t\tBase class for widgets corresponding to native HTML elements such as `<checkbox>` or `<button>`,\r\n\t//\t\twhich can be children of a `<form>` node or a `dojox.mobile.app.Form` widget.\r\n\t//\r\n\t// description:\r\n\t//\t\tRepresents a single HTML element.\r\n\t//\t\tAll these widgets should have these attributes just like native HTML input elements.\r\n\t//\t\tYou can set them during widget construction or afterwards, via `dijit._WidgetBase.attr`.\r\n\t//\r\n\t//\t\tThey also share some common methods.\r\n\r\n\t// name: String\r\n\t//\t\tName used when submitting form; same as \"name\" attribute or plain HTML elements\r\n\tname: \"\",\r\n\r\n\t// alt: String\r\n\t//\t\tCorresponds to the native HTML `<input>` element's attribute.\r\n\talt: \"\",\r\n\r\n\t// value: String\r\n\t//\t\tCorresponds to the native HTML `<input>` element's attribute.\r\n\tvalue: \"\",\r\n\r\n\t// type: String\r\n\t//\t\tCorresponds to the native HTML `<input>` element's attribute.\r\n\ttype: \"text\",\r\n\r\n\t// disabled: Boolean\r\n\t//\t\tShould this widget respond to user input?\r\n\t//\t\tIn markup, this is specified as \"disabled='disabled'\", or just \"disabled\".\r\n\tdisabled: false,\r\n\r\n\t// intermediateChanges: Boolean\r\n\t//\t\tFires onChange for each value change or only on demand\r\n\tintermediateChanges: false,\r\n\r\n\t// scrollOnFocus: Boolean\r\n\t//\t\tOn focus, should this widget scroll into view?\r\n\tscrollOnFocus: false,\r\n\r\n\t// These mixins assume that the focus node is an INPUT, as many but not all _FormWidgets are.\r\n\tattributeMap: dojo.delegate(dijit._WidgetBase.prototype.attributeMap, {\r\n\t\tvalue: \"focusNode\",\r\n\t\tid: \"focusNode\",\r\n\t\talt: \"focusNode\",\r\n\t\ttitle: \"focusNode\"\r\n\t}),\r\n\r\n\tpostMixInProperties: function(){\r\n\t\t// Setup name=foo string to be referenced from the template (but only if a name has been specified)\r\n\t\t// Unfortunately we can't use attributeMap to set the name due to IE limitations, see #8660\r\n\t\t// Regarding escaping, see heading \"Attribute values\" in\r\n\t\t// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2\r\n\t\tthis.nameAttrSetting = this.name ? ('name=\"' + this.name.replace(/'/g, \"&quot;\") + '\"') : '';\r\n\t\tthis.inherited(arguments);\r\n\t},\r\n\r\n\tpostCreate: function(){\r\n\t\tthis.inherited(arguments);\r\n\t\tthis.connect(this.domNode, \"onmousedown\", \"_onMouseDown\");\r\n\t},\r\n\r\n\t_setDisabledAttr: function(/*Boolean*/ value){\r\n\t\tthis.disabled = value;\r\n\t\tdojo.attr(this.focusNode, 'disabled', value);\r\n\t\tif(this.valueNode){\r\n\t\t\tdojo.attr(this.valueNode, 'disabled', value);\r\n\t\t}\r\n\t},\r\n\r\n\t_onFocus: function(e){\r\n\t\tif(this.scrollOnFocus){\r\n\t\t\tdojo.window.scrollIntoView(this.domNode);\r\n\t\t}\r\n\t\tthis.inherited(arguments);\r\n\t},\r\n\r\n\tisFocusable: function(){\r\n\t\t// summary:\r\n\t\t//\t\tTells if this widget is focusable or not.   Used internally by dijit.\r\n\t\t// tags:\r\n\t\t//\t\tprotected\r\n\t\treturn !this.disabled && !this.readOnly\r\n\t\t\t&& this.focusNode && (dojo.style(this.domNode, \"display\") != \"none\");\r\n\t},\r\n\r\n\tfocus: function(){\r\n\t\t// summary:\r\n\t\t//\t\tPut focus on this widget\r\n\t\tthis.focusNode.focus();\r\n\t},\r\n\r\n\tcompare: function(/*anything*/val1, /*anything*/val2){\r\n\t\t// summary:\r\n\t\t//\t\tCompare 2 values (as returned by attr('value') for this widget).\r\n\t\t// tags:\r\n\t\t//\t\tprotected\r\n\t\tif(typeof val1 == \"number\" && typeof val2 == \"number\"){\r\n\t\t\treturn (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;\r\n\t\t}else if(val1 > val2){\r\n\t\t\treturn 1;\r\n\t\t}else if(val1 < val2){\r\n\t\t\treturn -1;\r\n\t\t}else{\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t},\r\n\r\n\tonChange: function(newValue){\r\n\t\t// summary:\r\n\t\t//\t\tCallback when this widget's value is changed.\r\n\t\t// tags:\r\n\t\t//\t\tcallback\r\n\t},\r\n\r\n\t// _onChangeActive: [private] Boolean\r\n\t//\t\tIndicates that changes to the value should call onChange() callback.\r\n\t//\t\tThis is false during widget initialization, to avoid calling onChange()\r\n\t//\t\twhen the initial value is set.\r\n\t_onChangeActive: false,\r\n\r\n\t_handleOnChange: function(/*anything*/ newValue, /* Boolean? */ priorityChange){\r\n\t\t// summary:\r\n\t\t//\t\tCalled when the value of the widget is set.  Calls onChange() if appropriate\r\n\t\t// newValue:\r\n\t\t//\t\tthe new value\r\n\t\t// priorityChange:\r\n\t\t//\t\tFor a slider, for example, dragging the slider is priorityChange==false,\r\n\t\t//\t\tbut on mouse up, it's priorityChange==true.  If intermediateChanges==true,\r\n\t\t//\t\tonChange is only called form priorityChange=true events.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tthis._lastValue = newValue;\r\n\t\tif(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){\r\n\t\t\t// this block executes not for a change, but during initialization,\r\n\t\t\t// and is used to store away the original value (or for ToggleButton, the original checked state)\r\n\t\t\tthis._resetValue = this._lastValueReported = newValue;\r\n\t\t}\r\n\t\tif((this.intermediateChanges || priorityChange || priorityChange === undefined) &&\r\n\t\t\t((typeof newValue != typeof this._lastValueReported) ||\r\n\t\t\t\tthis.compare(newValue, this._lastValueReported) != 0)){\r\n\t\t\tthis._lastValueReported = newValue;\r\n\t\t\tif(this._onChangeActive){\r\n\t\t\t\tif(this._onChangeHandle){\r\n\t\t\t\t\tclearTimeout(this._onChangeHandle);\r\n\t\t\t\t}\r\n\t\t\t\t// setTimout allows hidden value processing to run and\r\n\t\t\t\t// also the onChange handler can safely adjust focus, etc\r\n\t\t\t\tthis._onChangeHandle = setTimeout(dojo.hitch(this,\r\n\t\t\t\t\tfunction(){\r\n\t\t\t\t\t\tthis._onChangeHandle = null;\r\n\t\t\t\t\t\tthis.onChange(newValue);\r\n\t\t\t\t\t}), 0); // try to collapse multiple onChange's fired faster than can be processed\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tcreate: function(){\r\n\t\t// Overrides _Widget.create()\r\n\t\tthis.inherited(arguments);\r\n\t\tthis._onChangeActive = true;\r\n\t},\r\n\r\n\tdestroy: function(){\r\n\t\tif(this._onChangeHandle){ // destroy called before last onChange has fired\r\n\t\t\tclearTimeout(this._onChangeHandle);\r\n\t\t\tthis.onChange(this._lastValueReported);\r\n\t\t}\r\n\t\tthis.inherited(arguments);\r\n\t},\r\n\r\n\t_onMouseDown: function(e){\r\n\t\t// If user clicks on the button, even if the mouse is released outside of it,\r\n\t\t// this button should get focus (to mimics native browser buttons).\r\n\t\t// This is also needed on chrome because otherwise buttons won't get focus at all,\r\n\t\t// which leads to bizarre focus restore on Dialog close etc.\r\n\t\tif(this.isFocusable()){\r\n\t\t\t// Set a global event to handle mouseup, so it fires properly\r\n\t\t\t// even if the cursor leaves this.domNode before the mouse up event.\r\n\t\t\tvar mouseUpConnector = this.connect(dojo.body(), \"onmouseup\", function(){\r\n\t\t\t\tif(this.isFocusable()){\r\n\t\t\t\t\tthis.focus();\r\n\t\t\t\t}\r\n\t\t\t\tthis.disconnect(mouseUpConnector);\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\tselectInputText: function(/*DomNode*/element, /*Number?*/ start, /*Number?*/ stop){\r\n\t\t// summary:\r\n\t\t//\t\tSelect text in the input element argument, from start (default 0), to stop (default end).\r\n\r\n\t\t// TODO: use functions in _editor/selection.js?\r\n\t\tvar _window = dojo.global;\r\n\t\tvar _document = dojo.doc;\r\n\t\telement = dojo.byId(element);\r\n\t\tif(isNaN(start)){ start = 0; }\r\n\t\tif(isNaN(stop)){ stop = element.value ? element.value.length : 0; }\r\n\t\tdijit.focus(element);\r\n\r\n\t\tif(_window[\"getSelection\"] && element.setSelectionRange){\r\n\t\t\telement.setSelectionRange(start, stop);\r\n\t\t}\r\n\t}\r\n});\r\n\r\ndojo.declare(\"dojox.mobile.app._FormValueWidget\", dojox.mobile.app._FormWidget,\r\n{\r\n\t// summary:\r\n\t//\t\tBase class for widgets corresponding to native HTML elements such as `<input>` or `<select>`\r\n\t//\t\tthat have user changeable values.\r\n\t// description:\r\n\t//\t\tEach _FormValueWidget represents a single input value, and has a (possibly hidden) `<input>` element,\r\n\t//\t\tto which it serializes it's input value, so that form submission (either normal submission or via FormBind?)\r\n\t//\t\tworks as expected.\r\n\r\n\t// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared\r\n\t// directly in the template as read by the parser in order to function. IE is known to specifically\r\n\t// require the 'name' attribute at element creation time.   See #8484, #8660.\r\n\t// TODO: unclear what that {value: \"\"} is for; FormWidget.attributeMap copies value to focusNode,\r\n\t// so maybe {value: \"\"} is so the value *doesn't* get copied to focusNode?\r\n\t// Seems like we really want value removed from attributeMap altogether\r\n\t// (although there's no easy way to do that now)\r\n\r\n\t// readOnly: Boolean\r\n\t//\t\tShould this widget respond to user input?\r\n\t//\t\tIn markup, this is specified as \"readOnly\".\r\n\t//\t\tSimilar to disabled except readOnly form values are submitted.\r\n\treadOnly: false,\r\n\r\n\tattributeMap: dojo.delegate(dojox.mobile.app._FormWidget.prototype.attributeMap, {\r\n\t\tvalue: \"\",\r\n\t\treadOnly: \"focusNode\"\r\n\t}),\r\n\r\n\t_setReadOnlyAttr: function(/*Boolean*/ value){\r\n\t\tthis.readOnly = value;\r\n\t\tdojo.attr(this.focusNode, 'readOnly', value);\r\n\t},\r\n\r\n\tpostCreate: function(){\r\n\t\tthis.inherited(arguments);\r\n\r\n\t\t// Update our reset value if it hasn't yet been set (because this.set()\r\n\t\t// is only called when there *is* a value)\r\n\t\tif(this._resetValue === undefined){\r\n\t\t\tthis._resetValue = this.value;\r\n\t\t}\r\n\t},\r\n\r\n\t_setValueAttr: function(/*anything*/ newValue, /*Boolean, optional*/ priorityChange){\r\n\t\t// summary:\r\n\t\t//\t\tHook so attr('value', value) works.\r\n\t\t// description:\r\n\t\t//\t\tSets the value of the widget.\r\n\t\t//\t\tIf the value has changed, then fire onChange event, unless priorityChange\r\n\t\t//\t\tis specified as null (or false?)\r\n\t\tthis.value = newValue;\r\n\t\tthis._handleOnChange(newValue, priorityChange);\r\n\t},\r\n\r\n\t_getValueAttr: function(){\r\n\t\t// summary:\r\n\t\t//\t\tHook so attr('value') works.\r\n\t\treturn this._lastValue;\r\n\t},\r\n\r\n\tundo: function(){\r\n\t\t// summary:\r\n\t\t//\t\tRestore the value to the last value passed to onChange\r\n\t\tthis._setValueAttr(this._lastValueReported, false);\r\n\t},\r\n\r\n\treset: function(){\r\n\t\t// summary:\r\n\t\t//\t\tReset the widget's value to what it was at initialization time\r\n\t\tthis._hasBeenBlurred = false;\r\n\t\tthis._setValueAttr(this._resetValue, true);\r\n\t}\r\n});\r\n"]}