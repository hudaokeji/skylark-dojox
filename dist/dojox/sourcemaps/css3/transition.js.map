{"version":3,"sources":["css3/transition.js"],"names":["define","lang","array","Deferred","when","all","on","has","transitionEndEventName","transitionPrefix","translateMethodStart","translateMethodEnd","transition","args","mixin","this","startState","endState","node","duration","in","direction","autoClear","deferred","extend","play","groupedPlay","_applyState","state","style","property","hasOwnProperty","initState","_beforeStart","display","beforeStart","_beforeClear","beforeClear","_onAfterEnd","resolve","id","playing","onAfterEnd","start","_startTime","Date","getTime","_cleared","self","once","clear","_removeState","slide","config","ret","startX","endX","fade","startOpacity","endOpacity","opacity","flip","getWaitingList","nodes","defs","forEach","push","animNodes","filter","item","waitingList","setTimeout","length","i","fired","chainedPlay","len","then","hitch"],"mappings":"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","file":"../../css3/transition.js","sourcesContent":["define([\"dojo/_base/lang\",\r\n\t\t\"dojo/_base/array\",\r\n\t\t\"dojo/Deferred\",\r\n\t\t\"dojo/when\",\r\n\t\t\"dojo/promise/all\",\r\n\t\t\"dojo/on\",\r\n\t\t\"dojo/sniff\"],\r\n\t\tfunction(lang, array, Deferred, when, all, on, has){\r\n\t// module: \r\n\t//\t\tdojox/css3/transition\r\n\t\r\n\t//create cross platform animation/transition effects\r\n\t//TODO enable opera mobile when it is hardware accelerated\r\n\t// IE10 is using standard names so this is working without any modifications\r\n\tvar transitionEndEventName = \"transitionend\";\r\n\tvar transitionPrefix = \"t\"; //by default use \"t\" prefix and \"ransition\" to make word \"transition\"\r\n\tvar translateMethodStart = \"translate3d(\";//Android 2.x does not support translateX in CSS Transition, we need to use translate3d in webkit browsers\r\n\tvar translateMethodEnd = \",0,0)\";\r\n\tif(has(\"webkit\")){\r\n\t\ttransitionPrefix = \"WebkitT\";\r\n\t\ttransitionEndEventName = \"webkitTransitionEnd\";\r\n\t}else if(has(\"mozilla\")){\r\n\t\ttransitionPrefix = \"MozT\";\r\n\t\ttranslateMethodStart = \"translateX(\";\r\n\t\ttranslateMethodEnd = \")\";\r\n\t}\r\n\t\r\n\t//TODO find a way to lock the animation and prevent animation conflict\r\n\t//Use the simple object inheritance\r\n\tvar transition = function(/*Object?*/args){\r\n\t\t// summary:\r\n\t\t//\t\tThis module defines the transition utilities which can be used\r\n\t\t//\t\tto perform transition effects based on the CSS Transition standard.\r\n\t\t// args:\r\n\t\t//\t\tThe arguments which will be mixed into this transition object.\r\n\t\t\r\n\t\t//default config should be in animation object itself instead of its prototype\r\n\t\t//otherwise, it might be easy for making mistake of modifying prototype\r\n\t\tvar defaultConfig = {\r\n\t\t\t\tstartState: {},\r\n\t\t\t\tendState: {},\r\n\t\t\t\tnode: null,\r\n\t\t\t\tduration: 250,\r\n\t\t\t\t\"in\": true,\r\n\t\t\t\tdirection: 1,\r\n\t\t\t\tautoClear: true\r\n\t\t};\r\n\r\n\t\tlang.mixin(this, defaultConfig);\r\n\t\tlang.mixin(this, args);\r\n\r\n\t\t//create the deferred object which will resolve after the animation is finished.\r\n\t\t//We can rely on \"onAfterEnd\" function to notify the end of a single animation,\r\n\t\t//but using a deferred object is easier to wait for multiple animations end.\r\n\t\tif(!this.deferred){\r\n\t\t\tthis.deferred = new Deferred();\r\n\t\t}\r\n\t};\r\n\t\r\n\tlang.extend(transition, {\r\n\t\t\r\n\t\tplay: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tPlays the transition effect defined by this transition object.\r\n\t\t\ttransition.groupedPlay([this]);\r\n\t\t},\r\n\t\t\r\n\t\t//method to apply the state of the transition\r\n\t\t_applyState: function(state){\r\n\t\t\tvar style = this.node.style;\r\n\t\t\tfor(var property in state){\r\n\t\t\t\tif(state.hasOwnProperty(property)){\r\n\t\t\t\t\tstyle[property] = state[property];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t\r\n\t\tinitState: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tMethod to initialize the state for a transition.\r\n\t\t\t\r\n\t\t\t//apply the immediate style change for initial state.\r\n\t\t\tthis.node.style[transitionPrefix + \"ransitionProperty\"] = \"none\";\r\n\t\t\tthis.node.style[transitionPrefix + \"ransitionDuration\"] = \"0ms\";\r\n\t\t\tthis._applyState(this.startState);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t_beforeStart: function(){\r\n\t\t\tif (this.node.style.display === \"none\"){\r\n\t\t\t\tthis.node.style.display = \"\";\r\n\t\t\t}\r\n\t\t\tthis.beforeStart();\r\n\t\t},\r\n\t\t\r\n\t\t_beforeClear: function(){\r\n\t\t\tthis.node.style[transitionPrefix + \"ransitionProperty\"] = \"\";\r\n\t\t\tthis.node.style[transitionPrefix + \"ransitionDuration\"] = \"\";\r\n\t\t\tif(this[\"in\"] !== true){\r\n\t\t\t\tthis.node.style.display = \"none\";\r\n\t\t\t}\t\t\t \r\n\t\t\tthis.beforeClear();\r\n\t\t},\r\n\t\t\r\n\t\t_onAfterEnd: function(){\r\n\t\t\tthis.deferred.resolve(this.node);\r\n\t\t\tif(this.node.id && transition.playing[this.node.id]===this.deferred){\r\n\t\t\t\tdelete transition.playing[this.node.id];\r\n\t\t\t}\r\n\t\t\tthis.onAfterEnd();\r\n\t\t},\r\n\t\t\r\n\t\tbeforeStart: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe callback which will be called right before the start\r\n\t\t\t//\t\tof the transition effect.\r\n\t\t},\r\n\t\t\r\n\t\tbeforeClear: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe callback which will be called right after the end\r\n\t\t\t//\t\tof the transition effect and before the final state is\r\n\t\t\t//\t\tcleared.\r\n\t\t},\r\n\t\t\r\n\t\tonAfterEnd: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe callback which will be called right after the end\r\n\t\t\t//\t\tof the transition effect and after the final state is\r\n\t\t\t//\t\tcleared.\r\n\t\t},\r\n\t\t\r\n\t\tstart: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tMethod to start the transition.\r\n\t\t\tthis._beforeStart();\r\n\t\t\tthis._startTime = new Date().getTime(); // set transition start timestamp\r\n\t\t\tthis._cleared = false; // set clear flag to false\r\n\r\n\t\t\tvar self = this;\r\n\t\t\t//change the transition duration\r\n\t\t\tself.node.style[transitionPrefix + \"ransitionProperty\"] = \"all\";\r\n\t\t\tself.node.style[transitionPrefix + \"ransitionDuration\"] = self.duration + \"ms\";\r\n\t\t\t\r\n\t\t\t//connect to clear the transition state after the transition end.\r\n\t\t\t//Since the transition is conducted asynchronously, we need to \r\n\t\t\t//connect to transition end event to clear the state\r\n\t\t\ton.once(self.node, transitionEndEventName, function(){\r\n\t\t\t\tself.clear();\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tthis._applyState(this.endState);\r\n\t\t},\r\n\t\t\r\n\t\tclear: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tMethod to clear the state after a transition.\r\n\t\t\tif(this._cleared) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis._cleared = true; // set clear flag to true\r\n\r\n\t\t\tthis._beforeClear();\r\n\t\t\tthis._removeState(this.endState);\r\n\t\t\t// console.log(this.node.id + \" clear.\");\r\n\t\t\tthis._onAfterEnd();\r\n\t\t},\r\n\t\t\r\n\t\t//create removeState method\r\n\t\t_removeState: function(state){\r\n\t\t\tvar style = this.node.style;\r\n\t\t\tfor(var property in state){\r\n\t\t\t\tif(state.hasOwnProperty(property)){\r\n\t\t\t\t\tstyle[property] = \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t});\r\n\t\r\n\t//TODO add the lock mechanism for all of the transition effects\r\n\t//\t   consider using only one object for one type of transition.\r\n\t\r\n\ttransition.slide = function(node, config){\r\n\t\t// summary:\r\n\t\t//\t\tMethod which is used to create the transition object of a slide effect.\r\n\t\t// node:\r\n\t\t//\t\tThe node that the slide transition effect will be applied on.\r\n\t\t// config:\r\n\t\t//\t\tThe cofig arguments which will be mixed into this transition object.\r\n\r\n\t\t//create the return object and set the startState, endState of the return\r\n\t\tvar ret = new transition(config);\r\n\t\tret.node = node;\r\n\t\t\r\n\t\tvar startX = \"0\";\r\n\t\tvar endX = \"0\";\r\n\t\t\r\n\t\tif(ret[\"in\"]){\r\n\t\t\tif(ret.direction === 1){\r\n\t\t\t\tstartX = \"100%\";\r\n\t\t\t}else{\r\n\t\t\t\tstartX = \"-100%\";\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif(ret.direction === 1){\r\n\t\t\t\tendX = \"-100%\";\r\n\t\t\t}else{\r\n\t\t\t\tendX = \"100%\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tret.startState[transitionPrefix + \"ransform\"]=translateMethodStart+startX+translateMethodEnd;\r\n\t\t\r\n\t\tret.endState[transitionPrefix + \"ransform\"]=translateMethodStart+endX+translateMethodEnd;\r\n\t\t\r\n\t\treturn ret;\r\n\t};\r\n\t\t\r\n\ttransition.fade = function(node, config){\r\n\t\t// summary:\r\n\t\t//\t\tMethod which is used to create the transition object of fade effect.\r\n\t\t// node:\r\n\t\t//\t\tThe node that the fade transition effect will be applied on.\r\n\t\t// config:\r\n\t\t//\t\tThe cofig arguments which will be mixed into this transition object.\r\n\t\tvar ret = new transition(config);\r\n\t\tret.node = node;\r\n\t\t\r\n\t\tvar startOpacity = \"0\";\r\n\t\tvar endOpacity = \"0\";\r\n\t\t\r\n\t\tif(ret[\"in\"]){\r\n\t\t\tendOpacity = \"1\";\r\n\t\t}else{\r\n\t\t\tstartOpacity = \"1\";\r\n\t\t}\r\n\t\t\r\n\t\tlang.mixin(ret, {\r\n\t\t\tstartState:{\r\n\t\t\t\t\"opacity\": startOpacity\r\n\t\t\t},\r\n\t\t\tendState:{\r\n\t\t\t\t\"opacity\": endOpacity\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\treturn ret;\r\n\t};\r\n\t\r\n\ttransition.flip = function(node, config){\r\n\t\t// summary:\r\n\t\t//\t\tMethod which is used to create the transition object of flip effect.\r\n\t\t// node:\r\n\t\t//\t\tThe node that the flip transition effect will be applied on.\r\n\t\t// config:\r\n\t\t//\t\tThe cofig arguments which will be mixed into this transition object.\r\n\t\t\r\n\t\tvar ret = new transition(config);\r\n\t\tret.node = node;\r\n\t   \r\n\t\tif(ret[\"in\"]){\r\n\t\t\t//Need to set opacity here because Android 2.2 has bug that\r\n\t\t\t//scale(...) in transform does not persist status\r\n\t\t\tlang.mixin(ret,{\r\n\t\t\t\tstartState:{\r\n\t\t\t\t\t\"opacity\": \"0\"\r\n\t\t\t\t},\r\n\t\t\t\tendState:{\r\n\t\t\t\t\t\"opacity\": \"1\"\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tret.startState[transitionPrefix + \"ransform\"]=\"scale(0,0.8) skew(0,-30deg)\";\r\n\t\t\tret.endState[transitionPrefix + \"ransform\"]=\"scale(1,1) skew(0,0)\";\r\n\t\t}else{\r\n\t\t\tlang.mixin(ret,{\r\n\t\t\t\tstartState:{\r\n\t\t\t\t\t\"opacity\": \"1\"\r\n\t\t\t\t},\r\n\t\t\t\tendState:{\r\n\t\t\t\t\t\"opacity\": \"0\"\r\n\t\t\t\t}\r\n\t\t\t});\t\t\t\r\n\t\t\tret.startState[transitionPrefix + \"ransform\"]=\"scale(1,1) skew(0,0)\";\r\n\t\t\tret.endState[transitionPrefix + \"ransform\"]=\"scale(0,0.8) skew(0,30deg)\";\r\n\t\t}\r\n\t\t\r\n\t\treturn ret;\r\n\t};\r\n\t\r\n\tvar getWaitingList = function(/*Array*/ nodes){\r\n\t\tvar defs = [];\r\n\t\tarray.forEach(nodes, function(node){\r\n\t\t\t//check whether the node is under other animation\r\n\t\t\tif(node.id && transition.playing[node.id]){\r\n\t\t\t\t//hook on deferred object in transition.playing\r\n\t\t\t\tdefs.push(transition.playing[node.id]);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\treturn all(defs);\r\n\t};\r\n\t\r\n\ttransition.getWaitingList = getWaitingList;\r\n\t\r\n\ttransition.groupedPlay = function(/*Array*/args){\r\n\t\t// summary:\r\n\t\t//\t\tThe method which groups multiple transitions and plays \r\n\t\t//\t\tthem together.\r\n\t\t// args: \r\n\t\t//\t\tThe array of transition objects which will be played together.\r\n\t\t\r\n\t\tvar animNodes = array.filter(args, function(item){\r\n\t\t\treturn item.node;\r\n\t\t});\r\n\t\t\r\n\t\tvar waitingList = getWaitingList(animNodes);\r\n\r\n\t\t//update registry with deferred objects in animations of args.\r\n\t\tarray.forEach(args, function(item){\r\n\t\t\tif(item.node.id){\r\n\t\t\t\ttransition.playing[item.node.id] = item.deferred;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t//wait for all deferred object in deferred list to resolve\r\n\t\twhen(waitingList, function(){\r\n\t\t\tarray.forEach(args, function(item){\r\n\t\t\t\t//set the start state\r\n\t\t\t\titem.initState();\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t//Assume the fps of the animation should be higher than 30 fps and\r\n\t\t\t//allow the browser to use one frame's time to redraw so that\r\n\t\t\t//the transition can be started\r\n\t\t\tsetTimeout(function(){\r\n\t\t\t\tarray.forEach(args, function(item){\r\n\t\t\t\t\titem.start();\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// check and clear node if the node not cleared.\r\n\t\t\t\t// 1. on Android2.2/2.3, the \"fade out\" transitionEnd event will be lost if the soft keyboard popup, so we need to check nodes' clear status.\r\n\t\t\t\t// 2. The \"fade in\" transitionEnd event will before or after \"fade out\" transitionEnd event and it always occurs.\r\n\t\t\t\t//\t  We can check fade out node status in the last \"fade in\" node transitionEnd event callback, if node transition timeout, we clear it.\r\n\t\t\t\t// NOTE: the last \"fade in\" transitionEnd event will always fired, so we bind on this event and check other nodes.\r\n\t\t\t\ton.once(args[args.length-1].node, transitionEndEventName, function(){\r\n\t\t\t\t\tvar timeout;\r\n\t\t\t\t\tfor(var i=0; i<args.length-1; i++){\r\n\t\t\t\t\t\tif(args[i].deferred.fired !== 0 && !args[i]._cleared){\r\n\t\t\t\t\t\t\ttimeout = new Date().getTime() - args[i]._startTime;\r\n\t\t\t\t\t\t\tif(timeout >= args[i].duration){\r\n\t\t\t\t\t\t\t\targs[i].clear();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tsetTimeout(function(){\r\n\t\t\t\t\tvar timeout;\r\n\t\t\t\t\tfor(var i=0; i<args.length; i++){\r\n\t\t\t\t\t\tif(args[i].deferred.fired !== 0 && !args[i]._cleared){\r\n\t\t\t\t\t\t\ttimeout = new Date().getTime() - args[i]._startTime;\r\n\t\t\t\t\t\t\tif(timeout >= args[i].duration){\r\n\t\t\t\t\t\t\t\targs[i].clear();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}, args[0].duration+50);\r\n\t\t\t}, 33);\r\n\t\t});\r\n\t};\r\n\t\r\n\ttransition.chainedPlay = function(/*Array*/args){\r\n\t\t// summary:\r\n\t\t//\t\tThe method which plays multiple transitions one by one.\r\n\t\t// args: \r\n\t\t//\t\tThe array of transition objects which will be played in a chain.\r\n\t\t\r\n\t\tvar animNodes = array.filter(args, function(item){\r\n\t\t\treturn item.node;\r\n\t\t});\r\n\t\t\r\n\t\tvar waitingList = getWaitingList(animNodes);\r\n\r\n\t\t//update registry with deferred objects in animations of args.\r\n\t\tarray.forEach(args, function(item){\r\n\t\t\tif(item.node.id){\r\n\t\t\t\ttransition.playing[item.node.id] = item.deferred;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\twhen(waitingList, function(){\r\n\t\t\tarray.forEach(args, function(item){\r\n\t\t\t\t//set the start state\r\n\t\t\t\titem.initState();\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t//chain animations together\r\n\t\t\tfor (var i=1, len=args.length; i < len; i++){\r\n\t\t\t\targs[i-1].deferred.then(lang.hitch(args[i], function(){\r\n\t\t\t\t\tthis.start();\r\n\t\t\t\t}));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//Assume the fps of the animation should be higher than 30 fps and\r\n\t\t\t//allow the browser to use one frame's time to redraw so that\r\n\t\t\t//the transition can be started\r\n\t\t\tsetTimeout(function(){\r\n\t\t\t\targs[0].start();\r\n\t\t\t}, 33);\r\n\t\t});\t\t   \r\n\t};\r\n\t\r\n\t//TODO complete the registry mechanism for animation handling and prevent animation conflicts\r\n\ttransition.playing = {};\r\n\t\r\n\treturn transition;\r\n});\r\n"]}