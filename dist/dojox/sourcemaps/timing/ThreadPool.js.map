{"version":3,"sources":["timing/ThreadPool.js"],"names":["define","dojo","experimental","t","dojox","timing","threadStates","UNSTARTED","STOPPED","PENDING","RUNNING","SUSPENDED","WAITING","COMPLETE","ERROR","threadPriorities","LOWEST","BELOWNORMAL","NORMAL","ABOVENORMAL","HIGHEST","Thread","fn","priority","self","this","state","lastError","func","invoke","e","ThreadPool","mxthrs","intvl","availableThreads","queue","Math","floor","timers","Array","maxThreads","timer","Timer","getMaxThreads","getAvailableThreads","getTickInterval","queueUserWorkItem","item","Function","idx","length","i","splice","push","removeQueuedUserWorkItem","start","stop","abort","window","clearTimeout","thread","reset","sleep","nSleep","setTimeout","onTick"],"mappings":";;;;;;;AAAAA,QAAQ,WAAY,WACnBC,KAAKC,aAAa,2BASlB,IAAIC,EAAEC,MAAMC,OA2IZ,OA1IAF,EAAEG,cACDC,UAAU,YACVC,QAAQ,UACRC,QAAQ,UACRC,QAAQ,UACRC,UAAU,YACVC,QAAQ,UACRC,SAAS,WACTC,MAAM,SAIPX,EAAEY,kBACDC,OAAO,EACPC,YAAY,EACZC,OAAO,EACPC,YAAY,EACZC,QAAQ,GAGTjB,EAAEkB,OAAO,SAAuBC,EAAwCC,GACvE,IAAIC,EAAKC,KACTA,KAAKC,MAAMvB,EAAEG,aAAaC,UAC1BkB,KAAKF,SAASA,GAAUpB,EAAEY,iBAAiBG,OAC3CO,KAAKE,UAAU,KACfF,KAAKG,KAAKN,EACVG,KAAKI,OAAO,WACXL,EAAKE,MAAMvB,EAAEG,aAAaI,QAC1B,IACCY,EAAGG,MACHD,EAAKE,MAAMvB,EAAEG,aAAaO,SAC1B,MAAMiB,GACNN,EAAKG,UAAUG,EACfN,EAAKE,MAAMvB,EAAEG,aAAaQ,SAM7BX,EAAE4B,WAAW,IAAI,SAAsBC,EAAoBC,GAC1D,IAEIC,EA+FF,GA5FEC,GADaC,KAAKC,MAAM,YAExBC,EAAO,IAAIC,MAAMC,IACjBC,EAAM,IAAIrC,MAAMC,OAAOqC,MAc3BjB,KAAKkB,cAAc,WAAY,OA4E7B,IA3EFlB,KAAKmB,oBAAoB,WAAY,OAAOV,GAC5CT,KAAKoB,gBAAgB,WAAY,OA0E3B,KAzENpB,KAAKqB,kBAAkB,SAA2CxB,GACjE,IAAIyB,EAAKzB,EACNyB,aAAgBC,WAClBD,EAAK,IAAI5C,EAAEkB,OAAO0B,IAGnB,IADA,IAAIE,EAAId,EAAMe,OACNC,EAAE,EAAGA,EAAEhB,EAAMe,OAAQC,IAC5B,GAAGhB,EAAMgB,GAAG5B,SAASwB,EAAKxB,SAAS,CAClC0B,EAAIE,EACJ,MAQF,OALGF,EAAId,EAAMe,OACZf,EAAMiB,OAAOH,EAAK,EAAGF,GAErBZ,EAAMkB,KAAKN,IAEL,GAERtB,KAAK6B,yBAAyB,SAA2CP,GACxE,GAAGA,aAAgBC,SAAS,CAE3B,IADA,IAAIC,GAAK,EACDE,EAAE,EAAGA,EAAEhB,EAAMe,OAAQC,IAC5B,GAAGhB,EAAMgB,GAAGvB,MAAMmB,EAAK,CACtBE,EAAIE,EACJ,MAGF,OAAGF,GAAK,IACPd,EAAMiB,OAAOH,EAAI,IACV,GAMT,IADIA,GAAK,EACDE,EAAE,EAAGA,EAAEhB,EAAMe,OAAQC,IAC5B,GAAGhB,EAAMgB,IAAIJ,EAAK,CACjBE,EAAIE,EACJ,MAGF,OAAGF,GAAK,IACPd,EAAMiB,OAAOH,EAAI,IACV,IAITxB,KAAK8B,MAAM,WAAYd,EAAMc,SAC7B9B,KAAK+B,KAAK,WAAYf,EAAMe,QAC5B/B,KAAKgC,MAAM,WACVhC,KAAK+B,OACL,IAAI,IAAIL,EAAE,EAAGA,EAAEb,EAAOY,OAAQC,IAC1Bb,EAAOa,IACTO,OAAOC,aAAarB,EAAOa,IAG7B,IAAI,IAAIS,KAAUtB,EAAO,GACxBb,KAAKqB,kBAAkBc,GAExBtB,EAAO,OAERb,KAAKoC,MAAM,WACVpC,KAAKgC,QACLtB,MAEDV,KAAKqC,MAAM,SAAqBC,GAC/BtB,EAAMe,OACNE,OAAOM,WAAWvB,EAAMc,MAAOQ,IAIhCtB,EAAMwB,OAhGGxC,KAgGSI,OAjGN,CAkGV,GAAI,KACAzB,MAAMC,OAAO0B","file":"../../timing/ThreadPool.js","sourcesContent":["define([\"./_base\"], function(){\r\n\tdojo.experimental(\"dojox.timing.ThreadPool\");\r\n\r\n//\tdojox.timing.Timer is included as part of _base\r\n/********************************************************************\r\n\tThis is a port of the original System.Threading.ThreadPool from\r\n\tthe f(m) class library.\r\n\t\r\n\tDonated to the Dojo toolkit by the author :)\r\n*********************************************************************/\r\n\tvar t=dojox.timing;\r\n\tt.threadStates={\r\n\t\tUNSTARTED:\"unstarted\",\r\n\t\tSTOPPED:\"stopped\",\r\n\t\tPENDING:\"pending\",\r\n\t\tRUNNING:\"running\",\r\n\t\tSUSPENDED:\"suspended\",\r\n\t\tWAITING:\"waiting\",\r\n\t\tCOMPLETE:\"complete\",\r\n\t\tERROR:\"error\"\r\n\t};\r\n\r\n\t//\tBefore rar says a word, we actually *use* these numbers for a purpose :)\r\n\tt.threadPriorities={\r\n\t\tLOWEST:1,\r\n\t\tBELOWNORMAL:2,\r\n\t\tNORMAL:3,\r\n\t\tABOVENORMAL:4,\r\n\t\tHIGHEST:5\r\n\t};\r\n\t\r\n\tt.Thread=function(/* Function */fn, /* dojox.timing.threadPriorities? */priority){\r\n\t\tvar self=this;\r\n\t\tthis.state=t.threadStates.UNSTARTED;\r\n\t\tthis.priority=priority||t.threadPriorities.NORMAL;\r\n\t\tthis.lastError=null;\r\n\t\tthis.func=fn;\t//\tfor lookup purposes.\r\n\t\tthis.invoke=function(){\r\n\t\t\tself.state=t.threadStates.RUNNING;\r\n\t\t\ttry{\r\n\t\t\t\tfn(this);\r\n\t\t\t\tself.state=t.threadStates.COMPLETE;\r\n\t\t\t}catch(e){\r\n\t\t\t\tself.lastError=e;\r\n\t\t\t\tself.state=t.threadStates.ERROR;\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\t//\tTODO: allow for changing of maxThreads and tick interval\r\n\tt.ThreadPool=new (function(/* Number */mxthrs, /* Number */intvl){\r\n\t\tvar self=this;\r\n\t\tvar maxThreads=mxthrs;\r\n\t\tvar availableThreads=maxThreads;\r\n\t\tvar interval=intvl;\r\n\t\tvar fireInterval=Math.floor((interval/2)/maxThreads);\r\n\t\tvar queue=[];\r\n\t\tvar timers=new Array(maxThreads+1);\r\n\t\tvar timer=new dojox.timing.Timer();\r\n\t\tvar invoke=function(){\r\n\t\t\tvar tracker=timers[0]={};\r\n\t\t\tfor(var i=0; i<timers.length; i++){\r\n\t\t\t\twindow.clearTimeout(timers[i]);\r\n\t\t\t\tvar thread=queue.shift();\r\n\t\t\t\tif(typeof(thread)==\"undefined\"){ break; }\r\n\t\t\t\ttracker[\"thread-\"+i]=thread;\r\n\t\t\t\ttimers[i]=window.setTimeout(thread.invoke,(fireInterval*i));\r\n\t\t\t}\r\n\t\t\tavailableThreads=maxThreads-(i-1);\r\n\t\t};\r\n\r\n\t\t//\tpublic methods\r\n\t\tthis.getMaxThreads=function(){ return maxThreads; };\r\n\t\tthis.getAvailableThreads=function(){ return availableThreads; };\r\n\t\tthis.getTickInterval=function(){ return interval; };\r\n\t\tthis.queueUserWorkItem=function(/* Function|dojox/timing/Thread */fn){\r\n\t\t\tvar item=fn;\r\n\t\t\tif(item instanceof Function){\r\n\t\t\t\titem=new t.Thread(item);\r\n\t\t\t}\r\n\t\t\tvar idx=queue.length;\r\n\t\t\tfor(var i=0; i<queue.length; i++){\r\n\t\t\t\tif(queue[i].priority<item.priority){\r\n\t\t\t\t\tidx=i;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(idx<queue.length){\r\n\t\t\t\tqueue.splice(idx, 0, item);\r\n\t\t\t} else {\r\n\t\t\t\tqueue.push(item);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t};\r\n\t\tthis.removeQueuedUserWorkItem=function(/* Function|dojox/timing/Thread */item){\r\n\t\t\tif(item instanceof Function){\r\n\t\t\t\tvar idx=-1;\r\n\t\t\t\tfor(var i=0; i<queue.length; i++){\r\n\t\t\t\t\tif(queue[i].func==item){\r\n\t\t\t\t\t\tidx=i;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(idx>-1){\r\n\t\t\t\t\tqueue.splice(idx,1);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tvar idx=-1;\r\n\t\t\tfor(var i=0; i<queue.length; i++){\r\n\t\t\t\tif(queue[i]==item){\r\n\t\t\t\t\tidx=i;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(idx>-1){\r\n\t\t\t\tqueue.splice(idx,1);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t};\r\n\t\tthis.start=function(){ timer.start(); };\r\n\t\tthis.stop=function(){ timer.stop(); };\r\n\t\tthis.abort=function(){\r\n\t\t\tthis.stop();\r\n\t\t\tfor(var i=1; i<timers.length; i++){\r\n\t\t\t\tif(timers[i]){\r\n\t\t\t\t\twindow.clearTimeout(timers[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(var thread in timers[0]){\r\n\t\t\t\tthis.queueUserWorkItem(thread);\r\n\t\t\t}\r\n\t\t\ttimers[0]={};\r\n\t\t};\r\n\t\tthis.reset=function(){\r\n\t\t\tthis.abort();\r\n\t\t\tqueue=[];\r\n\t\t};\r\n\t\tthis.sleep=function(/* Number */nSleep){\r\n\t\t\ttimer.stop();\r\n\t\t\twindow.setTimeout(timer.start, nSleep);\r\n\t\t};\r\n\r\n\t\t//\tdedicate the timer to us.\r\n\t\ttimer.onTick=self.invoke;\r\n\t})(16, 5000);\r\n\treturn dojox.timing.ThreadPool;\r\n});\r\n"]}