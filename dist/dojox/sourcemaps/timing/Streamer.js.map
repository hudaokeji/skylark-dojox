{"version":3,"sources":["timing/Streamer.js"],"names":["define","dojo","experimental","dojox","timing","Streamer","input","output","interval","minimum","initialData","queue","this","minimumSize","inputFunction","q","outputFunction","point","timer","Timer","setInterval","ms","onTick","obj","start","Error","onStart","stop","onStop","tick","concat"],"mappings":";;;;;;;AAAAA,QAAQ,WAAY,WAGnB,OAFAC,KAAKC,aAAa,yBAEXC,MAAMC,OAAOC,SAAW,SAChBC,EACAC,EACLC,EACAC,EACEC,GAgBX,IACIC,KAGJC,KAAKJ,SAAWA,GAAY,IAC5BI,KAAKC,YAAcJ,GAAW,GAC9BG,KAAKE,cAAgBR,GAAS,SAASS,KACvCH,KAAKI,eAAiBT,GAAU,SAASU,KAGzC,IAAIC,EAAQ,IAAIf,MAAMC,OAAOe,MAAMP,KAAKJ,UAyBxCI,KAAKQ,YAAc,SAAkBC,GAGpCT,KAAKJ,SAAWa,EAChBH,EAAME,YAAYC,IAGnBT,KAAKU,OAAS,SAAoCC,KAElDX,KAAKY,MAAQ,WAGZ,GAAiC,mBAAvBZ,KAAkB,eAAkD,mBAAxBA,KAAmB,eAIzE,MAAM,IAAIa,MAAM,wEAHfP,EAAMM,SAKRZ,KAAKc,QAAU,aACfd,KAAKe,KAAO,WAGXT,EAAMS,QAEPf,KAAKgB,OAAS,aAGdV,EAAMI,OAASV,KAAKiB,KACpBX,EAAMQ,QAAUd,KAAKc,QACrBR,EAAMU,OAAShB,KAAKgB,OACjBlB,GACFC,EAAMmB,OAAOpB","file":"../../timing/Streamer.js","sourcesContent":["define([\"./_base\"], function(){\r\n\tdojo.experimental(\"dojox.timing.Streamer\");\r\n\r\n\treturn dojox.timing.Streamer = function(\r\n\t\t/* function */input,\r\n\t\t/* function */output,\r\n\t\t/* int */interval,\r\n\t\t/* int */minimum,\r\n\t\t/* array */initialData\r\n\t){\r\n\t\t// summary:\r\n\t\t//\t\tStreamer will take an input function that pushes N datapoints into a\r\n\t\t//\t\tqueue, and will pass the next point in that queue out to an\r\n\t\t//\t\toutput function at the passed interval; this way you can emulate\r\n\t\t//\t\ta constant buffered stream of data.\r\n\t\t// input:\r\n\t\t//\t\tthe function executed when the internal queue reaches minimumSize\r\n\t\t// output:\r\n\t\t//\t\tthe function executed on internal tick\r\n\t\t// interval:\r\n\t\t//\t\tthe interval in ms at which the output function is fired.\r\n\t\t// minimum:\r\n\t\t//\t\tthe minimum number of elements in the internal queue.\r\n\r\n\t\tvar self = this;\r\n\t\tvar queue = [];\r\n\r\n\t\t//\tpublic properties\r\n\t\tthis.interval = interval || 1000;\r\n\t\tthis.minimumSize = minimum || 10;\t//\tlatency usually == interval * minimumSize\r\n\t\tthis.inputFunction = input || function(q){ };\r\n\t\tthis.outputFunction = output || function(point){ };\r\n\r\n\t\t//\tmore setup\r\n\t\tvar timer = new dojox.timing.Timer(this.interval);\r\n\t\tvar tick = function(){\r\n\t\t\tself.onTick(self);\r\n\r\n\t\t\tif(queue.length < self.minimumSize){\r\n\t\t\t\tself.inputFunction(queue);\r\n\t\t\t}\r\n\r\n\t\t\tvar obj = queue.shift();\r\n\t\t\twhile(typeof(obj) == \"undefined\" && queue.length > 0){\r\n\t\t\t\tobj = queue.shift();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//\tcheck to see if the input function needs to be fired\r\n\t\t\t//\tstop before firing the output function\r\n\t\t\t//\tTODO: relegate this to the output function?\r\n\t\t\tif(typeof(obj) == \"undefined\"){\r\n\t\t\t\tself.stop();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t//\tcall the output function.\r\n\t\t\tself.outputFunction(obj);\r\n\t\t};\r\n\r\n\t\tthis.setInterval = function(/* int */ms){\r\n\t\t\t// summary:\r\n\t\t\t//\tsets the interval in milliseconds of the internal timer\r\n\t\t\tthis.interval = ms;\r\n\t\t\ttimer.setInterval(ms);\r\n\t\t};\r\n\r\n\t\tthis.onTick = function(/* dojox.timing.Streamer */obj){ };\r\n\t\t// wrap the timer functions so that we can connect to them if needed.\r\n\t\tthis.start = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\tstarts the Streamer\r\n\t\t\tif(typeof(this.inputFunction) == \"function\" && typeof(this.outputFunction) == \"function\"){\r\n\t\t\t\ttimer.start();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthrow new Error(\"You cannot start a Streamer without an input and an output function.\");\r\n\t\t};\r\n\t\tthis.onStart = function(){ };\r\n\t\tthis.stop = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\tstops the Streamer\r\n\t\t\ttimer.stop();\r\n\t\t};\r\n\t\tthis.onStop = function(){ };\r\n\r\n\t\t//\tfinish initialization\r\n\t\ttimer.onTick = this.tick;\r\n\t\ttimer.onStart = this.onStart;\r\n\t\ttimer.onStop = this.onStop;\r\n\t\tif(initialData){\r\n\t\t\tqueue.concat(initialData);\r\n\t\t}\r\n\t};\r\n});\r\n"]}