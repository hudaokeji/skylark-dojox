{"version":3,"sources":["timing/Sequence.js"],"names":["define","dojo","experimental","declare","_goOnPause","_running","constructor","this","_defsResolved","go","defs","doneFunction","forEach","cur","repeat","j","push","length","func","stop","_curId","_go","resolveAndCallFunc","pauseAfter","setTimeout","hitch","pauseBefore","x","isArray","apply","slice","goOn"],"mappings":";;;;;;;AAAAA,QACC,oBACA,mBACA,qBACA,kBACA,WACE,SAASC,GAGX,OAFAA,EAAKC,aAAa,yBAEXD,EAAKE,QAAQ,wBAAyB,MA6B5CC,WAAY,EAEZC,UAAU,EAEVC,YAAa,WACZC,KAAKC,kBAGNC,GAAI,SAAoBC,EAA2BC,GAOlDJ,KAAKF,UAAW,EAChBJ,EAAKW,QAAQF,EAAM,SAASG,GAC3B,GAAGA,EAAIC,OAAS,EAEf,IADA,IAAIA,EAASD,EAAIC,OACTC,EAAI,EAAGA,EAAID,EAAQC,IAC1BF,EAAIC,OAAS,EACbP,KAAKC,cAAcQ,KAAKH,QAGzBN,KAAKC,cAAcQ,KAAKH,IAEvBN,MACQG,EAAKA,EAAKO,OAAS,GAC3BN,GACFJ,KAAKC,cAAcQ,MAAOE,KAAMP,IAGjCJ,KAAKC,cAAcQ,MAAOE,MAAOX,KAAKY,KAAMZ,QAC5CA,KAAKa,OAAS,EACdb,KAAKc,OAGNA,IAAK,WAMJ,GAAId,KAAKF,SAAT,CAGA,IAAIQ,EAAMN,KAAKC,cAAcD,KAAKa,QAoBlC,GAnBAb,KAAKa,QAAU,EAmBZb,KAAKa,QAAUb,KAAKC,cAAcS,OACpCK,EAAmBT,EAAIK,WAKxB,GAAGL,EAAIU,YAC8B,IAAjCD,EAAmBT,EAAIK,MACzBM,WAAWvB,EAAKwB,MAAMlB,KAAM,OAAQM,EAAIU,YAExChB,KAAKH,WAAaS,EAAIU,gBAElB,GAAGV,EAAIa,YAAY,CACxB,IAAIC,EAAI1B,EAAKwB,MAAMlB,KAAK,YACa,IAAjCe,EAAmBT,EAAIK,OACzBX,KAAKc,QAGPG,WAAWG,EAAGd,EAAIa,kBAEkB,IAAjCJ,EAAmBT,EAAIK,OACzBX,KAAKc,MArCP,SAASC,EAAmBJ,GAa3B,OAXGjB,EAAK2B,QAAQV,GAGZA,EAAKD,OAAO,EACRC,EAAK,GAAGW,MAAMX,EAAK,GAAIA,EAAKY,MAAM,IAElCZ,EAAK,GAAGW,MAAMX,EAAK,IAGpBA,MA+BTa,KAAM,WAIFxB,KAAKH,YACPoB,WAAWvB,EAAKwB,MAAMlB,KAAM,OAAQA,KAAKH,YACzCG,KAAKH,WAAa,GACZG,KAAKc,OAGbF,KAAM,WAWLZ,KAAKF,UAAW","file":"../../timing/Sequence.js","sourcesContent":["define([\r\n\t\"dojo/_base/kernel\",\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/lang\",\r\n\t\"./_base\"\r\n], function(dojo){\r\n\tdojo.experimental(\"dojox.timing.Sequence\");\r\n\r\n\treturn dojo.declare(\"dojox.timing.Sequence\", null, {\r\n\t\t// summary:\r\n\t\t//\tThis class provides functionality to really sequentialize\r\n\t\t//\tfunction calls. You need to provide a list of functions and\r\n\t\t//\tsome parameters for each (like: pauseBefore) and they will\r\n\t\t//\tbe run one after another. This can be very useful for slideshows\r\n\t\t//\tor alike things.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\tThis array will contain the sequence defines resolved, so that\r\n\t\t// \tie. repeat:10 will result in 10 elements in the sequence, so\r\n\t\t// \tthe repeat handling is easier and we don't need to handle that\r\n\t\t// \tmany extra cases. Also the doneFunction, if given is added at the\r\n\t\t// \tend of the resolved-sequences.\r\n\r\n\t/*=====\r\n\t\t// _defsResolved: Array\r\n\t\t// \tThe resolved sequence, for easier handling.\r\n\t\t_defsResolved: [],\r\n\t=====*/\r\n\r\n\t\t// This is the time to wait before goOn() calls _go(), which\r\n\t\t// mostly results from a pauseAfter for a function that returned\r\n\t\t// false and is later continued by the external goOn() call.\r\n\t\t// The time to wait needs to be waited in goOn() where the\r\n\t\t// sequence is continued.\r\n\r\n\t\t// _goOnPause: Integer\r\n\t\t//\tThe pause to wait before really going on.\r\n\t\t_goOnPause: 0,\r\n\r\n\t\t_running: false,\r\n\r\n\t\tconstructor: function(){\r\n\t\t\tthis._defsResolved = [];\r\n\t\t},\r\n\r\n\t\tgo: function(/* Array */defs, /* Function|Array? */doneFunction){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRun the passed sequence definition\r\n\t\t\t// defs: Array\r\n\t\t\t//\t\tThe sequence of actions\r\n\t\t\t// doneFunction: Function|Array?\r\n\t\t\t//\t\tThe function to call when done\r\n\t\t\tthis._running = true;\r\n\t\t\tdojo.forEach(defs, function(cur){\r\n\t\t\t\tif(cur.repeat > 1){\r\n\t\t\t\t\tvar repeat = cur.repeat;\r\n\t\t\t\t\tfor(var j = 0; j < repeat; j++){\r\n\t\t\t\t\t\tcur.repeat = 1;\r\n\t\t\t\t\t\tthis._defsResolved.push(cur);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis._defsResolved.push(cur);\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t\tvar last = defs[defs.length - 1];\r\n\t\t\tif(doneFunction){\r\n\t\t\t\tthis._defsResolved.push({ func: doneFunction });\r\n\t\t\t}\r\n\t\t\t// stop the sequence, this actually just sets this._running to false\r\n\t\t\tthis._defsResolved.push({ func: [this.stop, this] });\r\n\t\t\tthis._curId = 0;\r\n\t\t\tthis._go();\r\n\t\t},\r\n\r\n\t\t_go: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tExecute one task of this._defsResolved.\r\n\r\n\t\t\t// if _running was set to false stop the sequence, this is the\r\n\t\t\t// case when i.e. stop() was called.\r\n\t\t\tif(!this._running){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar cur = this._defsResolved[this._curId];\r\n\t\t\tthis._curId += 1;\r\n\t\t\t// create the function to call, the func property might be an array, which means\r\n\t\t\t// [function, context, parameter1, parameter2, ...]\r\n\t\t\tfunction resolveAndCallFunc(func) {\r\n\t\t\t\tvar ret = null;\r\n\t\t\t\tif(dojo.isArray(func)){\r\n\t\t\t\t\t// Two elements might only be given when the function+context\r\n\t\t\t\t\t// is given, this is nice for using this, ie: [this.func, this]\r\n\t\t\t\t\tif(func.length>2){\r\n\t\t\t\t\t\tret = func[0].apply(func[1], func.slice(2));\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tret = func[0].apply(func[1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tret = func();\r\n\t\t\t\t}\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\r\n\t\t\tif(this._curId >= this._defsResolved.length){\r\n\t\t\t\tresolveAndCallFunc(cur.func); // call the last function, since it is the doneFunction we dont need to handle pause stuff\r\n\t\t\t\t// don't go on and call this._go() again, we are done\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif(cur.pauseAfter){\r\n\t\t\t\tif(resolveAndCallFunc(cur.func) !== false){\r\n\t\t\t\t\tsetTimeout(dojo.hitch(this, \"_go\"), cur.pauseAfter);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis._goOnPause = cur.pauseAfter;\r\n\t\t\t\t}\r\n\t\t\t}else if(cur.pauseBefore){\r\n\t\t\t\tvar x = dojo.hitch(this,function(){\r\n\t\t\t\t\tif(resolveAndCallFunc(cur.func) !== false){\r\n\t\t\t\t\t\tthis._go()\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tsetTimeout(x, cur.pauseBefore);\r\n\t\t\t}else{\r\n\t\t\t\tif(resolveAndCallFunc(cur.func) !== false){\r\n\t\t\t\t\tthis._go();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgoOn: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis method just provides a hook from the outside, so that\r\n\t\t\t//\t\tan interrupted sequence can be continued.\r\n\t\t\tif(this._goOnPause){\r\n\t\t\t\tsetTimeout(dojo.hitch(this, \"_go\"), this._goOnPause);\r\n\t\t\t\tthis._goOnPause = 0; // reset it, so if the next one doesnt set it we dont use the old pause\r\n\t\t\t}else{ this._go(); }\r\n\t\t},\r\n\r\n\t\tstop: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStop the currently running sequence.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis can only interrupt the sequence not the last function that\r\n\t\t\t//\t\thad been started. If the last function was i.e. a slideshow\r\n\t\t\t//\t\tthat is handled inside a function that you have given as\r\n\t\t\t//\t\tone sequence item it cant be stopped, since it is not controlled\r\n\t\t\t//\t\tby this object here. In this case it would be smarter to\r\n\t\t\t//\t\trun the slideshow using a sequence object so you can also stop\r\n\t\t\t//\t\tit using this method.\r\n\t\t\tthis._running = false;\r\n\t\t}\r\n\r\n\t});\r\n});\r\n"]}