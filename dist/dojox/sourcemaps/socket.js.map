{"version":3,"sources":["socket.js"],"names":["define","array","lang","xhr","aspect","on","Evented","dBaseUrl","WebSocket","window","Socket","argsOrUrl","url","LongPoll","args","fallback","opened","baseURI","document","location","href","ws","replace","type","listener","addEventListener","after","event","socket","newSocket","listenForOpen","send","hitch","close","proxyEvent","call","emit","forEach","timeoutId","fire","connect","cancelled","first","connections","data","sendArgs","delegate","rawBody","clearTimeout","deferred","firstRequest","transport","push","then","response","readyState","splice","indexOf","length","setTimeout","interval","error","wasClean","i","cancel","post","CONNECTING","OPEN","CLOSING","CLOSED","prototype","headers","Pragma","this","object","ioArgs"],"mappings":"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","file":"../socket.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/xhr\",\r\n\t\"dojo/aspect\",\r\n\t\"dojo/on\",\r\n\t\"dojo/Evented\",\r\n\t\"dojo/_base/url\"\r\n], function(array, lang, xhr, aspect, on, Evented, dBaseUrl) {\r\n\r\nvar WebSocket = window.WebSocket;\r\n\r\nvar Socket = function(/*dojo.__XhrArgs*/ argsOrUrl){\r\n\t// summary:\r\n\t//\t\tProvides a simple socket connection using WebSocket, or alternate\r\n\t//\t\tcommunication mechanisms in legacy browsers for comet-style communication. This is based\r\n\t//\t\ton the WebSocket API and returns an object that implements the WebSocket interface:\r\n\t//\t\thttp://dev.w3.org/html5/websockets/#websocket\r\n\t// description:\r\n\t//\t\tProvides socket connections. This can be used with virtually any Comet protocol.\r\n\t// argsOrUrl:\r\n\t//\t\tThis uses the same arguments as the other I/O functions in Dojo, or a\r\n\t//\t\tURL to connect to. The URL should be a relative URL in order to properly\r\n\t//\t\twork with WebSockets (it can still be host relative, like //other-site.org/endpoint)\r\n\t// returns:\r\n\t//\t\tAn object that implements the WebSocket API\r\n\t// example:\r\n\t//\t\t| require([\"dojox/socket\", \"dojo/aspect\"], function(socket, aspect) {\r\n\t//\t\t|    var sock = socket({\"url://comet-server/comet\");\r\n\t//\t\t|    // we could also add auto-reconnect support\r\n\t//\t\t|    // now we can connect to standard HTML5 WebSocket-style events\r\n\t//\t\t|    aspect.after(socket, \"onmessage\", function(event){\r\n\t//\t\t|       var message = event.data;\r\n\t//\t\t|       // do something with the message\r\n\t//\t\t|    });\r\n\t//\t\t|    // send something\r\n\t//\t\t|    sock.send(\"hi there\");\r\n\t//\t\t|    ...\r\n\t//\t\t| });\r\n\t//\t\tYou can also use the Reconnect module:\r\n\t//\t\t| require[\"dojox/socket\", \"dojox/socket/Reconnect\"], function(dxSocket, reconnect){\r\n\t//\t\t|    var socket = dxSocket({url:\"/comet\"});\r\n\t//\t\t|    // add auto-reconnect support\r\n\t//\t\t|    socket = reconnect(socket);\r\n\tif(typeof argsOrUrl == \"string\"){\r\n\t\targsOrUrl = {url: argsOrUrl};\r\n\t}\r\n\treturn WebSocket ? Socket.WebSocket(argsOrUrl, true) : Socket.LongPoll(argsOrUrl);\r\n};\r\n\r\nSocket.WebSocket = function(args, fallback){\r\n\t// summary:\r\n\t//\t\tA wrapper for WebSocket, than handles standard args and relative URLs\r\n\tvar baseURI = document.baseURI || window.location.href;\r\n\tvar ws = new WebSocket(new dBaseUrl(baseURI.replace(/^http/i,'ws'), args.url));\r\n\tws.on = function(type, listener){\r\n\t\tws.addEventListener(type, listener, true);\r\n\t};\r\n\tvar opened;\r\n\taspect.after(ws, \"onopen\", function(event){\r\n\t\topened = true;\r\n\t}, true);\r\n\taspect.after(ws, \"onclose\", function(event){\r\n\t\tif(opened){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(fallback){\r\n\t\t\tSocket.replace(ws, Socket.LongPoll(args), true);\r\n\t\t}\r\n\t}, true);\r\n\treturn ws;\r\n};\r\n\r\nSocket.replace = function(socket, newSocket, listenForOpen){\r\n\t// make the original socket a proxy for the new socket\r\n\tsocket.send = lang.hitch(newSocket, \"send\");\r\n\tsocket.close = lang.hitch(newSocket, \"close\");\r\n\tvar proxyEvent = function(type){\r\n\t\t(newSocket.addEventListener || newSocket.on).call(newSocket, type, function(event){\r\n\t\t\ton.emit(socket, event.type, event);\r\n\t\t}, true);\r\n\t};\r\n\r\n\tif(listenForOpen){\r\n\t\tproxyEvent(\"open\");\r\n\t}\r\n\t// redirect the events as well\r\n\tarray.forEach([\"message\", \"close\", \"error\"], proxyEvent);\r\n};\r\n\r\nSocket.LongPoll = function(/*dojo.__XhrArgs*/ args){\r\n\t// summary:\r\n\t//\t\tProvides a simple long-poll based comet-style socket/connection to a server and returns an\r\n\t//\t\tobject implementing the WebSocket interface:\r\n\t//\t\thttp://dev.w3.org/html5/websockets/#websocket\r\n\t// args:\r\n\t//\t\tThis uses the same arguments as the other I/O functions in Dojo, with this addition:\r\n\t//\targs.interval:\r\n\t//\t\tIndicates the amount of time (in milliseconds) after a response was received\r\n\t//\t\tbefore another request is made. By default, a request is made immediately\r\n\t//\t\tafter getting a response. The interval can be increased to reduce load on the\r\n\t//\t\tserver or to do simple time-based polling where the server always responds\r\n\t//\t\timmediately.\r\n\t//\targs.transport:\r\n\t//\t\tProvide an alternate transport like dojo.io.script.get\r\n\t// returns:\r\n\t//\t\tAn object that implements the WebSocket API\r\n\t// example:\r\n\t//\t\t| dojo.require(\"dojox.socket.LongPoll\");\r\n\t//\t\t| var socket = dojox.socket.LongPoll({url:\"/comet\"});\r\n\t//\t\tor:\r\n\t//\t\t| dojo.require(\"dojox.socket.LongPoll\");\r\n\t//\t\t| dojox.socket.LongPoll.add();\r\n\t//\t\t| var socket = dojox.socket({url:\"/comet\"});\r\n\r\n\tvar cancelled = false,\r\n\t\tfirst = true,\r\n\t\ttimeoutId,\r\n\t\tconnections = [];\r\n\r\n\t// create the socket object\r\n\tvar fire, connect;\r\n\tvar socket = {\r\n\t\tsend: function(data){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSend some data using XHR or provided transport\r\n\t\t\tvar sendArgs = lang.delegate(args);\r\n\t\t\tsendArgs.rawBody = data;\r\n\t\t\tclearTimeout(timeoutId);\r\n\t\t\tvar deferred = first ? (first = false) || socket.firstRequest(sendArgs) :\r\n\t\t\t\tsocket.transport(sendArgs);\r\n\t\t\tconnections.push(deferred);\r\n\t\t\tdeferred.then(function(response){\r\n\t\t\t\t// got a response\r\n\t\t\t\tsocket.readyState = 1;\r\n\t\t\t\t// remove the current connection\r\n\t\t\t\tconnections.splice(array.indexOf(connections, deferred), 1);\r\n\t\t\t\t// reconnect to listen for the next message if there are no active connections,\r\n\t\t\t\t// we queue it up in case one of the onmessage handlers has a message to send\r\n\t\t\t\tif(!connections.length){\r\n\t\t\t\t\ttimeoutId = setTimeout(connect, args.interval);\r\n\t\t\t\t}\r\n\t\t\t\tif(response){\r\n\t\t\t\t\t// now send the message along to listeners\r\n\t\t\t\t\tfire(\"message\", {data: response}, deferred);\r\n\t\t\t\t}\r\n\t\t\t}, function(error){\r\n\t\t\t\tconnections.splice(array.indexOf(connections, deferred), 1);\r\n\t\t\t\t// an error occurred, fire the appropriate event listeners\r\n\t\t\t\tif(!cancelled){\r\n\t\t\t\t\tfire(\"error\", {error:error}, deferred);\r\n\t\t\t\t\tif(!connections.length){\r\n\t\t\t\t\t\tsocket.readyState = 3;\r\n\t\t\t\t\t\tfire(\"close\", {wasClean:false}, deferred);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn deferred;\r\n\t\t},\r\n\t\tclose: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tClose the connection\r\n\t\t\tsocket.readyState = 2;\r\n\t\t\tcancelled = true;\r\n\t\t\tvar i;\r\n\t\t\tfor(i = 0; i < connections.length; i++){\r\n\t\t\t\tconnections[i].cancel();\r\n\t\t\t}\r\n\t\t\tsocket.readyState = 3;\r\n\t\t\tfire(\"close\", {wasClean:true});\r\n\t\t},\r\n\t\ttransport: args.transport || xhr.post,\r\n\t\targs: args,\r\n\t\turl: args.url,\r\n\t\treadyState: 0,\r\n\t\tCONNECTING: 0,\r\n\t\tOPEN: 1,\r\n\t\tCLOSING: 2,\r\n\t\tCLOSED: 3,\r\n\t\ton: Evented.prototype.on,\r\n\t\tfirstRequest: function(args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis allows for special handling for the first request. This is useful for\r\n\t\t\t//\t\tproviding information to disambiguate between the first request and\r\n\t\t\t//\t\tsubsequent long-poll requests so the server can properly setup a\r\n\t\t\t//\t\tconnection on the first connection or reject a request for an expired\r\n\t\t\t//\t\tconnection if the request is not expecting to be the first for a connection.\r\n\t\t\t//\t\tThis method can be overriden. The default behavior is to include a Pragma\r\n\t\t\t//\t\theader with a value of \"start-long-poll\"\r\n\t\t\tvar headers = (args.headers || (args.headers = {}));\r\n\t\t\theaders.Pragma = \"start-long-poll\";\r\n\t\t\ttry{\r\n\t\t\t\treturn this.transport(args);\r\n\t\t\t}finally{\r\n\t\t\t\t// cleanup the header so it is not used on subsequent requests\r\n\t\t\t\tdelete headers.Pragma;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tfire = function(type, object, deferred){\r\n\t\tif(socket[\"on\" + type]){\r\n\t\t\tobject.ioArgs = deferred && deferred.ioArgs;\r\n\t\t\tobject.type = type;\r\n\t\t\ton.emit(socket, type, object);\r\n\t\t}\r\n\t};\r\n\tconnect = function(){\r\n\t\tif(socket.readyState == 0){\r\n\t\t\t// we fire the open event now because we really don't know when the \"socket\"\r\n\t\t\t// is truly open, and this gives us a to do a send() and get it included in the\r\n\t\t\t// HTTP request\r\n\t\t\tfire(\"open\",{});\r\n\t\t}\r\n\t\t// make the long-poll connection, to wait for response from the server\r\n\t\tif(!connections.length){\r\n\t\t\tsocket.send();\r\n\t\t}\r\n\t};\r\n\t// provide an alias for Dojo's connect method\r\n\tsocket.connect = socket.on;\r\n\t// do the initial connection\r\n\tsetTimeout(connect);\r\n\treturn socket;\r\n};\r\n\r\nreturn Socket;\r\n\r\n});\r\n"]}