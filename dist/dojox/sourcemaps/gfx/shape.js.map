{"version":3,"sources":["gfx/shape.js"],"names":["define","g","lang","declare","kernel","has","on","arr","domConstruct","Color","matrixLib","shape","Shape","constructor","this","rawNode","matrix","fillStyle","strokeStyle","bbox","parent","parentMatrix","uid","register","getUID","destroy","dispose","__gfxObject__","getNode","getShape","getTransform","getFill","getStroke","getParent","getBoundingBox","getTransformedBoundingBox","b","m","_getRealMatrix","gm","multiplyPoint","x","y","width","height","getEventSource","setClip","clip","getClip","setShape","makeParameters","setFill","fill","f","type","defaultLinearGradient","defaultRadialGradient","defaultPattern","normalizeColor","setStroke","stroke","isArray","color","s","defaultStroke","setTransform","clone","normalize","identity","_applyTransform","moveToFront","p","_moveChildToFront","_moveToFront","moveToBack","_moveChildToBack","_moveToBack","applyRightTransform","applyLeftTransform","applyTransform","removeShape","silently","remove","_setParent","_updateParentMatrix","multiply","_eventsProcessing","listener","fixCallback","fixTarget","connect","name","object","method","substring","hitch","disconnect","token","gfxElement","fixFunction","scope","isString","global","join","e","apply","arguments","undefined","extend","Container","_init","children","_batch","openBatch","closeBatch","add","oldParent","push","i","length","splice","clear","result","forEach","bb","ct","multiplyRectangle","Math","min","endX","max","endY","unshift","Surface","_parent","_nodes","_events","h","lastChild","innerHTML","isLoaded","onLoad","surface","whenLoaded","context","once","Rect","getDefault","Ellipse","cx","rx","cy","ry","Circle","r","Line","x1","x2","y1","y2","abs","Polyline","points","closed","Array","inherited","_normalizePoints","l","t","Image","Text","fontStyle","getFont","setFont","newFont","splitFontString","defaultFont","_setFont","text","_base","_computeTextBoundingBox","Creator","createShape","defaultPath","createPath","defaultRect","createRect","defaultCircle","createCircle","defaultEllipse","createEllipse","defaultLine","createLine","defaultPolyline","createPolyline","defaultImage","createImage","defaultText","createText","defaultTextPath","createTextPath","createGroup","createObject","Group","rect","ellipse","circle","line","image","path","Path","TextPath","setText","shapeType","rawShape"],"mappings":"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","file":"../../gfx/shape.js","sourcesContent":["define([\"./_base\", \"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/kernel\", \"dojo/_base/sniff\",\r\n\t\"dojo/on\", \"dojo/_base/array\", \"dojo/dom-construct\", \"dojo/_base/Color\", \"./matrix\" ],\r\n\tfunction(g, lang, declare, kernel, has, on, arr, domConstruct, Color, matrixLib){\r\n\r\n\tvar shape = g.shape = {\r\n\t\t// summary:\r\n\t\t//\t\tThis module contains the core graphics Shape API.\r\n\t\t//\t\tDifferent graphics renderer implementation modules (svg, canvas, vml, silverlight, etc.) extend this\r\n\t\t//\t\tbasic api to provide renderer-specific implementations for each shape.\r\n\t};\r\n\r\n\tshape.Shape = declare(\"dojox.gfx.shape.Shape\", null, {\r\n\t\t// summary:\r\n\t\t//\t\ta Shape object, which knows how to apply\r\n\t\t//\t\tgraphical attributes and transformations\r\n\t\r\n\t\tconstructor: function(){\r\n\t\t\t// rawNode: Node\r\n\t\t\t//\t\tunderlying graphics-renderer-specific implementation object (if applicable)\r\n\t\t\tthis.rawNode = null;\r\n\r\n\t\t\t// shape: Object\r\n\t\t\t//\t\tan abstract shape object\r\n\t\t\t//\t\t(see dojox/gfx.defaultPath,\r\n\t\t\t//\t\tdojox/gfx.defaultPolyline,\r\n\t\t\t//\t\tdojox/gfx.defaultRect,\r\n\t\t\t//\t\tdojox/gfx.defaultEllipse,\r\n\t\t\t//\t\tdojox/gfx.defaultCircle,\r\n\t\t\t//\t\tdojox/gfx.defaultLine,\r\n\t\t\t//\t\tor dojox/gfx.defaultImage)\r\n\t\t\tthis.shape = null;\r\n\t\r\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\ta transformation matrix\r\n\t\t\tthis.matrix = null;\r\n\t\r\n\t\t\t// fillStyle: dojox/gfx.Fill\r\n\t\t\t//\t\ta fill object\r\n\t\t\t//\t\t(see dojox/gfx.defaultLinearGradient,\r\n\t\t\t//\t\tdojox/gfx.defaultRadialGradient,\r\n\t\t\t//\t\tdojox/gfx.defaultPattern,\r\n\t\t\t//\t\tor dojo/Color)\r\n\t\t\tthis.fillStyle = null;\r\n\t\r\n\t\t\t// strokeStyle: dojox/gfx.Stroke\r\n\t\t\t//\t\ta stroke object\r\n\t\t\t//\t\t(see dojox/gfx.defaultStroke)\r\n\t\t\tthis.strokeStyle = null;\r\n\t\r\n\t\t\t// bbox: dojox/gfx.Rectangle\r\n\t\t\t//\t\ta bounding box of this shape\r\n\t\t\t//\t\t(see dojox/gfx.defaultRect)\r\n\t\t\tthis.bbox = null;\r\n\t\r\n\t\t\t// virtual group structure\r\n\t\r\n\t\t\t// parent: Object\r\n\t\t\t//\t\ta parent or null\r\n\t\t\t//\t\t(see dojox/gfx/shape.Surface,\r\n\t\t\t//\t\tor dojox/gfx.Group)\r\n\t\t\tthis.parent = null;\r\n\t\r\n\t\t\t// parentMatrix: dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\ta transformation matrix inherited from the parent\r\n\t\t\tthis.parentMatrix = null;\r\n\r\n\t\t\tif(has(\"gfxRegistry\")){\r\n\t\t\t\tvar uid = shape.register(this);\r\n\t\t\t\tthis.getUID = function(){\r\n\t\t\t\t\treturn uid;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tdestroy: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReleases all internal resources owned by this shape. Once this method has been called,\r\n\t\t\t//\t\tthe instance is considered destroyed and should not be used anymore.\r\n\t\t\tif(has(\"gfxRegistry\")){\r\n\t\t\t\tshape.dispose(this);\r\n\t\t\t}\r\n\t\t\tif(this.rawNode && \"__gfxObject__\" in this.rawNode){\r\n\t\t\t\tthis.rawNode.__gfxObject__ = null;\r\n\t\t\t}\r\n\t\t\tthis.rawNode = null;\r\n\t\t},\r\n\t\r\n\t\t// trivial getters\r\n\t\r\n\t\tgetNode: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDifferent graphics rendering subsystems implement shapes in different ways.  This\r\n\t\t\t//\t\tmethod provides access to the underlying graphics subsystem object.  Clients calling this\r\n\t\t\t//\t\tmethod and using the return value must be careful not to try sharing or using the underlying node\r\n\t\t\t//\t\tin a general way across renderer implementation.\r\n\t\t\t//\t\tReturns the underlying graphics Node, or null if no underlying graphics node is used by this shape.\r\n\t\t\treturn this.rawNode; // Node\r\n\t\t},\r\n\t\tgetShape: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the current Shape object or null\r\n\t\t\t//\t\t(see dojox/gfx.defaultPath,\r\n\t\t\t//\t\tdojox/gfx.defaultPolyline,\r\n\t\t\t//\t\tdojox/gfx.defaultRect,\r\n\t\t\t//\t\tdojox/gfx.defaultEllipse,\r\n\t\t\t//\t\tdojox/gfx.defaultCircle,\r\n\t\t\t//\t\tdojox/gfx.defaultLine,\r\n\t\t\t//\t\tor dojox/gfx.defaultImage)\r\n\t\t\treturn this.shape; // Object\r\n\t\t},\r\n\t\tgetTransform: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the current transformation matrix applied to this Shape or null\r\n\t\t\treturn this.matrix;\t// dojox/gfx/matrix.Matrix2D\r\n\t\t},\r\n\t\tgetFill: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the current fill object or null\r\n\t\t\t//\t\t(see dojox/gfx.defaultLinearGradient,\r\n\t\t\t//\t\tdojox/gfx.defaultRadialGradient,\r\n\t\t\t//\t\tdojox/gfx.defaultPattern,\r\n\t\t\t//\t\tor dojo/Color)\r\n\t\t\treturn this.fillStyle;\t// Object\r\n\t\t},\r\n\t\tgetStroke: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the current stroke object or null\r\n\t\t\t//\t\t(see dojox/gfx.defaultStroke)\r\n\t\t\treturn this.strokeStyle;\t// Object\r\n\t\t},\r\n\t\tgetParent: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the parent Shape, Group or null if this Shape is unparented.\r\n\t\t\t//\t\t(see dojox/gfx/shape.Surface,\r\n\t\t\t//\t\tor dojox/gfx.Group)\r\n\t\t\treturn this.parent;\t// Object\r\n\t\t},\r\n\t\tgetBoundingBox: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the bounding box Rectangle for this shape or null if a BoundingBox cannot be\r\n\t\t\t//\t\tcalculated for the shape on the current renderer or for shapes with no geometric area (points).\r\n\t\t\t//\t\tA bounding box is a rectangular geometric region\r\n\t\t\t//\t\tdefining the X and Y extent of the shape.\r\n\t\t\t//\t\t(see dojox/gfx.defaultRect)\r\n\t\t\t//\t\tNote that this method returns a direct reference to the attribute of this instance. Therefore you should\r\n\t\t\t//\t\tnot modify its value directly but clone it instead.\r\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\r\n\t\t},\r\n\t\tgetTransformedBoundingBox: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns an array of four points or null\r\n\t\t\t//\t\tfour points represent four corners of the untransformed bounding box\r\n\t\t\tvar b = this.getBoundingBox();\r\n\t\t\tif(!b){\r\n\t\t\t\treturn null;\t// null\r\n\t\t\t}\r\n\t\t\tvar m = this._getRealMatrix(),\r\n\t\t\t\tgm = matrixLib;\r\n\t\t\treturn [\t// Array\r\n\t\t\t\t\tgm.multiplyPoint(m, b.x, b.y),\r\n\t\t\t\t\tgm.multiplyPoint(m, b.x + b.width, b.y),\r\n\t\t\t\t\tgm.multiplyPoint(m, b.x + b.width, b.y + b.height),\r\n\t\t\t\t\tgm.multiplyPoint(m, b.x, b.y + b.height)\r\n\t\t\t\t];\r\n\t\t},\r\n\t\tgetEventSource: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns a Node, which is used as\r\n\t\t\t//\t\ta source of events for this shape\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t\treturn this.rawNode;\t// Node\r\n\t\t},\r\n\t\r\n\t\t// empty settings\r\n\t\t\r\n\t\tsetClip: function(clip){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets the clipping area of this shape.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe clipping area defines the shape area that will be effectively visible. Everything that\r\n\t\t\t//\t\twould be drawn outside of the clipping area will not be rendered.\r\n\t\t\t//\t\tThe possible clipping area types are rectangle, ellipse, polyline and path, but all are not\r\n\t\t\t//\t\tsupported by all the renderers. vml only supports rectangle clipping, while the gfx silverlight renderer does not\r\n\t\t\t//\t\tsupport path clipping.\r\n\t\t\t//\t\tThe clip parameter defines the clipping area geometry, and should be an object with the following properties:\r\n\t\t\t//\r\n\t\t\t//\t\t- {x:Number, y:Number, width:Number, height:Number} for rectangular clip\r\n\t\t\t//\t\t- {cx:Number, cy:Number, rx:Number, ry:Number} for ellipse clip\r\n\t\t\t//\t\t- {points:Array} for polyline clip\r\n\t\t\t//\t\t- {d:String} for a path clip.\r\n\t\t\t//\r\n\t\t\t//\t\tThe clip geometry coordinates are expressed in the coordinate system used to draw the shape. In other\r\n\t\t\t//\t\twords, the clipping area is defined in the shape parent coordinate system and the shape transform is automatically applied.\r\n\t\t\t// example:\r\n\t\t\t//\t\tThe following example shows how to clip a gfx image with all the possible clip geometry: a rectangle,\r\n\t\t\t//\t\tan ellipse, a circle (using the ellipse geometry), a polyline and a path:\r\n\t\t\t//\r\n\t\t\t//\t|\tsurface.createImage({src:img, width:200,height:200}).setClip({x:10,y:10,width:50,height:50});\r\n\t\t\t//\t|\tsurface.createImage({src:img, x:100,y:50,width:200,height:200}).setClip({cx:200,cy:100,rx:20,ry:30});\r\n\t\t\t//\t|\tsurface.createImage({src:img, x:0,y:350,width:200,height:200}).setClip({cx:100,cy:425,rx:60,ry:60});\r\n\t\t\t//\t|\tsurface.createImage({src:img, x:300,y:0,width:200,height:200}).setClip({points:[350,0,450,50,380,130,300,110]});\r\n\t\t\t//\t|\tsurface.createImage({src:img, x:300,y:350,width:200,height:200}).setClip({d:\"M 350,350 C314,414 317,557 373,450.0000 z\"});\r\n\r\n\t\t\t// clip: Object\r\n\t\t\t//\t\tan object that defines the clipping geometry, or null to remove clip.\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t\tthis.clip = clip;\r\n\t\t},\r\n\t\t\r\n\t\tgetClip: function(){\r\n\t\t\treturn this.clip;\r\n\t\t},\r\n\t\r\n\t\tsetShape: function(shape){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets a shape object\r\n\t\t\t//\t\t(the default implementation simply ignores it)\r\n\t\t\t// shape: Object\r\n\t\t\t//\t\ta shape object\r\n\t\t\t//\t\t(see dojox/gfx.defaultPath,\r\n\t\t\t//\t\tdojox/gfx.defaultPolyline,\r\n\t\t\t//\t\tdojox/gfx.defaultRect,\r\n\t\t\t//\t\tdojox/gfx.defaultEllipse,\r\n\t\t\t//\t\tdojox/gfx.defaultCircle,\r\n\t\t\t//\t\tdojox/gfx.defaultLine,\r\n\t\t\t//\t\tor dojox/gfx.defaultImage)\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t\tthis.shape = g.makeParameters(this.shape, shape);\r\n\t\t\tthis.bbox = null;\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\tsetFill: function(fill){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets a fill object\r\n\t\t\t//\t\t(the default implementation simply ignores it)\r\n\t\t\t// fill: Object\r\n\t\t\t//\t\ta fill object\r\n\t\t\t//\t\t(see dojox/gfx.defaultLinearGradient,\r\n\t\t\t//\t\tdojox/gfx.defaultRadialGradient,\r\n\t\t\t//\t\tdojox/gfx.defaultPattern,\r\n\t\t\t//\t\tor dojo/_base/Color)\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t\tif(!fill){\r\n\t\t\t\t// don't fill\r\n\t\t\t\tthis.fillStyle = null;\r\n\t\t\t\treturn this;\t// self\r\n\t\t\t}\r\n\t\t\tvar f = null;\r\n\t\t\tif(typeof(fill) == \"object\" && \"type\" in fill){\r\n\t\t\t\t// gradient or pattern\r\n\t\t\t\tswitch(fill.type){\r\n\t\t\t\t\tcase \"linear\":\r\n\t\t\t\t\t\tf = g.makeParameters(g.defaultLinearGradient, fill);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"radial\":\r\n\t\t\t\t\t\tf = g.makeParameters(g.defaultRadialGradient, fill);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"pattern\":\r\n\t\t\t\t\t\tf = g.makeParameters(g.defaultPattern, fill);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t// color object\r\n\t\t\t\tf = g.normalizeColor(fill);\r\n\t\t\t}\r\n\t\t\tthis.fillStyle = f;\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\tsetStroke: function(stroke){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets a stroke object\r\n\t\t\t//\t\t(the default implementation simply ignores it)\r\n\t\t\t// stroke: Object\r\n\t\t\t//\t\ta stroke object\r\n\t\t\t//\t\t(see dojox/gfx.defaultStroke)\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t\tif(!stroke){\r\n\t\t\t\t// don't stroke\r\n\t\t\t\tthis.strokeStyle = null;\r\n\t\t\t\treturn this;\t// self\r\n\t\t\t}\r\n\t\t\t// normalize the stroke\r\n\t\t\tif(typeof stroke == \"string\" || lang.isArray(stroke) || stroke instanceof Color){\r\n\t\t\t\tstroke = {color: stroke};\r\n\t\t\t}\r\n\t\t\tvar s = this.strokeStyle = g.makeParameters(g.defaultStroke, stroke);\r\n\t\t\ts.color = g.normalizeColor(s.color);\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\tsetTransform: function(matrix){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets a transformation matrix\r\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\ta matrix or a matrix-like object\r\n\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t\tthis.matrix = matrixLib.clone(matrix ? matrixLib.normalize(matrix) : matrixLib.identity);\r\n\t\t\treturn this._applyTransform();\t// self\r\n\t\t},\r\n\t\r\n\t\t_applyTransform: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tphysically sets a matrix\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\r\n\t\t// z-index\r\n\t\r\n\t\tmoveToFront: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tmoves a shape to front of its parent's list of shapes\r\n\t\t\tvar p = this.getParent();\r\n\t\t\tif(p){\r\n\t\t\t\tp._moveChildToFront(this);\r\n\t\t\t\tthis._moveToFront();\t// execute renderer-specific action\r\n\t\t\t}\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\tmoveToBack: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tmoves a shape to back of its parent's list of shapes\r\n\t\t\tvar p = this.getParent();\r\n\t\t\tif(p){\r\n\t\t\t\tp._moveChildToBack(this);\r\n\t\t\t\tthis._moveToBack();\t// execute renderer-specific action\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t_moveToFront: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\trenderer-specific hook, see dojox/gfx/shape.Shape.moveToFront()\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t},\r\n\t\t_moveToBack: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\trenderer-specific hook, see dojox/gfx/shape.Shape.moveToFront()\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t},\r\n\t\r\n\t\t// apply left & right transformation\r\n\t\r\n\t\tapplyRightTransform: function(matrix){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tmultiplies the existing matrix with an argument on right side\r\n\t\t\t//\t\t(this.matrix * matrix)\r\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\ta matrix or a matrix-like object\r\n\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\t\treturn matrix ? this.setTransform([this.matrix, matrix]) : this;\t// self\r\n\t\t},\r\n\t\tapplyLeftTransform: function(matrix){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tmultiplies the existing matrix with an argument on left side\r\n\t\t\t//\t\t(matrix * this.matrix)\r\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\ta matrix or a matrix-like object\r\n\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\t\treturn matrix ? this.setTransform([matrix, this.matrix]) : this;\t// self\r\n\t\t},\r\n\t\tapplyTransform: function(matrix){\r\n\t\t\t// summary:\r\n\t\t\t//\t\ta shortcut for dojox/gfx/shape.Shape.applyRightTransform\r\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\ta matrix or a matrix-like object\r\n\t\t\t//\t\t(see an argument of dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\t\treturn matrix ? this.setTransform([this.matrix, matrix]) : this;\t// self\r\n\t\t},\r\n\t\r\n\t\t// virtual group methods\r\n\t\r\n\t\tremoveShape: function(silently){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tremoves the shape from its parent's list of shapes\r\n\t\t\t// silently: Boolean\r\n\t\t\t//\t\tif true, do not redraw a picture yet\r\n\t\t\tif(this.parent){\r\n\t\t\t\tthis.parent.remove(this, silently);\r\n\t\t\t}\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\t_setParent: function(parent, matrix){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets a parent\r\n\t\t\t// parent: Object\r\n\t\t\t//\t\ta parent or null\r\n\t\t\t//\t\t(see dojox/gfx/shape.Surface,\r\n\t\t\t//\t\tor dojox/gfx.Group)\r\n\t\t\t// matrix: dojox/gfx/matrix.Matrix2D\r\n\t\t\t//\t\ta 2D matrix or a matrix-like object\r\n\t\t\tthis.parent = parent;\r\n\t\t\treturn this._updateParentMatrix(matrix);\t// self\r\n\t\t},\r\n\t\t_updateParentMatrix: function(matrix){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tupdates the parent matrix with new matrix\r\n\t\t\t// matrix: dojox/gfx/Matrix2D\r\n\t\t\t//\t\ta 2D matrix or a matrix-like object\r\n\t\t\tthis.parentMatrix = matrix ? matrixLib.clone(matrix) : null;\r\n\t\t\treturn this._applyTransform();\t// self\r\n\t\t},\r\n\t\t_getRealMatrix: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the cumulative ('real') transformation matrix\r\n\t\t\t//\t\tby combining the shape's matrix with its parent's matrix\r\n\t\t\tvar m = this.matrix;\r\n\t\t\tvar p = this.parent;\r\n\t\t\twhile(p){\r\n\t\t\t\tif(p.matrix){\r\n\t\t\t\t\tm = matrixLib.multiply(p.matrix, m);\r\n\t\t\t\t}\r\n\t\t\t\tp = p.parent;\r\n\t\t\t}\r\n\t\t\treturn m;\t// dojox/gfx/matrix.Matrix2D\r\n\t\t}\r\n\t});\r\n\t\r\n\tshape._eventsProcessing = {\r\n\t\ton: function(type, listener){\r\n\t\t\t//\tsummary:\r\n\t\t\t//\t\tConnects an event to this shape.\r\n\r\n\t\t\treturn on(this.getEventSource(), type, shape.fixCallback(this, g.fixTarget, listener));\r\n\t\t},\r\n\r\n\t\tconnect: function(name, object, method){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tconnects a handler to an event on this shape\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t\t// redirect to fixCallback to normalize events and add the gfxTarget to the event. The latter\r\n\t\t\t// is done by dojox/gfx.fixTarget which is defined by each renderer\r\n\t\t\tif(name.substring(0, 2) == \"on\"){\r\n\t\t\t\tname = name.substring(2);\r\n\t\t\t}\r\n\t\t\treturn this.on(name, method ? lang.hitch(object, method) : object);\r\n\t\t},\r\n\r\n\t\tdisconnect: function(token){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tconnects a handler by token from an event on this shape\r\n\t\t\t\r\n\t\t\t// COULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\r\n\t\t\treturn token.remove();\r\n\t\t}\r\n\t};\r\n\t\r\n\tshape.fixCallback = function(gfxElement, fixFunction, scope, method){\r\n\t\t// summary:\r\n\t\t//\t\tWraps the callback to allow for tests and event normalization\r\n\t\t//\t\tbefore it gets invoked. This is where 'fixTarget' is invoked.\r\n\t\t// tags:\r\n\t\t//      private\r\n\t\t// gfxElement: Object\r\n\t\t//\t\tThe GFX object that triggers the action (ex.:\r\n\t\t//\t\tdojox/gfx.Surface and dojox/gfx/shape.Shape). A new event property\r\n\t\t//\t\t'gfxTarget' is added to the event to reference this object.\r\n\t\t//\t\tfor easy manipulation of GFX objects by the event handlers.\r\n\t\t// fixFunction: Function\r\n\t\t//\t\tThe function that implements the logic to set the 'gfxTarget'\r\n\t\t//\t\tproperty to the event. It should be 'dojox/gfx.fixTarget' for\r\n\t\t//\t\tmost of the cases\r\n\t\t// scope: Object\r\n\t\t//\t\tOptional. The scope to be used when invoking 'method'. If\r\n\t\t//\t\tomitted, a global scope is used.\r\n\t\t// method: Function|String\r\n\t\t//\t\tThe original callback to be invoked.\r\n\t\tif(!method){\r\n\t\t\tmethod = scope;\r\n\t\t\tscope = null;\r\n\t\t}\r\n\t\tif(lang.isString(method)){\r\n\t\t\tscope = scope || kernel.global;\r\n\t\t\tif(!scope[method]){ throw(['dojox.gfx.shape.fixCallback: scope[\"', method, '\"] is null (scope=\"', scope, '\")'].join('')); }\r\n\t\t\treturn function(e){  \r\n\t\t\t\treturn fixFunction(e,gfxElement) ? scope[method].apply(scope, arguments || []) : undefined; }; // Function\r\n\t\t}\r\n\t\treturn !scope \r\n\t\t\t? function(e){ \r\n\t\t\t\treturn fixFunction(e,gfxElement) ? method.apply(scope, arguments) : undefined; } \r\n\t\t\t: function(e){ \r\n\t\t\t\treturn fixFunction(e,gfxElement) ? method.apply(scope, arguments || []) : undefined; }; // Function\r\n\t};\r\n\tlang.extend(shape.Shape, shape._eventsProcessing);\r\n\t\r\n\tshape.Container = {\r\n\t\t// summary:\r\n\t\t//\t\ta container of shapes, which can be used\r\n\t\t//\t\tas a foundation for renderer-specific groups, or as a way\r\n\t\t//\t\tto logically group shapes (e.g, to propagate matricies)\r\n\t\r\n\t\t_init: function() {\r\n\t\t\t// children: Array\r\n\t\t\t//\t\ta list of children\r\n\t\t\tthis.children = [];\r\n\t\t\tthis._batch = 0;\r\n\t\t},\r\n\t\r\n\t\t// group management\r\n\t\r\n\t\topenBatch: function() {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tstarts a new batch, subsequent new child shapes will be held in\r\n\t\t\t//\t\tthe batch instead of appending to the container directly.\r\n\t\t\t// description:\r\n\t\t\t//\t\tBecause the canvas renderer has no DOM hierarchy, the canvas implementation differs\r\n\t\t\t//\t\tsuch that it suspends the repaint requests for this container until the current batch is closed by a call to closeBatch().\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tcloseBatch: function() {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsubmits the current batch, append all pending child shapes to DOM\r\n\t\t\t// description:\r\n\t\t\t//\t\tOn canvas, this method flushes the pending redraws queue.\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tadd: function(shape){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tadds a shape to the list\r\n\t\t\t// shape: dojox/gfx/shape.Shape\r\n\t\t\t//\t\tthe shape to add to the list\r\n\t\t\tvar oldParent = shape.getParent();\r\n\t\t\tif(oldParent){\r\n\t\t\t\toldParent.remove(shape, true);\r\n\t\t\t}\r\n\t\t\tthis.children.push(shape);\r\n\t\t\treturn shape._setParent(this, this._getRealMatrix());\t// self\r\n\t\t},\r\n\t\tremove: function(shape, silently){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tremoves a shape from the list\r\n\t\t\t// shape: dojox/gfx/shape.Shape\r\n\t\t\t//\t\tthe shape to remove\r\n\t\t\t// silently: Boolean\r\n\t\t\t//\t\tif true, do not redraw a picture yet\r\n\t\t\tfor(var i = 0; i < this.children.length; ++i){\r\n\t\t\t\tif(this.children[i] == shape){\r\n\t\t\t\t\tif(silently){\r\n\t\t\t\t\t\t// skip for now\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tshape.parent = null;\r\n\t\t\t\t\t\tshape.parentMatrix = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.children.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\tclear: function(/*Boolean?*/ destroy){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tremoves all shapes from a group/surface.\r\n\t\t\t// destroy: Boolean\r\n\t\t\t//\t\tIndicates whether the children should be destroyed. Optional.\r\n\t\t\tvar shape;\r\n\t\t\tfor(var i = 0; i < this.children.length;++i){\r\n\t\t\t\tshape = this.children[i];\r\n\t\t\t\tshape.parent = null;\r\n\t\t\t\tshape.parentMatrix = null;\r\n\t\t\t\tif(destroy){\r\n\t\t\t\t\tshape.destroy();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.children = [];\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\tgetBoundingBox: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the bounding box Rectangle for this shape.\r\n\t\t\tif(this.children){\r\n\t\t\t\t// if this is a composite shape, then sum up all the children\r\n\t\t\t\tvar result = null;\r\n\t\t\t\tarr.forEach(this.children, function(shape){\r\n\t\t\t\t\tvar bb = shape.getBoundingBox();\r\n\t\t\t\t\tif(bb){\r\n\t\t\t\t\t\tvar ct = shape.getTransform();\r\n\t\t\t\t\t\tif(ct){\r\n\t\t\t\t\t\t\tbb = matrixLib.multiplyRectangle(ct, bb);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(result){\r\n\t\t\t\t\t\t\t// merge two bbox \r\n\t\t\t\t\t\t\tresult.x = Math.min(result.x, bb.x);\r\n\t\t\t\t\t\t\tresult.y = Math.min(result.y, bb.y);\r\n\t\t\t\t\t\t\tresult.endX = Math.max(result.endX, bb.x + bb.width);\r\n\t\t\t\t\t\t\tresult.endY = Math.max(result.endY, bb.y + bb.height);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// first bbox \r\n\t\t\t\t\t\t\tresult = {\r\n\t\t\t\t\t\t\t\tx: bb.x,\r\n\t\t\t\t\t\t\t\ty: bb.y,\r\n\t\t\t\t\t\t\t\tendX: bb.x + bb.width,\r\n\t\t\t\t\t\t\t\tendY: bb.y + bb.height\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tif(result){\r\n\t\t\t\t\tresult.width = result.endX - result.x;\r\n\t\t\t\t\tresult.height = result.endY - result.y;\r\n\t\t\t\t}\r\n\t\t\t\treturn result; // dojox/gfx.Rectangle\r\n\t\t\t}\r\n\t\t\t// unknown/empty bounding box, subclass shall override this impl \r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t// moving child nodes\r\n\t\t_moveChildToFront: function(shape){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tmoves a shape to front of the list of shapes\r\n\t\t\t// shape: dojox/gfx/shape.Shape\r\n\t\t\t//\t\tone of the child shapes to move to the front\r\n\t\t\tfor(var i = 0; i < this.children.length; ++i){\r\n\t\t\t\tif(this.children[i] == shape){\r\n\t\t\t\t\tthis.children.splice(i, 1);\r\n\t\t\t\t\tthis.children.push(shape);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\t_moveChildToBack: function(shape){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tmoves a shape to back of the list of shapes\r\n\t\t\t// shape: dojox/gfx/shape.Shape\r\n\t\t\t//\t\tone of the child shapes to move to the front\r\n\t\t\tfor(var i = 0; i < this.children.length; ++i){\r\n\t\t\t\tif(this.children[i] == shape){\r\n\t\t\t\t\tthis.children.splice(i, 1);\r\n\t\t\t\t\tthis.children.unshift(shape);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\t// self\r\n\t\t}\r\n\t};\r\n\r\n\tshape.Surface = declare(\"dojox.gfx.shape.Surface\", null, {\r\n\t\t// summary:\r\n\t\t//\t\ta surface object to be used for drawings\r\n\t\tconstructor: function(){\r\n\t\t\t// underlying node\r\n\t\t\tthis.rawNode = null;\r\n\t\t\t// the parent node\r\n\t\t\tthis._parent = null;\r\n\t\t\t// the list of DOM nodes to be deleted in the case of destruction\r\n\t\t\tthis._nodes = [];\r\n\t\t\t// the list of events to be detached in the case of destruction\r\n\t\t\tthis._events = [];\r\n\t\t},\r\n\t\tdestroy: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tdestroy all relevant external resources and release all\r\n\t\t\t//\t\texternal references to make this object garbage-collectible\r\n\t\t\tarr.forEach(this._nodes, domConstruct.destroy);\r\n\t\t\tthis._nodes = [];\r\n\t\t\tarr.forEach(this._events, function(h){ if(h){ h.remove(); } });\r\n\t\t\tthis._events = [];\r\n\t\t\tthis.rawNode = null;\t// recycle it in _nodes, if it needs to be recycled\r\n\t\t\tif(has(\"ie\")){\r\n\t\t\t\twhile(this._parent.lastChild){\r\n\t\t\t\t\tdomConstruct.destroy(this._parent.lastChild);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tthis._parent.innerHTML = \"\";\r\n\t\t\t}\r\n\t\t\tthis._parent = null;\r\n\t\t},\r\n\t\tgetEventSource: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns a node, which can be used to attach event listeners\r\n\t\t\treturn this.rawNode; // Node\r\n\t\t},\r\n\t\t_getRealMatrix: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\talways returns the identity matrix\r\n\t\t\treturn null;\t// dojox/gfx/Matrix2D\r\n\t\t},\r\n\t\t/*=====\r\n\t\t setDimensions: function(width, height){\r\n\t\t\t // summary:\r\n\t\t\t //\t\tsets the width and height of the rawNode\r\n\t\t\t // width: String\r\n\t\t\t //\t\twidth of surface, e.g., \"100px\"\r\n\t\t\t // height: String\r\n\t\t\t //\t\theight of surface, e.g., \"100px\"\r\n\t\t\t return this;\t// self\r\n\t\t },\r\n\t\t getDimensions: function(){\r\n\t\t\t // summary:\r\n\t\t\t //     gets current width and height in pixels\r\n\t\t\t // returns: Object\r\n\t\t\t //     object with properties \"width\" and \"height\"\r\n\t\t },\r\n\t\t =====*/\r\n\t\tisLoaded: true,\r\n\t\tonLoad: function(/*dojox/gfx/shape.Surface*/ surface){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tlocal event, fired once when the surface is created\r\n\t\t\t//\t\tasynchronously, used only when isLoaded is false, required\r\n\t\t\t//\t\tonly for Silverlight.\r\n\t\t},\r\n\t\twhenLoaded: function(/*Object|Null*/ context, /*Function|String*/ method){\r\n\t\t\tvar f = lang.hitch(context, method);\r\n\t\t\tif(this.isLoaded){\r\n\t\t\t\tf(this);\r\n\t\t\t}else{\r\n\t\t\t\ton.once(this, \"load\", function(surface){\r\n\t\t\t\t\tf(surface);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\tlang.extend(shape.Surface, shape._eventsProcessing);\r\n\r\n\t/*=====\r\n\tg.Point = declare(\"dojox/gfx.Point\", null, {\r\n\t\t// summary:\r\n\t\t//\t\t2D point for drawings - {x, y}\r\n\t\t// description:\r\n\t\t//\t\tDo not use this object directly!\r\n\t\t//\t\tUse the naked object instead: {x: 1, y: 2}.\r\n\t});\r\n\r\n\tg.Rectangle = declare(\"dojox.gfx.Rectangle\", null, {\r\n\t\t// summary:\r\n\t\t//\t\trectangle - {x, y, width, height}\r\n\t\t// description:\r\n\t\t//\t\tDo not use this object directly!\r\n\t\t//\t\tUse the naked object instead: {x: 1, y: 2, width: 100, height: 200}.\r\n\t});\r\n\t =====*/\r\n\r\n\r\n\tshape.Rect = declare(\"dojox.gfx.shape.Rect\", shape.Shape, {\r\n\t\t// summary:\r\n\t\t//\t\ta generic rectangle\r\n\t\tconstructor: function(rawNode){\r\n\t\t\t// rawNode: Node\r\n\t\t\t//\t\tThe underlying graphics system object (typically a DOM Node)\r\n\t\t\tthis.shape = g.getDefault(\"Rect\");\r\n\t\t\tthis.rawNode = rawNode;\r\n\t\t},\r\n\t\tgetBoundingBox: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the bounding box (its shape in this case)\r\n\t\t\treturn this.shape;\t// dojox/gfx.Rectangle\r\n\t\t}\r\n\t});\r\n\t\r\n\tshape.Ellipse = declare(\"dojox.gfx.shape.Ellipse\", shape.Shape, {\r\n\t\t// summary:\r\n\t\t//\t\ta generic ellipse\r\n\t\tconstructor: function(rawNode){\r\n\t\t\t// rawNode: Node\r\n\t\t\t//\t\ta DOM Node\r\n\t\t\tthis.shape = g.getDefault(\"Ellipse\");\r\n\t\t\tthis.rawNode = rawNode;\r\n\t\t},\r\n\t\tgetBoundingBox: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the bounding box\r\n\t\t\tif(!this.bbox){\r\n\t\t\t\tvar shape = this.shape;\r\n\t\t\t\tthis.bbox = {x: shape.cx - shape.rx, y: shape.cy - shape.ry,\r\n\t\t\t\t\twidth: 2 * shape.rx, height: 2 * shape.ry};\r\n\t\t\t}\r\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\r\n\t\t}\r\n\t});\r\n\t\r\n\tshape.Circle = declare(\"dojox.gfx.shape.Circle\", shape.Shape, {\r\n\t\t// summary:\r\n\t\t//\t\ta generic circle\r\n\t\tconstructor: function(rawNode){\r\n\t\t\t// rawNode: Node\r\n\t\t\t//\t\ta DOM Node\r\n\t\t\tthis.shape = g.getDefault(\"Circle\");\r\n\t\t\tthis.rawNode = rawNode;\r\n\t\t},\r\n\t\tgetBoundingBox: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the bounding box\r\n\t\t\tif(!this.bbox){\r\n\t\t\t\tvar shape = this.shape;\r\n\t\t\t\tthis.bbox = {x: shape.cx - shape.r, y: shape.cy - shape.r,\r\n\t\t\t\t\twidth: 2 * shape.r, height: 2 * shape.r};\r\n\t\t\t}\r\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\r\n\t\t}\r\n\t});\r\n\t\r\n\tshape.Line = declare(\"dojox.gfx.shape.Line\", shape.Shape, {\r\n\t\t// summary:\r\n\t\t//\t\ta generic line (do not instantiate it directly)\r\n\t\tconstructor: function(rawNode){\r\n\t\t\t// rawNode: Node\r\n\t\t\t//\t\ta DOM Node\r\n\t\t\tthis.shape = g.getDefault(\"Line\");\r\n\t\t\tthis.rawNode = rawNode;\r\n\t\t},\r\n\t\tgetBoundingBox: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the bounding box\r\n\t\t\tif(!this.bbox){\r\n\t\t\t\tvar shape = this.shape;\r\n\t\t\t\tthis.bbox = {\r\n\t\t\t\t\tx:\t\tMath.min(shape.x1, shape.x2),\r\n\t\t\t\t\ty:\t\tMath.min(shape.y1, shape.y2),\r\n\t\t\t\t\twidth:\tMath.abs(shape.x2 - shape.x1),\r\n\t\t\t\t\theight:\tMath.abs(shape.y2 - shape.y1)\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\r\n\t\t}\r\n\t});\r\n\t\r\n\tshape.Polyline = declare(\"dojox.gfx.shape.Polyline\", shape.Shape, {\r\n\t\t// summary:\r\n\t\t//\t\ta generic polyline/polygon (do not instantiate it directly)\r\n\t\tconstructor: function(rawNode){\r\n\t\t\t// rawNode: Node\r\n\t\t\t//\t\ta DOM Node\r\n\t\t\tthis.shape = g.getDefault(\"Polyline\");\r\n\t\t\tthis.rawNode = rawNode;\r\n\t\t},\r\n\t\tsetShape: function(points, closed){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets a polyline/polygon shape object\r\n\t\t\t// points: Object|Array\r\n\t\t\t//\t\ta polyline/polygon shape object, or an array of points\r\n\t\t\t// closed: Boolean\r\n\t\t\t//\t\tclose the polyline to make a polygon\r\n\t\t\tif(points && points instanceof Array){\r\n\t\t\t\tthis.inherited(arguments, [{points: points}]);\r\n\t\t\t\tif(closed && this.shape.points.length){\r\n\t\t\t\t\tthis.shape.points.push(this.shape.points[0]);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tthis.inherited(arguments, [points]);\r\n\t\t\t}\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\t_normalizePoints: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tnormalize points to array of {x:number, y:number}\r\n\t\t\tvar p = this.shape.points, l = p && p.length;\r\n\t\t\tif(l && typeof p[0] == \"number\"){\r\n\t\t\t\tvar points = [];\r\n\t\t\t\tfor(var i = 0; i < l; i += 2){\r\n\t\t\t\t\tpoints.push({x: p[i], y: p[i + 1]});\r\n\t\t\t\t}\r\n\t\t\t\tthis.shape.points = points;\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetBoundingBox: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the bounding box\r\n\t\t\tif(!this.bbox && this.shape.points.length){\r\n\t\t\t\tvar p = this.shape.points;\r\n\t\t\t\tvar l = p.length;\r\n\t\t\t\tvar t = p[0];\r\n\t\t\t\tvar bbox = {l: t.x, t: t.y, r: t.x, b: t.y};\r\n\t\t\t\tfor(var i = 1; i < l; ++i){\r\n\t\t\t\t\tt = p[i];\r\n\t\t\t\t\tif(bbox.l > t.x) bbox.l = t.x;\r\n\t\t\t\t\tif(bbox.r < t.x) bbox.r = t.x;\r\n\t\t\t\t\tif(bbox.t > t.y) bbox.t = t.y;\r\n\t\t\t\t\tif(bbox.b < t.y) bbox.b = t.y;\r\n\t\t\t\t}\r\n\t\t\t\tthis.bbox = {\r\n\t\t\t\t\tx:\t\tbbox.l,\r\n\t\t\t\t\ty:\t\tbbox.t,\r\n\t\t\t\t\twidth:\tbbox.r - bbox.l,\r\n\t\t\t\t\theight:\tbbox.b - bbox.t\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\treturn this.bbox;\t// dojox/gfx.Rectangle\r\n\t\t}\r\n\t});\r\n\t\r\n\tshape.Image = declare(\"dojox.gfx.shape.Image\", shape.Shape, {\r\n\t\t// summary:\r\n\t\t//\t\ta generic image (do not instantiate it directly)\r\n\t\tconstructor: function(rawNode){\r\n\t\t\t// rawNode: Node\r\n\t\t\t//\t\ta DOM Node\r\n\t\t\tthis.shape = g.getDefault(\"Image\");\r\n\t\t\tthis.rawNode = rawNode;\r\n\t\t},\r\n\t\tgetBoundingBox: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the bounding box (its shape in this case)\r\n\t\t\treturn this.shape;\t// dojox/gfx.Rectangle\r\n\t\t},\r\n\t\tsetStroke: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tignore setting a stroke style\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\tsetFill: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tignore setting a fill style\r\n\t\t\treturn this;\t// self\r\n\t\t}\r\n\t});\r\n\t\r\n\tshape.Text = declare(shape.Shape, {\r\n\t\t// summary:\r\n\t\t//\t\ta generic text (do not instantiate it directly)\r\n\t\tconstructor: function(rawNode){\r\n\t\t\t// rawNode: Node\r\n\t\t\t//\t\ta DOM Node\r\n\t\t\tthis.fontStyle = null;\r\n\t\t\tthis.shape = g.getDefault(\"Text\");\r\n\t\t\tthis.rawNode = rawNode;\r\n\t\t},\r\n\t\tgetFont: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the current font object or null\r\n\t\t\treturn this.fontStyle;\t// Object\r\n\t\t},\r\n\t\tsetFont: function(newFont){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets a font for text\r\n\t\t\t// newFont: Object\r\n\t\t\t//\t\ta font object (see dojox/gfx.defaultFont) or a font string\r\n\t\t\tthis.fontStyle = typeof newFont == \"string\" ? g.splitFontString(newFont) :\r\n\t\t\t\tg.makeParameters(g.defaultFont, newFont);\r\n\t\t\tthis._setFont();\r\n\t\t\treturn this;\t// self\r\n\t\t},\r\n\t\tgetBoundingBox: function(){\r\n\t\t\tvar bbox = null, s = this.getShape();\r\n\t\t\tif(s.text){\r\n\t\t\t\tbbox = g._base._computeTextBoundingBox(this);\r\n\t\t\t}\r\n\t\t\treturn bbox;\r\n\t\t}\r\n\t});\r\n\t\r\n\tshape.Creator = {\r\n\t\t// summary:\r\n\t\t//\t\tshape creators\r\n\t\tcreateShape: function(shape){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a shape object based on its type; it is meant to be used\r\n\t\t\t//\t\tby group-like objects\r\n\t\t\t// shape: Object\r\n\t\t\t//\t\ta shape descriptor object\r\n\t\t\t// returns: dojox/gfx/shape.Shape | Null\r\n\t\t\t//      a fully instantiated surface-specific Shape object\r\n\t\t\tswitch(shape.type){\r\n\t\t\t\tcase g.defaultPath.type:\t\treturn this.createPath(shape);\r\n\t\t\t\tcase g.defaultRect.type:\t\treturn this.createRect(shape);\r\n\t\t\t\tcase g.defaultCircle.type:\t    return this.createCircle(shape);\r\n\t\t\t\tcase g.defaultEllipse.type:\t    return this.createEllipse(shape);\r\n\t\t\t\tcase g.defaultLine.type:\t\treturn this.createLine(shape);\r\n\t\t\t\tcase g.defaultPolyline.type:\treturn this.createPolyline(shape);\r\n\t\t\t\tcase g.defaultImage.type:\t\treturn this.createImage(shape);\r\n\t\t\t\tcase g.defaultText.type:\t\treturn this.createText(shape);\r\n\t\t\t\tcase g.defaultTextPath.type:\treturn this.createTextPath(shape);\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\tcreateGroup: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a group shape\r\n\t\t\treturn this.createObject(g.Group);\t// dojox/gfx/Group\r\n\t\t},\r\n\t\tcreateRect: function(rect){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a rectangle shape\r\n\t\t\t// rect: Object\r\n\t\t\t//\t\ta path object (see dojox/gfx.defaultRect)\r\n\t\t\treturn this.createObject(g.Rect, rect);\t// dojox/gfx/shape.Rect\r\n\t\t},\r\n\t\tcreateEllipse: function(ellipse){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates an ellipse shape\r\n\t\t\t// ellipse: Object\r\n\t\t\t//\t\tan ellipse object (see dojox/gfx.defaultEllipse)\r\n\t\t\treturn this.createObject(g.Ellipse, ellipse);\t// dojox/gfx/shape.Ellipse\r\n\t\t},\r\n\t\tcreateCircle: function(circle){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a circle shape\r\n\t\t\t// circle: Object\r\n\t\t\t//\t\ta circle object (see dojox/gfx.defaultCircle)\r\n\t\t\treturn this.createObject(g.Circle, circle);\t// dojox/gfx/shape.Circle\r\n\t\t},\r\n\t\tcreateLine: function(line){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a line shape\r\n\t\t\t// line: Object\r\n\t\t\t//\t\ta line object (see dojox/gfx.defaultLine)\r\n\t\t\treturn this.createObject(g.Line, line);\t// dojox/gfx/shape.Line\r\n\t\t},\r\n\t\tcreatePolyline: function(points){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a polyline/polygon shape\r\n\t\t\t// points: Object\r\n\t\t\t//\t\ta points object (see dojox/gfx.defaultPolyline)\r\n\t\t\t//\t\tor an Array of points\r\n\t\t\treturn this.createObject(g.Polyline, points);\t// dojox/gfx/shape.Polyline\r\n\t\t},\r\n\t\tcreateImage: function(image){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a image shape\r\n\t\t\t// image: Object\r\n\t\t\t//\t\tan image object (see dojox/gfx.defaultImage)\r\n\t\t\treturn this.createObject(g.Image, image);\t// dojox/gfx/shape.Image\r\n\t\t},\r\n\t\tcreateText: function(text){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a text shape\r\n\t\t\t// text: Object\r\n\t\t\t//\t\ta text object (see dojox/gfx.defaultText)\r\n\t\t\treturn this.createObject(g.Text, text);\t// dojox/gfx/shape.Text\r\n\t\t},\r\n\t\tcreatePath: function(path){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a path shape\r\n\t\t\t// path: Object\r\n\t\t\t//\t\ta path object (see dojox/gfx.defaultPath)\r\n\t\t\treturn this.createObject(g.Path, path);\t// dojox/gfx/shape.Path\r\n\t\t},\r\n\t\tcreateTextPath: function(text){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a text shape\r\n\t\t\t// text: Object\r\n\t\t\t//\t\ta textpath object (see dojox/gfx.defaultTextPath)\r\n\t\t\treturn this.createObject(g.TextPath, {}).setText(text);\t// dojox/gfx/shape.TextPath\r\n\t\t},\r\n\t\tcreateObject: function(shapeType, rawShape){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates an instance of the passed shapeType class\r\n\t\t\t// shapeType: Function\r\n\t\t\t//\t\ta class constructor to create an instance of\r\n\t\t\t// rawShape: Object \r\n\t\t\t//\t\tproperties to be passed in to the classes 'setShape' method\r\n\t\r\n\t\t\t// SHOULD BE RE-IMPLEMENTED BY THE RENDERER!\r\n\t\t\treturn null;\t// dojox/gfx/shape.Shape\r\n\t\t}\r\n\t};\r\n\t\r\n\t/*=====\r\n\t lang.extend(shape.Surface, shape.Container);\r\n\t lang.extend(shape.Surface, shape.Creator);\r\n\r\n\t g.Group = declare(shape.Shape, {\r\n\t\t// summary:\r\n\t\t//\t\ta group shape, which can be used\r\n\t\t//\t\tto logically group shapes (e.g, to propagate matricies)\r\n\t});\r\n\tlang.extend(g.Group, shape.Container);\r\n\tlang.extend(g.Group, shape.Creator);\r\n\r\n\tg.Rect     = shape.Rect;\r\n\tg.Circle   = shape.Circle;\r\n\tg.Ellipse  = shape.Ellipse;\r\n\tg.Line     = shape.Line;\r\n\tg.Polyline = shape.Polyline;\r\n\tg.Text     = shape.Text;\r\n\tg.Surface  = shape.Surface;\r\n\t=====*/\r\n\r\n\treturn shape;\r\n});\r\n"]}