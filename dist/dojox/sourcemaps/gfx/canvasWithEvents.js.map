{"version":3,"sources":["gfx/canvasWithEvents.js"],"names":["define","lang","declare","has","on","aspect","touch","Color","dom","domGeom","win","g","canvas","shapeLib","m","makeFakeEvent","event","fakeEvent","k","hitch","add","document","createEvent","Object","defineProperty","value","type","e","canvasWithEvents","Shape","_testInputs","ctx","pos","this","clip","canvasFill","strokeStyle","_hitTestPixel","_renderShape","length","t","getTransform","i","input","target","x","y","p","multiplyPoint","invert","_hitTestGeometry","clearRect","save","translate","_render","getImageData","data","restore","isPointInPath","_renderFill","apply","pickingMode","fill","inherited","arguments","_renderStroke","c","color","getEventSource","surface","rawNode","listener","expectedTarget","isDescendant","connect","name","object","method","substring","disconnect","handle","remove","Group","j","children","posbk","allFound","Image","s","shape","fillRect","width","height","Text","Rect","Circle","Ellipse","Line","Polyline","Path","TextPath","fixedEventData","Surface","constructor","_elementUnderPointer","fixTarget","defineProperties","_dojoElementFromPoint","changedTouches","pageX","pageY","configurable","enumerable","gfxTarget","changedTouch","corrected","call","_checkPointer","emit","types","relatedTarget","oldBubbles","bubbles","TYPES","elementUnderPointer","oldElementUnderPointer","_initMirrorCanvas","mirror","mirrorCanvas","ownerDocument","createElement","style","position","left","top","parentNode","appendChild","moveEvt","destroy","removeChild","createSurface","w","h","parent","byId","normalizedLength","_parent","_base","_fixMsTouchAction","oldAddEventListener","addEventListener","oldRemoveEventListener","removeEventListener","listeners","addEventListenerImpl","useCapture","actualListener","push","original","actual","removeEventListenerImpl","record","splice","surfacePosition","getContext","fillStyle","inputs","Creator","createObject","listenersOfType","after","extend"],"mappings":"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","file":"../../gfx/canvasWithEvents.js","sourcesContent":["define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/has\", \"dojo/on\", \"dojo/aspect\", \"dojo/touch\", \"dojo/_base/Color\", \"dojo/dom\",\r\n\t\t\"dojo/dom-geometry\", \"dojo/_base/window\", \"./_base\",\"./canvas\", \"./shape\", \"./matrix\"],\r\nfunction(lang, declare, has, on, aspect, touch, Color, dom, domGeom, win, g, canvas, shapeLib, m){\r\n\tfunction makeFakeEvent(event){\r\n\t\t// summary:\r\n\t\t//\t\tGenerates a \"fake\", fully mutable event object by copying the properties from an original host Event\r\n\t\t//\t\tobject to a new standard JavaScript object.\r\n\r\n\t\tvar fakeEvent = {};\r\n\t\tfor(var k in event){\r\n\t\t\tif(typeof event[k] === \"function\"){\r\n\t\t\t\t// Methods (like preventDefault) must be invoked on the original event object, or they will not work\r\n\t\t\t\tfakeEvent[k] = lang.hitch(event, k);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tfakeEvent[k] = event[k];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn fakeEvent;\r\n\t}\r\n\r\n\t// Browsers that implement the current (January 2013) WebIDL spec allow Event object properties to be mutated\r\n\t// using Object.defineProperty; some older WebKits (Safari 6-) and at least IE10- do not follow the spec. Direct\r\n\t// mutation is, of course, much faster when it can be done.\r\n    has.add(\"dom-mutableEvents\", function(){\r\n        var event = document.createEvent(\"UIEvents\");\r\n        try {\r\n            if(Object.defineProperty){\r\n                Object.defineProperty(event, \"type\", { value: \"foo\" });\r\n            }else{\r\n                event.type = \"foo\";\r\n            }\r\n            return event.type === \"foo\";\r\n        }catch(e){\r\n            return false;\r\n        }\r\n    });\r\n\r\n\tvar canvasWithEvents = g.canvasWithEvents = {\r\n\t\t// summary:\r\n\t\t//\t\tThis the graphics rendering bridge for W3C Canvas compliant browsers which extends\r\n\t\t//\t\tthe basic canvas drawing renderer bridge to add additional support for graphics events\r\n\t\t//\t\ton Shapes.\r\n\t\t//\t\tSince Canvas is an immediate mode graphics api, with no object graph or\r\n\t\t//\t\teventing capabilities, use of the canvas module alone will only add in drawing support.\r\n\t\t//\t\tThis additional module, canvasWithEvents extends this module with additional support\r\n\t\t//\t\tfor handling events on Canvas.  By default, the support for events is now included\r\n\t\t//\t\thowever, if only drawing capabilities are needed, canvas event module can be disabled\r\n\t\t//\t\tusing the dojoConfig option, canvasEvents:true|false.\r\n\t};\r\n\r\n\tcanvasWithEvents.Shape = declare(\"dojox.gfx.canvasWithEvents.Shape\", canvas.Shape, {\r\n\t\t_testInputs: function(/* Object */ ctx, /* Array */ pos){\r\n\t\t\tif(this.clip || (!this.canvasFill && this.strokeStyle)){\r\n\t\t\t\t// pixel-based until a getStrokedPath-like api is available on the path\r\n\t\t\t\tthis._hitTestPixel(ctx, pos);\r\n\t\t\t}else{\r\n\t\t\t\tthis._renderShape(ctx);\r\n\t\t\t\tvar length = pos.length,\r\n\t\t\t\t\tt = this.getTransform();\r\n\r\n\t\t\t\tfor(var i = 0; i < length; ++i){\r\n\t\t\t\t\tvar input = pos[i];\r\n\t\t\t\t\t// already hit\r\n\t\t\t\t\tif(input.target){continue;}\r\n\t\t\t\t\tvar x = input.x,\r\n\t\t\t\t\t\ty = input.y,\r\n\t\t\t\t\t\tp = t ? m.multiplyPoint(m.invert(t), x, y) : { x: x, y: y };\r\n\t\t\t\t\tinput.target = this._hitTestGeometry(ctx, p.x, p.y);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_hitTestPixel: function(/* Object */ ctx, /* Array */ pos){\r\n\t\t\tfor(var i = 0; i < pos.length; ++i){\r\n\t\t\t\tvar input = pos[i];\r\n\t\t\t\tif(input.target){continue;}\r\n\t\t\t\tvar x = input.x,\r\n\t\t\t\t\ty = input.y;\r\n\t\t\t\tctx.clearRect(0,0,1,1);\r\n\t\t\t\tctx.save();\r\n\t\t\t\tctx.translate(-x, -y);\r\n\t\t\t\tthis._render(ctx, true);\r\n\t\t\t\tinput.target = ctx.getImageData(0, 0, 1, 1).data[0] ? this : null;\r\n\t\t\t\tctx.restore();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_hitTestGeometry: function(ctx, x, y){\r\n\t\t\treturn ctx.isPointInPath(x, y) ? this : null;\r\n\t\t},\r\n\r\n\t\t_renderFill: function(/* Object */ ctx, /* Boolean */ apply){\r\n\t\t\t// summary:\r\n\t\t\t//\t\trender fill for the shape\r\n\t\t\t// ctx:\r\n\t\t\t//\t\ta canvas context object\r\n\t\t\t// apply:\r\n\t\t\t//\t\twhether ctx.fill() shall be called\r\n\t\t\tif(ctx.pickingMode){\r\n\t\t\t\tif(\"canvasFill\" in this && apply){\r\n\t\t\t\t\tctx.fill();\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\t_renderStroke: function(/* Object */ ctx){\r\n\t\t\t// summary:\r\n\t\t\t//\t\trender stroke for the shape\r\n\t\t\t// ctx:\r\n\t\t\t//\t\ta canvas context object\r\n\t\t\t// apply:\r\n\t\t\t//\t\twhether ctx.stroke() shall be called\r\n\t\t\tif(this.strokeStyle && ctx.pickingMode){\r\n\t\t\t\tvar c = this.strokeStyle.color;\r\n\t\t\t\ttry{\r\n\t\t\t\t\tthis.strokeStyle.color = new Color(ctx.strokeStyle);\r\n\t\t\t\t\tthis.inherited(arguments);\r\n\t\t\t\t}finally{\r\n\t\t\t\t\tthis.strokeStyle.color = c;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tthis.inherited(arguments);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// events\r\n\r\n\t\tgetEventSource: function(){\r\n\t\t\treturn this.surface.rawNode;\r\n\t\t},\r\n\r\n\t\ton: function(type, listener){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConnects an event to this shape.\r\n\r\n\t\t\tvar expectedTarget = this.rawNode;\r\n\r\n\t\t\t// note that event listeners' targets are automatically fixed up in the canvas's addEventListener method\r\n\t\t\treturn on(this.getEventSource(), type, function(event){\r\n\t\t\t\tif(dom.isDescendant(event.target, expectedTarget)){\r\n\t\t\t\t\tlistener.apply(expectedTarget, arguments);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tconnect: function(name, object, method){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated. Connects a handler to an event on this shape. Use `on` instead.\r\n\r\n\t\t\tif(name.substring(0, 2) == \"on\"){\r\n\t\t\t\tname = name.substring(2);\r\n\t\t\t}\r\n\t\t\treturn this.on(name, method ? lang.hitch(object, method) : lang.hitch(null, object));\r\n\t\t},\r\n\r\n\t\tdisconnect: function(handle){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated. Disconnects an event handler. Use `handle.remove` instead.\r\n\r\n\t\t\thandle.remove();\r\n\t\t}\r\n\t});\r\n\r\n\tcanvasWithEvents.Group = declare(\"dojox.gfx.canvasWithEvents.Group\", [canvasWithEvents.Shape, canvas.Group], {\r\n\t\t_testInputs: function(/*Object*/ ctx, /*Array*/ pos){\r\n\t\t\tvar children = this.children,\r\n\t\t\t\tt = this.getTransform(),\r\n\t\t\t\ti,\r\n\t\t\t\tj,\r\n\t\t\t\tinput;\r\n\r\n\t\t\tif(children.length === 0){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar posbk = [];\r\n\t\t\tfor(i = 0; i < pos.length; ++i){\r\n\t\t\t\tinput = pos[i];\r\n\t\t\t\t// backup position before transform applied\r\n\t\t\t\tposbk[i] = {\r\n\t\t\t\t\tx: input.x,\r\n\t\t\t\t\ty: input.y\r\n\t\t\t\t};\r\n\t\t\t\tif(input.target){continue;}\r\n\t\t\t\tvar x = input.x, y = input.y;\r\n\t\t\t\tvar p = t ? m.multiplyPoint(m.invert(t), x, y) : { x: x, y: y };\r\n\t\t\t\tinput.x = p.x;\r\n\t\t\t\tinput.y = p.y;\r\n\t\t\t}\r\n\t\t\tfor(i = children.length - 1; i >= 0; --i){\r\n\t\t\t\tchildren[i]._testInputs(ctx, pos);\r\n\t\t\t\t// does it need more hit tests ?\r\n\t\t\t\tvar allFound = true;\r\n\t\t\t\tfor(j = 0; j < pos.length; ++j){\r\n\t\t\t\t\tif(pos[j].target == null){\r\n\t\t\t\t\t\tallFound = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(allFound){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(this.clip){\r\n\t\t\t\t// filter positive hittests against the group clipping area\r\n\t\t\t\tfor(i = 0; i < pos.length; ++i){\r\n\t\t\t\t\tinput = pos[i];\r\n\t\t\t\t\tinput.x = posbk[i].x;\r\n\t\t\t\t\tinput.y = posbk[i].y;\r\n\t\t\t\t\tif(input.target){\r\n\t\t\t\t\t\tctx.clearRect(0,0,1,1);\r\n\t\t\t\t\t\tctx.save();\r\n\t\t\t\t\t\tctx.translate(-input.x, -input.y);\r\n\t\t\t\t\t\tthis._render(ctx, true);\r\n\t\t\t\t\t\tif(!ctx.getImageData(0, 0, 1, 1).data[0]){\r\n\t\t\t\t\t\t\tinput.target = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tctx.restore();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tfor(i = 0; i < pos.length; ++i){\r\n\t\t\t\t\tpos[i].x = posbk[i].x;\r\n\t\t\t\t\tpos[i].y = posbk[i].y;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t});\r\n\r\n\tcanvasWithEvents.Image = declare(\"dojox.gfx.canvasWithEvents.Image\", [canvasWithEvents.Shape, canvas.Image], {\r\n\t\t_renderShape: function(/* Object */ ctx){\r\n\t\t\t// summary:\r\n\t\t\t//\t\trender image\r\n\t\t\t// ctx:\r\n\t\t\t//\t\ta canvas context object\r\n\t\t\tvar s = this.shape;\r\n\t\t\tif(ctx.pickingMode){\r\n\t\t\t\tctx.fillRect(s.x, s.y, s.width, s.height);\r\n\t\t\t}else{\r\n\t\t\t\tthis.inherited(arguments);\r\n\t\t\t}\r\n\t\t},\r\n\t\t_hitTestGeometry: function(ctx, x, y){\r\n\t\t\t// TODO: improve hit testing to take into account transparency\r\n\t\t\tvar s = this.shape;\r\n\t\t\treturn x >= s.x && x <= s.x + s.width && y >= s.y && y <= s.y + s.height ? this : null;\r\n\t\t}\r\n\t});\r\n\r\n\tcanvasWithEvents.Text = declare(\"dojox.gfx.canvasWithEvents.Text\", [canvasWithEvents.Shape, canvas.Text], {\r\n\t\t_testInputs: function(ctx, pos){\r\n\t\t\treturn this._hitTestPixel(ctx, pos);\r\n\t\t}\r\n\t});\r\n\r\n\tcanvasWithEvents.Rect = declare(\"dojox.gfx.canvasWithEvents.Rect\", [canvasWithEvents.Shape, canvas.Rect], {});\r\n\tcanvasWithEvents.Circle = declare(\"dojox.gfx.canvasWithEvents.Circle\", [canvasWithEvents.Shape, canvas.Circle], {});\r\n\tcanvasWithEvents.Ellipse = declare(\"dojox.gfx.canvasWithEvents.Ellipse\", [canvasWithEvents.Shape, canvas.Ellipse],{});\r\n\tcanvasWithEvents.Line = declare(\"dojox.gfx.canvasWithEvents.Line\", [canvasWithEvents.Shape, canvas.Line],{});\r\n\tcanvasWithEvents.Polyline = declare(\"dojox.gfx.canvasWithEvents.Polyline\", [canvasWithEvents.Shape, canvas.Polyline],{});\r\n\tcanvasWithEvents.Path = declare(\"dojox.gfx.canvasWithEvents.Path\", [canvasWithEvents.Shape, canvas.Path],{});\r\n\tcanvasWithEvents.TextPath = declare(\"dojox.gfx.canvasWithEvents.TextPath\", [canvasWithEvents.Shape, canvas.TextPath],{});\r\n\r\n\t// When events are dispatched using on.emit, certain properties of these events (like target) get overwritten by\r\n\t// the DOM. The only real way to deal with this at the moment, short of never using any standard event properties,\r\n\t// is to store this data out-of-band and fix up the event object passed to the listener by wrapping the listener.\r\n\t// The out-of-band data is stored here.\r\n\tvar fixedEventData = null;\r\n\r\n\tcanvasWithEvents.Surface = declare(\"dojox.gfx.canvasWithEvents.Surface\", canvas.Surface, {\r\n\t\tconstructor: function(){\r\n\t\t\tthis._elementUnderPointer = null;\r\n\t\t},\r\n\r\n\t\tfixTarget: function(listener){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCorrects the `target` properties of the event object passed to the actual listener.\r\n\t\t\t// listener: Function\r\n\t\t\t//\t\tAn event listener function.\r\n\r\n\t\t\tvar surface = this;\r\n\r\n\t\t\treturn function(event){\r\n\t\t\t\tvar k;\r\n\t\t\t\tif(fixedEventData){\r\n\t\t\t\t\tif(has(\"dom-mutableEvents\")){\r\n\t\t\t\t\t\tObject.defineProperties(event, fixedEventData);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tevent = makeFakeEvent(event);\r\n\t\t\t\t\t\tfor(k in fixedEventData){\r\n\t\t\t\t\t\t\tevent[k] = fixedEventData[k].value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// non-synthetic events need to have target correction too, but since there is no out-of-band\r\n\t\t\t\t\t// data we need to figure out the target ourselves\r\n\t\t\t\t\tvar canvas = surface.getEventSource(),\r\n\t\t\t\t\t\ttarget = canvas._dojoElementFromPoint(\r\n\t\t\t\t\t\t\t// touch events may not be fixed at this point, so clientX/Y may not be set on the\r\n\t\t\t\t\t\t\t// event object\r\n\t\t\t\t\t\t\t(event.changedTouches ? event.changedTouches[0] : event).pageX,\r\n\t\t\t\t\t\t\t(event.changedTouches ? event.changedTouches[0] : event).pageY\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\tif(has(\"dom-mutableEvents\")){\r\n\t\t\t\t\t\tObject.defineProperties(event, {\r\n\t\t\t\t\t\t\ttarget: {\r\n\t\t\t\t\t\t\t\tvalue: target,\r\n\t\t\t\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\t\t\t\tenumerable: true\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tgfxTarget: {\r\n\t\t\t\t\t\t\t\tvalue: target.shape,\r\n\t\t\t\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\t\t\t\tenumerable: true\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tevent = makeFakeEvent(event);\r\n\t\t\t\t\t\tevent.target = target;\r\n\t\t\t\t\t\tevent.gfxTarget = target.shape;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// fixTouchListener in dojo/on undoes target changes by copying everything from changedTouches even\r\n\t\t\t\t// if the value already exists on the event; of course, this canvas implementation currently only\r\n\t\t\t\t// supports one pointer at a time. if we wanted to make sure all the touches arrays' targets were\r\n\t\t\t\t// updated correctly as well, we could support multi-touch and this workaround would not be needed\r\n\t\t\t\tif(has(\"touch\")){\r\n\t\t\t\t\t// some standard properties like clientX/Y are not provided on the main touch event object,\r\n\t\t\t\t\t// so copy them over if we need to\r\n\t\t\t\t\tif(event.changedTouches && event.changedTouches[0]){\r\n\t\t\t\t\t\tvar changedTouch = event.changedTouches[0];\r\n\t\t\t\t\t\tfor(k in changedTouch){\r\n\t\t\t\t\t\t\tif(!event[k]){\r\n\t\t\t\t\t\t\t\tif(has(\"dom-mutableEvents\")){\r\n\t\t\t\t\t\t\t\t\tObject.defineProperty(event, k, {\r\n\t\t\t\t\t\t\t\t\t\tvalue: changedTouch[k],\r\n\t\t\t\t\t\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\t\t\t\t\t\tenumerable: true\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\tevent[k] = changedTouch[k];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tevent.corrected = event;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn listener.call(this, event);\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\t_checkPointer: function(event){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEmits enter/leave/over/out events in response to the pointer entering/leaving the inner elements\r\n\t\t\t//\t\twithin the canvas.\r\n\r\n\t\t\tfunction emit(types, target, relatedTarget){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tEmits multiple synthetic events defined in `types` with the given target `target`.\r\n\r\n\t\t\t\tvar oldBubbles = event.bubbles;\r\n\r\n\t\t\t\tfor(var i = 0, type; (type = types[i]); ++i){\r\n\t\t\t\t\t// targets get reset when the event is dispatched so we need to give information to fixTarget to\r\n\t\t\t\t\t// restore the target on the dispatched event through a back channel\r\n\t\t\t\t\tfixedEventData = {\r\n\t\t\t\t\t\ttarget: { value: target, configurable: true, enumerable: true},\r\n\t\t\t\t\t\tgfxTarget: { value: target.shape, configurable: true, enumerable: true },\r\n\t\t\t\t\t\trelatedTarget: { value: relatedTarget, configurable: true, enumerable: true }\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// bubbles can be set directly, though.\r\n\t\t\t\t\tObject.defineProperty(event, \"bubbles\", {\r\n\t\t\t\t\t\tvalue: type.bubbles,\r\n\t\t\t\t\t\tconfigurable: true,\r\n\t\t\t\t\t\tenumerable: true\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\ton.emit(canvas, type.type, event);\r\n\t\t\t\t\tfixedEventData = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tObject.defineProperty(event, \"bubbles\", { value: oldBubbles, configurable: true, enumerable: true });\r\n\t\t\t}\r\n\r\n\t\t\t// Types must be arrays because hash map order is not guaranteed but we must fire in order to match normal\r\n\t\t\t// event behaviour\r\n\t\t\tvar TYPES = {\r\n\t\t\t\t\tout: [\r\n\t\t\t\t\t\t{ type: \"mouseout\", bubbles: true },\r\n\t\t\t\t\t\t{ type: \"MSPointerOut\", bubbles: true },\r\n\t\t\t\t\t\t{ type: \"pointerout\", bubbles: true },\r\n\t\t\t\t\t\t{ type: \"mouseleave\", bubbles: false },\r\n\t\t\t\t\t\t{ type: \"dojotouchout\", bubbles: true}\r\n\t\t\t\t\t],\r\n\t\t\t\t\tover: [\r\n\t\t\t\t\t\t{ type: \"mouseover\", bubbles: true },\r\n\t\t\t\t\t\t{ type: \"MSPointerOver\", bubbles: true },\r\n\t\t\t\t\t\t{ type: \"pointerover\", bubbles: true },\r\n\t\t\t\t\t\t{ type: \"mouseenter\", bubbles: false },\r\n\t\t\t\t\t\t{ type: \"dojotouchover\", bubbles: true}\r\n\t\t\t\t\t]\r\n\t\t\t\t},\r\n\t\t\t\telementUnderPointer = event.target,\r\n\t\t\t\toldElementUnderPointer = this._elementUnderPointer,\r\n\t\t\t\tcanvas = this.getEventSource();\r\n\r\n\t\t\tif(oldElementUnderPointer !== elementUnderPointer){\r\n\t\t\t\tif(oldElementUnderPointer && oldElementUnderPointer !== canvas){\r\n\t\t\t\t\temit(TYPES.out, oldElementUnderPointer, elementUnderPointer);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._elementUnderPointer = elementUnderPointer;\r\n\r\n\t\t\t\tif(elementUnderPointer && elementUnderPointer !== canvas){\r\n\t\t\t\t\temit(TYPES.over, elementUnderPointer, oldElementUnderPointer);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetEventSource: function(){\r\n\t\t\treturn this.rawNode;\r\n\t\t},\r\n\r\n\t\ton: function(type, listener){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConnects an event to this surface.\r\n\r\n\t\t\treturn on(this.getEventSource(), type, listener);\r\n\t\t},\r\n\r\n\t\tconnect: function(/*String*/ name, /*Object*/ object, /*Function|String*/ method){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated. Connects a handler to an event on this surface. Use `on` instead.\r\n\t\t\t// name: String\r\n\t\t\t//\t\tThe event name\r\n\t\t\t// object: Object\r\n\t\t\t//\t\tThe object that method will receive as \"this\".\r\n\t\t\t// method: Function\r\n\t\t\t//\t\tA function reference, or name of a function in context.\r\n\r\n\t\t\tif(name.substring(0, 2) == \"on\"){\r\n\t\t\t\tname = name.substring(2);\r\n\t\t\t}\r\n\t\t\treturn this.on(name, method ? lang.hitch(object, method) : object);\r\n\t\t},\r\n\r\n\t\tdisconnect: function(handle){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeprecated. Disconnects a handler. Use `handle.remove` instead.\r\n\r\n\t\t\thandle.remove();\r\n\t\t},\r\n\r\n\t\t_initMirrorCanvas: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInitialises a mirror canvas used for event hit detection.\r\n\r\n\t\t\tthis._initMirrorCanvas = function(){};\r\n\r\n\t\t\tvar canvas = this.getEventSource(),\r\n\t\t\t\tmirror = this.mirrorCanvas = canvas.ownerDocument.createElement(\"canvas\");\r\n\r\n\t\t\tmirror.width = 1;\r\n\t\t\tmirror.height = 1;\r\n\t\t\tmirror.style.position = \"absolute\";\r\n\t\t\tmirror.style.left = mirror.style.top = \"-99999px\";\r\n\t\t\tcanvas.parentNode.appendChild(mirror);\r\n\r\n\t\t\tvar moveEvt = \"mousemove\";\r\n\t\t\tif(has(\"pointer-events\")){\r\n\t\t\t\tmoveEvt = \"pointermove\";\r\n\t\t\t}else if(has(\"MSPointer\")){\r\n\t\t\t\tmoveEvt = \"MSPointerMove\";\r\n\t\t\t}else if(has(\"touch-events\")){\r\n\t\t\t\tmoveEvt = \"touchmove\";\r\n\t\t\t}\r\n\t\t\ton(canvas, moveEvt, lang.hitch(this, \"_checkPointer\"));\r\n\t\t},\r\n\r\n\t\tdestroy: function(){\r\n\t\t\tif(this.mirrorCanvas){\r\n\t\t\t\tthis.mirrorCanvas.parentNode.removeChild(this.mirrorCanvas);\r\n\t\t\t\tthis.mirrorCanvas = null;\r\n\t\t\t}\r\n\t\t\tthis.inherited(arguments);\r\n\t\t}\r\n\t});\r\n\r\n\tcanvasWithEvents.createSurface = function(parentNode, width, height){\r\n\t\t// summary:\r\n\t\t//\t\tcreates a surface (Canvas)\r\n\t\t// parentNode: Node\r\n\t\t//\t\ta parent node\r\n\t\t// width: String\r\n\t\t//\t\twidth of surface, e.g., \"100px\"\r\n\t\t// height: String\r\n\t\t//\t\theight of surface, e.g., \"100px\"\r\n\r\n\t\tif(!width && !height){\r\n\t\t\tvar pos = domGeom.position(parentNode);\r\n\t\t\twidth  = width  || pos.w;\r\n\t\t\theight = height || pos.h;\r\n\t\t}\r\n\t\tif(typeof width === \"number\"){\r\n\t\t\twidth = width + \"px\";\r\n\t\t}\r\n\t\tif(typeof height === \"number\"){\r\n\t\t\theight = height + \"px\";\r\n\t\t}\r\n\r\n\t\tvar surface = new canvasWithEvents.Surface(),\r\n\t\t\tparent = dom.byId(parentNode),\r\n\t\t\tcanvas = parent.ownerDocument.createElement(\"canvas\");\r\n\r\n\t\tcanvas.width  = g.normalizedLength(width);\t// in pixels\r\n\t\tcanvas.height = g.normalizedLength(height);\t// in pixels\r\n\r\n\t\tparent.appendChild(canvas);\r\n\t\tsurface.rawNode = canvas;\r\n\t\tsurface._parent = parent;\r\n\t\tsurface.surface = surface;\r\n\r\n\t\tg._base._fixMsTouchAction(surface);\r\n\r\n\t\t// any event handler added to the canvas needs to have its target fixed.\r\n\t\tvar oldAddEventListener = canvas.addEventListener,\r\n\t\t\toldRemoveEventListener = canvas.removeEventListener,\r\n\t\t\tlisteners = [];\r\n\r\n\t\tvar addEventListenerImpl = function(type, listener, useCapture){\r\n\t\t\tsurface._initMirrorCanvas();\r\n\r\n\t\t\tvar actualListener = surface.fixTarget(listener);\r\n\t\t\tlisteners.push({ original: listener, actual: actualListener });\r\n\t\t\toldAddEventListener.call(this, type, actualListener, useCapture);\r\n\t\t};\r\n\t\tvar removeEventListenerImpl = function(type, listener, useCapture){\r\n\t\t\tfor(var i = 0, record; (record = listeners[i]); ++i){\r\n\t\t\t\tif(record.original === listener){\r\n\t\t\t\t\toldRemoveEventListener.call(this, type, record.actual, useCapture);\r\n\t\t\t\t\tlisteners.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\ttry{\r\n\t\t\tObject.defineProperties(canvas, {\r\n\t\t\t\taddEventListener: {\r\n\t\t\t\t\tvalue: addEventListenerImpl,\r\n\t\t\t\t\tenumerable: true,\r\n\t\t\t\t\tconfigurable: true\r\n\t\t\t\t},\r\n\t\t\t\tremoveEventListener: {\r\n\t\t\t\t\tvalue: removeEventListenerImpl\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}catch(e){\r\n\t\t\t// Object.defineProperties fails on iOS 4-5. \"Not supported on DOM objects\").\r\n\t\t\tcanvas.addEventListener = addEventListenerImpl;\r\n\t\t\tcanvas.removeEventListener = removeEventListenerImpl;\r\n\t\t}\r\n\r\n\r\n\t\tcanvas._dojoElementFromPoint = function(x, y){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the shape under the given (x, y) coordinate.\r\n\t\t\t// evt:\r\n\t\t\t//\t\tmouse event\r\n\r\n\t\t\tif(!surface.mirrorCanvas){\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\r\n\t\t\tvar surfacePosition = domGeom.position(this, true);\r\n\r\n\t\t\t// use canvas-relative positioning\r\n\t\t\tx -= surfacePosition.x;\r\n\t\t\ty -= surfacePosition.y;\r\n\r\n\t\t\tvar mirror = surface.mirrorCanvas,\r\n\t\t\t\tctx = mirror.getContext(\"2d\"),\r\n\t\t\t\tchildren = surface.children;\r\n\r\n\t\t\tctx.clearRect(0, 0, mirror.width, mirror.height);\r\n\t\t\tctx.save();\r\n\t\t\tctx.strokeStyle = \"rgba(127,127,127,1.0)\";\r\n\t\t\tctx.fillStyle = \"rgba(127,127,127,1.0)\";\r\n\t\t\tctx.pickingMode = true;\r\n\r\n\t\t\t// TODO: Make inputs non-array\r\n\t\t\tvar inputs = [ { x: x, y: y } ];\r\n\r\n\t\t\t// process the inputs to find the target.\r\n\t\t\tfor(var i = children.length - 1; i >= 0; i--){\r\n\t\t\t\tchildren[i]._testInputs(ctx, inputs);\r\n\r\n\t\t\t\tif(inputs[0].target){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tctx.restore();\r\n\t\t\treturn inputs[0] && inputs[0].target ? inputs[0].target.rawNode : this;\r\n\t\t};\r\n\r\n\r\n\t\treturn surface; // dojox/gfx.Surface\r\n\t};\r\n\r\n\tvar Creator = {\r\n\t\tcreateObject: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreates a synthetic, partially-interoperable Element object used to uniquely identify the given\r\n\t\t\t//\t\tshape within the canvas pseudo-DOM.\r\n\r\n\t\t\tvar shape = this.inherited(arguments),\r\n\t\t\t\tlisteners = {};\r\n\r\n\t\t\tshape.rawNode = {\r\n\t\t\t\tshape: shape,\r\n\t\t\t\townerDocument: shape.surface.rawNode.ownerDocument,\r\n\t\t\t\tparentNode: shape.parent ? shape.parent.rawNode : null,\r\n\t\t\t\taddEventListener: function(type, listener){\r\n\t\t\t\t\tvar listenersOfType = listeners[type] = (listeners[type] || []);\r\n\t\t\t\t\tfor(var i = 0, record; (record = listenersOfType[i]); ++i){\r\n\t\t\t\t\t\tif(record.listener === listener){\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlistenersOfType.push({\r\n\t\t\t\t\t\tlistener: listener,\r\n\t\t\t\t\t\thandle: aspect.after(this, \"on\" + type, shape.surface.fixTarget(listener), true)\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\tremoveEventListener: function(type, listener){\r\n\t\t\t\t\tvar listenersOfType = listeners[type];\r\n\t\t\t\t\tif(!listenersOfType){\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor(var i = 0, record; (record = listenersOfType[i]); ++i){\r\n\t\t\t\t\t\tif(record.listener === listener){\r\n\t\t\t\t\t\t\trecord.handle.remove();\r\n\t\t\t\t\t\t\tlistenersOfType.splice(i, 1);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treturn shape;\r\n\t\t}\r\n\t};\r\n\r\n\tcanvasWithEvents.Group.extend(Creator);\r\n\tcanvasWithEvents.Surface.extend(Creator);\r\n\r\n\treturn canvasWithEvents;\r\n});\r\n"]}