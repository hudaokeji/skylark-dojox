{"version":3,"sources":["gfx/VectorText.js"],"names":["define","lang","declare","arr","loader","xhr","gfx","xmlDomParser","HtmlMetrics","Matrix","getObject","mixin","vectorFontFitting","NONE","FLOW","FIT","defaultVectorText","type","x","y","width","height","text","align","decoration","fitting","leading","defaultVectorFont","size","family","_vectorFontCache","_svgFontCache","getVectorFont","url","VectorFont","_entityRe","_decodeEntitySequence","str","match","this","r","xmlEntityMap","amp","apos","quot","lt","gt","tmp","exec","charAt","String","fromCharCode","parseInt","slice","isNaN","_parse","svg","doc","parse","f","documentElement","byName","face","unitsPerEm","parseFloat","getAttribute","advance","origin","horiz","vert","style","variant","weight","stretch","range","ascent","descent","baseline","name","forEach","attr","a","missing","glyphs","glyphsByName","g","node","code","xAdv","path","o","xAdvance","hkern","i","gl","k","u1","g1","u2","g2","kern","viewbox","_clean","prop","e","constructor","_defaultLeading","undefined","load","onLoadBegin","toString","result","get","sync","_getText","onLoad","initialized","_round","n","Math","round","_leading","unit","_normalize","replace","_getWidth","w","last","lastGlyph","glyph","_getLongestLine","lines","maxw","idx","line","max","index","_trim","fn","length","splice","isArray","_split","chars","nLines","limit","floor","cw","c","found","l","chr","pop","push","_getSizeFactor","metrics","getCachedFontMeasurements","indexOf","medium","_getFitFactor","h","maxh","min","_getBestFit","ldng","factor","scale","_getBestFlow","tw","getWidth","map","split","getLineHeight","getCenterline","getBaseline","draw","group","textArgs","fontArgs","fillArgs","strokeArgs","Error","createGroup","applyTransform","dx","dy","filter","item","cy","cx","linew","lg","j","p","createPath","setFill","setStroke","setTransform","flipY","translate","font"],"mappings":"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","file":"../../gfx/VectorText.js","sourcesContent":["define([\"dojo/_base/lang\",\"dojo/_base/declare\",\"dojo/_base/array\", \"dojo/_base/loader\" /* dojo._getText */,\r\n\t    \"dojo/_base/xhr\",\"./_base\", \"dojox/xml/DomParser\", \"dojox/html/metrics\",\"./matrix\"],\r\nfunction (lang,declare,arr,loader,xhr,gfx,xmlDomParser,HtmlMetrics,Matrix){\r\n\tvar _getText = function(url){\r\n\t\tvar result;\r\n\t\txhr.get({url:url, sync:true, load:function(text){ // Note synchronous!\r\n\t\t\tresult = text;\r\n\t\t}});\r\n\t\treturn result;\r\n\t};\r\n\r\n\t lang.getObject(\"dojox.gfx.VectorText\", true);\r\n\r\n\t lang.mixin(gfx, {\r\n\t\t  vectorFontFitting: {\r\n\t\t\t  NONE: 0,\t//\t\trender text according to passed size.\r\n\t\t\t  FLOW: 1,\t\t//\t\trender text based on the passed width and size\r\n\t\t\t  FIT: 2\t\t\t//\t\trender text based on a passed viewbox.\r\n\t\t  },\r\n\t\t  defaultVectorText: {\r\n\t\t\t  type:\"vectortext\", x:0, y:0, width: null, height: null,\r\n\t\t\t  text: \"\", align: \"start\", decoration: \"none\", fitting: 0,\t//\t\tvectorFontFitting.NONE\r\n\t\t\t  leading: 1.5\t//\t\tin ems.\r\n\t\t  },\r\n\t\t  defaultVectorFont: {\r\n\t\t\t  type:\"vectorfont\", size: \"10pt\", family: null\r\n\t\t  },\r\n\t\t  _vectorFontCache: {},\r\n\t\t  _svgFontCache: {},\r\n\t\t  getVectorFont: function(/* String */url){\r\n\t\t\t  if(gfx._vectorFontCache[url]){\r\n\t\t\t\t  return gfx._vectorFontCache[url];\r\n\t\t\t  }\r\n\t\t\t  return new gfx.VectorFont(url);\r\n\t\t  }\r\n\t });\r\n\r\n\t// TODO: Make up your mind.   Module is called VectorText but it's creating and returning a global called VectorFont\r\n\r\n\treturn declare(\"dojox.gfx.VectorFont\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tAn implementation of the SVG Font 1.1 spec, using dojox/gfx.\r\n\t\t//\r\n\t\t//\t\tBasic interface:\r\n\t\t//\t|\tvar f = new gfx.Font(url|string);\r\n\t\t//\t|\tsurface||group.createVectorText(text)\r\n\t\t//\t|\t.setFill(fill)\r\n\t\t//\t|\t.setStroke(stroke)\r\n\t\t//\t|\t.setFont(fontStyleObject);\r\n\t\t//\r\n\t\t//\t\tThe arguments passed to createVectorText are the same as you would\r\n\t\t//\t\tpass to surface||group.createText; the difference is that this\r\n\t\t//\t\tis entirely renderer-agnostic, and the return value is a subclass\r\n\t\t//\t\tof dojox/gfx.Group.\r\n\t\t//\r\n\t\t//\t\tNote also that the \"defaultText\" object is slightly different:\r\n\t\t//\t\t{ type:\"vectortext\", x:0, y:0, width:null, height: null,\r\n\t\t//\t\ttext: \"\", align: \"start\", decoration: \"none\" }\r\n\t\t//\r\n\t\t//\t\t...as well as the \"defaultVectorFont\" object:\r\n\t\t//\t\t{ type:\"vectorfont\", size:\"10pt\" }\r\n\t\t//\r\n\t\t//\t\tThe reason for this should be obvious: most of the style for the font is defined\r\n\t\t//\t\tby the font object itself.\r\n\t\t//\r\n\t\t//\t\tNote that this will only render IF and WHEN you set the font.\r\n\r\n\t\t_entityRe: /&(quot|apos|lt|gt|amp|#x[^;]+|#\\d+);/g,\r\n\t\t_decodeEntitySequence: function(str){\r\n\t\t\t//\t\tunescape the unicode sequences\r\n\r\n\t\t\t//\t\tnothing to decode\r\n\t\t\tif(!str.match(this._entityRe)){ return; }  // undefined\r\n\t\t\tvar xmlEntityMap = {\r\n\t\t\t\tamp:\"&\", apos:\"'\", quot:'\"', lt:\"<\", gt:\">\"\r\n\t\t\t};\r\n\r\n\t\t\t//\t\twe have at least one encoded entity.\r\n\t\t\tvar r, tmp=\"\";\r\n\t\t\twhile((r=this._entityRe.exec(str))!==null){\r\n\t\t\t\tif(r[1].charAt(1)==\"x\"){\r\n\t\t\t\t\ttmp += String.fromCharCode(parseInt(r[1].slice(2), 16));\r\n\t\t\t\t}\r\n\t\t\t\telse if(!isNaN(parseInt(r[1].slice(1),10))){\r\n\t\t\t\t\ttmp += String.fromCharCode(parseInt(r[1].slice(1), 10));\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttmp += xmlEntityMap[r[1]] || \"\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn tmp;\t//\t\tString\r\n\t\t},\r\n\t\t_parse: function(/* String */svg, /* String */url){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTake the loaded SVG Font definition file and convert the info\r\n\t\t\t//\t\tinto things we can use. The SVG Font definition must follow\r\n\t\t\t//\t\tthe SVG 1.1 Font specification.\r\n\t\t\tvar doc = gfx._svgFontCache[url]||xmlDomParser.parse(svg);\r\n\r\n\t\t\t//\t\tfont information\r\n\t\t\tvar f = doc.documentElement.byName(\"font\")[0], face = doc.documentElement.byName(\"font-face\")[0];\r\n\t\t\tvar unitsPerEm = parseFloat(face.getAttribute(\"units-per-em\")||1000, 10);\r\n\t\t\tvar advance = {\r\n\t\t\t\tx: parseFloat(f.getAttribute(\"horiz-adv-x\"), 10),\r\n\t\t\t\ty: parseFloat(f.getAttribute(\"vert-adv-y\")||0, 10)\r\n\t\t\t};\r\n\t\t\tif(!advance.y){\r\n\t\t\t\tadvance.y = unitsPerEm;\r\n\t\t\t}\r\n\r\n\t\t\tvar origin = {\r\n\t\t\t\thoriz: {\r\n\t\t\t\t\tx: parseFloat(f.getAttribute(\"horiz-origin-x\")||0, 10),\r\n\t\t\t\t\ty: parseFloat(f.getAttribute(\"horiz-origin-y\")||0, 10)\r\n\t\t\t\t},\r\n\t\t\t\tvert: {\r\n\t\t\t\t\tx: parseFloat(f.getAttribute(\"vert-origin-x\")||0, 10),\r\n\t\t\t\t\ty: parseFloat(f.getAttribute(\"vert-origin-y\")||0, 10)\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t//\t\tface information\r\n\t\t\tvar family = face.getAttribute(\"font-family\"),\r\n\t\t\t\tstyle = face.getAttribute(\"font-style\")||\"all\",\r\n\t\t\t\tvariant = face.getAttribute(\"font-variant\")||\"normal\",\r\n\t\t\t\tweight = face.getAttribute(\"font-weight\")||\"all\",\r\n\t\t\t\tstretch = face.getAttribute(\"font-stretch\")||\"normal\",\r\n\r\n\t\t\t\t//\t\tadditional info, may not be needed\r\n\t\t\t\trange = face.getAttribute(\"unicode-range\")||\"U+0-10FFFF\",\r\n\t\t\t\tpanose = face.getAttribute(\"panose-1\") || \"0 0 0 0 0 0 0 0 0 0\",\r\n\t\t\t\tcapHeight = face.getAttribute(\"cap-height\"),\r\n\t\t\t\tascent = parseFloat(face.getAttribute(\"ascent\")||(unitsPerEm-origin.vert.y), 10),\r\n\t\t\t\tdescent = parseFloat(face.getAttribute(\"descent\")||origin.vert.y, 10),\r\n\t\t\t\tbaseline = {};\r\n\r\n\t\t\t//\t\tcheck for font-face-src/font-face-name\r\n\t\t\tvar name = family;\r\n\t\t\tif(face.byName(\"font-face-name\")[0]){\r\n\t\t\t\tname = face.byName(\"font-face-name\")[0].getAttribute(\"name\");\r\n\t\t\t}\r\n\r\n\t\t\t//\t\tsee if this is cached already, and if so, forget the rest of the parsing.\r\n\t\t\tif(gfx._vectorFontCache[name]){ return; }\r\n\r\n\t\t\t//\t\tget any provided baseline alignment offsets.\r\n\t\t\tarr.forEach([\"alphabetic\", \"ideographic\", \"mathematical\", \"hanging\" ], function(attr){\r\n\t\t\t\tvar a = face.getAttribute(attr);\r\n\t\t\t\tif(a !== null /* be explicit, might be 0 */){\r\n\t\t\t\t\tbaseline[attr] = parseFloat(a, 10);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t/*\r\n\t\t\t//\t\tTODO: decoration hinting.\r\n\t\t\tvar decoration = { };\r\n\t\t\tarr.forEach([\"underline\", \"strikethrough\", \"overline\"], function(type){\r\n\t\t\t\tif(face.getAttribute(type+\"-position\")!=null){\r\n\t\t\t\t\tdecoration[type]={ };\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t*/\r\n\r\n\t\t\t//\t\tmissing glyph info\r\n\t\t\tvar missing = parseFloat(doc.documentElement.byName(\"missing-glyph\")[0].getAttribute(\"horiz-adv-x\")||advance.x, 10);\r\n\r\n\t\t\t//\t\tglyph information\r\n\t\t\tvar glyphs = {}, glyphsByName={}, g=doc.documentElement.byName(\"glyph\");\r\n\t\t\tarr.forEach(g, function(node){\r\n\t\t\t\t//\t\twe are going to assume the following:\r\n\t\t\t\t//\t\t1) we have the unicode attribute\r\n\t\t\t\t//\t\t2) we have the name attribute\r\n\t\t\t\t//\t\t3) we have the horiz-adv-x and d attributes.\r\n\t\t\t\tvar code = node.getAttribute(\"unicode\"),\r\n\t\t\t\t\tname = node.getAttribute(\"glyph-name\"),\r\n\t\t\t\t\txAdv = parseFloat(node.getAttribute(\"horiz-adv-x\")||advance.x, 10),\r\n\t\t\t\t\tpath = node.getAttribute(\"d\");\r\n\r\n\t\t\t\t//\t\tunescape the unicode sequences\r\n\t\t\t\tif(code.match(this._entityRe)){\r\n\t\t\t\t\tcode = this._decodeEntitySequence(code);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// build our glyph objects\r\n\t\t\t\tvar o = { code: code, name: name, xAdvance: xAdv, path: path };\r\n\t\t\t\tglyphs[code]=o;\r\n\t\t\t\tglyphsByName[name]=o;\r\n\t\t\t}, this);\r\n\r\n\t\t\t//\t\tnow the fun part: look for kerning pairs.\r\n\t\t\tvar hkern=doc.documentElement.byName(\"hkern\");\r\n\t\t\tarr.forEach(hkern, function(node, i){\r\n\t\t\t\tvar k = -parseInt(node.getAttribute(\"k\"),10);\r\n\t\t\t\t//\t\tlook for either a code or a name\r\n\t\t\t\tvar u1=node.getAttribute(\"u1\"),\r\n\t\t\t\t\tg1=node.getAttribute(\"g1\"),\r\n\t\t\t\t\tu2=node.getAttribute(\"u2\"),\r\n\t\t\t\t\tg2=node.getAttribute(\"g2\"),\r\n\t\t\t\t\tgl;\r\n\r\n\t\t\t\tif(u1){\r\n\t\t\t\t\t//\t\tthe first of the pair is a sequence of unicode characters.\r\n\t\t\t\t\t//\t\tTODO: deal with unicode ranges and mulitple characters.\r\n\t\t\t\t\tu1 = this._decodeEntitySequence(u1);\r\n\t\t\t\t\tif(glyphs[u1]){\r\n\t\t\t\t\t\tgl = glyphs[u1];\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//\t\twe are referring to a name.\r\n\t\t\t\t\t//\t\tTODO: deal with multiple names\r\n\t\t\t\t\tif(glyphsByName[g1]){\r\n\t\t\t\t\t\tgl = glyphsByName[g1];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(gl){\r\n\t\t\t\t\tif(!gl.kern){ gl.kern = {}; }\r\n\t\t\t\t\tif(u2){\r\n\t\t\t\t\t\t//\t\tsee the notes above.\r\n\t\t\t\t\t\tu2 = this._decodeEntitySequence(u2);\r\n\t\t\t\t\t\tgl.kern[u2] = { x: k };\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif(glyphsByName[g2]){\r\n\t\t\t\t\t\t\tgl.kern[glyphsByName[g2].code] = { x: k };\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\r\n\t\t\t//\t\tpop the final definition in the font cache.\r\n\t\t\tlang.mixin(this, {\r\n\t\t\t\tfamily: family,\r\n\t\t\t\tname: name,\r\n\t\t\t\tstyle: style,\r\n\t\t\t\tvariant: variant,\r\n\t\t\t\tweight: weight,\r\n\t\t\t\tstretch: stretch,\r\n\t\t\t\trange: range,\r\n\t\t\t\tviewbox: { width: unitsPerEm, height: unitsPerEm },\r\n\t\t\t\torigin: origin,\r\n\t\t\t\tadvance: lang.mixin(advance, {\r\n\t\t\t\t\tmissing:{ x: missing, y: missing }\r\n\t\t\t\t}),\r\n\t\t\t\tascent: ascent,\r\n\t\t\t\tdescent: descent,\r\n\t\t\t\tbaseline: baseline,\r\n\t\t\t\tglyphs: glyphs\r\n\t\t\t});\r\n\r\n\t\t\t//\t\tcache the parsed font\r\n\t\t\tgfx._vectorFontCache[name] = this;\r\n\t\t\tgfx._vectorFontCache[url] = this;\r\n\t\t\tif(name!=family && !gfx._vectorFontCache[family]){\r\n\t\t\t\tgfx._vectorFontCache[family] = this;\r\n\t\t\t}\r\n\r\n\t\t\t//\t\tcache the doc\r\n\t\t\tif(!gfx._svgFontCache[url]){\r\n\t\t\t\tgfx._svgFontCache[url]=doc;\r\n\t\t\t}\r\n\t\t},\r\n\t\t_clean: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tClean off all of the given mixin parameters.\r\n\t\t\tvar name = this.name, family = this.family;\r\n\t\t\tarr.forEach([\"family\",\"name\",\"style\",\"variant\",\r\n\t\t\t\t\"weight\",\"stretch\",\"range\",\"viewbox\",\r\n\t\t\t\t\"origin\",\"advance\",\"ascent\",\"descent\",\r\n\t\t\t\t\"baseline\",\"glyphs\"], function(prop){\r\n\t\t\t\t\ttry{ delete this[prop]; } catch(e) { }\r\n\t\t\t}, this);\r\n\r\n\t\t\t//\t\ttry to pull out of the font cache.\r\n\t\t\tif(gfx._vectorFontCache[name]){\r\n\t\t\t\tdelete gfx._vectorFontCache[name];\r\n\t\t\t}\r\n\t\t\tif(gfx._vectorFontCache[family]){\r\n\t\t\t\tdelete gfx._vectorFontCache[family];\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tconstructor: function(/* String|dojo._Url */url){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreate this font object based on the SVG Font definition at url.\r\n\t\t\t// url:\r\n\t\t\t//\t\tAn url pointing to the SVG Font definition.\r\n\t\t\tthis._defaultLeading = 1.5;\r\n\t\t\tif(url!==undefined){\r\n\t\t\t\tthis.load(url);\r\n\t\t\t}\r\n\t\t},\r\n\t\tload: function(/* String|dojo._Url */url){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tLoad the passed SVG and send it to the parser for parsing.\r\n\t\t\t// url:\r\n\t\t\t//\t\tThe svg to parse.\r\n\t\t\tthis.onLoadBegin(url.toString());\r\n\t\t\tthis._parse(\r\n\t\t\t\tgfx._svgFontCache[url.toString()]||_getText(url.toString()),\r\n\t\t\t\turl.toString()\r\n\t\t\t);\r\n\t\t\tthis.onLoad(this);\r\n\t\t\treturn this;\t//\t\tdojox/gfx.VectorFont\r\n\t\t},\r\n\t\tinitialized: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn if we've loaded a font def, and the parsing was successful.\r\n\t\t\treturn (this.glyphs!==null);\t//\t\tBoolean\r\n\t\t},\r\n\r\n\t\t//\t\tpreset round to 3 places.\r\n\t\t_round: function(n){ return Math.round(1000*n)/1000; },\r\n\t\t_leading: function(unit){ return this.viewbox.height * (unit||this._defaultLeading); },\r\n\t\t_normalize: function(str){\r\n\t\t\treturn str.replace(/\\s+/g, String.fromCharCode(0x20));\r\n\t\t},\r\n\r\n\t\t_getWidth: function(glyphs){\r\n\t\t\tvar w=0, last=0, lastGlyph=null;\r\n\t\t\tarr.forEach(glyphs, function(glyph, i){\r\n\t\t\t\tlast=glyph.xAdvance;\r\n\t\t\t\tif(glyphs[i] && glyph.kern && glyph.kern[glyphs[i].code]){\r\n\t\t\t\t\tlast += glyph.kern[glyphs[i].code].x;\r\n\t\t\t\t}\r\n\t\t\t\tw += last;\r\n\t\t\t\tlastGlyph = glyph;\r\n\t\t\t});\r\n\r\n\t\t\t//\t\tif the last glyph was a space, pull it off.\r\n\t\t\tif(lastGlyph && lastGlyph.code == \" \"){\r\n\t\t\t\tw -= lastGlyph.xAdvance;\r\n\t\t\t}\r\n\r\n\t\t\treturn this._round(w/*-last*/);\r\n\t\t},\r\n\r\n\t\t_getLongestLine: function(lines){\r\n\t\t\tvar maxw=0, idx=0;\r\n\t\t\tarr.forEach(lines, function(line, i){\r\n\t\t\t\tvar max = Math.max(maxw, this._getWidth(line));\r\n\t\t\t\tif(max > maxw){\r\n\t\t\t\t\tmaxw = max;\r\n\t\t\t\t\tidx=i;\r\n\t\t\t\t}\r\n\t\t\t}, this);\r\n\t\t\treturn { width: maxw, index: idx, line: lines[idx] };\r\n\t\t},\r\n\r\n\t\t_trim: function(lines){\r\n\t\t\tvar fn = function(arr){\r\n\t\t\t\t//\t\tcheck if the first or last character is a space and if so, remove it.\r\n\t\t\t\tif(!arr.length){ return; }\r\n\t\t\t\tif(arr[arr.length-1].code == \" \"){ arr.splice(arr.length-1, 1); }\r\n\t\t\t\tif(!arr.length){ return; }\r\n\t\t\t\tif(arr[0].code == \" \"){ arr.splice(0, 1); }\r\n\t\t\t};\r\n\r\n\t\t\tif(lang.isArray(lines[0])){\r\n\t\t\t\t//\t\tmore than one line.\r\n\t\t\t\tarr.forEach(lines, fn);\r\n\t\t\t} else {\r\n\t\t\t\tfn(lines);\r\n\t\t\t}\r\n\t\t\treturn lines;\r\n\t\t},\r\n\r\n\t\t_split: function(chars, nLines){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsplit passed chars into nLines by finding the closest whitespace.\r\n\t\t\tvar w = this._getWidth(chars),\r\n\t\t\t\tlimit = Math.floor(w/nLines),\r\n\t\t\t\tlines = [],\r\n\t\t\t\tcw = 0,\r\n\t\t\t\tc = [],\r\n\t\t\t\tfound = false;\r\n\r\n\t\t\tfor(var i=0, l=chars.length; i<l; i++){\r\n\t\t\t\tif(chars[i].code == \" \"){ found = true; }\r\n\t\t\t\tcw += chars[i].xAdvance;\r\n\t\t\t\tif(i+1<l && chars[i].kern && chars[i].kern[chars[i+1].code]){\r\n\t\t\t\t\tcw += chars[i].kern[chars[i+1].code].x;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(cw>=limit){\r\n\t\t\t\t\tvar chr=chars[i];\r\n\t\t\t\t\twhile(found && chr.code != \" \" && i>=0){\r\n\t\t\t\t\t\tchr = c.pop(); i--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlines.push(c);\r\n\t\t\t\t\tc=[];\r\n\t\t\t\t\tcw=0;\r\n\t\t\t\t\tfound=false;\r\n\t\t\t\t}\r\n\t\t\t\tc.push(chars[i]);\r\n\t\t\t}\r\n\t\t\tif(c.length){ lines.push(c); }\r\n\t\t\t//\t\t\"trim\" it\r\n\t\t\treturn this._trim(lines);\r\n\t\t},\r\n\r\n\t\t_getSizeFactor: function(size){\r\n\t\t\t//\t\tgiven the size, return a scaling factor based on the height of the\r\n\t\t\t//\t\tfont as defined in the font definition file.\r\n\t\t\tsize += \"\";\t//\t\tforce the string cast.\r\n\t\t\tvar metrics = HtmlMetrics.getCachedFontMeasurements(),\r\n\t\t\t\theight=this.viewbox.height,\r\n\t\t\t\tf=metrics[\"1em\"],\r\n\t\t\t\tunit=parseFloat(size, 10);\t//\t\tthe default.\r\n\t\t\tif(size.indexOf(\"em\")>-1){\r\n\t\t\t\treturn this._round((metrics[\"1em\"]*unit)/height);\r\n\t\t\t}\r\n\t\t\telse if(size.indexOf(\"ex\")>-1){\r\n\t\t\t\treturn this._round((metrics[\"1ex\"]*unit)/height);\r\n\t\t\t}\r\n\t\t\telse if(size.indexOf(\"pt\")>-1){\r\n\t\t\t\treturn this._round(((metrics[\"12pt\"] / 12)*unit) / height);\r\n\t\t\t}\r\n\t\t\telse if(size.indexOf(\"px\")>-1){\r\n\t\t\t\treturn this._round(((metrics[\"16px\"] / 16)*unit) / height);\r\n\t\t\t}\r\n\t\t\telse if(size.indexOf(\"%\")>-1){\r\n\t\t\t\treturn this._round((metrics[\"1em\"]*(unit / 100)) / height);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tf=metrics[size]||metrics.medium;\r\n\t\t\t\treturn this._round(f/height);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_getFitFactor: function(lines, w, h, l){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFind the scaling factor for the given phrase set.\r\n\t\t\tif(!h){\r\n\t\t\t\t//\t\tif no height was passed, we assume an array of glyphs instead of lines.\r\n\t\t\t\treturn this._round(w/this._getWidth(lines));\r\n\t\t\t} else {\r\n\t\t\t\tvar maxw = this._getLongestLine(lines).width,\r\n\t\t\t\t\tmaxh = (lines.length*(this.viewbox.height*l))-((this.viewbox.height*l)-this.viewbox.height);\r\n\t\t\t\treturn this._round(Math.min(w/maxw, h/maxh));\r\n\t\t\t}\r\n\t\t},\r\n\t\t_getBestFit: function(chars, w, h, ldng){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet the best number of lines to return given w and h.\r\n\t\t\tvar limit=32,\r\n\t\t\t\tfactor=0,\r\n\t\t\t\tlines=limit;\r\n\t\t\twhile(limit>0){\r\n\t\t\t\tvar f=this._getFitFactor(this._split(chars, limit), w, h, ldng);\r\n\t\t\t\tif(f>factor){\r\n\t\t\t\t\tfactor = f;\r\n\t\t\t\t\tlines=limit;\r\n\t\t\t\t}\r\n\t\t\t\tlimit--;\r\n\t\t\t}\r\n\t\t\treturn { scale: factor, lines: this._split(chars, lines) };\r\n\t\t},\r\n\r\n\t\t_getBestFlow: function(chars, w, scale){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tBased on the given scale, do the best line splitting possible.\r\n\t\t\tvar lines = [],\r\n\t\t\t\tcw = 0,\r\n\t\t\t\tc = [],\r\n\t\t\t\tfound = false;\r\n\t\t\tfor(var i=0, l=chars.length; i<l; i++){\r\n\t\t\t\tif(chars[i].code == \" \"){ found = true; }\r\n\t\t\t\tvar tw = chars[i].xAdvance;\r\n\t\t\t\tif(i+1<l && chars[i].kern && chars[i].kern[chars[i+1].code]){\r\n\t\t\t\t\ttw += chars[i].kern[chars[i+1].code].x;\r\n\t\t\t\t}\r\n\t\t\t\tcw += scale*tw;\r\n\r\n\t\t\t\tif(cw>=w){\r\n\t\t\t\t\tvar chr=chars[i];\r\n\t\t\t\t\twhile(found && chr.code != \" \" && i>=0){\r\n\t\t\t\t\t\tchr = c.pop(); i--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlines.push(c);\r\n\t\t\t\t\tc=[];\r\n\t\t\t\t\tcw=0;\r\n\t\t\t\t\tfound=false;\r\n\t\t\t\t}\r\n\t\t\t\tc.push(chars[i]);\r\n\t\t\t}\r\n\t\t\tif(c.length){ lines.push(c); }\r\n\t\t\treturn this._trim(lines);\r\n\t\t},\r\n\r\n\t\t//\t\tpublic functions\r\n\t\tgetWidth: function(/* String */text, /* Float? */scale){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet the width of the rendered text without actually rendering it.\r\n\t\t\t// text:\r\n\t\t\t//\t\tThe string to measure.\r\n\t\t\t// scale:\r\n\t\t\t//\t\tan optional scaling factor.\r\n\t\t\treturn this._getWidth(arr.map(this._normalize(text).split(\"\"), function(chr){\r\n\t\t\t\treturn this.glyphs[chr] || { xAdvance: this.advance.missing.x };\r\n\t\t\t}, this)) * (scale || 1);\t//\t\tFloat\r\n\t\t},\r\n\t\tgetLineHeight: function(/* Float? */scale){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturn the height of a single line, sans leading, based on scale.\r\n\t\t\t// scale:\r\n\t\t\t//\t\tan optional scaling factor.\r\n\t\t\treturn this.viewbox.height * (scale || 1);\t//\t\tFloat\r\n\t\t},\r\n\r\n\t\t//\t\tA note:\r\n\t\t//\t\tMany SVG exports do not include information such as x-height, caps-height\r\n\t\t//\t\tand other coords that may help alignment.  We can calc the baseline and\r\n\t\t//\t\twe can get a mean line (i.e. center alignment) but that's about all, reliably.\r\n\t\tgetCenterline: function(/* Float? */scale){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturn the y coordinate that is the center of the viewbox.\r\n\t\t\t// scale:\r\n\t\t\t//\t\tan optional scaling factor.\r\n\t\t\treturn (scale||1) * (this.viewbox.height/2);\r\n\t\t},\r\n\t\tgetBaseline: function(/* Float? */scale){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFind the baseline coord for alignment; adjust for scale if passed.\r\n\t\t\t// scale:\r\n\t\t\t//\t\tan optional scaling factor.\r\n\t\t\treturn (scale||1) * (this.viewbox.height+this.descent);\t//\t\tFloat\r\n\t\t},\r\n\r\n\t\tdraw: function(\r\n\t\t\t\t/* dojox/gfx.Container */group,\r\n\t\t\t\t/* dojox/gfx.Text */ textArgs,\r\n\t\t\t\t/* dojox/gfx.Font */fontArgs,\r\n\t\t\t\t/* dojox/gfx.Fill */fillArgs,\r\n\t\t\t\t/* dojox/gfx.Stroke */strokeArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tbased on the passed parameters, draw the given text using paths\r\n\t\t\t//\t\tdefined by this font.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe main method of a VectorFont, draw() will take a text fragment\r\n\t\t\t//\t\tand render it in a set of groups and paths based on the parameters\r\n\t\t\t//\t\tpassed.\r\n\t\t\t//\r\n\t\t\t//\t\tThe basics of drawing text are simple enough: pass it your text as\r\n\t\t\t//\t\tpart of the textArgs object, pass size and family info as part of\r\n\t\t\t//\t\tthe fontArgs object, pass at least a color as the fillArgs object,\r\n\t\t\t//\t\tand if you are looking to create an outline, pass the strokeArgs\r\n\t\t\t//\t\tobject as well. fillArgs and strokeArgs are the same as any other\r\n\t\t\t//\t\tgfx fill and stroke arguments; they are simply applied to any path\r\n\t\t\t//\t\tobject generated by this method.\r\n\t\t\t//\r\n\t\t\t//\t\tResulting GFX structure\r\n\t\t\t//\t\t-----------------------\r\n\t\t\t//\r\n\t\t\t//\t\tThe result of this function is a set of gfx objects in the following structure:\r\n\t\t\t//\r\n\t\t\t//\t|\tgfx.Group \t\t\t//\t\tthe parent group generated by this function\r\n\t\t\t//\t|\t+\tgfx.Group[]\t\t//\t\ta group generated for each line of text\r\n\t\t\t//\t|\t\t+\tgfx.Path[]\t//\t\teach glyph/character in the text\r\n\t\t\t//\r\n\t\t\t//\t\tScaling transformations (i.e. making the generated text the correct size)\r\n\t\t\t//\t\tare always applied to the parent Group that is generated (i.e. the top\r\n\t\t\t//\t\tnode in the above example).  In theory, if you are looking to do any kind\r\n\t\t\t//\t\tof other transformations (such as a translation), you should apply it to\r\n\t\t\t//\t\tthe group reference you pass to this method.  If you find that you need\r\n\t\t\t//\t\tto apply transformations to the group that is returned by this method,\r\n\t\t\t//\t\tyou will need to reapply the scaling transformation as the *last* transform,\r\n\t\t\t//\t\tlike so:\r\n\t\t\t//\r\n\t\t\t//\t|\ttextGroup.setTransform(new matrix.Matrix2D([\r\n\t\t\t//\t|\t\tmatrix.translate({ dx: dx, dy: dy }),\r\n\t\t\t//\t|\t\ttextGroup.getTransform()\r\n\t\t\t//\t|\t]));\r\n\t\t\t//\r\n\t\t\t//\t\tIn general, this should never be necessary unless you are doing advanced\r\n\t\t\t//\t\tplacement of your text.\r\n\t\t\t//\r\n\t\t\t//\t\tAdvanced Layout Functionality\r\n\t\t\t//\t\t-----------------------------\r\n\t\t\t//\r\n\t\t\t//\t\tIn addition to straight text fragments, draw() supports a few advanced\r\n\t\t\t//\t\toperations not normally available with vector graphics:\r\n\t\t\t//\r\n\t\t\t//\t\t- Flow operations (i.e. wrap to a given width)\r\n\t\t\t//\t\t- Fitting operations (i.e. find a best fit to a given rectangle)\r\n\t\t\t//\r\n\t\t\t//\t\tTo enable either, pass a `fitting` property along with the textArgs object.\r\n\t\t\t//\t\tThe possible values are contained in the dojox/gfx.vectorFontFitting enum\r\n\t\t\t//\t\t(NONE, FLOW, FIT).\r\n\t\t\t//\r\n\t\t\t//\t\t`Flow fitting`\r\n\t\t\t//\t\tFlow fitting requires both a passed size (in the fontArgs object) and a\r\n\t\t\t//\t\twidth (passed with the textArgs object).  draw() will attempt to split the\r\n\t\t\t//\t\tpassed text up into lines, at the closest whitespace according to the\r\n\t\t\t//\t\tpassed width.  If a width is missing, it will revert to NONE.\r\n\t\t\t//\r\n\t\t\t//\t\t`Best fit fitting`\r\n\t\t\t//\t\tDoing a \"best fit\" means taking the passed text, and finding the largest\r\n\t\t\t//\t\tsize and line breaks so that it is the closest fit possible.  With best\r\n\t\t\t//\t\tfit, any size arguments are ignored; if a height is missing, it will revert\r\n\t\t\t//\t\tto NONE.\r\n\t\t\t//\r\n\t\t\t//\t\tOther notes\r\n\t\t\t//\t\t-----------\r\n\t\t\t//\r\n\t\t\t//\t\t`a11y`\r\n\t\t\t//\t\tSince the results of this method are rendering using pure paths (think\r\n\t\t\t//\t\t\"convert to outlines\" in Adobe Illustrator), any text rendered by this\r\n\t\t\t//\t\tcode is NOT considered a11y-friendly.  If a11y is a requirement, we\r\n\t\t\t//\t\tsuggest using other, more a11y-friendly methods.\r\n\t\t\t//\r\n\t\t\t//\t\t`Font sources`\r\n\t\t\t//\t\tAlways make sure that you are legally allowed to use any fonts that you\r\n\t\t\t//\t\tconvert to SVG format; we claim no responsibility for any licensing\r\n\t\t\t//\t\tinfractions that may be caused by the use of this code.\r\n\t\t\t// returns: dojox/gfx.Group\r\n\t\t\tif(!this.initialized()){\r\n\t\t\t\tthrow new Error(\"dojox.gfx.VectorFont.draw(): we have not been initialized yet.\");\r\n\t\t\t}\r\n\t\t\t//\t\tTODO: BIDI handling.  Deal with layout/alignments based on font parameters.\r\n\r\n\t\t\t//\t\tstart by creating the overall group.  This is the INNER group (the caller\r\n\t\t\t//\t\tshould be the outer).\r\n\t\t\tvar g = group.createGroup();\r\n\r\n\t\t\t//\t\tdo the x/y translation on the parent group\r\n\t\t\t//\t\tFIXME: this is probably not the best way of doing this.\r\n\t\t\tif(textArgs.x || textArgs.y){\r\n\t\t\t\tgroup.applyTransform({ dx: textArgs.x||0, dy: textArgs.y||0 });\r\n\t\t\t}\r\n\r\n\t\t\t//\t\tgo get the glyph array.\r\n\t\t\tvar text = arr.map(this._normalize(textArgs.text).split(\"\"), function(chr){\r\n\t\t\t\treturn this.glyphs[chr] || { path:null, xAdvance: this.advance.missing.x };\r\n\t\t\t}, this);\r\n\r\n\t\t\t//\t\tdetermine the font style info, ignore decoration.\r\n\t\t\tvar size = fontArgs.size,\r\n\t\t\t\tfitting = textArgs.fitting,\r\n\t\t\t\twidth = textArgs.width,\r\n\t\t\t\theight = textArgs.height,\r\n\t\t\t\talign = textArgs.align,\r\n\t\t\t\tleading = textArgs.leading||this._defaultLeading;\r\n\r\n\t\t\t//\t\tfigure out if we have to do fitting at all.\r\n\t\t\tif(fitting){\r\n\t\t\t\t//\t\tmore than zero.\r\n\t\t\t\tif((fitting==gfx.vectorFontFitting.FLOW && !width) || (fitting==gfx.vectorFontFitting.FIT && (!width || !height))){\r\n\t\t\t\t\t//\t\treset the fitting if we don't have everything we need.\r\n\t\t\t\t\tfitting = gfx.vectorFontFitting.NONE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//\t\tset up the lines array and the scaling factor.\r\n\t\t\tvar lines, scale;\r\n\t\t\tswitch(fitting){\r\n\t\t\t\tcase gfx.vectorFontFitting.FIT:\r\n\t\t\t\t\tvar o=this._getBestFit(text, width, height, leading);\r\n\t\t\t\t\tscale = o.scale;\r\n\t\t\t\t\tlines = o.lines;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase gfx.vectorFontFitting.FLOW:\r\n\t\t\t\t\tscale = this._getSizeFactor(size);\r\n\t\t\t\t\tlines = this._getBestFlow(text, width, scale);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tscale = this._getSizeFactor(size);\r\n\t\t\t\t\tlines = [ text ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\t\tmake sure lines doesn't have any empty lines.\r\n\t\t\tlines = arr.filter(lines, function(item){\r\n\t\t\t\treturn item.length>0;\r\n\t\t\t});\r\n\r\n\t\t\t//\t\tlet's start drawing.\r\n\t\t\tvar cy = 0,\r\n\t\t\t\tmaxw = this._getLongestLine(lines).width;\r\n\r\n\t\t\tfor(var i=0, l=lines.length; i<l; i++){\r\n\t\t\t\tvar cx = 0,\r\n\t\t\t\t\tline=lines[i],\r\n\t\t\t\t\tlinew = this._getWidth(line),\r\n\t\t\t\t\tlg=g.createGroup();\r\n\r\n\t\t\t\t//\t\tloop through the glyphs and add them to the line group (lg)\r\n\t\t\t\tfor (var j=0; j<line.length; j++){\r\n\t\t\t\t\tvar glyph=line[j];\r\n\t\t\t\t\tif(glyph.path!==null){\r\n\t\t\t\t\t\tvar p = lg.createPath(glyph.path).setFill(fillArgs);\r\n\t\t\t\t\t\tif(strokeArgs){ p.setStroke(strokeArgs); }\r\n\t\t\t\t\t\tp.setTransform([\r\n\t\t\t\t\t\t\tMatrix.flipY,\r\n\t\t\t\t\t\t\tMatrix.translate(cx, -this.viewbox.height-this.descent)\r\n\t\t\t\t\t\t]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcx += glyph.xAdvance;\r\n\t\t\t\t\tif(j+1<line.length && glyph.kern && glyph.kern[line[j+1].code]){\r\n\t\t\t\t\t\tcx += glyph.kern[line[j+1].code].x;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//\t\ttransform the line group.\r\n\t\t\t\tvar dx = 0;\r\n\t\t\t\tif(align==\"middle\"){ dx = maxw/2 - linew/2; }\r\n\t\t\t\telse if(align==\"end\"){ dx = maxw - linew; }\r\n\t\t\t\tlg.setTransform({ dx: dx, dy: cy });\r\n\t\t\t\tcy += this.viewbox.height * leading;\r\n\t\t\t}\r\n\r\n\t\t\t//\t\tscale the group\r\n\t\t\tg.setTransform(Matrix.scale(scale));\r\n\r\n\t\t\t//\t\treturn the overall group\r\n\t\t\treturn g;\t//\t\tdojox/gfx.Group\r\n\t\t},\r\n\r\n\t\t//\t\tevents\r\n\t\tonLoadBegin: function(/* String */url){ },\r\n\t\tonLoad: function(/* dojox/gfx/VectorText */font){ }\r\n\t});\r\n\r\n\t//\t\tTODO: dojox/gfx integration\r\n/*\r\n\r\n\t//\t\tInherit from Group but attach Text properties to it.\r\n\tdojo.declare(\"dojox.gfx.VectorText\", dojox.gfx.Group, {\r\n\t\tconstructor: function(rawNode){\r\n\t\t\tdojox.gfx.Group._init.call(this);\r\n\t\t\tthis.fontStyle = null;\r\n\t\t},\r\n\r\n\t\t//\t\tprivate methods.\r\n\t\t_setFont: function(){\r\n\t\t\t//\t\trender this using the font code.\r\n\t\t\tvar f = this.fontStyle;\r\n\t\t\tvar font = dojox.gfx._vectorFontCache[f.family];\r\n\t\t\tif(!font){\r\n\t\t\t\tthrow new Error(\"dojox.gfx.VectorText._setFont: the passed font family '\" + f.family + \"' was not found.\");\r\n\t\t\t}\r\n\r\n\t\t\t//\t\tthe actual rendering belongs to the font itself.\r\n\t\t\tfont.draw(this, this.shape, this.fontStyle, this.fillStyle, this.strokeStyle);\r\n\t\t},\r\n\r\n\t\tgetFont: function(){ return this.fontStyle; },\r\n\r\n\t\t//\t\toverridden public methods.\r\n\t\tsetShape: function(newShape){\r\n\t\t\tdojox.gfx.Group.setShape.call(this);\r\n\t\t\tthis.shape = dojox.gfx.makeParameters(this.shape, newShape);\r\n\t\t\tthis.bbox = null;\r\n\t\t\tthis._setFont();\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t//\t\tif we've been drawing, we should have exactly one child, and that\r\n\t\t//\t\tchild will contain the real children.\r\n\t\tsetFill: function(fill){\r\n\t\t\tthis.fillStyle = fill;\r\n\t\t\tif(this.children[0]){\r\n\t\t\t\tdojo.forEach(this.children[0].children, function(group){\r\n\t\t\t\t\tdojo.forEach(group.children, function(path){\r\n\t\t\t\t\t\tpath.setFill(fill);\r\n\t\t\t\t\t});\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tsetStroke: function(stroke){\r\n\t\t\tthis.strokeStyle = stroke;\r\n\t\t\tif(this.children[0]){\r\n\t\t\t\tdojo.forEach(this.children[0].children, function(group){\r\n\t\t\t\t\tdojo.forEach(group.children, function(path){\r\n\t\t\t\t\t\tpath.setStroke(stroke);\r\n\t\t\t\t\t});\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tsetFont: function(newFont){\r\n\t\t\t//\t\tthis will do the real rendering.\r\n\t\t\tthis.fontStyle = typeof newFont == \"string\" ? dojox.gfx.splitFontString(newFont)\r\n\t\t\t\t: dojox.gfx.makeParameters(dojox.gfx.defaultFont, newFont);\r\n\t\t\tthis._setFont();\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\tgetBoundingBox: function(){\r\n\t\t\treturn this.bbox;\r\n\t\t}\r\n\t});\r\n\r\n\t//\t\tTODO: figure out how to add this to container objects!\r\n\tdojox.gfx.shape.Creator.createVectorText = function(text){\r\n\t\treturn this.createObject(dojox.gfx.VectorText, text);\r\n\t}\r\n*/\r\n});\r\n"]}