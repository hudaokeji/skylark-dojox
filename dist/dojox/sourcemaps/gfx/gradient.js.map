{"version":3,"sources":["gfx/gradient.js"],"names":["define","lang","m","Color","grad","getObject","C","getPoint","x","y","matrix","project","shiftAndRotate","scale","r","multiplyPoint","p","o","sortPoints","a","b","rescale","stops","from","to","newStops","len","length","reverseFlag","tmp","offset","color","stop","prev","i","span","push","blendColors","reverse","gradient","tl","rb","ttl","trb","identity","f1","x1","y1","f2","x2","y2","angle","Math","atan2","pf1","pf2","Matrix2D","rotate","dx","dy","points","sort","colors","type"],"mappings":"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","file":"../../gfx/gradient.js","sourcesContent":["define([\"dojo/_base/lang\", \"./matrix\", \"dojo/_base/Color\"], \r\n  function(lang, m, Color){\r\n// Various utilities to deal with a linear gradient (mostly VML-specific)\r\n\tvar grad = lang.getObject(\"dojox.gfx.gradient\", true);\r\n\tvar C = Color;\r\n\t\r\n\tgrad.rescale = function(stops, from, to){\r\n\t\t// summary:\r\n\t\t//\t\tRecalculates a gradient from 0-1 window to\r\n\t\t//\t\t\"from\"-\"to\" window blending and replicating colors,\r\n\t\t//\t\tif necessary.\r\n\t\t// stops: Array\r\n\t\t//\t\tinput gradient as a list of colors with offsets\r\n\t\t//\t\t(see dojox/gfx.defaultLinearGradient and dojox/gfx.defaultRadialGradient)\r\n\t\t// from: Number\r\n\t\t//\t\tthe beginning of the window, should be less than \"to\"\r\n\t\t// to: Number\r\n\t\t//\t\tthe end of the window, should be more than \"from\"\r\n\r\n\t\tvar len = stops.length, reverseFlag = (to < from), newStops;\r\n\r\n\t\t// do we need to reverse the color table?\r\n\t\tif(reverseFlag){\r\n\t\t\tvar tmp = from;\r\n\t\t\tfrom = to;\r\n\t\t\tto = tmp;\r\n\t\t}\r\n\t\t\r\n\t\t// various edge cases\r\n\t\tif(!len){\r\n\t\t\t// no colors\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\tif(to <= stops[0].offset){\r\n\t\t\t// all colors are before the color table\r\n\t\t\tnewStops = [\r\n\t\t\t\t{offset: 0, color: stops[0].color},\r\n\t\t\t\t{offset: 1, color: stops[0].color}\r\n\t\t\t];\r\n\t\t}else if(from >= stops[len - 1].offset){\r\n\t\t\t// all colors are after the color table\r\n\t\t\tnewStops = [\r\n\t\t\t\t{offset: 0, color: stops[len - 1].color},\r\n\t\t\t\t{offset: 1, color: stops[len - 1].color}\r\n\t\t\t];\r\n\t\t}else{\r\n\t\t\t// main scanning algorithm\r\n\t\t\tvar span = to - from, stop, prev, i;\r\n\t\t\tnewStops = [];\r\n\t\t\tif(from < 0){\r\n\t\t\t\tnewStops.push({offset: 0, color: new C(stops[0].color)});\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < len; ++i){\r\n\t\t\t\tstop = stops[i];\r\n\t\t\t\tif(stop.offset >= from){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// skip this color\r\n\t\t\t}\r\n\t\t\tif(i){\r\n\t\t\t\tprev = stops[i - 1];\r\n\t\t\t\tnewStops.push({\r\n\t\t\t\t\toffset: 0,\r\n\t\t\t\t\tcolor: Color.blendColors(new C(prev.color), new C(stop.color), (from - prev.offset) / (stop.offset - prev.offset))\r\n\t\t\t\t});\r\n\t\t\t}else{\r\n\t\t\t\tnewStops.push({offset: 0, color: new C(stop.color)});\r\n\t\t\t}\r\n\t\t\tfor(; i < len; ++i){\r\n\t\t\t\tstop = stops[i];\r\n\t\t\t\tif(stop.offset >= to){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tnewStops.push({offset: (stop.offset - from) / span, color: new C(stop.color)});\r\n\t\t\t}\r\n\t\t\tif(i < len){\r\n\t\t\t\tprev = stops[i - 1];\r\n\t\t\t\tnewStops.push({\r\n\t\t\t\t\toffset: 1,\r\n\t\t\t\t\tcolor: Color.blendColors(new C(prev.color), new C(stop.color), (to - prev.offset) / (stop.offset - prev.offset))\r\n\t\t\t\t});\r\n\t\t\t}else{\r\n\t\t\t\tnewStops.push({offset: 1, color: new C(stops[len - 1].color)});\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// reverse the color table, if needed\r\n\t\tif(reverseFlag){\r\n\t\t\tnewStops.reverse();\r\n\t\t\tfor(i = 0, len = newStops.length; i < len; ++i){\r\n\t\t\t\tstop = newStops[i];\r\n\t\t\t\tstop.offset = 1 - stop.offset;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn newStops;\r\n\t};\r\n\t\r\n\tfunction getPoint(x, y, matrix, project, shiftAndRotate, scale){\r\n\t\tvar r = m.multiplyPoint(matrix, x, y),\r\n\t\t\tp = m.multiplyPoint(project, r);\r\n\t\treturn {r: r, p: p, o: m.multiplyPoint(shiftAndRotate, p).x / scale};\r\n\t}\r\n\t\r\n\tfunction sortPoints(a, b){\r\n\t\treturn a.o - b.o;\r\n\t}\r\n\t\r\n\tgrad.project = function(matrix, gradient, tl, rb, ttl, trb){\r\n\t\t// summary:\r\n\t\t//\t\tReturns a new gradient using the \"VML algorithm\" and suitable for VML.\r\n\t\t// matrix: dojox/gfx/matrix.Matrix2D|null\r\n\t\t//\t\tmatrix to apply to a shape and its gradient\r\n\t\t// gradient: Object\r\n\t\t//\t\ta linear gradient object to be transformed\r\n\t\t// tl: dojox/gfx.Point\r\n\t\t//\t\ttop-left corner of shape's bounding box\r\n\t\t// rb: dojox/gfx.Point\r\n\t\t//\t\tright-bottom corner of shape's bounding box\r\n\t\t// ttl: dojox/gfx.Point\r\n\t\t//\t\ttop-left corner of shape's transformed bounding box\r\n\t\t// trb: dojox/gfx.Point\r\n\t\t//\t\tright-bottom corner of shape's transformed bounding box\r\n\t\t\r\n\t\tmatrix = matrix || m.identity;\r\n\r\n\t\tvar f1 = m.multiplyPoint(matrix, gradient.x1, gradient.y1),\r\n\t\t\tf2 = m.multiplyPoint(matrix, gradient.x2, gradient.y2),\r\n\t\t\tangle = Math.atan2(f2.y - f1.y, f2.x - f1.x),\r\n\t\t\tproject = m.project(f2.x - f1.x, f2.y - f1.y),\r\n\t\t\tpf1 = m.multiplyPoint(project, f1),\r\n\t\t\tpf2 = m.multiplyPoint(project, f2),\r\n\t\t\tshiftAndRotate = new m.Matrix2D([m.rotate(-angle), {dx: -pf1.x, dy: -pf1.y}]),\r\n\t\t\tscale = m.multiplyPoint(shiftAndRotate, pf2).x,\r\n\t\t\t//comboMatrix = new m.Matrix2D([shiftAndRotate, project, matrix]),\r\n\t\t\t// bbox-specific calculations\r\n\t\t\tpoints = [\r\n\t\t\t\t\tgetPoint(tl.x, tl.y, matrix, project, shiftAndRotate, scale),\r\n\t\t\t\t\tgetPoint(rb.x, rb.y, matrix, project, shiftAndRotate, scale),\r\n\t\t\t\t\tgetPoint(tl.x, rb.y, matrix, project, shiftAndRotate, scale),\r\n\t\t\t\t\tgetPoint(rb.x, tl.y, matrix, project, shiftAndRotate, scale)\r\n\t\t\t\t].sort(sortPoints),\r\n\t\t\tfrom = points[0].o,\r\n\t\t\tto   = points[3].o,\r\n\t\t\tstops = grad.rescale(gradient.colors, from, to),\r\n\t\t\t//angle2 = Math.atan2(Math.abs(points[3].r.y - points[0].r.y) * (f2.y - f1.y), Math.abs(points[3].r.x - points[0].r.x) * (f2.x - f1.x));\r\n\t\t\tangle2 = Math.atan2(points[3].r.y - points[0].r.y, points[3].r.x - points[0].r.x);\r\n\r\n\t\treturn {\r\n\t\t\ttype: \"linear\",\r\n\t\t\tx1: points[0].p.x, y1: points[0].p.y, x2: points[3].p.x, y2: points[3].p.y,\r\n\t\t\tcolors: stops,\r\n\t\t\t// additional helpers (for VML)\r\n\t\t\tangle: angle\r\n\t\t};\r\n\t};\r\n\t\r\n\treturn grad;\r\n});\r\n"]}