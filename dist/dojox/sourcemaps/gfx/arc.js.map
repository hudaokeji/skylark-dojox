{"version":3,"sources":["gfx/arc.js"],"names":["define","g","lang","m","twoPI","Math","PI","pi4","pi8","pi48","curvePI4","unitArcAsBezier","alpha","cosa","cos","sina","sin","p2","x","y","s","c1","c2","e","arc","arcAsBezier","last","rx","ry","xRotg","large","sweep","Boolean","xRot","_degToRad","rx2","ry2","pa","multiplyPoint","rotate","pax2","pay2","sqrt","isNaN","ca","c","translate","elliptic_transform","normalize","scale","inversed","invert","sp","ep","startAngle","atan2","theta","curve","step","result","angle","M","push"],"mappings":"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","file":"../../gfx/arc.js","sourcesContent":["define([\"./_base\", \"dojo/_base/lang\", \"./matrix\"], \r\n  function(g, lang, m){\r\n\tvar twoPI = 2 * Math.PI, pi4 = Math.PI / 4, pi8 = Math.PI / 8,\r\n\t\tpi48 = pi4 + pi8, curvePI4 = unitArcAsBezier(pi8);\r\n\r\n\tfunction unitArcAsBezier(alpha){\r\n\t\t// summary:\r\n\t\t//\t\treturn a start point, 1st and 2nd control points, and an end point of\r\n\t\t//\t\ta an arc, which is reflected on the x axis\r\n\t\t// alpha: Number\r\n\t\t//\t\tangle in radians, the arc will be 2 * angle size\r\n\t\tvar cosa  = Math.cos(alpha), sina  = Math.sin(alpha),\r\n\t\t\tp2 = {x: cosa + (4 / 3) * (1 - cosa), y: sina - (4 / 3) * cosa * (1 - cosa) / sina};\r\n\t\treturn {\t// Object\r\n\t\t\ts:  {x: cosa, y: -sina},\r\n\t\t\tc1: {x: p2.x, y: -p2.y},\r\n\t\t\tc2: p2,\r\n\t\t\te:  {x: cosa, y: sina}\r\n\t\t};\r\n\t}\r\n\r\n\tvar arc = g.arc = {\r\n\t\t// summary:\r\n\t\t//\t\tThis module contains the core graphics Arc functions.\r\n\t\t\r\n\t\tunitArcAsBezier: unitArcAsBezier,\r\n\t\t/*===== \r\n\t\tunitArcAsBezier: function(alpha) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturn a start point, 1st and 2nd control points, and an end point of\r\n\t\t\t//\t\ta an arc, which is reflected on the x axis\r\n\t\t\t// alpha: Number\r\n\t\t\t//\t\tangle in radians, the arc will be 2 * angle size\r\n\t\t},\r\n\t\t=====*/\r\n\r\n\t\t// curvePI4: Object\r\n\t\t//\t\tan object with properties of an arc around a unit circle from 0 to pi/4\r\n\t\tcurvePI4: curvePI4,\r\n\r\n\t\tarcAsBezier: function(last, rx, ry, xRotg, large, sweep, x, y){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcalculates an arc as a series of Bezier curves\r\n\t\t\t//\t\tgiven the last point and a standard set of SVG arc parameters,\r\n\t\t\t//\t\tit returns an array of arrays of parameters to form a series of\r\n\t\t\t//\t\tabsolute Bezier curves.\r\n\t\t\t// last: Object\r\n\t\t\t//\t\ta point-like object as a start of the arc\r\n\t\t\t// rx: Number\r\n\t\t\t//\t\ta horizontal radius for the virtual ellipse\r\n\t\t\t// ry: Number\r\n\t\t\t//\t\ta vertical radius for the virtual ellipse\r\n\t\t\t// xRotg: Number\r\n\t\t\t//\t\ta rotation of an x axis of the virtual ellipse in degrees\r\n\t\t\t// large: Boolean\r\n\t\t\t//\t\twhich part of the ellipse will be used (the larger arc if true)\r\n\t\t\t// sweep: Boolean\r\n\t\t\t//\t\tdirection of the arc (CW if true)\r\n\t\t\t// x: Number\r\n\t\t\t//\t\tthe x coordinate of the end point of the arc\r\n\t\t\t// y: Number\r\n\t\t\t//\t\tthe y coordinate of the end point of the arc\r\n\r\n\t\t\t// calculate parameters\r\n\t\t\tlarge = Boolean(large);\r\n\t\t\tsweep = Boolean(sweep);\r\n\t\t\tvar xRot = m._degToRad(xRotg),\r\n\t\t\t\trx2 = rx * rx, ry2 = ry * ry,\r\n\t\t\t\tpa = m.multiplyPoint(\r\n\t\t\t\t\tm.rotate(-xRot),\r\n\t\t\t\t\t{x: (last.x - x) / 2, y: (last.y - y) / 2}\r\n\t\t\t\t),\r\n\t\t\t\tpax2 = pa.x * pa.x, pay2 = pa.y * pa.y,\r\n\t\t\t\tc1 = Math.sqrt((rx2 * ry2 - rx2 * pay2 - ry2 * pax2) / (rx2 * pay2 + ry2 * pax2));\r\n\t\t\tif(isNaN(c1)){ c1 = 0; }\r\n\t\t\tvar\tca = {\r\n\t\t\t\t\tx:  c1 * rx * pa.y / ry,\r\n\t\t\t\t\ty: -c1 * ry * pa.x / rx\r\n\t\t\t\t};\r\n\t\t\tif(large == sweep){\r\n\t\t\t\tca = {x: -ca.x, y: -ca.y};\r\n\t\t\t}\r\n\t\t\t// the center\r\n\t\t\tvar c = m.multiplyPoint(\r\n\t\t\t\t[\r\n\t\t\t\t\tm.translate(\r\n\t\t\t\t\t\t(last.x + x) / 2,\r\n\t\t\t\t\t\t(last.y + y) / 2\r\n\t\t\t\t\t),\r\n\t\t\t\t\tm.rotate(xRot)\r\n\t\t\t\t],\r\n\t\t\t\tca\r\n\t\t\t);\r\n\t\t\t// calculate the elliptic transformation\r\n\t\t\tvar elliptic_transform = m.normalize([\r\n\t\t\t\tm.translate(c.x, c.y),\r\n\t\t\t\tm.rotate(xRot),\r\n\t\t\t\tm.scale(rx, ry)\r\n\t\t\t]);\r\n\t\t\t// start, end, and size of our arc\r\n\t\t\tvar inversed = m.invert(elliptic_transform),\r\n\t\t\t\tsp = m.multiplyPoint(inversed, last),\r\n\t\t\t\tep = m.multiplyPoint(inversed, x, y),\r\n\t\t\t\tstartAngle = Math.atan2(sp.y, sp.x),\r\n\t\t\t\tendAngle   = Math.atan2(ep.y, ep.x),\r\n\t\t\t\ttheta = startAngle - endAngle;\t// size of our arc in radians\r\n\t\t\tif(sweep){ theta = -theta; }\r\n\t\t\tif(theta < 0){\r\n\t\t\t\ttheta += twoPI;\r\n\t\t\t}else if(theta > twoPI){\r\n\t\t\t\ttheta -= twoPI;\r\n\t\t\t}\r\n\r\n\t\t\t// draw curve chunks\r\n\t\t\tvar alpha = pi8, curve = curvePI4, step  = sweep ? alpha : -alpha,\r\n\t\t\t\tresult = [];\r\n\t\t\tfor(var angle = theta; angle > 0; angle -= pi4){\r\n\t\t\t\tif(angle < pi48){\r\n\t\t\t\t\talpha = angle / 2;\r\n\t\t\t\t\tcurve = unitArcAsBezier(alpha);\r\n\t\t\t\t\tstep  = sweep ? alpha : -alpha;\r\n\t\t\t\t\tangle = 0;\t// stop the loop\r\n\t\t\t\t}\r\n\t\t\t\tvar c2, e, M = m.normalize([elliptic_transform, m.rotate(startAngle + step)]);\r\n\t\t\t\tif(sweep){\r\n\t\t\t\t\tc1 = m.multiplyPoint(M, curve.c1);\r\n\t\t\t\t\tc2 = m.multiplyPoint(M, curve.c2);\r\n\t\t\t\t\te  = m.multiplyPoint(M, curve.e );\r\n\t\t\t\t}else{\r\n\t\t\t\t\tc1 = m.multiplyPoint(M, curve.c2);\r\n\t\t\t\t\tc2 = m.multiplyPoint(M, curve.c1);\r\n\t\t\t\t\te  = m.multiplyPoint(M, curve.s );\r\n\t\t\t\t}\r\n\t\t\t\t// draw the curve\r\n\t\t\t\tresult.push([c1.x, c1.y, c2.x, c2.y, e.x, e.y]);\r\n\t\t\t\tstartAngle += 2 * step;\r\n\t\t\t}\r\n\t\t\treturn result;\t// Array\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn arc;\r\n});\r\n"]}