{"version":3,"sources":["gfx/bezierutils.js"],"names":["define","gfx","bu","bezierutils","computeLength","tAtLength","points","length","t","quadratic","currentLen","splitCount","splitFunc","splitQBezierAtT","splitBezierAtT","_compute","p","error","pLen","i","distance","newbezier","Math","abs","newBeziers","splitCBezierAtT","x1","y1","x2","y2","sqrt","r","r2","t2","p1x","p1y","cx","cy","p2x","p2y","px","py","r3","t3","c1x","c1y","c2x","c2y"],"mappings":"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","file":"../../gfx/bezierutils.js","sourcesContent":["define([\r\n\t\"./_base\"\r\n], function(gfx){\r\n\r\n\tvar bu = gfx.bezierutils = {},\r\n\t\terror = 0.1;\r\n\r\n\tvar tAtLength = bu.tAtLength = function(points, length){\r\n\t\t// summary:\r\n\t\t//\t\tReturns the t corresponding to the given length for the specified bezier curve.\r\n\t\t// points: Number[]\r\n\t\t//\t\tThe bezier points. Should be [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y] for a cubic\r\n\t\t//\t\tbezier curve or [p1x, p1y, cx, cy, p2x, p2y] for a quadratic bezier curve.\r\n\t\t// length: Number\r\n\t\t//\t\tThe length.\r\n\t\tvar t = 0,\r\n\t\t\tquadratic = points.length == 6,\r\n\t\t\tcurrentLen = 0,\r\n\t\t\tsplitCount = 0,\r\n\t\t\tsplitFunc = quadratic ? splitQBezierAtT : splitBezierAtT;\r\n\t\tvar _compute = function(p, error){\r\n\t\t\t// control points polygon length\r\n\t\t\tvar pLen = 0;\r\n\t\t\tfor(var i = 0; i < p.length-2; i+=2)\r\n\t\t\t\tpLen += distance(p[i],p[i+1],p[i+2],p[i+3]);\r\n\t\t\t// chord length\r\n\t\t\tvar chord = quadratic ?\r\n\t\t\t\tdistance(points[0],points[1],points[4],points[5]) :\r\n\t\t\t\tdistance(points[0],points[1],points[6],points[7]);\r\n\t\t\t// if needs more approx. or if currentLen is greater than the target length,\r\n\t\t\t// split the curve one more time\r\n\t\t\tif(pLen - chord > error || currentLen + pLen > length + error){\r\n\t\t\t\t++splitCount;\r\n\t\t\t\tvar newbezier = splitFunc(p, .5);\r\n\t\t\t\t// check 1st subpath\r\n\t\t\t\t_compute(newbezier[0], error);\r\n\t\t\t\t// the 1st subcurve was the good one, we stop\r\n\t\t\t\tif(Math.abs(currentLen - length) <= error){\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t// need to continue with the 2nde subcurve\r\n\t\t\t\t_compute(newbezier[1], error);\r\n\t\t\t\treturn ;\r\n\t\t\t}\r\n\t\t\tcurrentLen += pLen;\r\n\t\t\tt += 1.0 / (1 << splitCount);\r\n\t\t};\r\n\t\tif(length)\r\n\t\t\t_compute(points, 0.5);\r\n\t\treturn t;\r\n\t};\r\n\r\n\tvar computeLength = bu.computeLength = function(/*Array*/points){\r\n\t\t// summary:\r\n\t\t//\t\tReturns the length of the given bezier curve.\r\n\t\t// points: Number[]\r\n\t\t//\t\tThe bezier points. Should be [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y] for a cubic\r\n\t\t//\t\tbezier curve or [p1x, p1y, cx, cy, p2x, p2y] for a quadratic bezier curve.\r\n\r\n\t\tvar quadratic = points.length == 6, pLen=0;\r\n\t\t// control points polygon length\r\n\t\tfor(var i = 0; i < points.length-2; i+=2)\r\n\t\t\tpLen += distance(points[i],points[i+1],points[i+2],points[i+3]);\r\n\t\t// chord length\r\n\t\tvar chord = quadratic ?\r\n\t\t\tdistance(points[0],points[1],points[4],points[5]) :\r\n\t\t\tdistance(points[0],points[1],points[6],points[7]);\r\n\t\t// split polygons until the polygon and the chord are \"the same\"\r\n\t\tif(pLen-chord>error){\r\n\t\t\tvar newBeziers = quadratic ? splitQBezierAtT(points,.5) : splitCBezierAtT(points,.5);\r\n\t\t\tvar length = computeLength(newBeziers[0], quadratic);\r\n\t\t\tlength += computeLength(newBeziers[1], quadratic);\r\n\t\t\treturn length;\r\n\t\t}\r\n\t\t// pLen is close enough, done.\r\n\t\treturn pLen;\r\n\t};\r\n\r\n\tvar distance = bu.distance = function(x1, y1, x2, y2){\r\n\t\t// summary:\r\n\t\t//\t\tReturns the distance between the specified points.\r\n\t\treturn Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\r\n\t};\r\n\r\n\tvar splitQBezierAtT = function(points, t){\r\n\t\t// summary:\r\n\t\t//\t\tSplit a quadratic bezier curve into 2 sub-quadratic beziers at the specified t.\r\n\r\n\t\t// de Casteljau\r\n\t\tvar r = 1-t,\r\n\t\t\tr2 = r*r,\r\n\t\t\tt2 = t*t,\r\n\t\t\tp1x = points[0],\r\n\t\t\tp1y = points[1],\r\n\t\t\tcx = points[2],\r\n\t\t\tcy = points[3],\r\n\t\t\tp2x = points[4],\r\n\t\t\tp2y = points[5],\r\n\r\n\t\t\tax = r*p1x + t*cx,\r\n\t\t\tay = r*p1y + t*cy,\r\n\t\t\tbx = r*cx + t*p2x,\r\n\t\t\tby = r*cy + t*p2y,\r\n\t\t\tpx = r2*p1x + 2*r*t*cx + t2*p2x,\r\n\t\t\tpy = r2*p1y + 2*r*t*cy + t2*p2y;\r\n\r\n\t\treturn [\r\n\t\t\t[\r\n\t\t\t\tp1x, p1y,\r\n\t\t\t\tax, ay,\r\n\t\t\t\tpx, py\r\n\t\t\t],\r\n\t\t\t[\r\n\t\t\t\tpx, py,\r\n\t\t\t\tbx, by,\r\n\t\t\t\tp2x, p2y\r\n\t\t\t]\r\n\t\t];\r\n\t};\r\n\r\n\tvar splitCBezierAtT = function(points, t){\r\n\t\t// summary:\r\n\t\t//\t\tSplit a cubic bezier curve into 2 sub-cubic beziers at the specified t.\r\n\r\n\t\t// de Casteljau\r\n\t\tvar r = 1-t,\r\n\t\t\tr2 = r*r,\r\n\t\t\tr3 = r2*r,\r\n\t\t\tt2 = t*t,\r\n\t\t\tt3 = t2*t,\r\n\t\t\tp1x = points[0],\r\n\t\t\tp1y = points[1],\r\n\t\t\tc1x = points[2],\r\n\t\t\tc1y = points[3],\r\n\t\t\tc2x = points[4],\r\n\t\t\tc2y = points[5],\r\n\t\t\tp2x = points[6],\r\n\t\t\tp2y = points[7],\r\n\r\n\t\t\tax = r*p1x + t*c1x,\r\n\t\t\tay = r*p1y + t*c1y,\r\n\t\t\tcx = r*c2x + t*p2x,\r\n\t\t\tcy = r*c2y + t*p2y,\r\n\t\t\tmx = r2*p1x + 2*r*t*c1x + t2*c2x,\r\n\t\t\tmy = r2*p1y + 2*r*t*c1y + t2*c2y,\r\n\t\t\tnx = r2*c1x + 2*r*t*c2x + t2*p2x,\r\n\t\t\tny = r2*c1y + 2*r*t*c2y + t2*p2y,\r\n\t\t\tpx = r3*p1x + 3*r2*t*c1x + 3*r*t2*c2x+t3*p2x,\r\n\t\t\tpy = r3*p1y + 3*r2*t*c1y + 3*r*t2*c2y+t3*p2y;\r\n\r\n\t\treturn [\r\n\t\t\t[\r\n\t\t\t\tp1x, p1y,\r\n\t\t\t\tax, ay,\r\n\t\t\t\tmx, my,\r\n\t\t\t\tpx, py\r\n\t\t\t],\r\n\t\t\t[\r\n\t\t\t\tpx, py,\r\n\t\t\t\tnx, ny,\r\n\t\t\t\tcx, cy,\r\n\t\t\t\tp2x, p2y\r\n\t\t\t]\r\n\t\t];\r\n\t};\r\n\r\n\tvar splitBezierAtT = bu.splitBezierAtT = function(points, t){\r\n\t\treturn points.length == 6 ? splitQBezierAtT(points, t) : splitCBezierAtT(points, t);\r\n\t};\r\n\treturn bu;\r\n});"]}