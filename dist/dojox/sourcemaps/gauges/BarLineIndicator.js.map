{"version":3,"sources":["gauges/BarLineIndicator.js"],"names":["define","declare","fx","connect","lang","gfx","Indicator","width","_getShapes","group","this","_gauge","v","value","min","max","pos","_getPosition","shapes","createRect","x","y","dataY","offset","height","length","setStroke","color","setFill","setTransform","matrix","translate","createLine","x1","y1","x2","y2","draw","dontAnimate","shape","_move","parent","remove","text","dataHeight","highlight","highlight2","createGroup","s","add","label","direction","fz","font","defaultFont","size","th","normalizedLength","drawText","handleMouseOver","handleMouseOut","handleMouseDown","handleTouchStart","currentValue","c","anim","Animation","curve","duration","easing","hitch","jump","play"],"mappings":"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","file":"../../gauges/BarLineIndicator.js","sourcesContent":["define([\"dojo/_base/declare\",\"dojo/_base/fx\",\"dojo/_base/connect\",\"dojo/_base/lang\", \"dojox/gfx\", \"./_Indicator\"], \r\n  function(declare, fx, connect, lang, gfx, Indicator) {\r\n\r\nreturn declare(\"dojox.gauges.BarLineIndicator\",[Indicator],{\r\n\t\r\n\t// summary:\r\n\t//\t\tAn indicator for the BarGauge that draws a segment a line corresponding to the indicator value.\t\r\n\t\r\n\twidth: 1,\r\n\t_getShapes: function(/*dojox.gfx.Group*/ group){\r\n\t\t// summary:\r\n\t\t//\t\tPrivate function for generating the shapes for this indicator. An indicator that behaves the \r\n\t\t//\t\tsame might override this one and simply replace the shapes (such as BarIndicator).\r\n\t\tif(!this._gauge){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tvar v = this.value;\r\n\t\tif(v < this._gauge.min){v = this._gauge.min;}\r\n\t\tif(v > this._gauge.max){v = this._gauge.max;}\r\n\t\tvar pos = this._gauge._getPosition(v);\r\n\t\tvar shapes = [];\r\n\t\tif(this.width > 1){\r\n\t\t\tshapes[0] = group.createRect({\r\n\t\t\t\tx:0, \r\n\t\t\t\ty:this._gauge.dataY + this.offset,\r\n\t\t\t\twidth:this.width, \r\n\t\t\t\theight:this.length\r\n\t\t\t});\r\n\t\t\tshapes[0].setStroke({color: this.color});\r\n\t\t\tshapes[0].setFill(this.color);\r\n\t\t\tshapes[0].setTransform(gfx.matrix.translate(pos,0));\r\n\t\t}else{\r\n\t\t\tshapes[0] = group.createLine({\r\n\t\t\t\tx1:0, \r\n\t\t\t\ty1:this._gauge.dataY + this.offset,\r\n\t\t\t\tx2:0, \r\n\t\t\t\ty2:this._gauge.dataY + this.offset + this.length\r\n\t\t\t});\r\n\t\t\tshapes[0].setStroke({color: this.color});\r\n\t\t\tshapes[0].setTransform(gfx.matrix.translate(pos,0));\r\n\t\t}\r\n\t\treturn shapes;\r\n\t},\r\n\tdraw: function(/*dojox.gfx.Group*/group, /*Boolean?*/ dontAnimate){\r\n\t\t// summary:\r\n\t\t//\t\tOverride of dojox.gauges._Indicator.draw\r\n\t\t// dontAnimate: Boolean\r\n\t\t//\t\tIndicates if the drawing should not be animated (vs. the default of doing an animation)\r\n\t\tvar i;\r\n\t\tif (this.shape){\r\n\t\t\tthis._move(dontAnimate);\r\n\t\t}else{\r\n\t\t\tif (this.shape){\r\n\t\t\t\tthis.shape.parent.remove(this.shape);\r\n\t\t\t\tthis.shape = null;\r\n\t\t\t}\r\n\t\t\tif (this.text){\r\n\t\t\t\tthis.text.parent.remove(this.text);\r\n\t\t\t\tthis.text = null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.color = this.color || '#000000';\r\n\t\t\tthis.length = this.length || this._gauge.dataHeight;\r\n\t\t\tthis.width = this.width || 3;\r\n\t\t\tthis.offset = this.offset || 0;\r\n\t\t\tthis.highlight = this.highlight || '#4D4D4D';\r\n\t\t\tthis.highlight2 = this.highlight2 || '#A3A3A3';\r\n\t\t\t\r\n\t\t\tvar shapes = this._getShapes(group, this._gauge, this);\r\n\t\t\t\r\n\t\t\tif (shapes.length > 1){\r\n\t\t\t\tthis.shape = group.createGroup();\r\n\t\t\t\tfor (var s = 0; s < shapes.length; s++){\r\n\t\t\t\t\tthis.shape.add(shapes[s]);\r\n\t\t\t\t}\r\n\t\t\t} else this.shape = shapes[0];\r\n\t\t\t\r\n\t\t\tif (this.label){\r\n\t\t\t\tvar v = this.value;\r\n\t\t\t\tif (v < this._gauge.min){\r\n\t\t\t\t\tv = this._gauge.min;\r\n\t\t\t\t}\r\n\t\t\t\tif (v > this._gauge.max){\r\n\t\t\t\t\tv = this._gauge.max;\r\n\t\t\t\t}\r\n\t\t\t\tvar pos = this._gauge._getPosition(v);\r\n\t\t\t\t\r\n\t\t\t\tif (this.direction == 'inside'){\r\n\t\t\t\t\tvar font = this.font ? this.font : gfx.defaultFont;\r\n\t\t\t\t\tvar fz = font.size;\r\n\t\t\t\t\tvar th = gfx.normalizedLength(fz);\r\n\t\t\t\t\t\r\n\t\t\t\t\tthis.text = this._gauge.drawText(group, '' + this.label, pos, this._gauge.dataY + this.offset + this.length + 5 + th, 'middle', this.color, this.font);\r\n\t\t\t\t} else this.text = this._gauge.drawText(group, '' + this.label, pos, this._gauge.dataY + this.offset - 5, 'middle', this.color, this.font);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.shape.connect(\"onmouseover\", this, this.handleMouseOver);\r\n\t\t\tthis.shape.connect(\"onmouseout\", this, this.handleMouseOut);\r\n\t\t\tthis.shape.connect(\"onmousedown\", this, this.handleMouseDown);\r\n\t\t\tthis.shape.connect(\"touchstart\", this, this.handleTouchStart);\r\n\t\t\tthis.currentValue = this.value;\r\n\t\t}\r\n\t},\r\n\t\r\n\t_move: function(/*Boolean?*/ dontAnimate){\r\n\t\t// summary:\r\n\t\t//\t\tMoves this indicator (since it's already been drawn once)\r\n\t\t// dontAnimate: Boolean\r\n\t\t//\t\tIndicates if the drawing should not be animated (vs. the default of doing an animation)\r\n\t\tvar v = this.value ;\r\n\t\tif(v < this._gauge.min){v = this._gauge.min;}\r\n\t\tif(v > this._gauge.max){v = this._gauge.max;}\r\n\t\tvar c = this._gauge._getPosition(this.currentValue);\r\n\t\tthis.currentValue = v;\r\n\t\tv = this._gauge._getPosition(v);\r\n \r\n\t\tif(dontAnimate || (c==v)){\r\n\t\t\tthis.shape.setTransform(gfx.matrix.translate(v,0));\r\n\t\t}else{\r\n\t\t\tvar anim = new fx.Animation({curve: [c, v], duration: this.duration, easing: this.easing});\r\n\t\t\tconnect.connect(anim, \"onAnimate\", lang.hitch(this, function(jump){\r\n\t\t\t\tif (this.shape)\r\n\t\t\t\t this.shape.setTransform(gfx.matrix.translate(jump,0));\r\n\t\t\t}));\r\n\t\t\tanim.play();\r\n\t\t}\r\n\t}\r\n});\r\n});"]}