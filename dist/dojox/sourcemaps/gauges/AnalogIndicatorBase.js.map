{"version":3,"sources":["gauges/AnalogIndicatorBase.js"],"names":["define","lang","declare","connect","fx","gfx","Indicator","draw","group","dontAnimate","this","shape","_move","text","parent","remove","a","_gauge","_getAngle","Math","min","max","value","color","length","radius","width","offset","highlight","shapes","_getShapes","createGroup","s","add","setTransform","dx","cx","dy","cy","matrix","rotateg","handleMouseOver","handleMouseOut","handleMouseDown","handleTouchStart","label","len","direction","rad","_getRadians","_layoutLabel","currentValue","txt","ox","oy","lrad","angle","labelPlacement","side","dif","font","defaultFont","tw","_base","_getTextBox","makeFontString","makeParameters","w","fz","size","th","normalizedLength","tfx","cos","tfy","sin","intersections","ipx","ipy","tan","push","x","y","it","ip","_distance","drawText","x1","y1","x2","y2","sqrt","v","c","anim","Animation","curve","duration","easing","hitch","step","play"],"mappings":"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","file":"../../gauges/AnalogIndicatorBase.js","sourcesContent":["define([\"dojo/_base/lang\",\"dojo/_base/declare\",\"dojo/_base/connect\",\"dojo/_base/fx\",\"dojox/gfx\",\"./_Indicator\"],\r\n  function(lang, declare, connect, fx, gfx, Indicator) {\r\n \r\nreturn declare(\"dojox.gauges.AnalogIndicatorBase\",[Indicator],{\r\n\t\t// summary:\r\n\t\t//\t\tAn abstract base class for indicators that can be used in an AnalogGauge.\r\n\t\t//\r\n\r\n\tdraw: function(/*dojox.gfx.Group*/ group, /*Boolean?*/ dontAnimate){\r\n\t\t// summary:\r\n\t\t//\t\tOverride of dojox.gauges._Indicator.draw\r\n\t\t// group: dojox.gfx.Group\r\n\t\t//\t\tThe GFX group when the indicator must be drawn\r\n\t\t// dontAnimate: Boolean\r\n\t\t//\t\tIndicates if the drawing should not be animated (vs. the default of doing an animation)\r\n\t\tif(this.shape){\r\n\t\t\tthis._move(dontAnimate);\r\n\t\t}else{\r\n\t\t\tif(this.text){\r\n\t\t\t\tthis.text.parent.remove(this.text);\r\n\t\t\t\tthis.text = null;\r\n\t\t\t}\r\n\t\t\tvar a = this._gauge._getAngle(Math.min(Math.max(this.value, this._gauge.min), this._gauge.max));\r\n\r\n\t\t\tthis.color = this.color || '#000000';\r\n\t\t\tthis.length = this.length || this._gauge.radius;\r\n\t\t\tthis.width = this.width || 1;\r\n\t\t\tthis.offset = this.offset || 0;\r\n\t\t\tthis.highlight = this.highlight || '#D0D0D0';\r\n\r\n\t\t\tvar shapes = this._getShapes(group, this._gauge, this);\r\n\r\n\t\t\tif (shapes){\r\n\t\t\t\tif (shapes.length > 1){\r\n\t\t\t\t\tthis.shape = group.createGroup();\r\n\t\t\t\t\tfor (var s = 0; s < shapes.length; s++){\r\n\t\t\t\t\t\tthis.shape.add(shapes[s]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse \r\n\t\t\t\t\tthis.shape = shapes[0];\r\n \r\n\t\t\t\tthis.shape.setTransform([{\r\n\t\t\t\t\tdx: this._gauge.cx,\r\n\t\t\t\t\tdy: this._gauge.cy\r\n\t\t\t\t}, gfx.matrix.rotateg(a)]);\r\n\r\n\t\t\t\tthis.shape.connect(\"onmouseover\", this, this.handleMouseOver);\r\n\t\t\t\tthis.shape.connect(\"onmouseout\", this, this.handleMouseOut);\r\n\t\t\t\tthis.shape.connect(\"onmousedown\", this, this.handleMouseDown);\r\n\t\t\t\tthis.shape.connect(\"touchstart\", this, this.handleTouchStart);\r\n}\r\n\t\t\tif(this.label){\r\n\t\t\t\tvar direction = this.direction;\r\n\t\t\t\tif (!direction) direction = 'outside';\r\n\t\t\r\n\t\t\t\tvar len;\r\n\t\t\t\tif (direction == 'inside') \r\n\t\t\t\t\tlen=-this.length+this.offset - 5;\r\n\t\t\t\telse\r\n\t\t\t\t\tlen=this.length+this.offset + 5;\r\n\t\t\t\t\r\n\t\t\t\tvar rad=this._gauge._getRadians(90-a);\r\n\t\t\t\tthis._layoutLabel(group, this.label+'', this._gauge.cx, this._gauge.cy,len ,rad , direction);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tthis.currentValue = this.value;\r\n\t\t}\r\n\t},\r\n\t\r\n\t_layoutLabel:function(group, txt, ox, oy, lrad, angle, labelPlacement){\r\n\t\t// summary:\r\n\t\t//\t\tPlaces the label on the side of the tick.\r\n\t\r\n\t\tvar font = this.font ? this.font : gfx.defaultFont;\r\n\r\n\t\tvar box =  gfx._base._getTextBox(txt,\r\n\t\t{\r\n\t\t\tfont: gfx.makeFontString(gfx.makeParameters(gfx.defaultFont,font))\r\n\t\t});\r\n\t\r\n\t\tvar tw = box.w;\r\n\t\tvar fz = font.size;\r\n\t\tvar th = gfx.normalizedLength(fz);\r\n\t\r\n\t\tvar tfx = ox + Math.cos(angle) * lrad - tw / 2;\r\n\t\tvar tfy = oy - Math.sin(angle) * lrad - th / 2;\r\n\t\tvar side;\r\n\r\n\t\tvar intersections = [];\r\n\r\n\t\t// Intersection with top segment\r\n\t\tside = tfx;\r\n\t\tvar ipx = side;\r\n\t\tvar ipy = -Math.tan(angle) * side + oy + Math.tan(angle) * ox;\r\n\t\t// Verify if intersection is on segment\r\n\t\tif (ipy >= tfy && ipy <= tfy + th) \r\n\t\t\tintersections.push({\r\n\t\t\t\tx: ipx,\r\n\t\t\t\ty: ipy\r\n\t\t\t});\r\n\r\n\t\t\t// Intersection with bottom segment\r\n\t\t\tside = tfx + tw;\r\n\t\t\tipx = side;\r\n\t\t\tipy = -Math.tan(angle) * side + oy + Math.tan(angle) * ox;\r\n\t\t\t// Verify if intersection is on segment\r\n\t\t\tif (ipy >= tfy && ipy <= tfy + th) intersections.push({\r\n\t\t\t\tx: ipx,\r\n\t\t\t\ty: ipy\r\n\t\t\t});\r\n\r\n\t\t// Intersection with left segment\r\n\t\tside = tfy;\r\n\t\tipx = -1 / Math.tan(angle) * side + ox + 1 / Math.tan(angle) * oy;\r\n\t\tipy = side;\r\n\t\t// Verify if intersection is on segment\r\n\t\tif (ipx >= tfx && ipx <= tfx + tw) \r\n\t\t\tintersections.push({\r\n\t\t\t\tx: ipx,\r\n\t\t\t\ty: ipy\r\n\t\t\t});\r\n\r\n\t\t// Intersection with right segment\r\n\t\tside = tfy + th;\r\n\t\tipx = -1 / Math.tan(angle) * side + ox + 1 / Math.tan(angle) * oy;\r\n\t\tipy = side;\r\n\t\t// Verify if intersection is on segment\r\n\t\tif (ipx >= tfx && ipx <= tfx + tw) \r\n\t\t\tintersections.push({\r\n\t\t\t\tx: ipx,\r\n\t\t\t\ty: ipy\r\n\t\t\t});\r\n\r\n\t\tvar dif;\r\n\t\tif (labelPlacement == \"inside\"){\r\n\t\t\tfor (var it = 0; it < intersections.length; it++){\r\n\t\t\t\tvar ip = intersections[it];\r\n\t\t\t\tdif = this._distance(ip.x, ip.y, ox, oy) - lrad;\r\n\t\t\t\tif (dif >= 0){\r\n\t\t\t\t\t// Place reference intersection point on reference circle\r\n\t\t\t\t\ttfx = ox + Math.cos(angle) * (lrad - dif) - tw / 2;\r\n\t\t\t\t\ttfy = oy - Math.sin(angle) * (lrad - dif) - th / 2;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse // \"outside\" placement\r\n\t\t{\r\n\t\t\tfor (it = 0; it < intersections.length; it++){\r\n\t\t\t\tip = intersections[it];\r\n\t\t\t\tdif = this._distance(ip.x, ip.y, ox, oy) - lrad;\r\n\t\t\t\tif (dif <= 0){\r\n\t\t\t\t\t// Place reference intersection point on reference circle\r\n\t\t\t\t\ttfx = ox + Math.cos(angle) * (lrad - dif) - tw / 2;\r\n\t\t\t\t\ttfy = oy - Math.sin(angle) * (lrad - dif) - th / 2;\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// since the size computed by getTextBox is too big,\r\n\t\t// to lower the problem, we align this to the middle and\r\n\t\t// place at the middle of the computed size.\r\n\t\tthis.text = this._gauge.drawText(group, txt, tfx + tw / 2, tfy + th, 'middle', this.color, this.font);\r\n\t},\r\n\t\r\n\t_distance: function(x1,y1,x2,y2){\r\n\t\treturn Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\r\n\t},\r\n\t\r\n\t_move: function(/*Boolean?*/ dontAnimate){\r\n\t\t// summary:\r\n\t\t// dontAnimate: Boolean\r\n\t\t//\t\tIndicates if the drawing should not be animated (vs. the default of doing an animation)\r\n\t\tvar v = Math.min(Math.max(this.value, this._gauge.min), this._gauge.max),\r\n\t\t\tc = this.currentValue\r\n\t\t;\r\n\t\tif(dontAnimate){\r\n\t\t\tvar angle = this._gauge._getAngle(v);\r\n\t\t\tthis.shape.setTransform([{dx:this._gauge.cx,dy:this._gauge.cy}, gfx.matrix.rotateg(angle)]);\r\n\t\t\tthis.currentValue = v;\r\n\t\t}else{\r\n\t\t\tif(c!=v){\r\n\t\t\t\tvar anim = new fx.Animation({curve: [c, v], duration: this.duration, easing: this.easing});\r\n\t\t\t\tconnect.connect(anim, \"onAnimate\", lang.hitch(this, function(step){\r\n\t\t\t\tthis.shape.setTransform([{dx:this._gauge.cx,dy:this._gauge.cy}, gfx.matrix.rotateg(this._gauge._getAngle(step))]);\r\n\t\t\t\t\t\r\n\t\t\t\tthis.currentValue = step;\r\n\t\t\t\t}));\r\n\t\t\t\tanim.play();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n});"]}