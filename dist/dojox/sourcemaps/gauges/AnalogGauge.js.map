{"version":3,"sources":["gauges/AnalogGauge.js"],"names":["define","dojo","declare","arr","lang","html","event","gfx","Gauge","AnalogLineIndicator","domGeometry","startAngle","endAngle","cx","cy","radius","orientation","_defaultIndicator","startup","this","getChildren","forEach","child","Number","width","height","Math","min","inherited","arguments","_getAngle","value","angle","v","isNaN","_mod360","max","relativeValue","_getAngleRange","abs","_getValueForAngle","_angleInRange","range","relativeAngle","min1","min2","max1","max2","_isScaleCircular","_getRadians","PI","_getDegrees","radians","drawRange","group","path","a1","a2","shape","parent","remove","low","high","createCircle","r","a","x1","sin","y1","cos","x2","y2","big","createPath","size","moveTo","lineTo","arcTo","closePath","isArray","color","isString","setStroke","setFill","type","colors","svg","getEventSource","setAttribute","style","connect","hitch","_handleMouseOverRange","_handleMouseOutRange","getRangeUnderMouse","e","pos","getContentBox","gaugeContent","x","clientX","y","clientY","sqrt","atan2","_rangeData","i","length","_dragIndicator","widget","_dragIndicatorAt","pageX","pageY","stop","position","xf","yf","_drag","currentValue","onDragMove","draw","_indicatorsGroup","valueChanged"],"mappings":";;;;;;;AAAAA,QAAQ,oBAAoB,qBAAqB,mBAAmB,kBAAkB,kBAAkB,mBACtG,YAAa,WAAW,wBAAyB,qBAClD,SAASC,EAAMC,EAASC,EAAKC,EAAMC,EAAMC,EACvCC,EAAKC,EAAOC,EAAqBC,GAEpC,OAAOR,EAAQ,2BAA2BM,GA8BzCG,YAAa,GAIbC,SAAU,GAIVC,GAAI,EAIJC,GAAI,EAIJC,OAAQ,EAIRC,YAAa,YAIbC,kBAAmBR,EAEnBS,QAAS,WAMLC,KAAKC,aACPjB,EAAIkB,QAAQF,KAAKC,cAAe,SAASE,GAAQA,EAAMJ,YAGxDC,KAAKR,WAAaY,OAAOJ,KAAKR,YAC9BQ,KAAKP,SAAWW,OAAOJ,KAAKP,UAE5BO,KAAKN,GAAKU,OAAOJ,KAAKN,IAClBM,KAAKN,KAAIM,KAAKN,GAAKM,KAAKK,MAAM,GAClCL,KAAKL,GAAKS,OAAOJ,KAAKL,IAClBK,KAAKL,KAAIK,KAAKL,GAAKK,KAAKM,OAAO,GACnCN,KAAKJ,OAASQ,OAAOJ,KAAKJ,QACtBI,KAAKJ,SAAQI,KAAKJ,OAASW,KAAKC,IAAIR,KAAKN,GAAGM,KAAKL,IAAM,IAG3DK,KAAKS,UAAUC,YAGhBC,UAAW,SAAmBC,GAO7B,IACIC,EADAC,EAAIV,OAAOQ,GAEf,GAAa,MAATA,GAAiBG,MAAMD,IAAMA,GAAKd,KAAKQ,IAC1CK,EAAQb,KAAKgB,QAAQhB,KAAKR,iBAE1B,GAAIsB,GAAKd,KAAKiB,IACbJ,EAAQb,KAAKgB,QAAQhB,KAAKP,cACtB,CACJ,IAAID,EAAaQ,KAAKgB,QAAQhB,KAAKR,YAC/B0B,EAAiBJ,EAAId,KAAKQ,IACN,aAApBR,KAAKH,cACRqB,GAAiBA,GAElBL,EAAQb,KAAKgB,QAAQxB,EAAaQ,KAAKmB,iBAAmBD,EAAgBX,KAAKa,IAAIpB,KAAKQ,IAAMR,KAAKiB,MAGrG,OAAOJ,GAGRQ,kBAAmB,SAAmBR,GAMrC,IAAIrB,EAAaQ,KAAKgB,QAAQhB,KAAKR,YAC/BC,EAAWO,KAAKgB,QAAQhB,KAAKP,UAEjC,GAAKO,KAAKsB,cAAcT,GAWnB,CACJ,IAAIU,EAAQhB,KAAKa,IAAIpB,KAAKiB,IAAMjB,KAAKQ,KACjCgB,EAAgBxB,KAAKgB,QAA4B,aAApBhB,KAAKH,YACpCgB,EAAQrB,GAAeqB,EAAQrB,GACjC,OAAOQ,KAAKQ,IAAMe,EAAQC,EAAgBxB,KAAKmB,iBAb/C,IAAIM,EAAOzB,KAAKgB,QAAQxB,EAAaqB,GACjCa,EAAO,IAAMD,EACbE,EAAO3B,KAAKgB,QAAQvB,EAAWoB,GAC/Be,EAAO,IAAMD,EACjB,OAAIpB,KAAKC,IAAIiB,EAAMC,GAAQnB,KAAKC,IAAImB,EAAMC,GAClC5B,KAAKQ,IAELR,KAAKiB,KAUfE,eAAgB,WAIf,IACI3B,EAAaQ,KAAKgB,QAAQhB,KAAKR,YAC/BC,EAAWO,KAAKgB,QAAQhB,KAAKP,UACjC,OAAID,GAAcC,EACV,IACgB,aAApBO,KAAKH,YACJJ,EAAWD,EACN,KAAOA,EAAaC,GAEpBA,EAAWD,EAGhBC,EAAWD,EACNA,EAAaC,EAEb,KAAOA,EAAWD,IAK7B8B,cAAe,SAASV,GAGvB,IAAIpB,EAAaQ,KAAKgB,QAAQhB,KAAKR,YAC/BC,EAAWO,KAAKgB,QAAQhB,KAAKP,UACjC,OAAID,GAAcC,IAEjBmB,EAAQZ,KAAKgB,QAAQJ,GACE,aAApBZ,KAAKH,YACJL,EAAaC,EACTmB,GAASpB,GAAcoB,GAASnB,IAE9BmB,EAAQnB,GAAYmB,EAAQpB,GAGlCA,EAAaC,IACPmB,EAAQpB,GAAcoB,EAAQnB,GAEhCmB,GAASnB,GAAYmB,GAASpB,IAIxCqC,iBAAkB,WAGjB,OAAQ7B,KAAKgB,QAAQhB,KAAKR,aAAeQ,KAAKgB,QAAQhB,KAAKP,WAG5DuB,QAAQ,SAASF,GAGhB,KAAOA,EAAE,KAAKA,GAAQ,IACtB,KAAOA,EAAE,GAAGA,GAAQ,IACpB,OAAOA,GAGRgB,YAAa,SAAmBjB,GAK/B,OAAOA,EAAMN,KAAKwB,GAAG,KAGtBC,YAAa,SAAmBC,GAK/B,OAAe,IAARA,EAAY1B,KAAKwB,IAIzBG,UAAW,SAA6BC,EAAiBZ,GAWxD,IAAIa,EAKAC,EAAIC,EACR,GALGf,EAAMgB,QACRhB,EAAMgB,MAAMC,OAAOC,OAAOlB,EAAMgB,OAChChB,EAAMgB,MAAQ,MAGXhB,EAAMmB,KAAO1C,KAAKQ,KAASe,EAAMoB,MAAQ3C,KAAKiB,KAAUjB,KAAKgB,QAAQhB,KAAKP,WAAaO,KAAKgB,QAAQhB,KAAKR,YAC5G4C,EAAOD,EAAMS,cAAclD,GAAIM,KAAKN,GAAIC,GAAIK,KAAKL,GAAIkD,EAAG7C,KAAKJ,aACzD,CAKJ,GAFAyC,EAAKrC,KAAK8B,YAAY9B,KAAKW,UAAUY,EAAMmB,MAC3CJ,EAAKtC,KAAK8B,YAAY9B,KAAKW,UAAUY,EAAMoB,OACnB,cAApB3C,KAAKH,YACT,CACC,IAAIiD,EAAIR,EACRA,EAAKD,EACLA,EAAKS,EAGN,IAAIC,EAAG/C,KAAKN,GAAGM,KAAKJ,OAAOW,KAAKyC,IAAIX,GACnCY,EAAGjD,KAAKL,GAAGK,KAAKJ,OAAOW,KAAK2C,IAAIb,GAChCc,EAAGnD,KAAKN,GAAGM,KAAKJ,OAAOW,KAAKyC,IAAIV,GAChCc,EAAGpD,KAAKL,GAAGK,KAAKJ,OAAOW,KAAK2C,IAAIZ,GAChCe,EAAI,GAIDhB,GAAIC,EACIA,EAAGD,EAEH,EAAE9B,KAAKwB,GAAGM,EAAGC,GACf/B,KAAKwB,KAAIsB,EAAI,GAEvBjB,EAAOD,EAAMmB,aACV/B,EAAMgC,KACRnB,EAAKoB,OAAOxD,KAAKN,IAAIM,KAAKJ,OAAO2B,EAAMgC,MAAMhD,KAAKyC,IAAIX,GACnDrC,KAAKL,IAAIK,KAAKJ,OAAO2B,EAAMgC,MAAMhD,KAAK2C,IAAIb,IAE7CD,EAAKoB,OAAOxD,KAAKN,GAAGM,KAAKL,IAE1ByC,EAAKqB,OAAOV,EAAGE,GACfb,EAAKsB,MAAM1D,KAAKJ,OAAOI,KAAKJ,OAAO,EAAEyD,EAAI,EAAEF,EAAGC,GAC3C7B,EAAMgC,OACRnB,EAAKqB,OAAOzD,KAAKN,IAAIM,KAAKJ,OAAO2B,EAAMgC,MAAMhD,KAAKyC,IAAIV,GACnDtC,KAAKL,IAAIK,KAAKJ,OAAO2B,EAAMgC,MAAMhD,KAAK2C,IAAIZ,IAC7CF,EAAKsB,MAAO1D,KAAKJ,OAAO2B,EAAMgC,KAAOvD,KAAKJ,OAAO2B,EAAMgC,KAAM,EAAEF,EAAI,EAChErD,KAAKN,IAAIM,KAAKJ,OAAO2B,EAAMgC,MAAMhD,KAAKyC,IAAIX,GAC1CrC,KAAKL,IAAIK,KAAKJ,OAAO2B,EAAMgC,MAAMhD,KAAK2C,IAAIb,KAE9CD,EAAKuB,YAGH1E,EAAK2E,QAAQrC,EAAMsC,QAAU5E,EAAK6E,SAASvC,EAAMsC,QACnDzB,EAAK2B,WAAWF,MAAOtC,EAAMsC,QAC7BzB,EAAK4B,QAAQzC,EAAMsC,QACXtC,EAAMsC,MAAMI,MAEpB5B,EAAKrC,KAAK8B,YAAY9B,KAAKW,UAAUY,EAAMmB,MAC3CJ,EAAKtC,KAAK8B,YAAY9B,KAAKW,UAAUY,EAAMoB,OAC3CpB,EAAMsC,MAAMd,GAAK/C,KAAKN,GAAIM,KAAKJ,OAAOW,KAAKyC,IAAIX,GAAK,EACpDd,EAAMsC,MAAMV,GAAKnD,KAAKN,GAAIM,KAAKJ,OAAOW,KAAKyC,IAAIV,GAAK,EACpDf,EAAMsC,MAAMZ,GAAKjD,KAAKL,GAAIK,KAAKJ,OAAOW,KAAK2C,IAAIb,GAAK,EACpDd,EAAMsC,MAAMT,GAAKpD,KAAKL,GAAIK,KAAKJ,OAAOW,KAAK2C,IAAIZ,GAAK,EACpDF,EAAK4B,QAAQzC,EAAMsC,OACnBzB,EAAK2B,WAAWF,MAAOtC,EAAMsC,MAAMK,OAAO,GAAGL,SACpCzE,EAAI+E,MAEb/B,EAAK2B,WAAWF,MAAO,UACvBzB,EAAK4B,QAAQ,SACb5B,EAAKgC,iBAAiBC,aAAa,QAAS9C,EAAMsC,MAAMS,QAGzDlC,EAAKmC,QAAQ,cAAetF,EAAKuF,MAAMxE,KAAMA,KAAKyE,sBAAuBlD,IACzEa,EAAKmC,QAAQ,aAActF,EAAKuF,MAAMxE,KAAMA,KAAK0E,qBAAsBnD,IAEvEA,EAAMgB,MAAQH,GAGfuC,mBAAoB,SAAmBC,GAKtC,IAAIrD,EAAQ,KACXsD,EAAMtF,EAAYuF,cAAc9E,KAAK+E,cACrCC,EAAIJ,EAAEK,QAAUJ,EAAIG,EACpBE,EAAIN,EAAEO,QAAUN,EAAIK,EAGrB,GAFK3E,KAAK6E,MAAMF,EAAIlF,KAAKL,KAAKuF,EAAIlF,KAAKL,KAAOqF,EAAIhF,KAAKN,KAAKsF,EAAIhF,KAAKN,KAE9DM,KAAKJ,OAAO,CAClB,IAAIiB,EAAQb,KAAKgC,YAAYzB,KAAK8E,MAAMH,EAAIlF,KAAKL,GAAIqF,EAAIhF,KAAKN,IAAMa,KAAKwB,GAAG,GAE3EnB,EAAQZ,KAAKqB,kBAAkBR,GAEhC,GAAGb,KAAKsF,WACP,IAAI,IAAIC,EAAE,EAAIA,EAAEvF,KAAKsF,WAAWE,SAAYjE,EAAOgE,IAC9CnF,OAAOJ,KAAKsF,WAAWC,GAAG7C,MAAQ9B,GAAWR,OAAOJ,KAAKsF,WAAWC,GAAG5C,OAAS/B,IACnFW,EAAQvB,KAAKsF,WAAWC,IAK5B,OAAOhE,GAGRkE,eAAgB,SAAoBC,EAAmBd,GAItD5E,KAAK2F,iBAAiBD,EAAQd,EAAEgB,MAAOhB,EAAEiB,OACzC1G,EAAM2G,KAAKlB,IAGZe,iBAAkB,SAAoBD,EAAQV,EAAEE,GAI/C,IAAIL,EAAMtF,EAAYwG,SAASL,EAAOX,cAAc,GACnDiB,EAAKhB,EAAIH,EAAIG,EACbiB,EAAKf,EAAIL,EAAIK,EACbrE,EAAQ6E,EAAO1D,YAAYzB,KAAK8E,MAAMY,EAAKP,EAAO/F,GAAIqG,EAAKN,EAAOhG,IAAMa,KAAKwB,GAAG,GAG7EnB,EAAQ8E,EAAOrE,kBAAkBR,GACrCD,EAAQL,KAAKC,IAAID,KAAKU,IAAIL,EAAO8E,EAAOlF,KAAMkF,EAAOzE,KAErDyE,EAAOQ,MAAMtF,MAAQ8E,EAAOQ,MAAMC,aAAevF,EAEjD8E,EAAOQ,MAAME,WAAWV,EAAOQ,OAE/BR,EAAOQ,MAAMG,KAAKrG,KAAKsG,kBAAkB,GACzCZ,EAAOQ,MAAMK","file":"../../gauges/AnalogGauge.js","sourcesContent":["define([\"dojo/_base/kernel\",\"dojo/_base/declare\",\"dojo/_base/array\",\"dojo/_base/lang\",\"dojo/_base/html\",\"dojo/_base/event\",\r\n\t\t\"dojox/gfx\", \"./_Gauge\",\"./AnalogLineIndicator\", \"dojo/dom-geometry\"],\r\n\tfunction(dojo, declare, arr, lang, html, event, \r\n\t\t\tgfx, Gauge, AnalogLineIndicator, domGeometry) {\r\n\r\nreturn declare(\"dojox.gauges.AnalogGauge\",Gauge,{\r\n\t// summary:\r\n\t//\t\ta gauge built using the dojox.gfx package.\r\n\t//\r\n\t// description:\r\n\t//\t\tusing dojo.gfx (and thus either SVG or VML based on what is supported), this widget\r\n\t//\t\tbuilds a gauge component, used to display numerical data in a familiar format \r\n\t//\r\n\t// example:\r\n\t//\t|\t<script type=\"text/javascript\">\r\n\t//\t|\t\trequire([\"dojox/gauges/AnalogGauge\"]);\r\n\t//\t|\t</script>\r\n\t//\t|\r\n\t//\t|\t<div\tdojoType=\"dojox.gauges.AnalogGauge\"\r\n\t//\t|\t\t\tid=\"testGauge\"\r\n\t//\t|\t\t\twidth=\"300\"\r\n\t//\t|\t\t\theight=\"200\"\r\n\t//\t|\t\t\tcx=150\r\n\t//\t|\t\t\tcy=175\r\n\t//\t|\t\t\tradius=125\r\n\t//\t|\t\t\timage=\"gaugeOverlay.png\"\r\n\t//\t|\t\t\timageOverlay=\"false\"\r\n\t//\t|\t\t\timageWidth=\"280\"\r\n\t//\t|\t\t\timageHeight=\"155\"\r\n\t//\t|\t\t\timageX=\"12\"\r\n\t//\t|\t\t\timageY=\"38\">\r\n\t//\t|\t</div>\r\n\r\n\t// startAngle: Number\r\n\t//\t\tangle (in degrees) for start of gauge (default is -90)\r\n\tstartAngle: -90,\r\n\r\n\t// endAngle: Number\r\n\t//\t\tangle (in degrees) for end of gauge (default is 90)\r\n\tendAngle: 90,\r\n\r\n\t// cx: Number\r\n\t//\t\tcenter of gauge x coordinate (default is gauge width / 2)\r\n\tcx: 0,\r\n\r\n\t// cy: Number\r\n\t//\t\tcenter of gauge x coordinate (default is gauge height / 2)\r\n\tcy: 0,\r\n\r\n\t// radius: Number\r\n\t//\t\tradius of gauge (default is smaller of cx-25 or cy-25)\r\n\tradius: 0,\r\n\t\r\n\t// orientation: String\r\n\t//\t\tThe orientation of the gauge. The value can be 'clockwise' or 'cclockwise' (default is 'clockwise')\r\n\torientation: \"clockwise\",\r\n\r\n\t// _defaultIndicator: dojox.gauges._Indicator\r\n\t//\t\toverride of dojox.gauges._Gauge._defaultIndicator\r\n\t_defaultIndicator: AnalogLineIndicator,\r\n\r\n\tstartup: function(){\r\n\t\t// handle settings from HTML by making sure all the options are\r\n\t\t// converted correctly to numbers and that we calculate defaults\r\n\t\t// for cx, cy and radius\r\n\t\t// also connects mouse handling events\r\n\r\n\t\tif(this.getChildren){\r\n\t\t\tarr.forEach(this.getChildren(), function(child){ child.startup(); });\r\n\t\t}\r\n\r\n\t\tthis.startAngle = Number(this.startAngle);\r\n\t\tthis.endAngle = Number(this.endAngle);\r\n\r\n\t\tthis.cx = Number(this.cx);\r\n\t\tif(!this.cx){this.cx = this.width/2;}\r\n\t\tthis.cy = Number(this.cy);\r\n\t\tif(!this.cy){this.cy = this.height/2;}\r\n\t\tthis.radius = Number(this.radius);\r\n\t\tif(!this.radius){this.radius = Math.min(this.cx,this.cy) - 25;}\r\n\t\r\n\r\n\t\tthis.inherited(arguments);\r\n\t},\r\n\r\n\t_getAngle: function(/*Number*/value){\r\n\t\t// summary:\r\n\t\t//\t\tThis is a helper function used to determine the angle that represents\r\n\t\t//\t\ta given value on the gauge\r\n\t\t// value:\tNumber\r\n\t\t//\t\tA value to be converted to an angle for this gauge.\r\n\t\t\r\n\t\tvar v = Number(value);\r\n\t\tvar angle;\r\n\t\tif (value == null || isNaN(v) || v <= this.min) \r\n\t\t\tangle = this._mod360(this.startAngle);\r\n\t\telse\r\n\t\t\tif (v >= this.max) \r\n\t\t\t\tangle = this._mod360(this.endAngle);\r\n\t\t\telse {\r\n\t\t\t\tvar startAngle = this._mod360(this.startAngle);\r\n\t\t\t\tvar relativeValue = (v - this.min);\r\n\t\t\t\tif (this.orientation != 'clockwise') \r\n\t\t\t\t\trelativeValue = -relativeValue;\r\n\r\n\t\t\t\tangle = this._mod360(startAngle + this._getAngleRange() * relativeValue / Math.abs(this.min - this.max));\r\n\t\t\t}\r\n\r\n\t\treturn angle;\r\n\t},\r\n\r\n\t_getValueForAngle: function(/*Number*/angle){\r\n\t\t// summary:\r\n\t\t//\t\tThis is a helper function used to determine the value represented by a\r\n\t\t//\t\tgiven angle on the gauge\r\n\t\t// angle:\tNumber\r\n\t\t//\t\tA angle to be converted to a value for this gauge.\r\n\t\tvar startAngle = this._mod360(this.startAngle);\r\n\t\tvar endAngle = this._mod360(this.endAngle);\r\n\r\n\t\tif (!this._angleInRange(angle)){\r\n\r\n\t\t\tvar min1 = this._mod360(startAngle - angle);\r\n\t\t\tvar min2 = 360 - min1;\r\n\t\t\tvar max1 = this._mod360(endAngle - angle);\r\n\t\t\tvar max2 = 360 - max1;\r\n\t\t\tif (Math.min(min1, min2) < Math.min(max1, max2)) \r\n\t\t\t\treturn this.min;\r\n\t\t\telse \r\n\t\t\t\treturn this.max;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvar range = Math.abs(this.max - this.min);\r\n\t\t\tvar relativeAngle = this._mod360(this.orientation == 'clockwise' ?\r\n\t\t\t\t(angle - startAngle): (-angle + startAngle));\r\n\t\t\treturn this.min + range * relativeAngle / this._getAngleRange();\r\n\t\t}\r\n\t},\r\n\r\n\t_getAngleRange: function(){\r\n\t\t// summary:\r\n\t\t//\t\tThis is a helper function that returns the angle range\r\n\t\t//\t\tfrom startAngle to endAngle according to orientation.\r\n\t\tvar range;\r\n\t\tvar startAngle = this._mod360(this.startAngle);\r\n\t\tvar endAngle = this._mod360(this.endAngle);\r\n\t\tif (startAngle == endAngle) \r\n\t\t\treturn 360;\r\n\t\tif (this.orientation == 'clockwise'){\r\n\t\t\tif (endAngle < startAngle) \r\n\t\t\t\trange = 360 - (startAngle - endAngle);\r\n\t\t\telse \r\n\t\t\t\trange = endAngle - startAngle;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (endAngle < startAngle) \r\n\t\t\t\trange = startAngle - endAngle;\r\n\t\t\telse \r\n\t\t\t\trange = 360 - (endAngle - startAngle); \r\n\t\t}\r\n\t\treturn range;\r\n\t},\r\n\t\r\n\t_angleInRange: function(value){\r\n\t\t// summary:\r\n\t\t//\t\tTest if the angle value is in the startAngle/endAngle range\r\n\t\tvar startAngle = this._mod360(this.startAngle);\r\n\t\tvar endAngle = this._mod360(this.endAngle);\r\n\t\tif (startAngle == endAngle) \r\n\t\t\treturn true;\r\n\t\t\tvalue = this._mod360(value);\r\n\t\tif (this.orientation == \"clockwise\"){\r\n\t\t\tif (startAngle < endAngle) \r\n\t\t\t\treturn value >= startAngle && value <= endAngle;\r\n\t\t\telse \r\n\t\t\t\treturn !(value > endAngle && value < startAngle);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (startAngle < endAngle) \r\n\t\t\t\treturn !(value > startAngle && value < endAngle);\r\n\t\t\telse \r\n\t\t\t\treturn value >= endAngle && value <= startAngle;\r\n\t\t}\r\n\t},\r\n\t\r\n\t_isScaleCircular: function(){\r\n\t\t// summary:\r\n\t\t//\t\tinternal method to check if the scale is fully circular\r\n\t\treturn (this._mod360(this.startAngle) == this._mod360(this.endAngle));\r\n\t},\r\n\t\r\n\t_mod360:function(v){\r\n\t\t// summary:\r\n\t\t//\t\treturns the angle between 0 and 360;\r\n\t\twhile (v>360) v = v - 360;\r\n\t\twhile (v<0) v = v + 360;\r\n\t\treturn v;\r\n\t},\r\n\r\n\t_getRadians: function(/*Number*/angle){\r\n\t\t// summary:\r\n\t\t//\t\tThis is a helper function than converts degrees to radians\r\n\t\t// angle:\tNumber\r\n\t\t//\t\tAn angle, in degrees, to be converted to radians.\r\n\t\treturn angle*Math.PI/180;\r\n\t},\r\n\r\n\t_getDegrees: function(/*Number*/radians){\r\n\t\t// summary:\r\n\t\t//\t\tThis is a helper function that converts radians to degrees\r\n\t\t// radians:\tNumber\r\n\t\t//\t\tAn angle, in radians, to be converted to degrees.\r\n\t\treturn radians*180/Math.PI;\r\n\t},\r\n\r\n\r\n\tdrawRange: function(/*dojox.gfx.Group*/ group, /*Object*/range){\r\n\t\t// summary:\r\n\t\t//\t\tThis function is used to draw (or redraw) a range\r\n\t\t// description:\r\n\t\t//\t\tDraws a range (colored area on the background of the gauge) \r\n\t\t//\t\tbased on the given arguments.\r\n\t\t// group:\r\n\t\t//\t\tThe GFX group where the range must be drawn.\r\n\t\t// range:\r\n\t\t//\t\tA range is a dojox.gauges.Range or an object\r\n\t\t//\t\twith similar parameters (low, high, hover, etc.).\r\n\t\tvar path;\r\n\t\tif(range.shape){\r\n\t\t\trange.shape.parent.remove(range.shape);\r\n\t\t\trange.shape = null;\r\n\t\t}\r\n\t\tvar a1, a2;\r\n\t\tif((range.low == this.min) && (range.high == this.max) && ((this._mod360(this.endAngle) == this._mod360(this.startAngle)))){\r\n\t\t\tpath = group.createCircle({cx: this.cx, cy: this.cy, r: this.radius});\r\n\t\t}else{\r\n\t\t\t\r\n\t\t\t\r\n\t\t\ta1 = this._getRadians(this._getAngle(range.low));\r\n\t\t\ta2 = this._getRadians(this._getAngle(range.high));\r\n\t\t\tif (this.orientation == 'cclockwise')\r\n\t\t\t{\r\n\t\t\t\tvar a = a2;\r\n\t\t\t\ta2 = a1;\r\n\t\t\t\ta1 = a;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar x1=this.cx+this.radius*Math.sin(a1),\r\n\t\t\t\ty1=this.cy-this.radius*Math.cos(a1),\r\n\t\t\t\tx2=this.cx+this.radius*Math.sin(a2),\r\n\t\t\t\ty2=this.cy-this.radius*Math.cos(a2),\r\n\t\t\t\tbig=0\r\n\t\t\t;\r\n\t\t\t\r\n\t\t\tvar arange;\r\n\t\t\tif (a1<=a2)\r\n\t\t\t   arange = a2-a1;\r\n\t\t\telse\r\n\t\t\t   arange = 2*Math.PI-a1+a2;\r\n\t\t\tif(arange>Math.PI){big=1;}\r\n\t\t\t\r\n\t\t\tpath = group.createPath();\r\n\t\t\tif(range.size){\r\n\t\t\t\tpath.moveTo(this.cx+(this.radius-range.size)*Math.sin(a1),\r\n\t\t\t\t\t\t\tthis.cy-(this.radius-range.size)*Math.cos(a1));\r\n\t\t\t}else{\r\n\t\t\t\tpath.moveTo(this.cx,this.cy);\r\n\t\t\t}\r\n\t\t\tpath.lineTo(x1,y1);\r\n\t\t\tpath.arcTo(this.radius,this.radius,0,big,1,x2,y2);\r\n\t\t\tif(range.size){\r\n\t\t\t\tpath.lineTo(this.cx+(this.radius-range.size)*Math.sin(a2),\r\n\t\t\t\t\t\t\tthis.cy-(this.radius-range.size)*Math.cos(a2));\r\n\t\t\t\tpath.arcTo((this.radius-range.size),(this.radius-range.size),0,big,0,\r\n\t\t\t\t\t\t\tthis.cx+(this.radius-range.size)*Math.sin(a1),\r\n\t\t\t\t\t\t\tthis.cy-(this.radius-range.size)*Math.cos(a1));\r\n\t\t\t}\r\n\t\t\tpath.closePath();\r\n\t\t}\r\n\r\n\t\tif(lang.isArray(range.color) || lang.isString(range.color)){\r\n\t\t\tpath.setStroke({color: range.color});\r\n\t\t\tpath.setFill(range.color);\r\n\t\t}else if(range.color.type){\r\n\t\t\t// Color is a gradient\r\n\t\t\ta1 = this._getRadians(this._getAngle(range.low));\r\n\t\t\ta2 = this._getRadians(this._getAngle(range.high));\r\n\t\t\trange.color.x1 = this.cx+(this.radius*Math.sin(a1))/2;\r\n\t\t\trange.color.x2 = this.cx+(this.radius*Math.sin(a2))/2;\r\n\t\t\trange.color.y1 = this.cy-(this.radius*Math.cos(a1))/2;\r\n\t\t\trange.color.y2 = this.cy-(this.radius*Math.cos(a2))/2;\r\n\t\t\tpath.setFill(range.color);\r\n\t\t\tpath.setStroke({color: range.color.colors[0].color});\r\n\t\t}else if (gfx.svg){\r\n\t\t\t// We've defined a style rather than an explicit color\r\n\t\t\tpath.setStroke({color: \"green\"});\t// Arbitrary color, just have to indicate\r\n\t\t\tpath.setFill(\"green\");\t\t\t\t// that we want it filled\r\n\t\t\tpath.getEventSource().setAttribute(\"class\", range.color.style);\r\n\t\t}\r\n\t\t\r\n\t\tpath.connect(\"onmouseover\", lang.hitch(this, this._handleMouseOverRange, range));\r\n\t\tpath.connect(\"onmouseout\", lang.hitch(this, this._handleMouseOutRange, range));\r\n\t\r\n\t\trange.shape = path;\r\n\t},\r\n\r\n\tgetRangeUnderMouse: function(/*Object*/e){\r\n\t\t// summary:\r\n\t\t//\t\tDetermines which range the mouse is currently over\r\n\t\t// e:\tObject\r\n\t\t//\t\tThe event object as received by the mouse handling functions below.\r\n\t\tvar range = null,\r\n\t\t\tpos = domGeometry.getContentBox(this.gaugeContent),\r\n\t\t\tx = e.clientX - pos.x,\r\n\t\t\ty = e.clientY - pos.y,\r\n\t\t\tr = Math.sqrt((y - this.cy)*(y - this.cy) + (x - this.cx)*(x - this.cx))\r\n\t\t;\r\n\t\tif(r < this.radius){\r\n\t\t\tvar angle = this._getDegrees(Math.atan2(y - this.cy, x - this.cx) + Math.PI/2),\r\n\t\t\t//if(angle > this.endAngle){angle = angle - 360;}\r\n\t\t\t\tvalue = this._getValueForAngle(angle)\r\n\t\t\t;\r\n\t\t\tif(this._rangeData){\r\n\t\t\t\tfor(var i=0; (i<this._rangeData.length) && !range; i++){\r\n\t\t\t\t\tif((Number(this._rangeData[i].low) <= value) && (Number(this._rangeData[i].high) >= value)){\r\n\t\t\t\t\t\trange = this._rangeData[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn range;\r\n\t},\r\n\r\n\t_dragIndicator: function(/*Object*/ widget, /*Object*/ e){\r\n\t\t// summary:\r\n\t\t//\t\tHandles the dragging of an indicator to the event position, including moving/re-drawing\r\n\t\t//\t\tget angle for mouse position\r\n\t\tthis._dragIndicatorAt(widget, e.pageX, e.pageY);\r\n\t\tevent.stop(e);\r\n\t},\r\n\t\t\r\n\t_dragIndicatorAt: function(/*Object*/ widget, x,y){\r\n\t\t// summary:\r\n\t\t//\t\tHandles the dragging of an indicator to a specific position, including moving/re-drawing\r\n\t\t//\t\tget angle for mouse position\r\n\t\tvar pos = domGeometry.position(widget.gaugeContent, true),\r\n\t\t\txf = x - pos.x,\r\n\t\t\tyf = y - pos.y,\r\n\t\t\tangle = widget._getDegrees(Math.atan2(yf - widget.cy, xf - widget.cx) + Math.PI/2);\r\n\t\t\r\n\t\t// get value and restrict to our min/max\r\n\t\tvar value = widget._getValueForAngle(angle);\r\n\t\tvalue = Math.min(Math.max(value, widget.min), widget.max);\r\n\t\t// update the indicator\r\n\t\twidget._drag.value = widget._drag.currentValue = value;\r\n\t\t// callback\r\n\t\twidget._drag.onDragMove(widget._drag);\r\n\t\t// rotate indicator\r\n\t\twidget._drag.draw(this._indicatorsGroup, true);\r\n\t\twidget._drag.valueChanged();\r\n\t}\r\n\r\n});\r\n});\r\n"]}