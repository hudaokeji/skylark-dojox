{"version":3,"sources":["data/ServiceStore.js"],"names":["define","declare","lang","array","getObject","service","constructor","options","this","byId","fetchItemByIdentity","_index","mixin","idAttribute","schema","_idAttr","labelAttribute","syncMode","estimateCountFactor","getSchema","loadLazyValues","getValue","item","property","defaultValue","value","_loadObject","dojox","rpc","_sync","arguments","callee","call","data","ServiceStore","prototype","loadItem","getValues","val","Array","undefined","getAttributes","res","i","hasOwnProperty","charAt","push","hasAttribute","attribute","containsValue","indexOf","isItem","Date","isItemLoaded","args","result","func","Error","onError","onItem","scope","_currentId","_processResults","results","deferred","id","__id","existingObj","j","items","count","length","totalCount","request","start","close","abort","fetch","self","defResult","cachingFetch","_doQuery","addCallback","clientFetch","clientSideFetch","query","sort","resultSet","onBegin","onComplete","addErrback","err","cancel","store","queryStr","getFeatures","dojo.data.api.Read","dojo.data.api.Identity","dojo.data.api.Schema","getLabel","getLabelAttributes","getIdentity","getIdentityAttributes","_prefix","identity"],"mappings":"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","file":"../../data/ServiceStore.js","sourcesContent":["define([\"dojo/_base/declare\", \"dojo/_base/lang\", \"dojo/_base/array\"], function(declare, lang, array) {\r\nreturn declare(\"dojox.data.ServiceStore\",\r\n\t// ClientFilter is intentionally not required, ServiceStore does not need it, and is more\r\n\t// lightweight without it, but if it is provided, the ServiceStore will use it.\r\n\tlang.getObject(\"dojox.data.ClientFilter\", 0)||null,{\r\n\t\t// summary:\r\n\t\t//\t\tnote that dojox.rpc.Service is not required, you can create your own services\r\n\t\t//\t\tA ServiceStore is a readonly data store that provides a data.data interface to an RPC service.\r\n\t\t//\t\t|\t\tvar myServices = new dojox.rpc.Service(dojo.moduleUrl(\"dojox.rpc.tests.resources\", \"test.smd\"));\r\n\t\t//\t\t|\t\tvar serviceStore = new dojox.data.ServiceStore({service:myServices.ServiceStore});\r\n\t\t//\r\n\t\t//\t\tThe ServiceStore also supports lazy loading. References can be made to objects that have not been loaded.\r\n\t\t//\t\tFor example if a service returned:\r\n\t\t//\t\t|\t\t{\"name\":\"Example\",\"lazyLoadedObject\":{\"$ref\":\"obj2\"}}\r\n\t\t//\r\n\t\t//\t\tAnd this object has accessed using the dojo.data API:\r\n\t\t//\t\t|\t\tvar obj = serviceStore.getValue(myObject,\"lazyLoadedObject\");\r\n\t\t//\t\tThe object would automatically be requested from the server (with an object id of \"obj2\").\r\n\t\r\n\t\r\n\t\t// service: Object\r\n\t\t//\tThis is the service object that is used to retrieve lazy data and save results\r\n\t\t//\tThe function should be directly callable with a single parameter of an object id to be loaded\r\n\t\tservice: null,\r\n\t\t\r\n\t\tconstructor: function(options){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tServiceStore constructor, instantiate a new ServiceStore\r\n\t\t\t//\t\tA ServiceStore can be configured from a JSON Schema. Queries are just\r\n\t\t\t//\t\tpassed through to the underlying services\r\n\t\t\t// options:\r\n\t\t\t//\t\tKeyword arguments\r\n\t\t\t//\r\n\t\t\t//\t\t####The *schema* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tThis is a schema object for this store. This should be JSON Schema format.\r\n\t\t\t//\r\n\t\t\t//\t\t####The *service* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tThis is the service object that is used to retrieve lazy data and save results\r\n\t\t\t//\t\tThe function should be directly callable with a single parameter of an object id to be loaded\r\n\t\t\t//\r\n\t\t\t//\t\t####The *idAttribute* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tDefaults to 'id'. The name of the attribute that holds an objects id.\r\n\t\t\t//\t\tThis can be a preexisting id provided by the server.\r\n\t\t\t//\t\tIf an ID isn't already provided when an object\r\n\t\t\t//\t\tis fetched or added to the store, the autoIdentity system\r\n\t\t\t//\t\twill generate an id for it and add it to the index.\r\n\t\t\t//\r\n\t\t\t//\t\t####The *estimateCountFactor* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tThis parameter is used by the ServiceStore to estimate the total count. When\r\n\t\t\t//\t\tpaging is indicated in a fetch and the response includes the full number of items\r\n\t\t\t//\t\trequested by the fetch's count parameter, then the total count will be estimated\r\n\t\t\t//\t\tto be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server\r\n\t\t\t//\t\tdoes not support paging, and the response is the full set of items, where the\r\n\t\t\t//\t\ttotal count is equal to the number of items returned. If the server does support\r\n\t\t\t//\t\tpaging, an estimateCountFactor of 2 is a good value for estimating the total count\r\n\t\t\t//\t\tIt is also possible to override _processResults if the server can provide an exact\r\n\t\t\t//\t\ttotal count.\r\n\t\t\t//\r\n\t\t\t//\t\t####The *syncMode* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tSetting this to true will set the store to using synchronous calls by default.\r\n\t\t\t//\t\tSync calls return their data immediately from the calling function, so\r\n\t\t\t//\t\tcallbacks are unnecessary. This will only work with a synchronous capable service.\r\n\t\t\t//\r\n\t\t\t// description:\r\n\t\t\t//\t\tServiceStore can do client side caching and result set updating if\r\n\t\t\t//\t\tdojox.data.ClientFilter is loaded. Do this add:\r\n\t\t\t//\t|\tdojo.require(\"dojox.data.ClientFilter\")\r\n\t\t\t//\t\tprior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).\r\n\t\t\t//\t\tTo utilize client side filtering with a subclass, you can break queries into\r\n\t\t\t//\t\tclient side and server side components by putting client side actions in\r\n\t\t\t//\t\tclientFilter property in fetch calls. For example you could override fetch:\r\n\t\t\t//\t|\tfetch: function(args){\r\n\t\t\t//\t|\t\t// do the sorting and paging on the client side\r\n\t\t\t//\t|\t\targs.clientFilter = {start:args.start, count: args.count, sort: args.sort};\r\n\t\t\t//\t|\t\t// args.query will be passed to the service object for the server side handling\r\n\t\t\t//\t|\t\treturn this.inherited(arguments);\r\n\t\t\t//\t|\t}\r\n\t\t\t//\t\tWhen extending this class, if you would like to create lazy objects, you can follow\r\n\t\t\t//\t\tthe example from dojox.data.tests.stores.ServiceStore:\r\n\t\t\t// |\tvar lazyItem = {\r\n\t\t\t// |\t\t_loadObject: function(callback){\r\n\t\t\t// |\t\t\tthis.name=\"loaded\";\r\n\t\t\t// |\t\t\tdelete this._loadObject;\r\n\t\t\t// |\t\t\tcallback(this);\r\n\t\t\t// |\t\t}\r\n\t\t\t// |\t};\r\n\r\n\t\t\t//setup a byId alias to the api call\r\n\t\t\tthis.byId=this.fetchItemByIdentity;\r\n\t\t\tthis._index = {};\r\n\t\t\t// if the advanced json parser is enabled, we can pass through object updates as onSet events\r\n\t\t\tif(options){\r\n\t\t\t\tlang.mixin(this,options);\r\n\t\t\t}\r\n\t\t\t// We supply a default idAttribute for parser driven construction, but if no id attribute\r\n\t\t\t//\tis supplied, it should be null so that auto identification takes place properly\r\n\t\t\tthis.idAttribute = (options && options.idAttribute) || (this.schema && this.schema._idAttr);\r\n\t\t},\r\n\t\t\r\n\t\t// schema: \r\n\t\t//\t\tThis is a schema object for this store. This should be JSON Schema format.\r\n\t\tschema: null,\r\n\t\t\r\n\t\t// idAttribute: String\r\n\t\t//\t\tDefaults to 'id'. The name of the attribute that holds an objects id.\r\n\t\t//\t\tThis can be a preexisting id provided by the server.\r\n\t\t//\t\tIf an ID isn't already provided when an object\r\n\t\t//\t\tis fetched or added to the store, the autoIdentity system\r\n\t\t//\t\twill generate an id for it and add it to the index.\r\n\r\n\t\tidAttribute: \"id\",\r\n\t\tlabelAttribute: \"label\",\r\n\t\t\r\n\t\t// syncMode: Boolean\r\n\t\t//\t\tSetting this to true will set the store to using synchronous calls by default.\r\n\t\t//\t\tSync calls return their data immediately from the calling function, so\r\n\t\t//\t\tcallbacks are unnecessary. This will only work with a synchronous capable service.\r\n\t\tsyncMode: false,\r\n\t\t\r\n\t\t// estimateCountFactor:\r\n\t\t//\t\tThis parameter is used by the ServiceStore to estimate the total count. When\r\n\t\t//\t\tpaging is indicated in a fetch and the response includes the full number of items\r\n\t\t//\t\trequested by the fetch's count parameter, then the total count will be estimated\r\n\t\t//\t\tto be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server\r\n\t\t//\t\tdoes not support paging, and the response is the full set of items, where the\r\n\t\t//\t\ttotal count is equal to the numer of items returned. If the server does support\r\n\t\t//\t\tpaging, an estimateCountFactor of 2 is a good value for estimating the total count\r\n\t\t//\t\tIt is also possible to override _processResults if the server can provide an exact\r\n\t\t//\t\ttotal count.\t\r\n\t\testimateCountFactor: 1,\r\n\t\t\r\n\t\tgetSchema: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns a reference to the JSON Schema\r\n\t\t\t// returns: Object\r\n\t\t\treturn this.schema;\r\n\t\t},\r\n\r\n\t\tloadLazyValues:true,\r\n\r\n\t\tgetValue: function(/*Object*/ item, /*String*/property, /*value?*/defaultValue){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGets the value of an item's 'property'\r\n\t\t\t// item:\r\n\t\t\t//\t\tThe item to get the value from\r\n\t\t\t// property:\r\n\t\t\t//\t\tproperty to look up value for\r\n\t\t\t// defaultValue:\r\n\t\t\t//\t\tthe default value\r\n\r\n\t\t\tvar value = item[property];\r\n\t\t\treturn value || // return the plain value since it was found;\r\n\t\t\t\t\t\t(property in item ? // a truthy value was not found, see if we actually have it\r\n\t\t\t\t\t\t\tvalue : // we do, so we can return it\r\n\t\t\t\t\t\t\titem._loadObject ? // property was not found, maybe because the item is not loaded, we will try to load it synchronously so we can get the property\r\n\t\t\t\t\t\t\t\t(dojox.rpc._sync = true) && arguments.callee.call(this,dojox.data.ServiceStore.prototype.loadItem({item:item}) || {}, property, defaultValue) : // load the item and run getValue again\r\n\t\t\t\t\t\t\t\tdefaultValue);// not in item -> return default value\r\n\t\t},\r\n\t\tgetValues: function(item, property){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGets the value of an item's 'property' and returns\r\n\t\t\t//\t\tit.\tIf this value is an array it is just returned,\r\n\t\t\t//\t\tif not, the value is added to an array and that is returned.\r\n\t\t\t// item: Object\r\n\t\t\t// property: String\r\n\t\t\t//\t\tproperty to look up value for\r\n\r\n\t\t\tvar val = this.getValue(item,property);\r\n\t\t\treturn val instanceof Array ? val : val === undefined ? [] : [val];\r\n\t\t},\r\n\r\n\t\tgetAttributes: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGets the available attributes of an item's 'property' and returns\r\n\t\t\t//\t\tit as an array.\r\n\t\t\t// item: Object\r\n\r\n\t\t\tvar res = [];\r\n\t\t\tfor(var i in item){\r\n\t\t\t\tif(item.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_')){\r\n\t\t\t\t\tres.push(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t},\r\n\r\n\t\thasAttribute: function(item,attribute){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks to see if item has attribute\r\n\t\t\t// item: Object\r\n\t\t\t// attribute: String\r\n\t\t\treturn attribute in item;\r\n\t\t},\r\n\r\n\t\tcontainsValue: function(item, attribute, value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks to see if 'item' has 'value' at 'attribute'\r\n\t\t\t// item: Object\r\n\t\t\t// attribute: String\r\n\t\t\t// value: Anything\r\n\t\t\treturn array.indexOf(this.getValues(item,attribute),value) > -1;\r\n\t\t},\r\n\r\n\r\n\t\tisItem: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks to see if the argument is an item\r\n\t\t\t// item: Object\r\n\r\n\t\t\t// we have no way of determining if it belongs, we just have object returned from\r\n\t\t\t// service queries\r\n\t\t\treturn (typeof item == 'object') && item && !(item instanceof Date);\r\n\t\t},\r\n\r\n\t\tisItemLoaded: function(/* object */ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks to see if the item is loaded.\r\n\r\n\t\t\treturn item && !item._loadObject;\r\n\t\t},\r\n\r\n\t\tloadItem: function(args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tLoads an item and calls the callback handler. Note, that this will call the callback\r\n\t\t\t//\t\thandler even if the item is loaded. Consequently, you can use loadItem to ensure\r\n\t\t\t//\t\tthat an item is loaded is situations when the item may or may not be loaded yet.\r\n\t\t\t//\t\tIf you access a value directly through property access, you can use this to load\r\n\t\t\t//\t\ta lazy value as well (doesn't need to be an item).\r\n\t\t\t// example:\r\n\t\t\t//\t|\tstore.loadItem({\r\n\t\t\t//\t|\t\titem: item, // this item may or may not be loaded\r\n\t\t\t//\t|\t\tonItem: function(item){\r\n\t\t\t//\t|\t\t\t// do something with the item\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t|\t});\r\n\r\n\t\t\tvar item;\r\n\t\t\tif(args.item._loadObject){\r\n\t\t\t\targs.item._loadObject(function(result){\r\n\t\t\t\t\titem = result; // in synchronous mode this can allow loadItem to return the value\r\n\t\t\t\t\tdelete item._loadObject;\r\n\t\t\t\t\tvar func = result instanceof Error ? args.onError : args.onItem;\r\n\t\t\t\t\tif(func){\r\n\t\t\t\t\t\tfunc.call(args.scope, result);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}else if(args.onItem){\r\n\t\t\t\t// even if it is already loaded, we will use call the callback, this makes it easier to\r\n\t\t\t\t// use when it is not known if the item is loaded (you can always safely call loadItem).\r\n\t\t\t\targs.onItem.call(args.scope, args.item);\r\n\t\t\t}\r\n\t\t\treturn item;\r\n\t\t},\r\n\t\t_currentId : 0,\r\n\t\t_processResults : function(results, deferred){\r\n\t\t\t// this should return an object with the items as an array and the total count of\r\n\t\t\t// items (maybe more than currently in the result set).\r\n\t\t\t// for example:\r\n\t\t\t//\t| {totalCount:10, items: [{id:1},{id:2}]}\r\n\r\n\t\t\t// index the results, assigning ids as necessary\r\n\r\n\t\t\tif(results && typeof results == 'object'){\r\n\t\t\t\tvar id = results.__id;\r\n\t\t\t\tif(!id){// if it hasn't been assigned yet\r\n\t\t\t\t\tif(this.idAttribute){\r\n\t\t\t\t\t\t// use the defined id if available\r\n\t\t\t\t\t\tid = results[this.idAttribute];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tid = this._currentId++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(id !== undefined){\r\n\t\t\t\t\t\tvar existingObj = this._index[id];\r\n\t\t\t\t\t\tif(existingObj){\r\n\t\t\t\t\t\t\tfor(var j in existingObj){\r\n\t\t\t\t\t\t\t\tdelete existingObj[j]; // clear it so we can mixin\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tresults = lang.mixin(existingObj,results);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tresults.__id = id;\r\n\t\t\t\t\t\tthis._index[id] = results;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor(var i in results){\r\n\t\t\t\t\tresults[i] = this._processResults(results[i], deferred).items;\r\n\t\t\t\t}\r\n\t\t\t\tvar count = results.length;\r\n\t\t\t}\r\n\t\t\treturn {totalCount: deferred.request.count == count ? (deferred.request.start || 0) + count * this.estimateCountFactor : count, items: results};\r\n\t\t},\r\n\t\tclose: function(request){\r\n\t\t\treturn request && request.abort && request.abort();\r\n\t\t},\r\n\t\tfetch: function(args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee dojo/data/api/Read.fetch\r\n\t\t\t// args:\r\n\t\t\t//\t\t####The *queryOptions.cache* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tIf true, indicates that the query result should be cached for future use. This is only available\r\n\t\t\t//\t\tif dojox.data.ClientFilter has been loaded before the ServiceStore\r\n\t\t\t//\r\n\t\t\t//\t\t####The *syncMode* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tIndicates that the call should be fetch synchronously if possible (this is not always possible)\r\n\t\t\t//\r\n\t\t\t//\t\t####The *clientFetch* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tThis is a fetch keyword argument for explicitly doing client side filtering, querying, and paging\r\n\r\n\t\t\targs = args || {};\r\n\r\n\t\t\tif(\"syncMode\" in args ? args.syncMode : this.syncMode){\r\n\t\t\t\tdojox.rpc._sync = true;\r\n\t\t\t}\r\n\t\t\tvar self = this;\r\n\r\n\t\t\tvar scope = args.scope || self;\r\n\t\t\tvar defResult = this.cachingFetch ? this.cachingFetch(args) : this._doQuery(args);\r\n\t\t\tdefResult.request = args;\r\n\t\t\tdefResult.addCallback(function(results){\r\n\t\t\t\tif(args.clientFetch){\r\n\t\t\t\t\tresults = self.clientSideFetch({query:args.clientFetch,sort:args.sort,start:args.start,count:args.count},results);\r\n\t\t\t\t}\r\n\t\t\t\tvar resultSet = self._processResults(results, defResult);\r\n\t\t\t\tresults = args.results = resultSet.items;\r\n\t\t\t\tif(args.onBegin){\r\n\t\t\t\t\targs.onBegin.call(scope, resultSet.totalCount, args);\r\n\t\t\t\t}\r\n\t\t\t\tif(args.onItem){\r\n\t\t\t\t\tfor(var i=0; i<results.length;i++){\r\n\t\t\t\t\t\targs.onItem.call(scope, results[i], args);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(args.onComplete){\r\n\t\t\t\t\targs.onComplete.call(scope, args.onItem ? null : results, args);\r\n\t\t\t\t}\r\n\t\t\t\treturn results;\r\n\t\t\t});\r\n\t\t\tdefResult.addErrback(args.onError && function(err){\r\n\t\t\t\treturn args.onError.call(scope, err, args);\r\n\t\t\t});\r\n\t\t\targs.abort = function(){\r\n\t\t\t\t// abort the request\r\n\t\t\t\tdefResult.cancel();\r\n\t\t\t};\r\n\t\t\targs.store = this;\r\n\t\t\treturn args;\r\n\t\t},\r\n\t\t_doQuery: function(args){\r\n\t\t\tvar query= typeof args.queryStr == 'string' ? args.queryStr : args.query;\r\n\t\t\treturn this.service(query);\r\n\t\t},\r\n\t\tgetFeatures: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturn the store feature set\r\n\r\n\t\t\treturn {\r\n\t\t\t\t\"dojo.data.api.Read\": true,\r\n\t\t\t\t\"dojo.data.api.Identity\": true,\r\n\t\t\t\t\"dojo.data.api.Schema\": this.schema\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\tgetLabel: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the label for an item. Just gets the \"label\" attribute.\r\n\r\n\t\t\treturn this.getValue(item,this.labelAttribute);\r\n\t\t},\r\n\r\n\t\tgetLabelAttributes: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns an array of attributes that are used to create the label of an item\r\n\t\t\treturn [this.labelAttribute];\r\n\t\t},\r\n\r\n\t\t//Identity API Support\r\n\r\n\r\n\t\tgetIdentity: function(item){\r\n\t\t\treturn item.__id;\r\n\t\t},\r\n\r\n\t\tgetIdentityAttributes: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the attributes which are used to make up the\r\n\t\t\t//\t\tidentity of an item.\tBasically returns this.idAttribute\r\n\r\n\t\t\treturn [this.idAttribute];\r\n\t\t},\r\n\r\n\t\tfetchItemByIdentity: function(args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tfetch an item by its identity, by looking in our index of what we have loaded\r\n\t\t\tvar item = this._index[(args._prefix || '') + args.identity];\r\n\t\t\tif(item){\r\n\t\t\t\t// the item exists in the index\r\n\t\t\t\tif(item._loadObject){\r\n\t\t\t\t\t// we have a handle on the item, but it isn't loaded yet, so we need to load it\r\n\t\t\t\t\targs.item = item;\r\n\t\t\t\t\treturn this.loadItem(args);\r\n\t\t\t\t}else if(args.onItem){\r\n\t\t\t\t\t// it's already loaded, so we can immediately callback\r\n\t\t\t\t\targs.onItem.call(args.scope, item);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t// convert the different spellings\r\n\t\t\t\treturn this.fetch({\r\n\t\t\t\t\t\tquery: args.identity,\r\n\t\t\t\t\t\tonComplete: args.onItem,\r\n\t\t\t\t\t\tonError: args.onError,\r\n\t\t\t\t\t\tscope: args.scope\r\n\t\t\t\t\t}).results;\r\n\t\t\t}\r\n\t\t\treturn item;\r\n\t\t}\r\n\r\n\t}\r\n);\r\n});\r\n"]}