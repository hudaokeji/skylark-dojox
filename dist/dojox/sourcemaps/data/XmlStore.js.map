{"version":3,"sources":["data/XmlStore.js"],"names":["define","lang","declare","xhr","simpleFetch","domQuery","array","kernel","filter","xmlParser","XmlItem","XmlStore","constructor","args","this","url","rootItem","rootitem","keyAttribute","keyattribute","_attributeMap","attributeMap","attributemap","label","sendQuery","sendquery","urlPreventCache","_newItems","_deletedItems","_modifiedItems","getValue","item","attribute","defaultValue","i","node","element","nodeName","childNodes","length","nodeType","_getItem","nodeValue","_getAttribute","charAt","name","substring","value","getAttribute","getValues","values","push","ec","undefined","getAttributes","attributes","names","text","key","indexOf","hasAttribute","containsValue","toString","isItem","something","store","isItemLoaded","loadItem","keywordArgs","getFeatures","features","dojo.data.api.Read","dojo.data.api.Write","getLabel","getLabelAttributes","_fetchItems","request","fetchHandler","errorHandler","_getFetchUrl","localRequest","self","getArgs","handleAs","preventCache","getHandler","get","addCallback","data","items","_getItems","addErrback","Error","query","isString","queryString","fullUrl","document","nodes","documentElement","queryOptions","deep","_flattenNodes","j","ignoreCase","match","emptyQuery","regexpList","patternToRegExp","queryValue","forEach","parentNode","removeChild","flattened","concat","close","newItem","parentInfo","tagName","_getDocument","createElement","createTextNode","appendChild","setAttribute","child","pInfo","parent","oldValue","tempValues","slice","setValues","newValue","setValue","deleteItem","_backupItem","_forgetItem","firstChild","unsetAttribute","removeAttribute","save","_saveItem","splice","revert","_restoreItems","isDirty","_getRootElement","_getItemIndex","method","scope","_getPutUrl","_getDeleteUrl","_getPostUrl","saveHandler","saveArgs","contentType","putData","_getPutContent","put","del","postData","_getPostContent","post","global","onComplete","call","error","onError","innerXML","q","_getXPath","e","console","log","_backup","cloneNode","index","ownerDocument","_document","parse","xpath","pos","sibling","previousSibling","temp","getIdentity","id","serverQuery","getIdentityAttributes","fetchItemByIdentity","handleDocument","identity","onItem","s","qArgs","split","section","vals","tag","parseInt","cNodes","foundNode","pNode","extend"],"mappings":"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","file":"../../data/XmlStore.js","sourcesContent":["define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/xhr\", \"dojo/data/util/simpleFetch\", \r\n\t\t\"dojo/_base/query\", \"dojo/_base/array\", \"dojo/_base/kernel\", \"dojo/data/util/filter\", \"dojox/xml/parser\",\r\n\t\t\"dojox/data/XmlItem\"], \r\n  function(lang, declare, xhr, simpleFetch, domQuery, array, kernel, filter, xmlParser, XmlItem) {\r\n\r\nvar XmlStore = declare(\"dojox.data.XmlStore\", null, {\r\n\t// summary:\r\n\t//\t\tA data store for XML based services or documents\r\n\t// description:\r\n\t//\t\tA data store for XML based services or documents\r\n\t\r\n\tconstructor: function(/* object */ args){\r\n\t\t// summary:\r\n\t\t//\t\tConstructor for the XML store.\r\n\t\t// args:\r\n\t\t//\t\tAn anonymous object to initialize properties.  It expects the following values:\r\n\t\t//\r\n\t\t//\t\t- url:\t\tThe url to a service or an XML document that represents the store\r\n\t\t//\t\t- rootItem:\tA tag name for root items\r\n\t\t//\t\t- keyAttribute:\tAn attribute name for a key or an identity (unique identifier)\r\n\t\t//\t\t\t\t\t\tRequired for serverside fetchByIdentity, etc.  Not required for\r\n\t\t//\t\t\t\t\t\tclient side fetchItemBIdentity, as it will use an XPath-like\r\n\t\t//\t\t\t\t\t\tstructure if keyAttribute was not specified.  Recommended to always\r\n\t\t//\t\t\t\t\t\tset this, though, for consistent identity behavior.\r\n\t\t//\t\t- attributeMap: An anonymous object contains properties for attribute mapping,\r\n\t\t//\t\t\t\t\t\t{\"tag_name.item_attribute_name\": \"@xml_attribute_name\", ...}\r\n\t\t//\t\t- sendQuery:\tA boolean indicate to add a query string to the service URL.\r\n\t\t//\t\t\t\t\t\tDefault is false.\r\n\t\t//\t\t- urlPreventCache: Parameter to indicate whether or not URL calls should apply\r\n\t\t//\t\t\t\t\t\t the preventCache option to the xhr request.\r\n\t\tif(args){\r\n\t\t\tthis.url = args.url;\r\n\t\t\tthis.rootItem = (args.rootItem || args.rootitem || this.rootItem);\r\n\t\t\tthis.keyAttribute = (args.keyAttribute || args.keyattribute || this.keyAttribute);\r\n\t\t\tthis._attributeMap = (args.attributeMap || args.attributemap);\r\n\t\t\tthis.label = args.label || this.label;\r\n\t\t\tthis.sendQuery = (args.sendQuery || args.sendquery || this.sendQuery);\r\n\t\t\tif(\"urlPreventCache\" in args){\r\n\t\t\t\tthis.urlPreventCache = args.urlPreventCache?true:false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._newItems = [];\r\n\t\tthis._deletedItems = [];\r\n\t\tthis._modifiedItems = [];\r\n\t},\r\n\r\n\t//Values that may be set by the parser.\r\n\t//Ergo, have to be instantiated to something\r\n\t//So the parser knows how to set them.\r\n\turl: \"\",\r\n\r\n\t//\tA tag name for XML tags to be considered root items in the hierarchy\r\n\trootItem: \"\",\r\n\r\n\t//\tAn attribute name for a key or an identity (unique identifier)\r\n\t//\tRequired for serverside fetchByIdentity, etc.  Not required for\r\n\t//\tclient side fetchItemBIdentity, as it will use an XPath-like\r\n\t//\tstructure if keyAttribute was not specified.  Recommended to always\r\n\t//\tset this, though, for consistent identity behavior.\r\n\tkeyAttribute: \"\",\r\n\r\n\t//\tAn attribute of the item to use as the label.\r\n\tlabel: \"\",\r\n\r\n\t//\tA boolean indicate to add a query string to the service URL.\r\n\t//\tDefault is false.\r\n\tsendQuery: false,\r\n\r\n\t//\tAn anonymous object that contains properties for attribute mapping,\r\n\t//\tfor example {\"tag_name.item_attribute_name\": \"@xml_attribute_name\", ...}.\r\n\t//\tThis is optional. This is done so that attributes which are actual\r\n\t//\tXML tag attributes (and not sub-tags of an XML tag), can be referenced.\r\n\tattributeMap: null,\r\n\r\n\t//\tParameter to indicate whether or not URL calls should apply the preventCache option to the xhr request.\r\n\turlPreventCache: true,\r\n\r\n\t/* dojo/data/api/Read */\r\n\r\n\tgetValue: function(/*dojo/data/api/Item*/ item, /* attribute|attribute-name-string */ attribute, /* value? */ defaultValue){\r\n\t\t// summary:\r\n\t\t//\t\tReturn an attribute value\r\n\t\t// description:\r\n\t\t//\t\t'item' must be an instance of a dojox.data.XmlItem from the store instance.\r\n\t\t//\t\tIf 'attribute' specifies \"tagName\", the tag name of the element is\r\n\t\t//\t\treturned.\r\n\t\t//\t\tIf 'attribute' specifies \"childNodes\", the first element child is\r\n\t\t//\t\treturned.\r\n\t\t//\t\tIf 'attribute' specifies \"text()\", the value of the first text\r\n\t\t//\t\tchild is returned.\r\n\t\t//\t\tFor generic attributes, if '_attributeMap' is specified,\r\n\t\t//\t\tan actual attribute name is looked up with the tag name of\r\n\t\t//\t\tthe element and 'attribute' (concatenated with '.').\r\n\t\t//\t\tThen, if 'attribute' starts with \"@\", the value of the XML\r\n\t\t//\t\tattribute is returned.\r\n\t\t//\t\tOtherwise, the first child element of the tag name specified with\r\n\t\t//\t\t'attribute' is returned.\r\n\t\t// item:\r\n\t\t//\t\tAn XML element that holds the attribute\r\n\t\t// attribute:\r\n\t\t//\t\tA tag name of a child element, An XML attribute name or one of\r\n\t\t//\t\tspecial names\r\n\t\t// defaultValue:\r\n\t\t//\t\tA default value\r\n\t\t// returns:\r\n\t\t//\t\tAn attribute value found, otherwise 'defaultValue'\r\n\t\tvar element = item.element;\r\n\t\tvar i;\r\n\t\tvar node;\r\n\t\tif(attribute === \"tagName\"){\r\n\t\t\treturn element.nodeName;\r\n\t\t}else if(attribute === \"childNodes\"){\r\n\t\t\tfor(i = 0; i < element.childNodes.length; i++){\r\n\t\t\t\tnode = element.childNodes[i];\r\n\t\t\t\tif(node.nodeType === 1 /*ELEMENT_NODE*/){\r\n\t\t\t\t\treturn this._getItem(node); //object\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn defaultValue;\r\n\t\t}else if(attribute === \"text()\"){\r\n\t\t\tfor(i = 0; i < element.childNodes.length; i++){\r\n\t\t\t\tnode = element.childNodes[i];\r\n\t\t\t\tif(node.nodeType === 3 /*TEXT_NODE*/ ||\r\n\t\t\t\t\tnode.nodeType === 4 /*CDATA_SECTION_NODE*/){\r\n\t\t\t\t\treturn node.nodeValue; //string\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn defaultValue;\r\n\t\t}else{\r\n\t\t\tattribute = this._getAttribute(element.nodeName, attribute);\r\n\t\t\tif(attribute.charAt(0) === '@'){\r\n\t\t\t\tvar name = attribute.substring(1);\r\n\t\t\t\tvar value = element.getAttribute(name);\r\n\t\t\t\t//Note that getAttribute will return null or empty string for undefined/unset\r\n\t\t\t\t//attributes, therefore, we should just check the return was valid\r\n\t\t\t\t//non-empty string and not null.\r\n\t\t\t\treturn (value) ? value : defaultValue; //object\r\n\t\t\t}else{\r\n\t\t\t\tfor(i = 0; i < element.childNodes.length; i++){\r\n\t\t\t\t\tnode = element.childNodes[i];\r\n\t\t\t\t\tif(\tnode.nodeType === 1 /*ELEMENT_NODE*/ &&\r\n\t\t\t\t\t\tnode.nodeName === attribute){\r\n\t\t\t\t\t\treturn this._getItem(node); //object\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn defaultValue; //object\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetValues: function(/*dojo/data/api/Item*/ item, /* attribute|attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tReturn an array of attribute values\r\n\t\t// description:\r\n\t\t//\t\t'item' must be an instance of a dojox.data.XmlItem from the store instance.\r\n\t\t//\t\tIf 'attribute' specifies \"tagName\", the tag name of the element is\r\n\t\t//\t\treturned.\r\n\t\t//\t\tIf 'attribute' specifies \"childNodes\", child elements are returned.\r\n\t\t//\t\tIf 'attribute' specifies \"text()\", the values of child text nodes\r\n\t\t//\t\tare returned.\r\n\t\t//\t\tFor generic attributes, if 'attributeMap' is specified,\r\n\t\t//\t\tan actual attribute name is looked up with the tag name of\r\n\t\t//\t\tthe element and 'attribute' (concatenated with '.').\r\n\t\t//\t\tThen, if 'attribute' starts with \"@\", the value of the XML\r\n\t\t//\t\tattribute is returned.\r\n\t\t//\t\tOtherwise, child elements of the tag name specified with\r\n\t\t//\t\t'attribute' are returned.\r\n\t\t// item:\r\n\t\t//\t\tAn XML element that holds the attribute\r\n\t\t// attribute:\r\n\t\t//\t\tA tag name of child elements, An XML attribute name or one of\r\n\t\t//\t\tspecial names\r\n\t\t// returns:\r\n\t\t//\t\tAn array of attribute values found, otherwise an empty array\r\n\t\tvar element = item.element;\r\n\t\tvar values = [];\r\n\t\tvar i;\r\n\t\tvar node;\r\n\t\tif(attribute === \"tagName\"){\r\n\t\t\treturn [element.nodeName];\r\n\t\t}else if(attribute === \"childNodes\"){\r\n\t\t\tfor(i = 0; i < element.childNodes.length; i++){\r\n\t\t\t\tnode = element.childNodes[i];\r\n\t\t\t\tif(node.nodeType === 1 /*ELEMENT_NODE*/){\r\n\t\t\t\t\tvalues.push(this._getItem(node));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn values; //array\r\n\t\t}else if(attribute === \"text()\"){\r\n\t\t\tvar ec = element.childNodes;\r\n\t\t\tfor(i = 0; i < ec.length; i++){\r\n\t\t\t\tnode = ec[i];\r\n\t\t\t\tif(node.nodeType === 3 || node.nodeType === 4){\r\n\t\t\t\t\tvalues.push(node.nodeValue);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn values; //array\r\n\t\t}else{\r\n\t\t\tattribute = this._getAttribute(element.nodeName, attribute);\r\n\t\t\tif(attribute.charAt(0) === '@'){\r\n\t\t\t\tvar name = attribute.substring(1);\r\n\t\t\t\tvar value = element.getAttribute(name);\r\n\t\t\t\treturn (value !== undefined) ? [value] : []; //array\r\n\t\t\t}else{\r\n\t\t\t\tfor(i = 0; i < element.childNodes.length; i++){\r\n\t\t\t\t\tnode = element.childNodes[i];\r\n\t\t\t\t\tif(\tnode.nodeType === 1 /*ELEMENT_NODE*/ &&\r\n\t\t\t\t\t\tnode.nodeName === attribute){\r\n\t\t\t\t\t\tvalues.push(this._getItem(node));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn values; //array\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetAttributes: function(/*dojo/data/api/Item*/ item){\r\n\t\t// summary:\r\n\t\t//\t\tReturn an array of attribute names\r\n\t\t// description:\r\n\t\t//\t\t'item' must be an instance of a dojox.data.XmlItem from the store instance.\r\n\t\t//\t\ttag names of child elements and XML attribute names of attributes\r\n\t\t//\t\tspecified to the element are returned along with special attribute\r\n\t\t//\t\tnames applicable to the element including \"tagName\", \"childNodes\"\r\n\t\t//\t\tif the element has child elements, \"text()\" if the element has\r\n\t\t//\t\tchild text nodes, and attribute names in '_attributeMap' that match\r\n\t\t//\t\tthe tag name of the element.\r\n\t\t// item:\r\n\t\t//\t\tAn XML element\r\n\t\t// returns:\r\n\t\t//\t\tAn array of attributes found\r\n\t\tvar element = item.element;\r\n\t\tvar attributes = [];\r\n\t\tvar i;\r\n\t\tattributes.push(\"tagName\");\r\n\t\tif(element.childNodes.length > 0){\r\n\t\t\tvar names = {};\r\n\t\t\tvar childNodes = true;\r\n\t\t\tvar text = false;\r\n\t\t\tfor(i = 0; i < element.childNodes.length; i++){\r\n\t\t\t\tvar node = element.childNodes[i];\r\n\t\t\t\tif(node.nodeType === 1 /*ELEMENT_NODE*/){\r\n\t\t\t\t\tvar name = node.nodeName;\r\n\t\t\t\t\tif(!names[name]){\r\n\t\t\t\t\t\tattributes.push(name);\r\n\t\t\t\t\t\tnames[name] = name;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchildNodes = true;\r\n\t\t\t\t}else if(node.nodeType === 3){\r\n\t\t\t\t\ttext = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(childNodes){\r\n\t\t\t\tattributes.push(\"childNodes\");\r\n\t\t\t}\r\n\t\t\tif(text){\r\n\t\t\t\tattributes.push(\"text()\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(i = 0; i < element.attributes.length; i++){\r\n\t\t\tattributes.push(\"@\" + element.attributes[i].nodeName);\r\n\t\t}\r\n\t\tif(this._attributeMap){\r\n\t\t\tfor(var key in this._attributeMap){\r\n\t\t\t\ti = key.indexOf('.');\r\n\t\t\t\tif(i > 0){\r\n\t\t\t\t\tvar tagName = key.substring(0, i);\r\n\t\t\t\t\tif(tagName === element.nodeName){\r\n\t\t\t\t\t\tattributes.push(key.substring(i + 1));\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{ // global attribute\r\n\t\t\t\t\tattributes.push(key);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn attributes; //array\r\n\t},\r\n\r\n\thasAttribute: function(/*dojo/data/api/Item*/ item, /* attribute|attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tCheck whether an element has the attribute\r\n\t\t// item:\r\n\t\t//\t\t'item' must be an instance of a dojox.data.XmlItem from the store instance.\r\n\t\t// attribute:\r\n\t\t//\t\tA tag name of a child element, An XML attribute name or one of\r\n\t\t//\t\tspecial names\r\n\t\t// returns:\r\n\t\t//\t\tTrue if the element has the attribute, otherwise false\r\n\t\treturn (this.getValue(item, attribute) !== undefined); //boolean\r\n\t},\r\n\r\n\tcontainsValue: function(/*dojo/data/api/Item*/ item, /* attribute|attribute-name-string */ attribute, /* anything */ value){\r\n\t\t// summary:\r\n\t\t//\t\tCheck whether the attribute values contain the value\r\n\t\t// item:\r\n\t\t//\t\t'item' must be an instance of a dojox.data.XmlItem from the store instance.\r\n\t\t// attribute:\r\n\t\t//\t\tA tag name of a child element, An XML attribute name or one of\r\n\t\t//\t\tspecial names\r\n\t\t// returns:\r\n\t\t//\t\tTrue if the attribute values contain the value, otherwise false\r\n\t\tvar values = this.getValues(item, attribute);\r\n\t\tfor(var i = 0; i < values.length; i++){\r\n\t\t\tif((typeof value === \"string\")){\r\n\t\t\t\tif(values[i].toString && values[i].toString() === value){\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}else if(values[i] === value){\r\n\t\t\t\treturn true; //boolean\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;//boolean\r\n\t},\r\n\r\n\tisItem: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tCheck whether the object is an item (XML element)\r\n\t\t// item:\r\n\t\t//\t\tAn object to check\r\n\t\t// returns:\r\n\t\t//\t\tTrue if the object is an XML element, otherwise false\r\n\t\tif(something && something.element && something.store && something.store === this){\r\n\t\t\treturn true; //boolean\r\n\t\t}\r\n\t\treturn false; //boolran\r\n\t},\r\n\r\n\tisItemLoaded: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tCheck whether the object is an item (XML element) and loaded\r\n\t\t// item:\r\n\t\t//\t\tAn object to check\r\n\t\t// returns:\r\n\t\t//\t\tTrue if the object is an XML element, otherwise false\r\n\t\treturn this.isItem(something); //boolean\r\n\t},\r\n\r\n\tloadItem: function(/* object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tLoad an item (XML element)\r\n\t\t// keywordArgs:\r\n\t\t//\t\tobject containing the args for loadItem.  See dojo/data/api/Read.loadItem()\r\n\t},\r\n\r\n\tgetFeatures: function(){\r\n\t\t// summary:\r\n\t\t//\t\tReturn supported data APIs\r\n\t\t// returns:\r\n\t\t//\t\t\"dojo.data.api.Read\" and \"dojo.data.api.Write\"\r\n\t\tvar features = {\r\n\t\t\t\"dojo.data.api.Read\": true,\r\n\t\t\t\"dojo.data.api.Write\": true\r\n\t\t};\r\n\r\n\t\t//Local XML parsing can implement Identity fairly simple via\r\n\t\tif(!this.sendQuery || this.keyAttribute !== \"\"){\r\n\t\t\tfeatures[\"dojo.data.api.Identity\"] = true;\r\n\t\t}\r\n\t\treturn features; //array\r\n\t},\r\n\r\n\tgetLabel: function(/*dojo/data/api/Item*/ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getLabel()\r\n\t\tif((this.label !== \"\") && this.isItem(item)){\r\n\t\t\tvar label = this.getValue(item,this.label);\r\n\t\t\tif(label){\r\n\t\t\t\treturn label.toString();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn undefined; //undefined\r\n\t},\r\n\r\n\tgetLabelAttributes: function(/*dojo/data/api/Item*/ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getLabelAttributes()\r\n\t\tif(this.label !== \"\"){\r\n\t\t\treturn [this.label]; //array\r\n\t\t}\r\n\t\treturn null; //null\r\n\t},\r\n\r\n\t_fetchItems: function(request, fetchHandler, errorHandler){\r\n\t\t// summary:\r\n\t\t//\t\tFetch items (XML elements) that match to a query\r\n\t\t// description:\r\n\t\t//\t\tIf 'sendQuery' is true, an XML document is loaded from\r\n\t\t//\t\t'url' with a query string.\r\n\t\t//\t\tOtherwise, an XML document is loaded and list XML elements that\r\n\t\t//\t\tmatch to a query (set of element names and their text attribute\r\n\t\t//\t\tvalues that the items to contain).\r\n\t\t//\t\tA wildcard, \"*\" can be used to query values to match all\r\n\t\t//\t\toccurrences.\r\n\t\t//\t\tIf 'rootItem' is specified, it is used to fetch items.\r\n\t\t// request:\r\n\t\t//\t\tA request object\r\n\t\t// fetchHandler:\r\n\t\t//\t\tA function to call for fetched items\r\n\t\t// errorHandler:\r\n\t\t//\t\tA function to call on error\r\n\t\tvar url = this._getFetchUrl(request);\r\n\t\tif(!url){\r\n\t\t\terrorHandler(new Error(\"No URL specified.\"), request);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar localRequest = (!this.sendQuery ? request : {}); // use request for _getItems()\r\n\r\n\t\tvar self = this;\r\n\t\tvar getArgs = {\r\n\t\t\t\turl: url,\r\n\t\t\t\thandleAs: \"xml\",\r\n\t\t\t\tpreventCache: self.urlPreventCache\r\n\t\t\t};\r\n\t\tvar getHandler = xhr.get(getArgs);\r\n\t\tgetHandler.addCallback(function(data){\r\n\t\t\tvar items = self._getItems(data, localRequest);\r\n\t\t\tif(items && items.length > 0){\r\n\t\t\t\tfetchHandler(items, request);\r\n\t\t\t}else{\r\n\t\t\t\tfetchHandler([], request);\r\n\t\t\t}\r\n\t\t});\r\n\t\tgetHandler.addErrback(function(data){\r\n\t\t\terrorHandler(data, request);\r\n\t\t});\r\n\t},\r\n\r\n\t_getFetchUrl: function(request){\r\n\t\t// summary:\r\n\t\t//\t\tGenerate a URL for fetch\r\n\t\t// description:\r\n\t\t//\t\tThis default implementation generates a query string in the form of\r\n\t\t//\t\t\"?name1=value1&name2=value2...\" off properties of 'query' object\r\n\t\t//\t\tspecified in 'request' and appends it to 'url', if 'sendQuery'\r\n\t\t//\t\tis set to false.\r\n\t\t//\t\tOtherwise, 'url' is returned as is.\r\n\t\t//\t\tSub-classes may override this method for the custom URL generation.\r\n\t\t// request:\r\n\t\t//\t\tA request object\r\n\t\t// returns:\r\n\t\t//\t\tA fetch URL\r\n\t\tif(!this.sendQuery){\r\n\t\t\treturn this.url;\r\n\t\t}\r\n\t\tvar query = request.query;\r\n\t\tif(!query){\r\n\t\t\treturn this.url;\r\n\t\t}\r\n\t\tif(lang.isString(query)){\r\n\t\t\treturn this.url + query;\r\n\t\t}\r\n\t\tvar queryString = \"\";\r\n\t\tfor(var name in query){\r\n\t\t\tvar value = query[name];\r\n\t\t\tif(value){\r\n\t\t\t\tif(queryString){\r\n\t\t\t\t\tqueryString += \"&\";\r\n\t\t\t\t}\r\n\t\t\t\tqueryString += (name + \"=\" + value);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!queryString){\r\n\t\t\treturn this.url;\r\n\t\t}\r\n\t\t//Check to see if the URL already has query params or not.\r\n\t\tvar fullUrl = this.url;\r\n\t\tif(fullUrl.indexOf(\"?\") < 0){\r\n\t\t\tfullUrl += \"?\";\r\n\t\t}else{\r\n\t\t\tfullUrl += \"&\";\r\n\t\t}\r\n\t\treturn fullUrl + queryString;\r\n\t},\r\n\r\n\t_getItems: function(document, request){\r\n\t\t// summary:\r\n\t\t//\t\tFetch items (XML elements) in an XML document based on a request\r\n\t\t// description:\r\n\t\t//\t\tThis default implementation walks through child elements of\r\n\t\t//\t\tthe document element to see if all properties of 'query' object\r\n\t\t//\t\tmatch corresponding attributes of the element (item).\r\n\t\t//\t\tIf 'request' is not specified, all child elements are returned.\r\n\t\t//\t\tSub-classes may override this method for the custom search in\r\n\t\t//\t\tan XML document.\r\n\t\t// document:\r\n\t\t//\t\tAn XML document\r\n\t\t// request:\r\n\t\t//\t\tA request object\r\n\t\t// returns:\r\n\t\t//\t\tAn array of items\r\n\t\tvar query = null;\r\n\t\tif(request){\r\n\t\t\tquery = request.query;\r\n\t\t}\r\n\t\tvar items = [];\r\n\t\tvar nodes = null;\r\n\r\n\t\tif(this.rootItem !== \"\"){\r\n\t\t\tnodes = domQuery(this.rootItem, document);\r\n\t\t}else{\r\n\t\t\tnodes = document.documentElement.childNodes;\r\n\t\t}\r\n\r\n\t\tvar deep = request.queryOptions ? request.queryOptions.deep : false;\r\n\t\tif(deep){\r\n\t\t\tnodes = this._flattenNodes(nodes);\r\n\t\t}\r\n\t\tfor(var i = 0; i < nodes.length; i++){\r\n\t\t\tvar node = nodes[i];\r\n\t\t\tif(node.nodeType != 1 /*ELEMENT_NODE*/){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tvar item = this._getItem(node);\r\n\t\t\tif(query){\r\n\t\t\t\tvar ignoreCase = request.queryOptions ? request.queryOptions.ignoreCase : false;\r\n\t\t\t\tvar value;\r\n\t\t\t\tvar match = false;\r\n\t\t\t\tvar j;\r\n\t\t\t\tvar emptyQuery = true;\r\n\r\n\t\t\t\t//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the\r\n\t\t\t\t//same value for each item examined.  Much more efficient.\r\n\t\t\t\tvar regexpList = {};\r\n\t\t\t\tfor(var key in query){\r\n\t\t\t\t\tvalue = query[key];\r\n\t\t\t\t\tif(typeof value === \"string\"){\r\n\t\t\t\t\t\tregexpList[key] = filter.patternToRegExp(value, ignoreCase);\r\n\t\t\t\t\t}else if(value){\r\n\t\t\t\t\t\t// It's an object, possibly regexp, so treat it as one.\r\n\t\t\t\t\t\tregexpList[key] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor(var attribute in query){\r\n\t\t\t\t\temptyQuery = false;\r\n\t\t\t\t\tvar values = this.getValues(item, attribute);\r\n\t\t\t\t\tfor(j = 0; j < values.length; j++){\r\n\t\t\t\t\t\tvalue = values[j];\r\n\t\t\t\t\t\tif(value){\r\n\t\t\t\t\t\t\tvar queryValue = query[attribute];\r\n\t\t\t\t\t\t\tif((typeof value) === \"string\" &&\r\n\t\t\t\t\t\t\t\t(regexpList[attribute])){\r\n\t\t\t\t\t\t\t\tif((value.match(regexpList[attribute])) !== null){\r\n\t\t\t\t\t\t\t\t\tmatch = true;\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\tmatch = false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}else if((typeof value) === \"object\"){\r\n\t\t\t\t\t\t\t\tif(\tvalue.toString &&\r\n\t\t\t\t\t\t\t\t\t(regexpList[attribute])){\r\n\t\t\t\t\t\t\t\t\tvar stringValue = value.toString();\r\n\t\t\t\t\t\t\t\t\tif((stringValue.match(regexpList[attribute])) !== null){\r\n\t\t\t\t\t\t\t\t\t\tmatch = true;\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\tmatch = false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\tif(queryValue === \"*\" || queryValue === value){\r\n\t\t\t\t\t\t\t\t\t\tmatch = true;\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\tmatch = false;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//One of the multiValue values matched,\r\n\t\t\t\t\t\t//so quit looking.\r\n\t\t\t\t\t\tif(match){\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(!match){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t//Either the query was an empty object {}, which is match all, or\r\n\t\t\t\t//was an actual match.\r\n\t\t\t\tif(emptyQuery || match){\r\n\t\t\t\t\titems.push(item);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t//No query, everything matches.\r\n\t\t\t\titems.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t\tarray.forEach(items,function(item){\r\n\t\t\tif(item.element.parentNode){\r\n\t\t\t\titem.element.parentNode.removeChild(item.element); // make it root\r\n\t\t\t}\r\n\t\t},this);\r\n\t\treturn items;\r\n\t},\r\n\r\n\t_flattenNodes: function(nodes){\r\n\t\t// summary:\r\n\t\t//\t\tFunction used to flatten a hierarchy of XML nodes into a single list for\r\n\t\t//\t\tquerying over.  Used when deep = true;\r\n\t\tvar flattened = [];\r\n\t\tif(nodes){\r\n\t\t\tvar i;\r\n\t\t\tfor(i = 0; i < nodes.length; i++){\r\n\t\t\t\tvar node = nodes[i];\r\n\t\t\t\tflattened.push(node);\r\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0){\r\n\t\t\t\t\tflattened = flattened.concat(this._flattenNodes(node.childNodes));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn flattened;\r\n\t},\r\n\r\n\tclose: function(/*dojo/data/api/Request|Object?*/ request){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.close()\r\n\t},\r\n\r\n/* dojo/data/api/Write */\r\n\r\n\tnewItem: function(/* object? */ keywordArgs, parentInfo){\r\n\t\t// summary:\r\n\t\t//\t\tReturn a new dojox.data.XmlItem\r\n\t\t// description:\r\n\t\t//\t\tAt least, 'keywordArgs' must contain \"tagName\" to be used for\r\n\t\t//\t\tthe new\telement.\r\n\t\t//\t\tOther attributes in 'keywordArgs' are set to the new element,\r\n\t\t//\t\tincluding \"text()\", but excluding \"childNodes\".\r\n\t\t// keywordArgs:\r\n\t\t//\t\tAn object containing initial attributes\r\n\t\t// returns:\r\n\t\t//\t\tAn XML element\r\n\t\tkeywordArgs = (keywordArgs || {});\r\n\t\tvar tagName = keywordArgs.tagName;\r\n\t\tif(!tagName){\r\n\t\t\ttagName = this.rootItem;\r\n\t\t\tif(tagName === \"\"){\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar document = this._getDocument();\r\n\t\tvar element = document.createElement(tagName);\r\n\t\tfor(var attribute in keywordArgs){\r\n\t\t\tvar text;\r\n\t\t\tif(attribute === \"tagName\"){\r\n\t\t\t\tcontinue;\r\n\t\t\t}else if(attribute === \"text()\"){\r\n\t\t\t\ttext = document.createTextNode(keywordArgs[attribute]);\r\n\t\t\t\telement.appendChild(text);\r\n\t\t\t}else{\r\n\t\t\t\tattribute = this._getAttribute(tagName, attribute);\r\n\t\t\t\tif(attribute.charAt(0) === '@'){\r\n\t\t\t\t\tvar name = attribute.substring(1);\r\n\t\t\t\t\telement.setAttribute(name, keywordArgs[attribute]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar child = document.createElement(attribute);\r\n\t\t\t\t\ttext = document.createTextNode(keywordArgs[attribute]);\r\n\t\t\t\t\tchild.appendChild(text);\r\n\t\t\t\t\telement.appendChild(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar item = this._getItem(element);\r\n\t\tthis._newItems.push(item);\r\n\r\n\t\tvar pInfo = null;\r\n\t\tif(parentInfo && parentInfo.parent && parentInfo.attribute){\r\n\t\t\tpInfo = {\r\n\t\t\t\titem: parentInfo.parent,\r\n\t\t\t\tattribute: parentInfo.attribute,\r\n\t\t\t\toldValue: undefined\r\n\t\t\t};\r\n\r\n\t\t\t//See if it is multi-valued or not and handle appropriately\r\n\t\t\t//Generally, all attributes are multi-valued for this store\r\n\t\t\t//So, we only need to append if there are already values present.\r\n\t\t\tvar values = this.getValues(parentInfo.parent, parentInfo.attribute);\r\n\t\t\tif(values && values.length > 0){\r\n\t\t\t\tvar tempValues = values.slice(0, values.length);\r\n\t\t\t\tif(values.length === 1){\r\n\t\t\t\t\tpInfo.oldValue = values[0];\r\n\t\t\t\t}else{\r\n\t\t\t\t\tpInfo.oldValue = values.slice(0, values.length);\r\n\t\t\t\t}\r\n\t\t\t\ttempValues.push(item);\r\n\t\t\t\tthis.setValues(parentInfo.parent, parentInfo.attribute, tempValues);\r\n\t\t\t\tpInfo.newValue = this.getValues(parentInfo.parent, parentInfo.attribute);\r\n\t\t\t}else{\r\n\t\t\t\tthis.setValue(parentInfo.parent, parentInfo.attribute, item);\r\n\t\t\t\tpInfo.newValue = item;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn item; //object\r\n\t},\r\n\t\r\n\tdeleteItem: function(/*dojo/data/api/Item*/ item){\r\n\t\t// summary:\r\n\t\t//\t\tDelete an dojox.data.XmlItem (wrapper to a XML element).\r\n\t\t// item:\r\n\t\t//\t\tAn XML element to delete\r\n\t\t// returns:\r\n\t\t//\t\tTrue\r\n\t\tvar element = item.element;\r\n\t\tif(element.parentNode){\r\n\t\t\tthis._backupItem(item);\r\n\t\t\telement.parentNode.removeChild(element);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tthis._forgetItem(item);\r\n\t\tthis._deletedItems.push(item);\r\n\t\treturn true; //boolean\r\n\t},\r\n\t\r\n\tsetValue: function(/*dojo/data/api/Item*/ item, /* attribute|String */ attribute, /* almost anything */ value){\r\n\t\t// summary:\r\n\t\t//\t\tSet an attribute value\r\n\t\t// description:\r\n\t\t//\t\t'item' must be an instance of a dojox.data.XmlItem from the store instance.\r\n\t\t//\t\tIf 'attribute' specifies \"tagName\", nothing is set and false is\r\n\t\t//\t\treturned.\r\n\t\t//\t\tIf 'attribute' specifies \"childNodes\", the value (XML element) is\r\n\t\t//\t\tadded to the element.\r\n\t\t//\t\tIf 'attribute' specifies \"text()\", a text node is created with\r\n\t\t//\t\tthe value and set it to the element as a child.\r\n\t\t//\t\tFor generic attributes, if '_attributeMap' is specified,\r\n\t\t//\t\tan actual attribute name is looked up with the tag name of\r\n\t\t//\t\tthe element and 'attribute' (concatenated with '.').\r\n\t\t//\t\tThen, if 'attribute' starts with \"@\", the value is set to the XML\r\n\t\t//\t\tattribute.\r\n\t\t//\t\tOtherwise, a text node is created with the value and set it to\r\n\t\t//\t\tthe first child element of the tag name specified with 'attribute'.\r\n\t\t//\t\tIf the child element does not exist, it is created.\r\n\t\t// item:\r\n\t\t//\t\tAn XML element that holds the attribute\r\n\t\t// attribute:\r\n\t\t//\t\tA tag name of a child element, An XML attribute name or one of\r\n\t\t//\t\tspecial names\r\n\t\t// value:\r\n\t\t//\t\tA attribute value to set\r\n\t\t// returns:\r\n\t\t//\t\tFalse for \"tagName\", otherwise true\r\n\t\tif(attribute === \"tagName\"){\r\n\t\t\treturn false; //boolean\r\n\t\t}\r\n\r\n\t\tthis._backupItem(item);\r\n\r\n\t\tvar element = item.element;\r\n\t\tvar child;\r\n\t\tvar text;\r\n\t\tif(attribute === \"childNodes\"){\r\n\t\t\tchild = value.element;\r\n\t\t\telement.appendChild(child);\r\n\t\t}else if(attribute === \"text()\"){\r\n\t\t\twhile(element.firstChild){\r\n\t\t\t\telement.removeChild(element.firstChild);\r\n\t\t\t}\r\n\t\t\ttext = this._getDocument(element).createTextNode(value);\r\n\t\t\telement.appendChild(text);\r\n\t\t}else{\r\n\t\t\tattribute = this._getAttribute(element.nodeName, attribute);\r\n\t\t\tif(attribute.charAt(0) === '@'){\r\n\t\t\t\tvar name = attribute.substring(1);\r\n\t\t\t\telement.setAttribute(name, value);\r\n\t\t\t}else{\r\n\t\t\t\tfor(var i = 0; i < element.childNodes.length; i++){\r\n\t\t\t\t\tvar node = element.childNodes[i];\r\n\t\t\t\t\tif(\tnode.nodeType === 1 /*ELEMENT_NODE*/ &&\r\n\t\t\t\t\t\tnode.nodeName === attribute){\r\n\t\t\t\t\t\tchild = node;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar document = this._getDocument(element);\r\n\t\t\t\tif(child){\r\n\t\t\t\t\twhile(child.firstChild){\r\n\t\t\t\t\t\tchild.removeChild(child.firstChild);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tchild = document.createElement(attribute);\r\n\t\t\t\t\telement.appendChild(child);\r\n\t\t\t\t}\r\n\t\t\t\ttext = document.createTextNode(value);\r\n\t\t\t\tchild.appendChild(text);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true; //boolean\r\n\t},\r\n\t\t\r\n\tsetValues: function(/*dojo/data/api/Item*/ item, /* attribute|String */ attribute, /*Array*/ values){\r\n\t\t// summary:\r\n\t\t//\t\tSet attribute values\r\n\t\t// description:\r\n\t\t//\t\t'item' must be an instance of a dojox.data.XmlItem from the store instance.\r\n\t\t//\t\tIf 'attribute' specifies \"tagName\", nothing is set and false is\r\n\t\t//\t\treturned.\r\n\t\t//\t\tIf 'attribute' specifies \"childNodes\", the value (array of XML\r\n\t\t//\t\telements) is set to the element's childNodes.\r\n\t\t//\t\tIf 'attribute' specifies \"text()\", a text node is created with\r\n\t\t//\t\tthe values and set it to the element as a child.\r\n\t\t//\t\tFor generic attributes, if '_attributeMap' is specified,\r\n\t\t//\t\tan actual attribute name is looked up with the tag name of\r\n\t\t//\t\tthe element and 'attribute' (concatenated with '.').\r\n\t\t//\t\tThen, if 'attribute' starts with \"@\", the first value is set to\r\n\t\t//\t\tthe XML attribute.\r\n\t\t//\t\tOtherwise, child elements of the tag name specified with\r\n\t\t//\t\t'attribute' are replaced with new child elements and their\r\n\t\t//\t\tchild text nodes of values.\r\n\t\t// item:\r\n\t\t//\t\tAn XML element that holds the attribute\r\n\t\t// attribute:\r\n\t\t//\t\tA tag name of child elements, an XML attribute name or one of\r\n\t\t//\t\tspecial names\r\n\t\t// value:\r\n\t\t//\t\tA attribute value to set\r\n\t\t// notify:\r\n\t\t//\t\tA non-API optional argument, used to indicate if notification API should be called\r\n\t\t//\t\tor not.\r\n\t\t// returns:\r\n\t\t//\t\tFalse for \"tagName\", otherwise true\r\n\r\n\t\tif(attribute === \"tagName\"){\r\n\t\t\treturn false; //boolean\r\n\t\t}\r\n\r\n\t\tthis._backupItem(item);\r\n\r\n\t\tvar element = item.element;\r\n\t\tvar i;\r\n\t\tvar child;\r\n\t\tvar text;\r\n\t\tif(attribute === \"childNodes\"){\r\n\t\t\twhile(element.firstChild){\r\n\t\t\t\telement.removeChild(element.firstChild);\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < values.length; i++){\r\n\t\t\t\tchild = values[i].element;\r\n\t\t\t\telement.appendChild(child);\r\n\t\t\t}\r\n\t\t}else if(attribute === \"text()\"){\r\n\t\t\twhile(element.firstChild){\r\n\t\t\t\telement.removeChild(element.firstChild);\r\n\t\t\t}\r\n\t\t\tvar value = \"\";\r\n\t\t\tfor(i = 0; i < values.length; i++){\r\n\t\t\t\tvalue += values[i];\r\n\t\t\t}\r\n\t\t\ttext = this._getDocument(element).createTextNode(value);\r\n\t\t\telement.appendChild(text);\r\n\t\t}else{\r\n\t\t\tattribute = this._getAttribute(element.nodeName, attribute);\r\n\t\t\tif(attribute.charAt(0) === '@'){\r\n\t\t\t\tvar name = attribute.substring(1);\r\n\t\t\t\telement.setAttribute(name, values[0]);\r\n\t\t\t}else{\r\n\t\t\t\tfor(i = element.childNodes.length - 1; i >= 0; i--){\r\n\t\t\t\t\tvar node = element.childNodes[i];\r\n\t\t\t\t\tif(\tnode.nodeType === 1 /*ELEMENT_NODE*/ &&\r\n\t\t\t\t\t\tnode.nodeName === attribute){\r\n\t\t\t\t\t\telement.removeChild(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar document = this._getDocument(element);\r\n\t\t\t\tfor(i = 0; i < values.length; i++){\r\n\t\t\t\t\tchild = document.createElement(attribute);\r\n\t\t\t\t\ttext = document.createTextNode(values[i]);\r\n\t\t\t\t\tchild.appendChild(text);\r\n\t\t\t\t\telement.appendChild(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true; //boolean\r\n\t},\r\n\t\r\n\tunsetAttribute: function(/*dojo/data/api/Item*/ item, /* attribute|String */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tRemove an attribute\r\n\t\t// description:\r\n\t\t//\t\t'item' must be an instance of a dojox.data.XmlItem from the store instance.\r\n\t\t//\t\t'attribute' can be an XML attribute name of the element or one of\r\n\t\t//\t\tspecial names described below.\r\n\t\t//\t\tIf 'attribute' specifies \"tagName\", nothing is removed and false is\r\n\t\t//\t\treturned.\r\n\t\t//\t\tIf 'attribute' specifies \"childNodes\" or \"text()\", all child nodes\r\n\t\t//\t\tare removed.\r\n\t\t//\t\tFor generic attributes, if '_attributeMap' is specified,\r\n\t\t//\t\tan actual attribute name is looked up with the tag name of\r\n\t\t//\t\tthe element and 'attribute' (concatenated with '.').\r\n\t\t//\t\tThen, if 'attribute' starts with \"@\", the XML attribute is removed.\r\n\t\t//\t\tOtherwise, child elements of the tag name specified with\r\n\t\t//\t\t'attribute' are removed.\r\n\t\t// item:\r\n\t\t//\t\tAn XML element that holds the attribute\r\n\t\t// attribute:\r\n\t\t//\t\tA tag name of child elements, an XML attribute name or one of\r\n\t\t//\t\tspecial names\r\n\t\t// returns:\r\n\t\t//\t\tFalse for \"tagName\", otherwise true\r\n\t\tif(attribute === \"tagName\"){\r\n\t\t\treturn false; //boolean\r\n\t\t}\r\n\r\n\t\tthis._backupItem(item);\r\n\r\n\t\tvar element = item.element;\r\n\t\tif(attribute === \"childNodes\" || attribute === \"text()\"){\r\n\t\t\twhile(element.firstChild){\r\n\t\t\t\telement.removeChild(element.firstChild);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tattribute = this._getAttribute(element.nodeName, attribute);\r\n\t\t\tif(attribute.charAt(0) === '@'){\r\n\t\t\t\tvar name = attribute.substring(1);\r\n\t\t\t\telement.removeAttribute(name);\r\n\t\t\t}else{\r\n\t\t\t\tfor(var i = element.childNodes.length - 1; i >= 0; i--){\r\n\t\t\t\t\tvar node = element.childNodes[i];\r\n\t\t\t\t\tif(\tnode.nodeType === 1 /*ELEMENT_NODE*/ &&\r\n\t\t\t\t\t\tnode.nodeName === attribute){\r\n\t\t\t\t\t\telement.removeChild(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true; //boolean\r\n\t},\r\n\t\r\n\tsave: function(/* object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tSave new and/or modified items (XML elements)\r\n\t\t// description:\r\n\t\t//\t\t'url' is used to save XML documents for new, modified and/or\r\n\t\t//\t\tdeleted XML elements.\r\n\t\t// keywordArgs:\r\n\t\t//\t\tAn object for callbacks\r\n\t\tif(!keywordArgs){\r\n\t\t\tkeywordArgs = {};\r\n\t\t}\r\n\t\tvar i;\r\n\t\tfor(i = 0; i < this._modifiedItems.length; i++){\r\n\t\t\tthis._saveItem(this._modifiedItems[i], keywordArgs, \"PUT\");\r\n\t\t}\r\n\t\tfor(i = 0; i < this._newItems.length; i++){\r\n\t\t\tvar item = this._newItems[i];\r\n\t\t\tif(item.element.parentNode){ // reparented\r\n\t\t\t\tthis._newItems.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tthis._saveItem(this._newItems[i], keywordArgs, \"POST\");\r\n\t\t}\r\n\t\tfor(i = 0; i < this._deletedItems.length; i++){\r\n\t\t\tthis._saveItem(this._deletedItems[i], keywordArgs, \"DELETE\");\r\n\t\t}\r\n\t},\r\n\r\n\trevert: function(){\r\n\t\t// summary:\r\n\t\t//\tInvalidate changes (new and/or modified elements)\r\n\t\t// returns:\r\n\t\t//\tTrue\r\n\t\tthis._newItems = [];\r\n\t\tthis._restoreItems(this._deletedItems);\r\n\t\tthis._deletedItems = [];\r\n\t\tthis._restoreItems(this._modifiedItems);\r\n\t\tthis._modifiedItems = [];\r\n\t\treturn true; //boolean\r\n\t},\r\n\t\r\n\tisDirty: function(/* item? */ item){\r\n\t\t// summary:\r\n\t\t//\t\tCheck whether an item is new, modified or deleted\r\n\t\t// description:\r\n\t\t//\t\tIf 'item' is specified, true is returned if the item is new,\r\n\t\t//\t\tmodified or deleted.\r\n\t\t//\t\tOtherwise, true is returned if there are any new, modified\r\n\t\t//\t\tor deleted items.\r\n\t\t// item:\r\n\t\t//\t\tAn item (XML element) to check\r\n\t\t// returns:\r\n\t\t//\t\tTrue if an item or items are new, modified or deleted, otherwise\r\n\t\t//\t\tfalse\r\n\t\tif(item){\r\n\t\t\tvar element = this._getRootElement(item.element);\r\n\t\t\treturn (this._getItemIndex(this._newItems, element) >= 0 ||\r\n\t\t\t\tthis._getItemIndex(this._deletedItems, element) >= 0 ||\r\n\t\t\t\tthis._getItemIndex(this._modifiedItems, element) >= 0); //boolean\r\n\t\t}else{\r\n\t\t\treturn (this._newItems.length > 0 ||\r\n\t\t\t\tthis._deletedItems.length > 0 ||\r\n\t\t\t\tthis._modifiedItems.length > 0); //boolean\r\n\t\t}\r\n\t},\r\n\r\n\t_saveItem: function(item, keywordArgs, method){\r\n\t\tvar url;\r\n\t\tvar scope;\r\n\t\tif(method === \"PUT\"){\r\n\t\t\turl = this._getPutUrl(item);\r\n\t\t}else if(method === \"DELETE\"){\r\n\t\t\turl = this._getDeleteUrl(item);\r\n\t\t}else{ // POST\r\n\t\t\turl = this._getPostUrl(item);\r\n\t\t}\r\n\t\tif(!url){\r\n\t\t\tif(keywordArgs.onError){\r\n\t\t\t\tscope = keywordArgs.scope || kernel.global;\r\n\t\t\t\tkeywordArgs.onError.call(scope, new Error(\"No URL for saving content: \" + this._getPostContent(item)));\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar saveArgs = {\r\n\t\t\turl: url,\r\n\t\t\tmethod: (method || \"POST\"),\r\n\t\t\tcontentType: \"text/xml\",\r\n\t\t\thandleAs: \"xml\"\r\n\t\t};\r\n\t\tvar saveHandler;\r\n\t\tif(method === \"PUT\"){\r\n\t\t\tsaveArgs.putData = this._getPutContent(item);\r\n\t\t\tsaveHandler = xhr.put(saveArgs);\r\n\t\t}else if(method === \"DELETE\"){\r\n\t\t\tsaveHandler = xhr.del(saveArgs);\r\n\t\t}else{ // POST\r\n\t\t\tsaveArgs.postData = this._getPostContent(item);\r\n\t\t\tsaveHandler = xhr.post(saveArgs);\r\n\t\t}\r\n\t\tscope = (keywordArgs.scope || kernel. global);\r\n\t\tvar self = this;\r\n\t\tsaveHandler.addCallback(function(data){\r\n\t\t\tself._forgetItem(item);\r\n\t\t\tif(keywordArgs.onComplete){\r\n\t\t\t\tkeywordArgs.onComplete.call(scope);\r\n\t\t\t}\r\n\t\t});\r\n\t\tsaveHandler.addErrback(function(error){\r\n\t\t\tif(keywordArgs.onError){\r\n\t\t\t\tkeywordArgs.onError.call(scope, error);\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_getPostUrl: function(item){\r\n\t\t// summary:\r\n\t\t//\t\tGenerate a URL for post\r\n\t\t// description:\r\n\t\t//\t\tThis default implementation just returns 'url'.\r\n\t\t//\t\tSub-classes may override this method for the custom URL.\r\n\t\t// item:\r\n\t\t//\t\tAn item to save\r\n\t\t// returns:\r\n\t\t//\t\tA post URL\r\n\t\treturn this.url; //string\r\n\t},\r\n\r\n\t_getPutUrl: function(item){\r\n\t\t// summary:\r\n\t\t//\t\tGenerate a URL for put\r\n\t\t// description:\r\n\t\t//\t\tThis default implementation just returns 'url'.\r\n\t\t//\t\tSub-classes may override this method for the custom URL.\r\n\t\t// item:\r\n\t\t//\t\tAn item to save\r\n\t\t// returns:\r\n\t\t//\t\tA put URL\r\n\t\treturn this.url; //string\r\n\t},\r\n\r\n\t_getDeleteUrl: function(item){\r\n\t\t// summary:\r\n\t\t//\t\tGenerate a URL for delete\r\n\t\t// description:\r\n\t\t//\t\tThis default implementation returns 'url' with 'keyAttribute'\r\n\t\t//\t\tas a query string.\r\n\t\t//\t\tSub-classes may override this method for the custom URL based on\r\n\t\t//\t\tchanges (new, deleted, or modified).\r\n\t\t// item:\r\n\t\t//\t\tAn item to delete\r\n\t\t// returns:\r\n\t\t//\t\tA delete URL\r\n\t\tvar url = this.url;\r\n\t\tif(item && this.keyAttribute !== \"\"){\r\n\t\t\tvar value = this.getValue(item, this.keyAttribute);\r\n\t\t\tif(value){\r\n\t\t\t\tvar key = this.keyAttribute.charAt(0) ==='@' ? this.keyAttribute.substring(1): this.keyAttribute;\r\n\t\t\t\turl += url.indexOf('?') < 0 ? '?' : '&';\r\n\t\t\t\turl += key + '=' + value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn url;\t//string\r\n\t},\r\n\r\n\t_getPostContent: function(item){\r\n\t\t// summary:\r\n\t\t//\t\tGenerate a content to post\r\n\t\t// description:\r\n\t\t//\t\tThis default implementation generates an XML document for one\r\n\t\t//\t\t(the first only) new or modified element.\r\n\t\t//\t\tSub-classes may override this method for the custom post content\r\n\t\t//\t\tgeneration.\r\n\t\t// item:\r\n\t\t//\t\tAn item to save\r\n\t\t// returns:\r\n\t\t//\t\tA post content\r\n\t\treturn \"<?xml version=\\'1.0\\'?>\" + xmlParser.innerXML(item.element); //XML string\r\n\t},\r\n\r\n\t_getPutContent: function(item){\r\n\t\t// summary:\r\n\t\t//\t\tGenerate a content to put\r\n\t\t// description:\r\n\t\t//\t\tThis default implementation generates an XML document for one\r\n\t\t//\t\t(the first only) new or modified element.\r\n\t\t//\t\tSub-classes may override this method for the custom put content\r\n\t\t//\t\tgeneration.\r\n\t\t// item:\r\n\t\t//\t\tAn item to save\r\n\t\t// returns:\r\n\t\t//\t\tA post content\r\n\t\treturn \"<?xml version='1.0'?>\" + xmlParser.innerXML(item.element); //XML string\r\n\t},\r\n\r\n/* internal API */\r\n\r\n\t_getAttribute: function(tagName, attribute){\r\n\t\tif(this._attributeMap){\r\n\t\t\tvar key = tagName + \".\" + attribute;\r\n\t\t\tvar value = this._attributeMap[key];\r\n\t\t\tif(value){\r\n\t\t\t\tattribute = value;\r\n\t\t\t}else{ // look for global attribute\r\n\t\t\t\tvalue = this._attributeMap[attribute];\r\n\t\t\t\tif(value){\r\n\t\t\t\t\tattribute = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn attribute; //object\r\n\t},\r\n\r\n\t_getItem: function(element){\r\n\t\ttry{\r\n\t\t\tvar q = null;\r\n\t\t\t//Avoid function call if possible.\r\n\t\t\tif(this.keyAttribute === \"\"){\r\n\t\t\t\tq = this._getXPath(element);\r\n\t\t\t}\r\n\t\t\treturn new XmlItem(element, this, q); //object\r\n\t\t}catch (e){\r\n\t\t\tconsole.log(e);\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_getItemIndex: function(items, element){\r\n\t\tfor(var i = 0; i < items.length; i++){\r\n\t\t\tif(items[i].element === element){\r\n\t\t\t\treturn i; //int\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1; //int\r\n\t},\r\n\r\n\t_backupItem: function(item){\r\n\t\tvar element = this._getRootElement(item.element);\r\n\t\tif(\tthis._getItemIndex(this._newItems, element) >= 0 ||\r\n\t\t\tthis._getItemIndex(this._modifiedItems, element) >= 0){\r\n\t\t\treturn; // new or already modified\r\n\t\t}\r\n\t\tif(element != item.element){\r\n\t\t\titem = this._getItem(element);\r\n\t\t}\r\n\t\titem._backup = element.cloneNode(true);\r\n\t\tthis._modifiedItems.push(item);\r\n\t},\r\n\r\n\t_restoreItems: function(items){\r\n\r\n\t\tarray.forEach(items,function(item){\r\n\t\t\tif(item._backup){\r\n\t\t\t\titem.element = item._backup;\r\n\t\t\t\titem._backup = null;\r\n\t\t\t}\r\n\t\t},this);\r\n\t},\r\n\r\n\t_forgetItem: function(item){\r\n\t\tvar element = item.element;\r\n\t\tvar index = this._getItemIndex(this._newItems, element);\r\n\t\tif(index >= 0){\r\n\t\t\tthis._newItems.splice(index, 1);\r\n\t\t}\r\n\t\tindex = this._getItemIndex(this._deletedItems, element);\r\n\t\tif(index >= 0){\r\n\t\t\tthis._deletedItems.splice(index, 1);\r\n\t\t}\r\n\t\tindex = this._getItemIndex(this._modifiedItems, element);\r\n\t\tif(index >= 0){\r\n\t\t\tthis._modifiedItems.splice(index, 1);\r\n\t\t}\r\n\t},\r\n\r\n\t_getDocument: function(element){\r\n\t\tif(element){\r\n\t\t\treturn element.ownerDocument; //DOMDocument\r\n\t\t}else if(!this._document){\r\n\t\t\treturn xmlParser.parse(); // DOMDocument\r\n\t\t}\r\n\t\treturn null; //null\r\n\t},\r\n\r\n\t_getRootElement: function(element){\r\n\t\twhile(element.parentNode){\r\n\t\t\telement = element.parentNode;\r\n\t\t}\r\n\t\treturn element; //DOMElement\r\n\t},\r\n\r\n\t_getXPath: function(element){\r\n\t\t// summary:\r\n\t\t//\t\tA function to compute the xpath of a node in a DOM document.\r\n\t\t// description:\r\n\t\t//\t\tA function to compute the xpath of a node in a DOM document.  Used for\r\n\t\t//\t\tClient side query handling and identity.\r\n\t\tvar xpath = null;\r\n\t\tif(!this.sendQuery){\r\n\t\t\t//xpath should be null for any server queries, as we don't have the entire\r\n\t\t\t//XML dom to figure it out.\r\n\t\t\tvar node = element;\r\n\t\t\txpath = \"\";\r\n\t\t\twhile(node && node != element.ownerDocument){\r\n\t\t\t\tvar pos = 0;\r\n\t\t\t\tvar sibling = node;\r\n\t\t\t\tvar name = node.nodeName;\r\n\t\t\t\twhile(sibling){\r\n\t\t\t\t\tsibling = sibling.previousSibling;\r\n\t\t\t\t\tif(sibling && sibling.nodeName === name){\r\n\t\t\t\t\t\tpos++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar temp = \"/\" + name + \"[\" + pos + \"]\";\r\n\t\t\t\tif(xpath){\r\n\t\t\t\t\txpath = temp + xpath;\r\n\t\t\t\t}else{\r\n\t\t\t\t\txpath = temp;\r\n\t\t\t\t}\r\n\t\t\t\tnode = node.parentNode;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn xpath; //string\r\n\t},\r\n\r\n\t/*************************************\r\n\t * Dojo.data Identity implementation *\r\n\t *************************************/\r\n\tgetIdentity: function(/*dojo/data/api/Item*/ item){\r\n\t\t// summary:\r\n\t\t//\t\tReturns a unique identifier for an item.\r\n\t\t// item:\r\n\t\t//\t\tThe XML Item from the store from which to obtain its identifier.\r\n\t\tif(!this.isItem(item)){\r\n\t\t\tthrow new Error(\"dojox.data.XmlStore: Object supplied to getIdentity is not an item\");\r\n\t\t}else{\r\n\t\t\tvar id = null;\r\n\t\t\tif(this.sendQuery && this.keyAttribute !== \"\"){\r\n\t\t\t\tid = this.getValue(item, this.keyAttribute).toString();\r\n\t\t\t}else if(!this.serverQuery){\r\n\t\t\t\tif(this.keyAttribute !== \"\"){\r\n\t\t\t\t\tid = this.getValue(item,this.keyAttribute).toString();\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//No specified identity, so return the dojo.query/xpath\r\n\t\t\t\t\t//for the node as fallback.\r\n\t\t\t\t\tid = item.q;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn id; //String.\r\n\t\t}\r\n\t},\r\n\r\n\tgetIdentityAttributes: function(/*dojo/data/api/Item*/ item){\r\n\t\t// summary:\r\n\t\t//\t\tReturns an array of attribute names that are used to generate the identity.\r\n\t\t// description:\r\n\t\t//\t\tFor XmlStore, if sendQuery is false and no keyAttribute was set, then this function\r\n\t\t//\t\treturns null, as xpath is used for the identity, which is not a public attribute of\r\n\t\t//\t\tthe item.  If sendQuery is true and keyAttribute is set, then this function\r\n\t\t//\t\treturns an array of one attribute name: keyAttribute.   This means the server side\r\n\t\t//\t\timplementation must apply a keyAttribute to a returned node that always allows\r\n\t\t//\t\tit to be looked up again.\r\n\t\t// item:\r\n\t\t//\t\tThe item from the store from which to obtain the array of public attributes that\r\n\t\t//\t\tcompose the identifier, if any.\r\n\t\tif(!this.isItem(item)){\r\n\t\t\tthrow new Error(\"dojox.data.XmlStore: Object supplied to getIdentity is not an item\");\r\n\t\t}else{\r\n\t\t\tif(this.keyAttribute !== \"\"){\r\n\t\t\t\treturn [this.keyAttribute]; //array\r\n\t\t\t}else{\r\n\t\t\t\t//Otherwise it's either using xpath (not an attribute), or the remote store\r\n\t\t\t\t//doesn't support identity.\r\n\t\t\t\treturn null; //null\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tfetchItemByIdentity: function(/* object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.fetchItemByIdentity(keywordArgs)\r\n\t\tvar handleDocument = null;\r\n\t\tvar scope = null;\r\n\t\tvar self = this;\r\n\t\tvar url = null;\r\n\t\tvar getArgs = null;\r\n\t\tvar getHandler = null;\r\n\r\n\t\tif(!self.sendQuery){\r\n\t\t\thandleDocument = function(data){\r\n\t\t\t\tif(data){\r\n\t\t\t\t\tif(self.keyAttribute !== \"\"){\r\n\t\t\t\t\t\t//We have a key attribute specified.  So ... we can process the items and locate the item\r\n\t\t\t\t\t\t//that contains a matching key attribute.  Its identity, as it were.\r\n\t\t\t\t\t\tvar request = {};\r\n\t\t\t\t\t\trequest.query={};\r\n\t\t\t\t\t\trequest.query[self.keyAttribute] = keywordArgs.identity;\r\n\t\t\t\t\t\trequest.queryOptions = {deep: true};\r\n\t\t\t\t\t\tvar items = self._getItems(data,request);\r\n\t\t\t\t\t\tscope = keywordArgs.scope || kernel.global;\r\n\t\t\t\t\t\tif(items.length === 1){\r\n\t\t\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\t\t\tkeywordArgs.onItem.call(scope, items[0]);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else if(items.length === 0){\r\n\t\t\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\t\t\tkeywordArgs.onItem.call(scope, null);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\t\t\tkeywordArgs.onError.call(scope, new Error(\"Items array size for identity lookup greater than 1, invalid keyAttribute.\"));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//Since dojo.query doesn't really support the functions needed\r\n\t\t\t\t\t\t//to do child node selection on IE well and since xpath support\r\n\t\t\t\t\t\t//is flakey across browsers, it's simpler to implement a\r\n\t\t\t\t\t\t//pseudo-xpath parser here.\r\n\t\t\t\t\t\tvar qArgs = keywordArgs.identity.split(\"/\");\r\n\t\t\t\t\t\tvar i;\r\n\t\t\t\t\t\tvar node = data;\r\n\t\t\t\t\t\tfor(i = 0; i < qArgs.length; i++){\r\n\t\t\t\t\t\t\tif(qArgs[i] && qArgs[i] !== \"\"){\r\n\t\t\t\t\t\t\t\tvar section = qArgs[i];\r\n\t\t\t\t\t\t\t\tsection = section.substring(0,section.length - 1);\r\n\t\t\t\t\t\t\t\tvar vals = section.split(\"[\");\r\n\t\t\t\t\t\t\t\tvar tag = vals[0];\r\n\t\t\t\t\t\t\t\tvar index = parseInt(vals[1], 10);\r\n\t\t\t\t\t\t\t\tvar pos = 0;\r\n\t\t\t\t\t\t\t\tif(node){\r\n\t\t\t\t\t\t\t\t\tvar cNodes = node.childNodes;\r\n\t\t\t\t\t\t\t\t\tif(cNodes){\r\n\t\t\t\t\t\t\t\t\t\tvar j;\r\n\t\t\t\t\t\t\t\t\t\tvar foundNode = null;\r\n\t\t\t\t\t\t\t\t\t\tfor(j = 0; j < cNodes.length; j++){\r\n\t\t\t\t\t\t\t\t\t\t\tvar pNode = cNodes[j];\r\n\t\t\t\t\t\t\t\t\t\t\tif(pNode.nodeName === tag){\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(pos < index){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpos++;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfoundNode = pNode;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tif(foundNode){\r\n\t\t\t\t\t\t\t\t\t\t\tnode = foundNode;\r\n\t\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t\tnode = null;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\tnode = null;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t//Return what we found, if any.\r\n\t\t\t\t\t\tvar item = null;\r\n\t\t\t\t\t\tif(node){\r\n\t\t\t\t\t\t\titem = self._getItem(node);\r\n\t\t\t\t\t\t\tif(item.element.parentNode){\r\n\t\t\t\t\t\t\t\titem.element.parentNode.removeChild(item.element);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\t\tscope = keywordArgs.scope || kernel.global;\r\n\t\t\t\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\turl = this._getFetchUrl(null);\r\n\t\t\tgetArgs = {\r\n\t\t\t\turl: url,\r\n\t\t\t\thandleAs: \"xml\",\r\n\t\t\t\tpreventCache: self.urlPreventCache\r\n\t\t\t};\r\n\t\t\tgetHandler = xhr.get(getArgs);\r\n\t\t\t\r\n\t\t\t//Add in the callbacks for completion of data load.\r\n\t\t\tgetHandler.addCallback(handleDocument);\r\n\t\t\tif(keywordArgs.onError){\r\n\t\t\t\tgetHandler.addErrback(function(error){\r\n\t\t\t\t\tvar s = keywordArgs.scope || kernel.global;\r\n\t\t\t\t\tkeywordArgs.onError.call(s, error);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t//Server side querying, so need to pass the keyAttribute back to the server and let it return\r\n\t\t\t//what it will.  It SHOULD be only one item.\r\n\t\t\tif(self.keyAttribute !== \"\"){\r\n\t\t\t\tvar request = {query:{}};\r\n\t\t\t\trequest.query[self.keyAttribute] = keywordArgs.identity;\r\n\t\t\t\turl = this._getFetchUrl(request);\r\n\t\t\t\thandleDocument = function(data){\r\n\t\t\t\t\tvar item = null;\r\n\t\t\t\t\tif(data){\r\n\t\t\t\t\t\tvar items = self._getItems(data, {});\r\n\t\t\t\t\t\tif(items.length === 1){\r\n\t\t\t\t\t\t\titem = items[0];\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\t\t\tvar scope = keywordArgs.scope || kernel.global;\r\n\t\t\t\t\t\t\t\tkeywordArgs.onError.call(scope, new Error(\"More than one item was returned from the server for the denoted identity\"));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\tscope = keywordArgs.scope || kernel.global;\r\n\t\t\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tgetArgs = {\r\n\t\t\t\t\turl: url,\r\n\t\t\t\t\thandleAs: \"xml\",\r\n\t\t\t\t\tpreventCache: self.urlPreventCache\r\n\t\t\t\t};\r\n\t\t\t\tgetHandler = xhr.get(getArgs);\r\n\r\n\t\t\t\t//Add in the callbacks for completion of data load.\r\n\t\t\t\tgetHandler.addCallback(handleDocument);\r\n\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\tgetHandler.addErrback(function(error){\r\n\t\t\t\t\t\tvar s = keywordArgs.scope || kernel.global;\r\n\t\t\t\t\t\tkeywordArgs.onError.call(s, error);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\tvar s = keywordArgs.scope || kernel.global;\r\n\t\t\t\t\tkeywordArgs.onError.call(s, new Error(\"XmlStore is not told that the server to provides identity support.  No keyAttribute specified.\"));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n\r\nlang.extend(XmlStore,simpleFetch);\r\n\r\nreturn XmlStore;\r\n});\r\n"]}