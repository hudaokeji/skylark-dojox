{"version":3,"sources":["data/JsonRestStore.js"],"names":["define","lang","declare","connect","rpcRest","rpcJsonRest","jsonSchema","ServiceStore","rpc","getObject","JsonRestStore","constructor","options","_index","this","obj","attrName","oldValue","newValue","prefix","service","servicePath","__id","substring","length","onSet","console","log","idAttribute","target","match","allowNoTrailingSlash","services","registerService","schema","_schema","_store","idAsRef","_idAttr","getConstructor","self","_constructor","data","call","onNew","prototype","loadReferencedSchema","referenceIntegrity","newItem","parentInfo","values","getValue","parent","attribute","concat","__parent","setValue","deleteItem","item","checked","store","dataExtCfg","_getStoreForItem","_saveNotNeeded","index","fixReferences","toSplice","i","push","__checked","value","Array","unsetAttribute","splice","deleteObject","onDelete","changing","_deleting","cancelChanging","object","dirtyObjects","dirty","getDirtyObjects","old","properties","mustBeValid","checkPropertyChange","Error","setValues","isArray","undefined","save","kwArgs","global","syncMode","_sync","actions","commit","serverVersion","_updates","revert","isDirty","isItem","anyStore","getServiceAndId","_doQuery","args","query","queryStr","deferred","addCallback","result","contentType","ioArgs","xhr","getResponseHeader","schemaRef","serviceAndId","replace","schemaDeferred","byId","id","addCallbacks","newSchema","mixin","error","_processResults","results","count","totalCount","fullLength","request","start","items","getIdentity","__clientId","fetchItemByIdentity","identity","toString","_prefix","inherited","arguments","getFeatures","features","getParent","getStore","Class","_useRefs"],"mappings":"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","file":"../../data/JsonRestStore.js","sourcesContent":["define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/connect\", \"dojox/rpc/Rest\", \r\n\t\t\"dojox/rpc/JsonRest\", \"dojox/json/schema\", \"dojox/data/ServiceStore\"], \r\n  function(lang, declare, connect, rpcRest, rpcJsonRest, jsonSchema, ServiceStore) {\r\n\r\nvar rpc = lang.getObject(\"dojox.rpc\", true);\r\n\r\nvar JsonRestStore = declare(\"dojox.data.JsonRestStore\", ServiceStore,\r\n\t{\r\n\t\tconstructor: function(options){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tJsonRestStore is a Dojo Data store interface to JSON HTTP/REST web\r\n\t\t\t//\t\tstorage services that support read and write through GET, PUT, POST, and DELETE.\r\n\t\t\t// options:\r\n\t\t\t//\t\tKeyword arguments\r\n\t\t\t//\r\n\t\t\t//\t\t####The *schema* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tThis is a schema object for this store. This should be JSON Schema format.\r\n\t\t\t//\r\n\t\t\t//\t\t####The *service* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tThis is the service object that is used to retrieve lazy data and save results\r\n\t\t\t//\t\tThe function should be directly callable with a single parameter of an object id to be loaded\r\n\t\t\t//\t\tThe function should also have the following methods:\r\n\t\t\t//\r\n\t\t\t//\t\t- put(id,value) - puts the value at the given id\r\n\t\t\t//\t\t- post(id,value) - posts (appends) the value at the given id\r\n\t\t\t//\t\t- delete(id) - deletes the value corresponding to the given id\r\n\t\t\t//\r\n\t\t\t//\t\tNote that it is critical that the service parses responses as JSON.\r\n\t\t\t//\t\tIf you are using dojox.rpc.Service, the easiest way to make sure this\r\n\t\t\t//\t\thappens is to make the responses have a content type of\r\n\t\t\t//\t\tapplication/json. If you are creating your own service, make sure you\r\n\t\t\t//\t\tuse handleAs: \"json\" with your XHR requests.\r\n\t\t\t//\r\n\t\t\t//\t\t####The *target* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tThis is the target URL for this Service store. This may be used in place\r\n\t\t\t//\t\tof a service parameter to connect directly to RESTful URL without\r\n\t\t\t//\t\tusing a dojox.rpc.Service object.\r\n\t\t\t//\r\n\t\t\t//\t\t####The *idAttribute* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tDefaults to 'id'. The name of the attribute that holds an objects id.\r\n\t\t\t//\t\tThis can be a preexisting id provided by the server.\r\n\t\t\t//\t\tIf an ID isn't already provided when an object\r\n\t\t\t//\t\tis fetched or added to the store, the autoIdentity system\r\n\t\t\t//\t\twill generate an id for it and add it to the index.\r\n\t\t\t//\r\n\t\t\t//\t\t####The *syncMode* parameter\r\n\t\t\t//\r\n\t\t\t//\t\tSetting this to true will set the store to using synchronous calls by default.\r\n\t\t\t//\t\tSync calls return their data immediately from the calling function, so\r\n\t\t\t//\t\tcallbacks are unnecessary\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).\r\n\t\t\t//\t\tWhen using a Rest store on a public network, it is important to implement proper security measures to\r\n\t\t\t//\t\tcontrol access to resources.\r\n\t\t\t//\r\n\t\t\t//\t\tOn the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.\r\n\t\t\t//\r\n\t\t\t//\t\t- GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a\r\n\t\t\t//\t\t\tquery (like /table/?name=foo).\r\n\t\t\t//\t\t- PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will\r\n\t\t\t//\t\t\tprovide the modified object\r\n\t\t\t//\t\t- POST - This should create a new object. The URL will correspond to the target store (like /table/)\r\n\t\t\t//\t\t\tand the body should be the properties of the new object. The server's response should include a\r\n\t\t\t//\t\t\tLocation header that indicates the id of the newly created object. This id will be used for subsequent\r\n\t\t\t//\t\t\tPUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates\r\n\t\t\t//\t\t\tthe temporary randomly generated id used by client, and this location is used for subsequent\r\n\t\t\t//\t\t\tPUT/DELETEs if no Location header is provided by the server or if a modification is sent prior\r\n\t\t\t//\t\t\tto receiving a response from the server.\r\n\t\t\t//\t\t- DELETE - This should delete an object by id.\r\n\t\t\t//\r\n\t\t\t//\t\tThese articles include more detailed information on using the JsonRestStore:\r\n\t\t\t//\r\n\t\t\t//\t\t- http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/\r\n\t\t\t//\t\t- http://blog.medryx.org/2008/07/24/jsonreststore-overview/\r\n\t\t\t// example:\r\n\t\t\t//\t\tA JsonRestStore takes a REST service or a URL and uses it the remote communication for a\r\n\t\t\t//\t\tread/write dojo.data implementation. A JsonRestStore can be created with a simple URL like:\r\n\t\t\t//\t|\tnew JsonRestStore({target:\"/MyData/\"});\r\n\t\t\t// example:\r\n\t\t\t//\t\tTo use a JsonRestStore with a service, you should create a\r\n\t\t\t//\t\tservice with a REST transport. This can be configured with an SMD:\r\n\t\t\t//\t|\t{\r\n\t\t\t//\t|\t\tservices: {\r\n\t\t\t//\t|\t\t\tjsonRestStore: {\r\n\t\t\t//\t|\t\t\t\ttransport: \"REST\",\r\n\t\t\t//\t|\t\t\t\tenvelope: \"URL\",\r\n\t\t\t//\t|\t\t\t\ttarget: \"store.php\",\r\n\t\t\t//\t|\t\t\t\tcontentType:\"application/json\",\r\n\t\t\t//\t|\t\t\t\tparameters: [\r\n\t\t\t//\t|\t\t\t\t\t{name: \"location\", type: \"string\", optional: true}\r\n\t\t\t//\t|\t\t\t\t]\r\n\t\t\t//\t|\t\t\t}\r\n\t\t\t//\t|\t\t}\r\n\t\t\t//\t|\t}\r\n\t\t\t//\t\tThe SMD can then be used to create service, and the service can be passed to a JsonRestStore. For example:\r\n\t\t\t//\t|\tvar myServices = new dojox.rpc.Service(dojo.moduleUrl(\"dojox.rpc.tests.resources\", \"test.smd\"));\r\n\t\t\t//\t|\tvar jsonStore = new dojox.data.JsonRestStore({service:myServices.jsonRestStore});\r\n\t\t\t// example:\r\n\t\t\t//\t\tThe JsonRestStore also supports lazy loading. References can be made to objects that have not been loaded.\r\n\t\t\t//\t\tFor example if a service returned:\r\n\t\t\t//\t|\t{\"name\":\"Example\",\"lazyLoadedObject\":{\"$ref\":\"obj2\"}}\r\n\t\t\t//\t\tAnd this object has accessed using the dojo.data API:\r\n\t\t\t//\t|\tvar obj = jsonStore.getValue(myObject,\"lazyLoadedObject\");\r\n\t\t\t//\t\tThe object would automatically be requested from the server (with an object id of \"obj2\").\r\n\r\n\t\t\tconnect.connect(rpcRest._index,\"onUpdate\",this,function(obj,attrName,oldValue,newValue){\r\n\t\t\t\tvar prefix = this.service.servicePath;\r\n\t\t\t\tif(!obj.__id){\r\n\t\t\t\t\tconsole.log(\"no id on updated object \", obj);\r\n\t\t\t\t}else if(obj.__id.substring(0,prefix.length) == prefix){\r\n\t\t\t\t\tthis.onSet(obj,attrName,oldValue,newValue);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tthis.idAttribute = this.idAttribute || 'id';// no options about it, we have to have identity\r\n\r\n\t\t\tif(typeof options.target == 'string'){\r\n\t\t\t\toptions.target = options.target.match(/\\/$/) || this.allowNoTrailingSlash ? options.target : (options.target + '/');\r\n\t\t\t\tif(!this.service){\r\n\t\t\t\t\tthis.service = rpcJsonRest.services[options.target] ||\r\n\t\t\t\t\t\t\trpcRest(options.target, true);\r\n\t\t\t\t\t// create a default Rest service\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\trpcJsonRest.registerService(this.service, options.target, this.schema);\r\n\t\t\tthis.schema = this.service._schema = this.schema || this.service._schema || {};\r\n\t\t\t// wrap the service with so it goes through JsonRest manager\r\n\t\t\tthis.service._store = this;\r\n\t\t\tthis.service.idAsRef = this.idAsRef;\r\n\t\t\tthis.schema._idAttr = this.idAttribute;\r\n\t\t\tvar constructor = rpcJsonRest.getConstructor(this.service);\r\n\t\t\tvar self = this;\r\n\t\t\tthis._constructor = function(data){\r\n\t\t\t\tconstructor.call(this, data);\r\n\t\t\t\tself.onNew(this);\r\n\t\t\t}\r\n\t\t\tthis._constructor.prototype = constructor.prototype;\r\n\t\t\tthis._index = rpcRest._index;\r\n\t\t},\r\n\t\t\r\n\t\t// loadReferencedSchema: Boolean\r\n\t\t//\t\tWill load any schemas referenced content-type header or in Link headers\r\n\t\tloadReferencedSchema: true,\r\n\t\t\r\n\t\t// idAsRef: Boolean\r\n\t\t//\t\tTreat objects in queries as partially loaded objects\r\n\t\tidAsRef: false,\r\n\t\t\r\n\t\treferenceIntegrity: true,\r\n\t\ttarget:\"\",\r\n\t\t\r\n\t\t// allowNoTrailingSlash: Boolean\r\n\t\t//\t\tAllow no trailing slash on target paths. This is generally discouraged since\r\n\t\t//\t\tit creates prevents simple scalar values from being used a relative URLs.\r\n\t\t//\t\tDisabled by default.\r\n\t\tallowNoTrailingSlash: false,\r\n\t\t\r\n\t\t//Write API Support\r\n\t\tnewItem: function(data, parentInfo){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tadds a new item to the store at the specified point.\r\n\t\t\t//\t\tTakes two parameters, data, and options.\r\n\t\t\t// data: Object\r\n\t\t\t//\t\tThe data to be added in as an item.\r\n\t\t\tdata = new this._constructor(data);\r\n\t\t\tif(parentInfo){\r\n\t\t\t\t// get the previous value or any empty array\r\n\t\t\t\tvar values = this.getValue(parentInfo.parent,parentInfo.attribute,[]);\r\n\t\t\t\t// set the new value\r\n\t\t\t\tvalues = values.concat([data]);\r\n\t\t\t\tdata.__parent = values;\r\n\t\t\t\tthis.setValue(parentInfo.parent, parentInfo.attribute, values);\r\n\t\t\t}\r\n\t\t\treturn data;\r\n\t\t},\r\n\t\tdeleteItem: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tdeletes item and any references to that item from the store.\r\n\t\t\t// item:\r\n\t\t\t//\t\titem to delete\r\n\r\n\t\t\t//\tIf the desire is to delete only one reference, unsetAttribute or\r\n\t\t\t//\tsetValue is the way to go.\r\n\t\t\tvar checked = [];\r\n\t\t\tvar store = dataExtCfg._getStoreForItem(item) || this;\r\n\t\t\tif(this.referenceIntegrity){\r\n\t\t\t\t// cleanup all references\r\n\t\t\t\trpcJsonRest._saveNotNeeded = true;\r\n\t\t\t\tvar index = rpcRest._index;\r\n\t\t\t\tvar fixReferences = function(parent){\r\n\t\t\t\t\tvar toSplice;\r\n\t\t\t\t\t// keep track of the checked ones\r\n\t\t\t\t\tchecked.push(parent);\r\n\t\t\t\t\t// mark it checked so we don't run into circular loops when encountering cycles\r\n\t\t\t\t\tparent.__checked = 1;\r\n\t\t\t\t\tfor(var i in parent){\r\n\t\t\t\t\t\tif(i.substring(0,2) != \"__\"){\r\n\t\t\t\t\t\t\tvar value = parent[i];\r\n\t\t\t\t\t\t\tif(value == item){\r\n\t\t\t\t\t\t\t\tif(parent != index){ // make sure we are just operating on real objects\r\n\t\t\t\t\t\t\t\t\tif(parent instanceof Array){\r\n\t\t\t\t\t\t\t\t\t\t// mark it as needing to be spliced, don't do it now or it will mess up the index into the array\r\n\t\t\t\t\t\t\t\t\t\t(toSplice = toSplice || []).push(i);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\t// property, just delete it.\r\n\t\t\t\t\t\t\t\t\t\t(dataExtCfg._getStoreForItem(parent) || store).unsetAttribute(parent, i);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tif((typeof value == 'object') && value){\r\n\t\t\t\t\t\t\t\t\tif(!value.__checked){\r\n\t\t\t\t\t\t\t\t\t\t// recursively search\r\n\t\t\t\t\t\t\t\t\t\tfixReferences(value);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif(typeof value.__checked == 'object' && parent != index){\r\n\t\t\t\t\t\t\t\t\t\t// if it is a modified array, we will replace it\r\n\t\t\t\t\t\t\t\t\t\t(dataExtCfg._getStoreForItem(parent) || store).setValue(parent, i, value.__checked);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(toSplice){\r\n\t\t\t\t\t\t// we need to splice the deleted item out of these arrays\r\n\t\t\t\t\t\ti = toSplice.length;\r\n\t\t\t\t\t\tparent = parent.__checked = parent.concat(); // indicates that the array is modified\r\n\t\t\t\t\t\twhile(i--){\r\n\t\t\t\t\t\t\tparent.splice(toSplice[i], 1);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t};\r\n\t\t\t\t// start with the index\r\n\t\t\t\tfixReferences(index);\r\n\t\t\t\trpcJsonRest._saveNotNeeded = false;\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\twhile(checked[i]){\r\n\t\t\t\t\t// remove the checked marker\r\n\t\t\t\t\tdelete checked[i++].__checked;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trpcJsonRest.deleteObject(item);\r\n\r\n\t\t\tstore.onDelete(item);\r\n\t\t},\r\n\t\tchanging: function(item,_deleting){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tadds an item to the list of dirty items.\tThis item\r\n\t\t\t//\t\tcontains a reference to the item itself as well as a\r\n\t\t\t//\t\tcloned and trimmed version of old item for use with\r\n\t\t\t//\t\trevert.\r\n\t\t\trpcJsonRest.changing(item,_deleting);\r\n\t\t},\r\n\t\tcancelChanging : function(object){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRemoves an object from the list of dirty objects\r\n\t\t\t//\t\tThis will prevent that object from being saved to the server on the next save\r\n\t\t\t// object:\r\n\t\t\t//\t\tThe item to cancel changes on\r\n\t\t\tif(!object.__id){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tdirtyObjects = dirty=rpcJsonRest.getDirtyObjects();\r\n\t\t\tfor(var i=0; i<dirtyObjects.length; i++){\r\n\t\t\t\tvar dirty = dirtyObjects[i];\r\n\t\t\t\tif(object==dirty.object){\r\n\t\t\t\t\tdirtyObjects.splice(i, 1);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\r\n\t\tsetValue: function(item, attribute, value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets 'attribute' on 'item' to 'value'\r\n\r\n\t\t\tvar old = item[attribute];\r\n\t\t\tvar store = item.__id ? dataExtCfg._getStoreForItem(item) : this;\r\n\t\t\tif(jsonSchema && store.schema && store.schema.properties){\r\n\t\t\t\t// if we have a schema and schema validator available we will validate the property change\r\n\t\t\t\tjsonSchema.mustBeValid(jsonSchema.checkPropertyChange(value,store.schema.properties[attribute]));\r\n\t\t\t}\r\n\t\t\tif(attribute == store.idAttribute){\r\n\t\t\t\tthrow new Error(\"Can not change the identity attribute for an item\");\r\n\t\t\t}\r\n\t\t\tstore.changing(item);\r\n\t\t\titem[attribute]=value;\r\n\t\t\tif(value && !value.__parent){\r\n\t\t\t\tvalue.__parent = item;\r\n\t\t\t}\r\n\t\t\tstore.onSet(item,attribute,old,value);\r\n\t\t},\r\n\t\tsetValues: function(item, attribute, values){\r\n\t\t\t// summary:\r\n\t\t\t//\tsets 'attribute' on 'item' to 'value' value\r\n\t\t\t//\tmust be an array.\r\n\r\n\r\n\t\t\tif(!lang.isArray(values)){\r\n\t\t\t\tthrow new Error(\"setValues expects to be passed an Array object as its value\");\r\n\t\t\t}\r\n\t\t\tthis.setValue(item,attribute,values);\r\n\t\t},\r\n\r\n\t\tunsetAttribute: function(item, attribute){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tunsets 'attribute' on 'item'\r\n\r\n\t\t\tthis.changing(item);\r\n\t\t\tvar old = item[attribute];\r\n\t\t\tdelete item[attribute];\r\n\t\t\tthis.onSet(item,attribute,old,undefined);\r\n\t\t},\r\n\t\tsave: function(kwArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSaves the dirty data using REST Ajax methods. See dojo/data/api/Write for API.\r\n\t\t\t// kwArgs:\r\n\t\t\t//\t\t- global:\r\n\t\t\t//\t\t\tThis will cause the save to commit the dirty data for all\r\n\t\t\t//\t\t\tJsonRestStores as a single transaction.\r\n\t\t\t//\t\t- revertOnError:\r\n\t\t\t//\t\t\tThis will cause the changes to be reverted if there is an\r\n\t\t\t//\t\t\terror on the save. By default a revert is executed unless\r\n\t\t\t//\t\t\ta value of false is provide for this parameter.\r\n\t\t\t//\t\t- incrementalUpdates:\r\n\t\t\t//\t\t\tFor items that have been updated, if this is enabled, the server will be sent a POST request\r\n\t\t\t//\t\t\twith a JSON object containing the changed properties. By default this is\r\n\t\t\t//\t\t\tnot enabled, and a PUT is used to deliver an update, and will include a full\r\n\t\t\t//\t\t\tserialization of all the properties of the item/object.\r\n\t\t\t//\t\t\tIf this is true, the POST request body will consist of a JSON object with\r\n\t\t\t//\t\t\tonly the changed properties. The incrementalUpdates parameter may also\r\n\t\t\t//\t\t\tbe a function, in which case it will be called with the updated and previous objects\r\n\t\t\t//\t\t\tand an object update representation can be returned.\r\n\t\t\t//\t\t- alwaysPostNewItems:\r\n\t\t\t//\t\t\tIf this is true, new items will always be sent with a POST request. By default\r\n\t\t\t//\t\t\tthis is not enabled, and the JsonRestStore will send a POST request if\r\n\t\t\t//\t\t\tthe item does not include its identifier (expecting server assigned location/\r\n\t\t\t//\t\t\tidentifier), and will send a PUT request if the item does include its identifier\r\n\t\t\t//\t\t\t(the PUT will be sent to the URI corresponding to the provided identifier).\r\n\r\n\t\t\tif(!(kwArgs && kwArgs.global)){\r\n\t\t\t\t(kwArgs = kwArgs || {}).service = this.service;\r\n\t\t\t}\r\n\t\t\tif(\"syncMode\" in kwArgs ? kwArgs.syncMode : this.syncMode){\r\n\t\t\t\trpc._sync = true;\r\n\t\t\t}\r\n\r\n\t\t\tvar actions = rpcJsonRest.commit(kwArgs);\r\n\t\t\tthis.serverVersion = this._updates && this._updates.length;\r\n\t\t\treturn actions;\r\n\t\t},\r\n\r\n\t\trevert: function(kwArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns any modified data to its original state prior to a save();\r\n\t\t\t// kwArgs:\r\n\t\t\t//\t\t- global:\r\n\t\t\t//\t\t\tThis will cause the revert to undo all the changes for all\r\n\t\t\t//\t\t\tJsonRestStores in a single operation.\r\n\t\t\trpcJsonRest.revert(!(kwArgs && kwArgs.global) && this.service);\r\n\t\t},\r\n\r\n\t\tisDirty: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns true if the item is marked as dirty.\r\n\t\t\treturn rpcJsonRest.isDirty(item, this);\r\n\t\t},\r\n\t\tisItem: function(item, anyStore){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tChecks to see if a passed 'item'\r\n\t\t\t//\t\treally belongs to this JsonRestStore.\r\n\t\t\t// item: Object\r\n\t\t\t//\t\tThe value to test for being an item\r\n\t\t\t// anyStore: Boolean\r\n\t\t\t//\t\tIf true, this will return true if the value is an item for any JsonRestStore,\r\n\t\t\t//\t\tnot just this instance\r\n\t\t\treturn item && item.__id && (anyStore || this.service == rpcJsonRest.getServiceAndId(item.__id).service);\r\n\t\t},\r\n\t\t_doQuery: function(args){\r\n\t\t\tvar query= typeof args.queryStr == 'string' ? args.queryStr : args.query;\r\n\t\t\tvar deferred = rpcJsonRest.query(this.service,query, args);\r\n\t\t\tvar self = this;\r\n\t\t\tif(this.loadReferencedSchema){\r\n\t\t\t\tdeferred.addCallback(function(result){\r\n\t\t\t\t\tvar contentType = deferred.ioArgs && deferred.ioArgs.xhr && deferred.ioArgs.xhr.getResponseHeader(\"Content-Type\");\r\n\t\t\t\t\tvar schemaRef = contentType && contentType.match(/definedby\\s*=\\s*([^;]*)/);\r\n\t\t\t\t\tif(contentType && !schemaRef){\r\n\t\t\t\t\t\tschemaRef = deferred.ioArgs.xhr.getResponseHeader(\"Link\");\r\n\t\t\t\t\t\tschemaRef = schemaRef && schemaRef.match(/<([^>]*)>;\\s*rel=\"?definedby\"?/);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tschemaRef = schemaRef && schemaRef[1];\r\n\t\t\t\t\tif(schemaRef){\r\n\t\t\t\t\t\tvar serviceAndId = rpcJsonRest.getServiceAndId((self.target + schemaRef).replace(/^(.*\\/)?(\\w+:\\/\\/)|[^\\/\\.]+\\/\\.\\.\\/|^.*\\/(\\/)/,\"$2$3\"));\r\n\t\t\t\t\t\tvar schemaDeferred = rpcJsonRest.byId(serviceAndId.service, serviceAndId.id);\r\n\t\t\t\t\t\tschemaDeferred.addCallbacks(function(newSchema){\r\n\t\t\t\t\t\t\tlang.mixin(self.schema, newSchema);\r\n\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t}, function(error){\r\n\t\t\t\t\t\t\tconsole.error(error); // log it, but don't let it cause the main request to fail\r\n\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\treturn schemaDeferred;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn undefined;//don't change anything, and deal with the stupid post-commit lint complaints\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\treturn deferred;\r\n\t\t},\r\n\t\t_processResults: function(results, deferred){\r\n\t\t\t// index the results\r\n\t\t\tvar count = results.length;\r\n\t\t\t// if we don't know the length, and it is partial result, we will guess that it is twice as big, that will work for most widgets\r\n\t\t\treturn {totalCount:deferred.fullLength || (deferred.request.count == count ? (deferred.request.start || 0) + count * 2 : count), items: results};\r\n\t\t},\r\n\r\n\t\tgetConstructor: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGets the constructor for objects from this store\r\n\t\t\treturn this._constructor;\r\n\t\t},\r\n\t\tgetIdentity: function(item){\r\n\t\t\tvar id = item.__clientId || item.__id;\r\n\t\t\tif(!id){\r\n\t\t\t\treturn id;\r\n\t\t\t}\r\n\t\t\tvar prefix = this.service.servicePath.replace(/[^\\/]*$/,'');\r\n\t\t\t// support for relative or absolute referencing with ids\r\n\t\t\treturn id.substring(0,prefix.length) != prefix ?\tid : id.substring(prefix.length); // String\r\n\t\t},\r\n\t\tfetchItemByIdentity: function(args){\r\n\t\t\tvar id = args.identity;\r\n\t\t\tvar store = this;\r\n\t\t\t// if it is an absolute id, we want to find the right store to query\r\n\t\t\tif(id.toString().match(/^(\\w*:)?\\//)){\r\n\t\t\t\tvar serviceAndId = rpcJsonRest.getServiceAndId(id);\r\n\t\t\t\tstore = serviceAndId.service._store;\r\n\t\t\t\targs.identity = serviceAndId.id;\r\n\t\t\t}\r\n\t\t\targs._prefix = store.service.servicePath.replace(/[^\\/]*$/,'');\r\n\t\t\treturn store.inherited(arguments);\r\n\t\t},\r\n\t\t//Notifcation Support\r\n\r\n\t\tonSet: function(){},\r\n\t\tonNew: function(){},\r\n\t\tonDelete: function(){},\r\n\r\n\t\tgetFeatures: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturn the store feature set\r\n\t\t\tvar features = this.inherited(arguments);\r\n\t\t\tfeatures[\"dojo.data.api.Write\"] = true;\r\n\t\t\tfeatures[\"dojo.data.api.Notification\"] = true;\r\n\t\t\treturn features;\r\n\t\t},\r\n\r\n\t\tgetParent: function(item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the parent item (or query) for the given item\r\n\t\t\t// item:\r\n\t\t\t//\t\tThe item to find the parent of\r\n\r\n\t\t\treturn item && item.__parent;\r\n\t\t}\r\n\r\n\r\n\t}\r\n);\r\nJsonRestStore.getStore = function(options, Class){\r\n\t// summary:\r\n\t//\t\tWill retrieve or create a store using the given options (the same options\r\n\t//\t\tthat are passed to JsonRestStore constructor. Returns a JsonRestStore instance\r\n\t// options:\r\n\t//\t\tSee the JsonRestStore constructor\r\n\t// Class:\r\n\t//\t\tConstructor to use (for creating stores from JsonRestStore subclasses).\r\n\t//\t\tThis is optional and defaults to JsonRestStore.\r\n\tif(typeof options.target == 'string'){\r\n\t\toptions.target = options.target.match(/\\/$/) || options.allowNoTrailingSlash ?\r\n\t\t\t\toptions.target : (options.target + '/');\r\n\t\tvar store = (rpcJsonRest.services[options.target] || {})._store;\r\n\t\tif(store){\r\n\t\t\treturn store;\r\n\t\t}\r\n\t}\r\n\treturn new (Class || JsonRestStore)(options);\r\n};\r\n\r\nvar dataExtCfg = lang.getObject(\"dojox.data\",true); \r\ndataExtCfg._getStoreForItem = function(item){\r\n\tif(item.__id){\r\n\t\tvar serviceAndId = rpcJsonRest.getServiceAndId(item.__id);\r\n\t\tif(serviceAndId && serviceAndId.service._store){\r\n\t\t\treturn serviceAndId.service._store;\r\n\t\t}else{\r\n\t\t\tvar servicePath = item.__id.toString().match(/.*\\//)[0];\r\n\t\t\treturn new JsonRestStore({target:servicePath});\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\nvar jsonRefConfig = lang.getObject(\"dojox.json.ref\", true);\r\njsonRefConfig._useRefs = true; // Use referencing when identifiable objects are referenced\r\n\r\nreturn JsonRestStore;\r\n});\r\n"]}