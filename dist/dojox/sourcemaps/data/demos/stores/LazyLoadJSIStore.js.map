{"version":3,"sources":["data/demos/stores/LazyLoadJSIStore.js"],"names":["dojo","provide","require","declare","data","ItemFileReadStore","constructor","keywordParameters","isItemLoaded","item","this","getValue","loadItem","keywordArgs","_assertIsItem","itemName","parent","dataUrl","self","xhrArgs","url","handleAs","d","xhrGet","addCallback","i","type","isArray","_arrayOfAllItems","_itemNumPropName","attributes","getAttributes","values","j","length","value","stub","name","push","_storeRefPropName","onItem","scope","global","call","addErrback","error","onError"],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,4CACbD,KAAKE,QAAQ,+BAEbF,KAAKG,QAAQ,2CAA4CH,KAAKI,KAAKC,mBAClEC,YAAa,SAAsBC,KAOnCC,aAAc,SAAoBC,GASjC,MAAmC,SAAhCC,KAAKC,SAASF,EAAM,SAMxBG,SAAU,SAASC,GASlB,IAAIJ,EAAOI,EAAYJ,KACvBC,KAAKI,cAAcL,GAKnB,IAAIM,EAAWL,KAAKC,SAASF,EAAM,QAC/BO,EAAWN,KAAKC,SAASF,EAAM,UAC/BQ,EAAW,GACXD,IACHC,GAAYD,EAAS,KAOtB,IAAIE,EAAOR,KA0EPS,GACHC,IA9EDH,GAAWF,EAAW,aA+ErBM,SAAU,yBAEPC,EAAItB,KAAKuB,OAAOJ,GACpBG,EAAEE,YA5EY,SAASpB,GAatB,IAAK,IAAIqB,YAJFhB,EAAKiB,YACLjB,EAAKO,OAGEZ,EACTJ,KAAK2B,QAAQvB,EAAKqB,IACrBhB,EAAKgB,GAAKrB,EAAKqB,GAEfhB,EAAKgB,IAAMrB,EAAKqB,IAKlBP,EAAKU,iBAAiBnB,EAAKS,EAAKW,mBAAqBpB,EAIrD,IAAIqB,EAAaZ,EAAKa,cAActB,GACpC,IAAIgB,KAAKK,EAER,IADA,IAAIE,EAASvB,EAAKqB,EAAWL,IACpBQ,EAAI,EAAGA,EAAID,EAAOE,OAAQD,IAAK,CACvC,IAAIE,EAAQH,EAAOC,GAEnB,GAAoB,iBAAVE,GACNA,EAAY,KAAG,CAEjB,IAAIC,GACHV,MAAO,QACPW,MAAOF,EAAY,MACnBnB,QAASD,IAENC,IAEHoB,EAAKpB,OAAO,GAAKA,EAAS,IAAMoB,EAAKpB,OAAO,IAG7CE,EAAKU,iBAAiBU,KAAKF,GAC3BA,EAAKlB,EAAKqB,mBAAqBrB,EAC/BkB,EAAKlB,EAAKW,kBAAqBX,EAAKU,iBAAiBM,OAAS,EAC9DF,EAAOC,GAAKG,GAOhB,GAAGvB,EAAY2B,OAAO,CACrB,IAAIC,EAAQ5B,EAAY4B,MAAQ5B,EAAY4B,MAAQzC,KAAK0C,OACzD7B,EAAY2B,OAAOG,KAAKF,EAAOhC,MAoBjCa,EAAEsB,WAfa,SAASC,GAEvB,GAAGhC,EAAYiC,QAAQ,CACtB,IAAIL,EAAQ5B,EAAY4B,MAAQ5B,EAAY4B,MAAQzC,KAAK0C,OACzD7B,EAAYiC,QAAQH,KAAKF,EAAOI","file":"../../../../data/demos/stores/LazyLoadJSIStore.js","sourcesContent":["dojo.provide(\"dojox.data.demos.stores.LazyLoadJSIStore\");\r\ndojo.require(\"dojo.data.ItemFileReadStore\");\r\n\r\ndojo.declare(\"dojox.data.demos.stores.LazyLoadJSIStore\", dojo.data.ItemFileReadStore, {\r\n\tconstructor: function(/* object */ keywordParameters){\r\n\t\t// LazyLoadJSIStore extends ItemFileReadStore to implement an\r\n\t\t// example of lazy-loading/faulting in items on-demand.\r\n\t\t// Note this is certianly not a perfect implementation, it is\r\n\t\t// an example.\r\n\t},\r\n\t\r\n\tisItemLoaded: function(/*object*/ item) {\r\n\t\t// summary:\r\n\t\t//\t\tOverload of the isItemLoaded function to look for items of type 'stub', which indicate\r\n\t\t//\t\tthe data hasn't been loaded in yet.\r\n\t\t// item:\r\n\t\t//\t\tThe item to examine.\r\n\t\t\r\n\t\t//For this store, if it has the value of stub for its type attribute,\r\n\t\t//then the item basn't been fully loaded yet.  It's just a placeholder.\r\n\t\tif(this.getValue(item, \"type\") === \"stub\"){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t},\r\n\t\t\r\n\tloadItem: function(keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tOverload of the loadItem function to fault in items.  This assumes the data for an item is laid out\r\n\t\t//\t\tin a RESTful sort of pattern name0/name1/data.json and so on and uses that to load the data.\r\n\t\t//\t\tIt will also detect stub items in the newly loaded item and insert the stubs into the ItemFileReadStore\r\n\t\t//\t\tlist so they can also be loaded in on-demand.\r\n\t\t// item:\r\n\t\t//\t\tThe item to examine.\r\n\r\n\t\tvar item = keywordArgs.item;\r\n\t\tthis._assertIsItem(item);\r\n\r\n\t\t//Build the path to the data.json for this item\r\n\t\t//The path consists of where its parent was loaded from\r\n\t\t//plus the item name.\r\n\t\tvar itemName = this.getValue(item, \"name\");\r\n\t\tvar parent   = this.getValue(item, \"parent\");\r\n\t\tvar dataUrl  = \"\";\r\n\t\tif (parent){\r\n\t\t\tdataUrl += (parent + \"/\");\r\n\t\t}\r\n\r\n\t\t//For this store, all child input data is loaded from a url that ends with data.json\r\n\t\tdataUrl += itemName + \"/data.json\";\r\n\r\n\t\t//Need a reference to the store to call back to its structures.\r\n\t\tvar self = this;\r\n\r\n\t\t// Callback for handling a successful load.\r\n\t\tvar gotData = function(data){\r\n\t\t\t//Now we need to modify the existing item a bit to take it out of stub state\r\n\t\t\t//Since we extend the store and have knowledge of the internal\r\n\t\t\t//structure, this can be done here.  Now, is we extended\r\n\t\t\t//a write store, we could call the write APIs to do this too\r\n\t\t\t//But for a simple demo the diretc modification in the store function\r\n\t\t\t//is sufficient.\r\n\r\n\t\t\t//Clear off the stub indicators.\r\n\t\t\tdelete item.type;\r\n\t\t\tdelete item.parent;\r\n\r\n\t\t\t//Set up the loaded values in the format ItemFileReadStore uses for attributes.\r\n\t\t\tfor (var i in data) {\r\n\t\t\t\tif (dojo.isArray(data[i])) {\r\n\t\t\t\t\titem[i] = data[i];\r\n\t\t\t\t}else{\r\n\t\t\t\t\titem[i] = [data[i]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Reset the item in the reference.\r\n\t\t\tself._arrayOfAllItems[item[self._itemNumPropName]] = item;\r\n\r\n\t\t\t//Scan the new values in the item for extra stub items we need to\r\n\t\t\t//add to the items array of the store so they can be lazy-loaded later...\r\n\t\t\tvar attributes = self.getAttributes(item);\r\n\t\t\tfor(i in attributes){\r\n\t\t\t\tvar values = item[attributes[i]];\r\n\t\t\t\tfor (var j = 0; j < values.length; j++) {\r\n\t\t\t\t\tvar value = values[j];\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(typeof value === \"object\"){\r\n\t\t\t\t\t\tif(value[\"stub\"] ){\r\n\t\t\t\t\t\t\t//We have a stub reference here, we need to create the stub item\r\n\t\t\t\t\t\t\tvar stub = {\r\n\t\t\t\t\t\t\t\ttype: [\"stub\"],\r\n\t\t\t\t\t\t\t\tname: [value[\"stub\"]],\r\n\t\t\t\t\t\t\t\tparent: [itemName]\t\t//The child stub item is parented by this item name...\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tif (parent) {\r\n\t\t\t\t\t\t\t\t//Add in any parents to your parent so URL construstruction is accurate.\r\n\t\t\t\t\t\t\t\tstub.parent[0] = parent + \"/\" + stub.parent[0];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//Finalize the addition of the new stub item into the ItemFileReadStore list.\r\n\t\t\t\t\t\t\tself._arrayOfAllItems.push(stub);\r\n\t\t\t\t\t\t\tstub[self._storeRefPropName] = self;\r\n\t\t\t\t\t\t\tstub[self._itemNumPropName] = (self._arrayOfAllItems.length - 1); //Last one pushed in should be the item\r\n\t\t\t\t\t\t\tvalues[j] = stub; //Set the stub item back in its place and replace the stub notation.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Done processing!  Call the onItem, if any.\r\n\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\tvar scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;\r\n\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t//Callback for any errors that occur during load.\r\n\t\tvar gotError = function(error){\r\n\t\t\t//Call the onComplete, if any\r\n\t\t\tif(keywordArgs.onError){\r\n\t\t\t\tvar scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;\r\n\t\t\t\tkeywordArgs.onError.call(scope, error);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t//Fire the get and pass the proper callbacks to the deferred.\r\n\t\tvar xhrArgs = {\r\n\t\t\turl: dataUrl,\r\n\t\t\thandleAs: \"json-comment-optional\"\r\n\t\t};\r\n\t\tvar d = dojo.xhrGet(xhrArgs);\r\n\t\td.addCallback(gotData);\r\n\t\td.addErrback(gotError);\r\n\t}\r\n});\r\n\r\n"]}