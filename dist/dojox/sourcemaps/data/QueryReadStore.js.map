{"version":3,"sources":["data/QueryReadStore.js"],"names":["define","dojo","dojox","declare","url","requestMethod","_className","_items","_lastServerQuery","_numRows","lastRequestHash","doClientPaging","doClientSorting","_itemsByIdentity","_identifier","_features","dojo.data.api.Read","dojo.data.api.Identity","_labelAttr","constructor","params","mixin","this","getValue","item","attribute","defaultValue","_assertIsItem","isString","Error","hasAttribute","i","getValues","ret","push","getAttributes","isItem","containsValue","value","values","len","length","something","r","isItemLoaded","loadItem","args","fetch","request","store","self","_fetchItems","items","requestObject","numRows","oldAbortFunction","abort","aborted","startIndex","start","endIndex","count","call","scope","global","onBegin","sort","data","util","sorter","createSortFunction","onItem","onComplete","subset","slice","errorData","onError","getFeatures","close","getLabel","getLabelAttributes","_xhrFetchHandler","fetchHandler","errorHandler","_filterResponse","label","forEach","e","identifier","identity","Number","n","serverQuery","query","sortInfo","descending","join","toJson","xhrHandler","toLowerCase","xhrPost","xhrGet","handleAs","content","failOk","cancel","addCallback","hitch","addErrback","error","Date","getTime","String","Math","random","substring","_assertIsAttribute","fetchItemByIdentity","keywordArgs","undefined","id","getIdentity","getIdentityAttributes"],"mappings":"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","file":"../../data/QueryReadStore.js","sourcesContent":["define([\"dojo\", \"dojox\", \"dojo/data/util/sorter\", \"dojo/string\"], function(dojo, dojox) {\r\n\r\n\treturn dojo.declare(\"dojox.data.QueryReadStore\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tThis class provides a store that is mainly intended to be used\r\n\t\t//\t\tfor loading data dynamically from the server, used i.e. for\r\n\t\t//\t\tretrieving chunks of data from huge data stores on the server (by server-side filtering!).\r\n\t\t//\t\tUpon calling the fetch() method of this store the data are requested from\r\n\t\t//\t\tthe server if they are not yet loaded for paging (or cached).\r\n\t\t//\r\n\t\t//\t\tFor example used for a combobox which works on lots of data. It\r\n\t\t//\t\tcan be used to retrieve the data partially upon entering the\r\n\t\t//\t\tletters \"ac\" it returns only items like \"action\", \"acting\", etc.\r\n\t\t//\r\n\t\t//\t\tnote:\r\n\t\t//\t\tThe field name \"id\" in a query is reserved for looking up data\r\n\t\t//\t\tby id. This is necessary as before the first fetch, the store\r\n\t\t//\t\thas no way of knowing which field the server will declare as\r\n\t\t//\t\tidentifier.\r\n\t\t//\r\n\t\t// example:\r\n\t\t// |\t// The parameter \"query\" contains the data that are sent to the server.\r\n\t\t// |\tvar store = new dojox.data.QueryReadStore({url:'/search.php'});\r\n\t\t// |\tstore.fetch({query:{name:'a'}, queryOptions:{ignoreCase:false}});\r\n\t\t//\r\n\t\t// |\t// Since \"serverQuery\" is given, it overrules and those data are\r\n\t\t// |\t// sent to the server.\r\n\t\t// |\tvar store = new dojox.data.QueryReadStore({url:'/search.php'});\r\n\t\t// |\tstore.fetch({serverQuery:{name:'a'}, queryOptions:{ignoreCase:false}});\r\n\t\t//\r\n\t\t// |\t<div dojoType=\"dojox.data.QueryReadStore\"\r\n\t\t// |\t\tjsId=\"store2\"\r\n\t\t// |\t\turl=\"../tests/stores/QueryReadStore.php\"\r\n\t\t// |\t\trequestMethod=\"post\"></div>\r\n\t\t// |\t<div dojoType=\"dojox.grid.data.DojoData\"\r\n\t\t// |\t\tjsId=\"model2\"\r\n\t\t// |\t\tstore=\"store2\"\r\n\t\t// |\t\tsortFields=\"[{attribute: 'name', descending: true}]\"\r\n\t\t// |\t\trowsPerPage=\"30\"></div>\r\n\t\t// |\t<div dojoType=\"dojox.Grid\" id=\"grid2\"\r\n\t\t// |\t\tmodel=\"model2\"\r\n\t\t// |\t\tstructure=\"gridLayout\"\r\n\t\t// |\t\tstyle=\"height:300px; width:800px;\"></div>\r\n\r\n\t\t// todo:\r\n\t\t//\t\t- there is a bug in the paging, when i set start:2, count:5 after an initial fetch() and doClientPaging:true\r\n\t\t//\t\t  it returns 6 elemetns, though count=5, try it in QueryReadStore.html\r\n\t\t//\t\t- add optional caching\r\n\t\t//\t\t- when the first query searched for \"a\" and the next for a subset of\r\n\t\t//\t\t  the first, i.e. \"ab\" then we actually dont need a server request, if\r\n\t\t//\t\t  we have client paging, we just need to filter the items we already have\r\n\t\t//\t\t  that might also be tooo much logic\r\n\t\t\r\n\t\turl:\"\",\r\n\t\trequestMethod:\"get\",\r\n\t\t//useCache:false,\r\n\t\t\r\n\t\t// We use the name in the errors, once the name is fixed hardcode it, may be.\r\n\t\t_className:\"dojox.data.QueryReadStore\",\r\n\t\t\r\n\t\t// This will contain the items we have loaded from the server.\r\n\t\t// The contents of this array is optimized to satisfy all read-api requirements\r\n\t\t// and for using lesser storage, so the keys and their content need some explaination:\r\n\t\t//\t\tthis._items[0].i - the item itself\r\n\t\t//\t\tthis._items[0].r - a reference to the store, so we can identify the item\r\n\t\t//\t\t\tsecurely. We set this reference right after receiving the item from the\r\n\t\t//\t\t\tserver.\r\n\t\t_items:[],\r\n\t\t\r\n\t\t// Store the last query that triggered xhr request to the server.\r\n\t\t// So we can compare if the request changed and if we shall reload\r\n\t\t// (this also depends on other factors, such as is caching used, etc).\r\n\t\t_lastServerQuery:null,\r\n\t\t\r\n\t\t// Store how many rows we have so that we can pass it to a clientPaging handler\r\n\t\t_numRows:-1,\r\n\t\t\r\n\t\t// Store a hash of the last server request. Actually I introduced this\r\n\t\t// for testing, so I can check if no unnecessary requests were issued for\r\n\t\t// client-side-paging.\r\n\t\tlastRequestHash:null,\r\n\t\t\r\n\t\t// doClientPaging: Boolean\r\n\t\t//\t\tBy default every request for paging is sent to the server.\r\n\t\tdoClientPaging:false,\r\n\t\r\n\t\t// doClientSorting: Boolean\r\n\t\t//\t\tBy default all the sorting is done serverside before the data is returned\r\n\t\t//\t\twhich is the proper place to be doing it for really large datasets.\r\n\t\tdoClientSorting:false,\r\n\t\r\n\t\t// Items by identify for Identify API\r\n\t\t_itemsByIdentity:null,\r\n\t\t\r\n\t\t// Identifier used\r\n\t\t_identifier:null,\r\n\t\r\n\t\t_features: {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true},\r\n\t\r\n\t\t_labelAttr: \"label\",\r\n\t\t\r\n\t\tconstructor: function(/* Object */ params){\r\n\t\t\tdojo.mixin(this,params);\r\n\t\t},\r\n\t\t\r\n\t\tgetValue: function(/* item */ item, /* attribute-name-string */ attribute, /* value? */ defaultValue){\r\n\t\t\t//\tAccording to the Read API comments in getValue() and exception is\r\n\t\t\t//\tthrown when an item is not an item or the attribute not a string!\r\n\t\t\tthis._assertIsItem(item);\r\n\t\t\tif(!dojo.isString(attribute)){\r\n\t\t\t\tthrow new Error(this._className+\".getValue(): Invalid attribute, string expected!\");\r\n\t\t\t}\r\n\t\t\tif(!this.hasAttribute(item, attribute)){\r\n\t\t\t\t// read api says: return defaultValue \"only if *item* does not have a value for *attribute*.\"\r\n\t\t\t\t// Is this the case here? The attribute doesn't exist, but a defaultValue, sounds reasonable.\r\n\t\t\t\tif(defaultValue){\r\n\t\t\t\t\treturn defaultValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn item.i[attribute];\r\n\t\t},\r\n\t\t\r\n\t\tgetValues: function(/* item */ item, /* attribute-name-string */ attribute){\r\n\t\t\tthis._assertIsItem(item);\r\n\t\t\tvar ret = [];\r\n\t\t\tif(this.hasAttribute(item, attribute)){\r\n\t\t\t\tret.push(item.i[attribute]);\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t},\r\n\t\t\r\n\t\tgetAttributes: function(/* item */ item){\r\n\t\t\tthis._assertIsItem(item);\r\n\t\t\tvar ret = [];\r\n\t\t\tfor(var i in item.i){\r\n\t\t\t\tret.push(i);\r\n\t\t\t}\r\n\t\t\treturn ret;\r\n\t\t},\r\n\t\r\n\t\thasAttribute: function(/* item */ item,\t/* attribute-name-string */ attribute){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee dojo/data/api/Read.hasAttribute()\r\n\t\t\treturn this.isItem(item) && typeof item.i[attribute]!=\"undefined\";\r\n\t\t},\r\n\t\t\r\n\t\tcontainsValue: function(/* item */ item, /* attribute-name-string */ attribute, /* anything */ value){\r\n\t\t\tvar values = this.getValues(item, attribute);\r\n\t\t\tvar len = values.length;\r\n\t\t\tfor(var i=0; i<len; i++){\r\n\t\t\t\tif(values[i] == value){\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t\r\n\t\tisItem: function(/* anything */ something){\r\n\t\t\t// Some basic tests, that are quick and easy to do here.\r\n\t\t\t// >>> var store = new dojox.data.QueryReadStore({});\r\n\t\t\t// >>> store.isItem(\"\");\r\n\t\t\t// false\r\n\t\t\t//\r\n\t\t\t// >>> var store = new dojox.data.QueryReadStore({});\r\n\t\t\t// >>> store.isItem({});\r\n\t\t\t// false\r\n\t\t\t//\r\n\t\t\t// >>> var store = new dojox.data.QueryReadStore({});\r\n\t\t\t// >>> store.isItem(0);\r\n\t\t\t// false\r\n\t\t\t//\r\n\t\t\t// >>> var store = new dojox.data.QueryReadStore({});\r\n\t\t\t// >>> store.isItem({name:\"me\", label:\"me too\"});\r\n\t\t\t// false\r\n\r\n\t\t\tif(something){\r\n\t\t\t\treturn typeof something.r != \"undefined\" && something.r == this;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t\r\n\t\tisItemLoaded: function(/* anything */ something){\r\n\t\t\t// Currently we dont have any state that tells if an item is loaded or not\r\n\t\t\t// if the item exists its also loaded.\r\n\t\t\t// This might change when we start working with refs inside items ...\r\n\t\t\treturn this.isItem(something);\r\n\t\t},\r\n\t\r\n\t\tloadItem: function(/* object */ args){\r\n\t\t\tif(this.isItemLoaded(args.item)){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// Actually we have nothing to do here, or at least I dont know what to do here ...\r\n\t\t},\r\n\t\r\n\t\tfetch:function(/* Object? */ request){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee dojo.data.util.simpleFetch.fetch() this is just a copy and I adjusted\r\n\t\t\t//\t\tonly the paging, since it happens on the server if doClientPaging is\r\n\t\t\t//\t\tfalse, thx to http://trac.dojotoolkit.org/ticket/4761 reporting this.\r\n\t\t\t//\t\tWould be nice to be able to use simpleFetch() to reduce copied code,\r\n\t\t\t//\t\tbut i dont know how yet. Ideas please!\r\n\t\t\trequest = request || {};\r\n\t\t\tif(!request.store){\r\n\t\t\t\trequest.store = this;\r\n\t\t\t}\r\n\t\t\tvar self = this;\r\n\t\t\r\n\t\t\tvar _errorHandler = function(errorData, requestObject){\r\n\t\t\t\tif(requestObject.onError){\r\n\t\t\t\t\tvar scope = requestObject.scope || dojo.global;\r\n\t\t\t\t\trequestObject.onError.call(scope, errorData, requestObject);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\r\n\t\t\tvar _fetchHandler = function(items, requestObject, numRows){\r\n\t\t\t\tvar oldAbortFunction = requestObject.abort || null;\r\n\t\t\t\tvar aborted = false;\r\n\t\t\t\t\r\n\t\t\t\tvar startIndex = requestObject.start?requestObject.start:0;\r\n\t\t\t\tif(self.doClientPaging == false){\r\n\t\t\t\t\t// For client paging we dont need no slicing of the result.\r\n\t\t\t\t\tstartIndex = 0;\r\n\t\t\t\t}\r\n\t\t\t\tvar endIndex = requestObject.count?(startIndex + requestObject.count):items.length;\r\n\t\t\r\n\t\t\t\trequestObject.abort = function(){\r\n\t\t\t\t\taborted = true;\r\n\t\t\t\t\tif(oldAbortFunction){\r\n\t\t\t\t\t\toldAbortFunction.call(requestObject);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\r\n\t\t\t\tvar scope = requestObject.scope || dojo.global;\r\n\t\t\t\tif(!requestObject.store){\r\n\t\t\t\t\trequestObject.store = self;\r\n\t\t\t\t}\r\n\t\t\t\tif(requestObject.onBegin){\r\n\t\t\t\t\trequestObject.onBegin.call(scope, numRows, requestObject);\r\n\t\t\t\t}\r\n\t\t\t\tif(requestObject.sort && self.doClientSorting){\r\n\t\t\t\t\titems.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));\r\n\t\t\t\t}\r\n\t\t\t\tif(requestObject.onItem){\r\n\t\t\t\t\tfor(var i = startIndex; (i < items.length) && (i < endIndex); ++i){\r\n\t\t\t\t\t\tvar item = items[i];\r\n\t\t\t\t\t\tif(!aborted){\r\n\t\t\t\t\t\t\trequestObject.onItem.call(scope, item, requestObject);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(requestObject.onComplete && !aborted){\r\n\t\t\t\t\tvar subset = null;\r\n\t\t\t\t\tif(!requestObject.onItem){\r\n\t\t\t\t\t\tsubset = items.slice(startIndex, endIndex);\r\n\t\t\t\t\t}\r\n\t\t\t\t\trequestObject.onComplete.call(scope, subset, requestObject);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tthis._fetchItems(request, _fetchHandler, _errorHandler);\r\n\t\t\treturn request;\t// Object\r\n\t\t},\r\n\t\r\n\t\tgetFeatures: function(){\r\n\t\t\treturn this._features;\r\n\t\t},\r\n\t\r\n\t\tclose: function(/*dojo/data/api/Request|Object?*/ request){\r\n\t\t\t// I have no idea if this is really needed ...\r\n\t\t},\r\n\t\r\n\t\tgetLabel: function(/* item */ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee dojo/data/api/Read.getLabel()\r\n\t\t\tif(this._labelAttr && this.isItem(item)){\r\n\t\t\t\treturn this.getValue(item, this._labelAttr); //String\r\n\t\t\t}\r\n\t\t\treturn undefined; //undefined\r\n\t\t},\r\n\t\r\n\t\tgetLabelAttributes: function(/* item */ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee dojo/data/api/Read.getLabelAttributes()\r\n\t\t\tif(this._labelAttr){\r\n\t\t\t\treturn [this._labelAttr]; //array\r\n\t\t\t}\r\n\t\t\treturn null; //null\r\n\t\t},\r\n\t\t\r\n\t\t_xhrFetchHandler: function(data, request, fetchHandler, errorHandler){\r\n\t\t\tdata = this._filterResponse(data);\r\n\t\t\tif(data.label){\r\n\t\t\t\tthis._labelAttr = data.label;\r\n\t\t\t}\r\n\t\t\tvar numRows = data.numRows || -1;\r\n\r\n\t\t\tthis._items = [];\r\n\t\t\t// Store a ref to \"this\" in each item, so we can simply check if an item\r\n\t\t\t// really origins form here (idea is from ItemFileReadStore, I just don't know\r\n\t\t\t// how efficient the real storage use, garbage collection effort, etc. is).\r\n\t\t\tdojo.forEach(data.items,function(e){\r\n\t\t\t\tthis._items.push({i:e, r:this});\r\n\t\t\t},this);\r\n\t\t\t\r\n\t\t\tvar identifier = data.identifier;\r\n\t\t\tthis._itemsByIdentity = {};\r\n\t\t\tif(identifier){\r\n\t\t\t\tthis._identifier = identifier;\r\n\t\t\t\tvar i;\r\n\t\t\t\tfor(i = 0; i < this._items.length; ++i){\r\n\t\t\t\t\tvar item = this._items[i].i;\r\n\t\t\t\t\tvar identity = item[identifier];\r\n\t\t\t\t\tif(!this._itemsByIdentity[identity]){\r\n\t\t\t\t\t\tthis._itemsByIdentity[identity] = item;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthrow new Error(this._className+\":  The json data as specified by: [\" + this.url + \"] is malformed.  Items within the list have identifier: [\" + identifier + \"].  Value collided: [\" + identity + \"]\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tthis._identifier = Number;\r\n\t\t\t\tfor(i = 0; i < this._items.length; ++i){\r\n\t\t\t\t\tthis._items[i].n = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// TODO actually we should do the same as dojo.data.ItemFileReadStore._getItemsFromLoadedData() to sanitize\r\n\t\t\t// (does it really sanititze them) and store the data optimal. should we? for security reasons???\r\n\t\t\tnumRows = this._numRows = (numRows === -1) ? this._items.length : numRows;\r\n\t\t\tfetchHandler(this._items, request, numRows);\r\n\t\t\tthis._numRows = numRows;\r\n\t\t},\r\n\t\t\r\n\t\t_fetchItems: function(request, fetchHandler, errorHandler){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe request contains the data as defined in the Read-API.\r\n\t\t\t//\t\tAdditionally there is following keyword \"serverQuery\".\r\n\t\t\t//\r\n\t\t\t//\t\t####The *serverQuery* parameter, optional.\r\n\t\t\t//\r\n\t\t\t//\t\tThis parameter contains the data that will be sent to the server.\r\n\t\t\t//\t\tIf this parameter is not given the parameter \"query\"'s\r\n\t\t\t//\t\tdata are sent to the server. This is done for some reasons:\r\n\t\t\t//\r\n\t\t\t//\t\t- to specify explicitly which data are sent to the server, they\r\n\t\t\t//\t\t  might also be a mix of what is contained in \"query\", \"queryOptions\"\r\n\t\t\t//\t\t  and the paging parameters \"start\" and \"count\" or may be even\r\n\t\t\t//\t\t  completely different things.\r\n\t\t\t//\t\t- don't modify the request.query data, so the interface using this\r\n\t\t\t//\t\t  store can rely on unmodified data, as the combobox dijit currently\r\n\t\t\t//\t\t  does it, it compares if the query has changed\r\n\t\t\t//\t\t- request.query is required by the Read-API\r\n\t\t\t//\r\n\t\t\t//\t\tI.e. the following examples might be sent via GET:\r\n\t\t\t//\t|\t  fetch({query:{name:\"abc\"}, queryOptions:{ignoreCase:true}})\r\n\t\t\t//\t\t  the URL will become:   /url.php?name=abc\r\n\t\t\t//\r\n\t\t\t//\t|\t  fetch({serverQuery:{q:\"abc\", c:true}, query:{name:\"abc\"}, queryOptions:{ignoreCase:true}})\r\n\t\t\t//\t\t  the URL will become:   /url.php?q=abc&c=true\r\n\t\t\t//\t|\t  // The serverQuery-parameter has overruled the query-parameter\r\n\t\t\t//\t|\t  // but the query parameter stays untouched, but is not sent to the server!\r\n\t\t\t//\t|\t  // The serverQuery contains more data than the query, so they might differ!\r\n\r\n\t\t\tvar serverQuery = request.serverQuery || request.query || {};\r\n\t\t\t//Need to add start and count\r\n\t\t\tif(!this.doClientPaging){\r\n\t\t\t\tserverQuery.start = request.start || 0;\r\n\t\t\t\t// Count might not be sent if not given.\r\n\t\t\t\tif(request.count){\r\n\t\t\t\t\tserverQuery.count = request.count;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!this.doClientSorting && request.sort){\r\n\t\t\t\tvar sortInfo = [];\r\n\t\t\t\tdojo.forEach(request.sort, function(sort){\r\n\t\t\t\t\tif(sort && sort.attribute){\r\n\t\t\t\t\t\tsortInfo.push((sort.descending ? \"-\" : \"\") + sort.attribute);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tserverQuery.sort = sortInfo.join(',');\r\n\t\t\t}\r\n\t\t\t// Compare the last query and the current query by simply json-encoding them,\r\n\t\t\t// so we dont have to do any deep object compare ... is there some dojo.areObjectsEqual()???\r\n\t\t\tif(this.doClientPaging && this._lastServerQuery !== null &&\r\n\t\t\t\tdojo.toJson(serverQuery) == dojo.toJson(this._lastServerQuery)\r\n\t\t\t\t){\r\n\t\t\t\tthis._numRows = (this._numRows === -1) ? this._items.length : this._numRows;\r\n\t\t\t\tfetchHandler(this._items, request, this._numRows);\r\n\t\t\t}else{\r\n\t\t\t\tvar xhrFunc = this.requestMethod.toLowerCase() == \"post\" ? dojo.xhrPost : dojo.xhrGet;\r\n\t\t\t\tvar xhrHandler = xhrFunc({url:this.url, handleAs:\"json-comment-optional\", content:serverQuery, failOk: true});\r\n\t\t\t\trequest.abort = function(){\r\n\t\t\t\t\txhrHandler.cancel();\r\n\t\t\t\t};\r\n\t\t\t\txhrHandler.addCallback(dojo.hitch(this, function(data){\r\n\t\t\t\t\tthis._xhrFetchHandler(data, request, fetchHandler, errorHandler);\r\n\t\t\t\t}));\r\n\t\t\t\txhrHandler.addErrback(function(error){\r\n\t\t\t\t\terrorHandler(error, request);\r\n\t\t\t\t});\r\n\t\t\t\t// Generate the hash using the time in milliseconds and a randon number.\r\n\t\t\t\t// Since Math.randon() returns something like: 0.23453463, we just remove the \"0.\"\r\n\t\t\t\t// probably just for esthetic reasons :-).\r\n\t\t\t\tthis.lastRequestHash = new Date().getTime()+\"-\"+String(Math.random()).substring(2);\r\n\t\t\t\tthis._lastServerQuery = dojo.mixin({}, serverQuery);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t_filterResponse: function(data){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tIf the data from servers needs to be processed before it can be processed by this\r\n\t\t\t//\t\tstore, then this function should be re-implemented in subclass. This default\r\n\t\t\t//\t\timplementation just return the data unchanged.\r\n\t\t\t// data:\r\n\t\t\t//\t\tThe data received from server\r\n\t\t\treturn data;\r\n\t\t},\r\n\t\r\n\t\t_assertIsItem: function(/* item */ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tIt throws an error if item is not valid, so you can call it in every method that needs to\r\n\t\t\t//\t\tthrow an error when item is invalid.\r\n\t\t\t// item:\r\n\t\t\t//\t\tThe item to test for being contained by the store.\r\n\t\t\tif(!this.isItem(item)){\r\n\t\t\t\tthrow new Error(this._className+\": Invalid item argument.\");\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_assertIsAttribute: function(/* attribute-name-string */ attribute){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis function tests whether the item passed in is indeed a valid 'attribute' like type for the store.\r\n\t\t\t// attribute:\r\n\t\t\t//\t\tThe attribute to test for being contained by the store.\r\n\t\t\tif(typeof attribute !== \"string\"){\r\n\t\t\t\tthrow new Error(this._className+\": Invalid attribute argument ('\"+attribute+\"').\");\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tfetchItemByIdentity: function(/* Object */ keywordArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee dojo/data/api/Identity.fetchItemByIdentity()\r\n\t\r\n\t\t\t// See if we have already loaded the item with that id\r\n\t\t\t// In case there hasn't been a fetch yet, _itemsByIdentity is null\r\n\t\t\t// and thus a fetch will be triggered below.\r\n\t\t\tif(this._itemsByIdentity){\r\n\t\t\t\tvar item = this._itemsByIdentity[keywordArgs.identity];\r\n\t\t\t\tif(!(item === undefined)){\r\n\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\tvar scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;\r\n\t\t\t\t\t\tkeywordArgs.onItem.call(scope, {i:item, r:this});\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\t// Otherwise we need to go remote\r\n\t\t\t// Set up error handler\r\n\t\t\tvar _errorHandler = function(errorData, requestObject){\r\n\t\t\t\tvar scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;\r\n\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\tkeywordArgs.onError.call(scope, errorData);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// Set up fetch handler\r\n\t\t\tvar _fetchHandler = function(items, requestObject){\r\n\t\t\t\tvar scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;\r\n\t\t\t\ttry{\r\n\t\t\t\t\t// There is supposed to be only one result\r\n\t\t\t\t\tvar item = null;\r\n\t\t\t\t\tif(items && items.length == 1){\r\n\t\t\t\t\t\titem = items[0];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// If no item was found, item is still null and we'll\r\n\t\t\t\t\t// fire the onItem event with the null here\r\n\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t\t\t}\r\n\t\t\t\t}catch(error){\r\n\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\tkeywordArgs.onError.call(scope, error);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// Construct query\r\n\t\t\tvar request = {serverQuery:{id:keywordArgs.identity}};\r\n\t\t\t\r\n\t\t\t// Dispatch query\r\n\t\t\tthis._fetchItems(request, _fetchHandler, _errorHandler);\r\n\t\t},\r\n\t\t\r\n\t\tgetIdentity: function(/* item */ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee dojo/data/api/Identity.getIdentity()\r\n\t\t\tvar identifier = null;\r\n\t\t\tif(this._identifier === Number){\r\n\t\t\t\tidentifier = item.n; // Number\r\n\t\t\t}else{\r\n\t\t\t\tidentifier = item.i[this._identifier];\r\n\t\t\t}\r\n\t\t\treturn identifier;\r\n\t\t},\r\n\t\t\r\n\t\tgetIdentityAttributes: function(/* item */ item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee dojo/data/api/Identity.getIdentityAttributes()\r\n\t\t\treturn [this._identifier];\r\n\t\t}\r\n\t});\r\n\r\n});\r\n"]}