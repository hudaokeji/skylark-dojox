{"version":3,"sources":["data/PersevereStore.js"],"names":["define","dojo","dojox","require","json","ref","serializeFunctions","PersevereStore","declare","data","JsonQueryRestStore","useFullIdInQueries","jsonQueryPagination","getStores","path","sync","match","io","xhrScriptPlugin","xhrPlugins","fullHttpAdapter","plainXhr","xhr","method","args","headers","apply","arguments","rootService","rpc","Rest","_sync","results","dfd","stores","callId","addCallback","schemas","setupHierarchy","schema","prototype","isPrototypeOf","_index","__id","mixin","delegate","setupMethods","methodsDefinitions","methodsTarget","j","runAt","methodName","deferred","rawXhrPost","url","this","postData","toJson","id","params","_toArray","handleAs","response","error","Error","result","i","resolveJson","index","idPrefix","assignAbsoluteIds","methods","staticMethods","target","_Url","addProxy"],"mappings":";;;;;;;AAAAA,QAAQ,OAAQ,QAAS,UAAW,gCAAiC,mBAAoB,kBAAmB,SAASC,EAAMC,EAAOC,SAIlID,EAAME,KAAKC,IAAIC,oBAAqB,EAEpC,IAAIC,EAAiBN,EAAKO,QAAQ,4BAA6BN,EAAMO,KAAKC,oBACzEC,oBAAoB,EACpBC,qBAAqB,IAqGtB,OAlGAL,EAAeM,UAAY,SAAqBC,EAAkBC,IAajED,EAAQA,IAASA,EAAKE,MAAM,OAASF,EAAQA,EAAO,MAAU,KACtDE,MAAM,eAEbb,QAAQ,4BACRD,EAAMe,GAAGC,gBAAgBJ,EAAM,WAAYZ,EAAMe,GAAGE,WAAWC,kBAEhE,IAAIC,EAAWpB,EAAKqB,IACpBrB,EAAKqB,IAAM,SAASC,EAAOC,GAE1B,OADCA,EAAKC,QAAUD,EAAKC,aAAe,kBAAoB,QACjDJ,EAASK,MAAMzB,EAAK0B,YAE5B,IAAIC,EAAa1B,EAAM2B,IAAIC,KAAKhB,GAAK,GACrCZ,EAAM2B,IAAIE,MAAQhB,EAClB,IACIiB,EADAC,EAAML,EAAY,UAElBM,KACAC,EAAS,EA4Db,OA3DAF,EAAIG,YAAY,SAASC,GAMxB,SAASC,EAAeC,GACpBA,EAAgB,SAAKA,EAAgB,QAAEC,YACrCD,EAAOC,WAAcD,EAAOC,UAAUC,cAAcF,EAAgB,QAAEC,aACzEF,EAAeC,EAAgB,SAC/BrC,EAAM2B,IAAIC,KAAKY,OAAOH,EAAOC,UAAUG,MAAQJ,EAAOC,UAAYvC,EAAK2C,MAAM3C,EAAK4C,SAASN,EAAgB,QAAEC,WAAYD,EAAOC,aAInI,SAASM,EAAaC,EAAoBC,GACzC,GAAGD,GAAsBC,EACxB,IAAI,IAAIC,KAAKF,EAAmB,CAIT,UAHNA,EAAmBE,GAGtBC,OAAsBF,EAAcC,KAChDD,EAAcC,GAAK,SAAUE,GAC5B,OAAO,WAEN,IAAIC,EAAWnD,EAAKoD,YACnBC,IAAKC,KAAKZ,KAEVa,SAAUtD,EAAME,KAAKC,IAAIoD,QACxBlC,OAAQ4B,EACRO,GAAIvB,IACJwB,OAAQ1D,EAAK2D,SAASjC,aAEvBkC,SAAU,SAQX,OANAT,EAAShB,YAAY,SAAS0B,GAE7B,OAAOA,EAASC,MACf,IAAIC,MAAMF,EAASC,OACnBD,EAASG,SAEJb,GAnBU,CAqBhBH,KAKP,IAAI,IAAIiB,KA9CRhE,EAAME,KAAKC,IAAI8D,YAAY9B,GAC1B+B,MAAOlE,EAAM2B,IAAIC,KAAKY,OACtB2B,SAAU,UACVC,mBAAmB,IA2CPjC,EACZ,GAAwB,iBAAdA,EAAQ6B,GAAe,CAChC,IAAI3B,EAASF,EAAQ6B,GACrB5B,EAAeC,GACfO,EAAaP,EAAOgC,QAAShC,EAAOC,UAAYD,EAAOC,eACvDM,EAAaP,EAAOiC,cAAejC,GACnCL,EAAOG,EAAQ6B,GAAGR,IAAM,IAAIxD,EAAMO,KAAKF,gBAAgBkE,OAAO,IAAIxE,EAAKyE,KAAK5D,EAAKuB,EAAQ6B,GAAGR,IAAM,IAAInB,OAAOA,IAG/G,OAAQP,EAAUE,IAEnBjC,EAAKqB,IAAMD,EACJN,EAAOiB,EAAUC,GAEzB1B,EAAeoE,SAAW,WAGzBxE,QAAQ,uBACRD,EAAMe,GAAGE,WAAWwD,SAAS,YAGvBpE","file":"../../data/PersevereStore.js","sourcesContent":["define([\"dojo\", \"dojox\", \"require\", \"dojox/data/JsonQueryRestStore\", \"dojox/rpc/Client\", \"dojo/_base/url\"], function(dojo, dojox, require) {\r\n\r\n// PersevereStore is an extension of JsonRestStore to handle Persevere's special features\r\n\r\ndojox.json.ref.serializeFunctions = true; // Persevere supports persisted functions\r\n\r\nvar PersevereStore = dojo.declare(\"dojox.data.PersevereStore\", dojox.data.JsonQueryRestStore, {\r\n\tuseFullIdInQueries: true, // in JSONQuerys use the full id\r\n\tjsonQueryPagination: false // use the Range headers instead\r\n});\r\n\r\nPersevereStore.getStores = function(/*String?*/ path,/*Boolean?*/ sync){\r\n\t// summary:\r\n\t//\t\tCreates Dojo data stores for all the table/classes on a Persevere server\r\n\t// path:\r\n\t//\t\tURL of the Persevere server's root, this normally just \"/\"\r\n\t//\t\twhich is the default value if the target is not provided\r\n\t// sync:\r\n\t//\t\tIndicates that the operation should happen synchronously.\r\n\t// returns:\r\n\t//\t\tA map/object of datastores will be returned if it is performed asynchronously,\r\n\t//\t\totherwise it will return a Deferred object that will provide the map/object.\r\n\t//\t\tThe name of each property is a the name of a store,\r\n\t//\t\tand the value is the actual data store object.\r\n\tpath = (path && (path.match(/\\/$/) ? path : (path + '/'))) || '/';\r\n\tif(path.match(/^\\w*:\\/\\//)){\r\n\t\t// if it is cross-domain, we will use window.name for communication\r\n\t\trequire(\"dojox/io/xhrScriptPlugin\");\r\n\t\tdojox.io.xhrScriptPlugin(path, \"callback\", dojox.io.xhrPlugins.fullHttpAdapter);\r\n\t}\r\n\tvar plainXhr = dojo.xhr;\r\n\tdojo.xhr = function(method,args){\r\n\t\t(args.headers = args.headers || {})['Server-Methods'] = \"false\";\r\n\t\treturn plainXhr.apply(dojo,arguments);\r\n\t};\r\n\tvar rootService= dojox.rpc.Rest(path,true);\r\n\tdojox.rpc._sync = sync;\r\n\tvar dfd = rootService(\"Class/\");//dojo.xhrGet({url: target, sync:!callback, handleAs:'json'});\r\n\tvar results;\r\n\tvar stores = {};\r\n\tvar callId = 0;\r\n\tdfd.addCallback(function(schemas){\r\n\t\tdojox.json.ref.resolveJson(schemas, {\r\n\t\t\tindex: dojox.rpc.Rest._index,\r\n\t\t\tidPrefix: \"/Class/\",\r\n\t\t\tassignAbsoluteIds: true\r\n\t\t});\r\n\t\tfunction setupHierarchy(schema){\r\n\t\t\tif(schema['extends'] && schema['extends'].prototype){\r\n\t\t\t\tif(!schema.prototype || !schema.prototype.isPrototypeOf(schema['extends'].prototype)){\r\n\t\t\t\t\tsetupHierarchy(schema['extends']);\r\n\t\t\t\t\tdojox.rpc.Rest._index[schema.prototype.__id] = schema.prototype = dojo.mixin(dojo.delegate(schema['extends'].prototype), schema.prototype);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction setupMethods(methodsDefinitions, methodsTarget){\r\n\t\t\tif(methodsDefinitions && methodsTarget){\r\n\t\t\t\tfor(var j in methodsDefinitions){\r\n\t\t\t\t\tvar methodDef = methodsDefinitions[j];\r\n\t\t\t\t\t// if any method definitions indicate that the method should run on the server, than add\r\n\t\t\t\t\t// it to the prototype as a JSON-RPC method\r\n\t\t\t\t\tif(methodDef.runAt != \"client\" && !methodsTarget[j]){\r\n\t\t\t\t\t\tmethodsTarget[j] = (function(methodName){\r\n\t\t\t\t\t\t\treturn function(){\r\n\t\t\t\t\t\t\t\t// execute a JSON-RPC call\r\n\t\t\t\t\t\t\t\tvar deferred = dojo.rawXhrPost({\r\n\t\t\t\t\t\t\t\t\turl: this.__id,\r\n\t\t\t\t\t\t\t\t\t// the JSON-RPC call\r\n\t\t\t\t\t\t\t\t\tpostData: dojox.json.ref.toJson({\r\n\t\t\t\t\t\t\t\t\t\tmethod: methodName,\r\n\t\t\t\t\t\t\t\t\t\tid: callId++,\r\n\t\t\t\t\t\t\t\t\t\tparams: dojo._toArray(arguments)\r\n\t\t\t\t\t\t\t\t\t}),\r\n\t\t\t\t\t\t\t\t\thandleAs: \"json\"\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\tdeferred.addCallback(function(response){\r\n\t\t\t\t\t\t\t\t\t// handle the response\r\n\t\t\t\t\t\t\t\t\treturn response.error ?\r\n\t\t\t\t\t\t\t\t\t\tnew Error(response.error) :\r\n\t\t\t\t\t\t\t\t\t\tresponse.result;\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\treturn deferred;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})(j);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(var i in schemas){\r\n\t\t\tif(typeof schemas[i] == 'object'){\r\n\t\t\t\tvar schema = schemas[i];\r\n\t\t\t\tsetupHierarchy(schema);\r\n\t\t\t\tsetupMethods(schema.methods, schema.prototype = schema.prototype || {});\r\n\t\t\t\tsetupMethods(schema.staticMethods, schema);\r\n\t\t\t\tstores[schemas[i].id] = new dojox.data.PersevereStore({target:new dojo._Url(path,schemas[i].id) + '/',schema:schema});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn (results = stores);\r\n\t});\r\n\tdojo.xhr = plainXhr;\r\n\treturn sync ? results : dfd;\r\n};\r\nPersevereStore.addProxy = function(){\r\n\t// summary:\r\n\t//\t\tInvokes the XHR proxy plugin. Call this if you will be using x-site data.\r\n\trequire(\"dojox/io/xhrPlugins\"); // also not necessary, but we can register that Persevere supports proxying\r\n\tdojox.io.xhrPlugins.addProxy(\"/proxy/\");\r\n};\r\n\r\nreturn PersevereStore;\r\n\r\n});\r\n"]}