{"version":3,"sources":["data/OpmlStore.js"],"names":["define","declare","lang","xhr","simpleFetch","filterUtil","kernel","OpmlStore","constructor","keywordParameters","this","_xmlData","_arrayOfTopLevelItems","_arrayOfAllItems","_metadataNodes","_loadFinished","url","_opmlData","data","label","_loadInProgress","_queuedFetches","_identityMap","_identCount","_idProp","urlPreventCache","_assertIsItem","item","isItem","Error","_assertIsAttribute","attribute","isString","_removeChildNodesThatAreNotElementNodes","node","recursive","childNodes","length","i","childNode","nodesToRemove","nodeType","push","removeChild","_processRawXmlTree","rawXmlTree","headNode","getElementsByTagName","bodyNodes","bodyNode","bodyChildNodes","tagName","_checkChildNodes","firstChild","child","_getItemsArray","queryOptions","deep","getValue","defaultValue","value","getAttribute","undefined","getValues","array","getAttributes","attributes","xmlNode","xmlAttributes","xmlAttribute","nodeName","hasAttribute","containsValue","regexp","patternToRegExp","_containsValue","values","possibleValue","match","something","ownerDocument","isItemLoaded","loadItem","getLabel","getLabelAttributes","_fetchItems","keywordArgs","findCallback","errorCallback","self","filter","requestArgs","arrayOfItems","items","query","ignoreCase","regexpList","key","candidateItem","slice","args","getArgs","handleAs","preventCache","getHandler","get","addCallback","_handleQueuedFetches","addErrback","error","getFeatures","dojo.data.api.Read","dojo.data.api.Identity","getIdentity","fetchItemByIdentity","identity","onItem","scope","global","call","onError","getIdentityAttributes","fData","delayedQuery","delayedFilter","close","request","extend"],"mappings":"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","file":"../../data/OpmlStore.js","sourcesContent":["define([\"dojo/_base/declare\", \"dojo/_base/lang\", \"dojo/_base/xhr\", \"dojo/data/util/simpleFetch\", \"dojo/data/util/filter\",\r\n\t\t\"dojo/_base/kernel\"],\r\n  function(declare, lang, xhr, simpleFetch, filterUtil, kernel) {\r\n\r\nvar OpmlStore = declare(\"dojox.data.OpmlStore\", null, {\r\n\t// summary:\r\n\t//\t\tThe OpmlStore implements the dojo/data/api/Read API.\r\n\t// examples:\r\n\t//\t|\tvar opmlStore = new dojo.data.OpmlStore({url:\"geography.xml\"});\r\n\t//\t|\tvar opmlStore = new dojo.data.OpmlStore({url:\"http://example.com/geography.xml\"});\r\n\r\n\tconstructor: function(/* Object */ keywordParameters){\r\n\t\t// summary:\r\n\t\t//\t\tconstructor\r\n\t\t// keywordParameters:\r\n\t\t//\t\t- {url: String, label: String}\r\n\t\t//\r\n\t\t//\t\tWhere label is optional and configures what should be used as the return from getLabel()\r\n\t\tthis._xmlData = null;\r\n\t\tthis._arrayOfTopLevelItems = [];\r\n\t\tthis._arrayOfAllItems = [];\r\n\t\tthis._metadataNodes = null;\r\n\t\tthis._loadFinished = false;\r\n\t\tthis.url = keywordParameters.url;\r\n\t\tthis._opmlData = keywordParameters.data; // XML DOM Document\r\n\t\tif(keywordParameters.label){\r\n\t\t\tthis.label = keywordParameters.label;\r\n\t\t}\r\n\t\tthis._loadInProgress = false;\t//Got to track the initial load to prevent duelling loads of the dataset.\r\n\t\tthis._queuedFetches = [];\r\n\t\tthis._identityMap = {};\r\n\t\tthis._identCount = 0;\r\n\t\tthis._idProp = \"_I\";\r\n\t\tif(keywordParameters && \"urlPreventCache\" in keywordParameters){\r\n\t\t\tthis.urlPreventCache = keywordParameters.urlPreventCache?true:false;\r\n\t\t}\r\n\t},\r\n\r\n\t// label: [public] string\r\n\t//\t\tThe attribute of the Opml item to act as a label.\r\n\tlabel: \"text\",\r\n\r\n\t// url: [public] string\r\n\t//\t\tThe location from which to fetch the Opml document.\r\n\turl: \"\",\r\n\r\n\t// urlPreventCache: [public] boolean\r\n\t//\t\tFlag to denote if the underlying xhrGet call should set preventCache.\r\n\turlPreventCache: false,\r\n\r\n\t_assertIsItem: function(/* item */ item){\r\n\t\tif(!this.isItem(item)){\r\n\t\t\tthrow new Error(\"dojo.data.OpmlStore: a function was passed an item argument that was not an item\");\r\n\t\t}\r\n\t},\r\n\t\r\n\t_assertIsAttribute: function(/*dojo/data/api/Item|String */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tThis function tests whether the item passed in is indeed a valid 'attribute' like type for the store.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to test for being contained by the store.\r\n\t\tif(!lang.isString(attribute)){\r\n\t\t\tthrow new Error(\"dojox.data.OpmlStore: a function was passed an attribute argument that was not an attribute object nor an attribute name string\");\r\n\t\t}\r\n\t},\r\n\t\r\n\t_removeChildNodesThatAreNotElementNodes: function(/* node */ node, /* boolean */ recursive){\r\n\t\tvar childNodes = node.childNodes;\r\n\t\tif(childNodes.length === 0){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar nodesToRemove = [];\r\n\t\tvar i, childNode;\r\n\t\tfor(i = 0; i < childNodes.length; ++i){\r\n\t\t\tchildNode = childNodes[i];\r\n\t\t\tif(childNode.nodeType != 1){\r\n\t\t\t\tnodesToRemove.push(childNode);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(i = 0; i < nodesToRemove.length; ++i){\r\n\t\t\tchildNode = nodesToRemove[i];\r\n\t\t\tnode.removeChild(childNode);\r\n\t\t}\r\n\t\tif(recursive){\r\n\t\t\tfor(i = 0; i < childNodes.length; ++i){\r\n\t\t\t\tchildNode = childNodes[i];\r\n\t\t\t\tthis._removeChildNodesThatAreNotElementNodes(childNode, recursive);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\r\n\t_processRawXmlTree: function(/* xmlDoc */ rawXmlTree){\r\n\t\tthis._loadFinished = true;\r\n\t\tthis._xmlData = rawXmlTree;\r\n\t\tvar headNodes = rawXmlTree.getElementsByTagName('head');\r\n\t\tvar headNode = headNodes[0];\r\n\t\tif(headNode){\r\n\t\t\tthis._removeChildNodesThatAreNotElementNodes(headNode);\r\n\t\t\tthis._metadataNodes = headNode.childNodes;\r\n\t\t}\r\n\t\tvar bodyNodes = rawXmlTree.getElementsByTagName('body');\r\n\t\tvar bodyNode = bodyNodes[0];\r\n\t\tif(bodyNode){\r\n\t\t\tthis._removeChildNodesThatAreNotElementNodes(bodyNode, true);\r\n\t\t\t\r\n\t\t\tvar bodyChildNodes = bodyNodes[0].childNodes;\r\n\t\t\tfor(var i = 0; i < bodyChildNodes.length; ++i){\r\n\t\t\t\tvar node = bodyChildNodes[i];\r\n\t\t\t\tif(node.tagName == 'outline'){\r\n\t\t\t\t\tthis._identityMap[this._identCount] = node;\r\n\t\t\t\t\tthis._identCount++;\r\n\t\t\t\t\tthis._arrayOfTopLevelItems.push(node);\r\n\t\t\t\t\tthis._arrayOfAllItems.push(node);\r\n\t\t\t\t\tthis._checkChildNodes(node);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_checkChildNodes: function(node /*Node*/){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to recurse over all child nodes from the store and add them\r\n\t\t//\t\tAs non-toplevel items\r\n\t\t// description:\r\n\t\t//\t\tInternal function to recurse over all child nodes from the store and add them\r\n\t\t//\t\tAs non-toplevel items\r\n\t\t// node:\r\n\t\t//\t\tThe child node to walk.\r\n\t\tif(node.firstChild){\r\n\t\t\tfor(var i = 0; i < node.childNodes.length; i++){\r\n\t\t\t\tvar child = node.childNodes[i];\r\n\t\t\t\tif(child.tagName == 'outline'){\r\n\t\t\t\t\tthis._identityMap[this._identCount] = child;\r\n\t\t\t\t\tthis._identCount++;\r\n\t\t\t\t\tthis._arrayOfAllItems.push(child);\r\n\t\t\t\t\tthis._checkChildNodes(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_getItemsArray: function(/*object?*/queryOptions){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to determine which list of items to search over.\r\n\t\t// queryOptions: The query options parameter, if any.\r\n\t\tif(queryOptions && queryOptions.deep){\r\n\t\t\treturn this._arrayOfAllItems;\r\n\t\t}\r\n\t\treturn this._arrayOfTopLevelItems;\r\n\t},\r\n\r\n/***************************************\r\n     dojo/data/api/Read API\r\n***************************************/\r\n\tgetValue: function( /* item */ item,\r\n\t\t\t\t\t\t/* attribute|attribute-name-string */ attribute,\r\n\t\t\t\t\t\t/* value? */ defaultValue){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getValue()\r\n\t\tthis._assertIsItem(item);\r\n\t\tthis._assertIsAttribute(attribute);\r\n\t\tif(attribute == 'children'){\r\n\t\t\treturn (item.firstChild || defaultValue); //Object\r\n\t\t}else{\r\n\t\t\tvar value = item.getAttribute(attribute);\r\n\t\t\treturn (value !== undefined) ? value : defaultValue; //Object\r\n\t\t}\r\n\t},\r\n\t\r\n\tgetValues: function(/* item */ item,\r\n\t\t\t\t\t\t/* attribute|attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getValues()\r\n\t\tthis._assertIsItem(item);\r\n\t\tthis._assertIsAttribute(attribute);\r\n\t\tvar array = [];\r\n\t\tif(attribute == 'children'){\r\n\t\t\tfor(var i = 0; i < item.childNodes.length; ++i){\r\n\t\t\t\tarray.push(item.childNodes[i]);\r\n\t\t\t}\r\n\t\t} else if(item.getAttribute(attribute) !== null){\r\n\t\t\t\tarray.push(item.getAttribute(attribute));\r\n\t\t}\r\n\t\treturn array; // Array\r\n\t},\r\n\t\r\n\tgetAttributes: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getAttributes()\r\n\t\tthis._assertIsItem(item);\r\n\t\tvar attributes = [];\r\n\t\tvar xmlNode = item;\r\n\t\tvar xmlAttributes = xmlNode.attributes;\r\n\t\tfor(var i = 0; i < xmlAttributes.length; ++i){\r\n\t\t\tvar xmlAttribute = xmlAttributes.item(i);\r\n\t\t\tattributes.push(xmlAttribute.nodeName);\r\n\t\t}\r\n\t\tif(xmlNode.childNodes.length > 0){\r\n\t\t\tattributes.push('children');\r\n\t\t}\r\n\t\treturn attributes; //Array\r\n\t},\r\n\t\r\n\thasAttribute: function( /* item */ item,\r\n\t\t\t\t\t\t\t/* attribute|attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.hasAttribute()\r\n\t\treturn (this.getValues(item, attribute).length > 0); //Boolean\r\n\t},\r\n\t\r\n\tcontainsValue: function(/* item */ item,\r\n\t\t\t\t\t\t\t/* attribute|attribute-name-string */ attribute,\r\n\t\t\t\t\t\t\t/* anything */ value){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.containsValue()\r\n\t\tvar regexp = undefined;\r\n\t\tif(typeof value === \"string\"){\r\n\t\t\tregexp = filterUtil.patternToRegExp(value, false);\r\n\t\t}\r\n\t\treturn this._containsValue(item, attribute, value, regexp); //boolean.\r\n\t},\r\n\r\n\t_containsValue: function(\t/* item */ item,\r\n\t\t\t\t\t\t\t\t/* attribute|attribute-name-string */ attribute,\r\n\t\t\t\t\t\t\t\t/* anything */ value,\r\n\t\t\t\t\t\t\t\t/* RegExp?*/ regexp){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function for looking at the values contained by the item.\r\n\t\t// description:\r\n\t\t//\t\tInternal function for looking at the values contained by the item.  This\r\n\t\t//\t\tfunction allows for denoting if the comparison should be case sensitive for\r\n\t\t//\t\tstrings or not (for handling filtering cases where string case should not matter)\r\n\t\t// item:\r\n\t\t//\t\tThe data item to examine for attribute values.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to inspect.\r\n\t\t// value:\r\n\t\t//\t\tThe value to match.\r\n\t\t// regexp:\r\n\t\t//\t\tOptional regular expression generated off value if value was of string type to handle wildcarding.\r\n\t\t//\t\tIf present and attribute values are string, then it can be used for comparison instead of 'value'\r\n\t\tvar values = this.getValues(item, attribute);\r\n\t\tfor(var i = 0; i < values.length; ++i){\r\n\t\t\tvar possibleValue = values[i];\r\n\t\t\tif(typeof possibleValue === \"string\" && regexp){\r\n\t\t\t\treturn (possibleValue.match(regexp) !== null);\r\n\t\t\t}else{\r\n\t\t\t\t//Non-string matching.\r\n\t\t\t\tif(value === possibleValue){\r\n\t\t\t\t\treturn true; // Boolean\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false; // Boolean\r\n\t},\r\n\t\t\t\r\n\tisItem: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.isItem()\r\n\t\t// description:\r\n\t\t//\t\tFour things are verified to ensure that \"something\" is an item:\r\n\t\t//\t\tsomething can not be null, the nodeType must be an XML Element,\r\n\t\t//\t\tthe tagName must be \"outline\", and the node must be a member of\r\n\t\t//\t\tXML document for this datastore.\r\n\t\treturn (something &&\r\n\t\t\t\tsomething.nodeType == 1 &&\r\n\t\t\t\tsomething.tagName == 'outline' &&\r\n\t\t\t\tsomething.ownerDocument === this._xmlData); //Boolean\r\n\t},\r\n\t\r\n\tisItemLoaded: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.isItemLoaded().\r\n\t\t//\t\tOpmlStore loads every item, so if it's an item, then it's loaded.\r\n\t\treturn this.isItem(something); //Boolean\r\n\t},\r\n\t\r\n\tloadItem: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.loadItem()\r\n\t\t// description:\r\n\t\t//\t\tThe OpmlStore always loads all items, so if it's an item, then it's loaded.\r\n\t\t//\r\n\t\t//\t\tFrom the dojo/data/api/Read.loadItem docs:\r\n\t\t//\r\n\t\t//\t\t\tIf a call to isItemLoaded() returns true before loadItem() is even called,\r\n\t\t//\t\t\tthen loadItem() need not do any work at all and will not even invoke the callback handlers.\r\n\t},\r\n\r\n\tgetLabel: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getLabel()\r\n\t\tif(this.isItem(item)){\r\n\t\t\treturn this.getValue(item,this.label); //String\r\n\t\t}\r\n\t\treturn undefined; //undefined\r\n\t},\r\n\r\n\tgetLabelAttributes: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getLabelAttributes()\r\n\t\treturn [this.label]; //array\r\n\t},\r\n\r\n\t// The dojo/data/api/Read.fetch() function is implemented as\r\n\t// a mixin from dojo.data.util.simpleFetch.\r\n\t// That mixin requires us to define _fetchItems().\r\n\t_fetchItems: function(\t/* Object */ keywordArgs,\r\n\t\t\t\t\t\t\t/* Function */ findCallback,\r\n\t\t\t\t\t\t\t/* Function */ errorCallback){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo.data.util.simpleFetch.fetch()\r\n\t\t\r\n\t\tvar self = this;\r\n\t\tvar filter = function(requestArgs, arrayOfItems){\r\n\t\t\tvar items = null;\r\n\t\t\tif(requestArgs.query){\r\n\t\t\t\titems = [];\r\n\t\t\t\tvar ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;\r\n\r\n\t\t\t\t//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the\r\n\t\t\t\t//same value for each item examined.  Much more efficient.\r\n\t\t\t\tvar regexpList = {};\r\n\t\t\t\tfor(var key in requestArgs.query){\r\n\t\t\t\t\tvar value = requestArgs.query[key];\r\n\t\t\t\t\tif(typeof value === \"string\"){\r\n\t\t\t\t\t\tregexpList[key] = filterUtil.patternToRegExp(value, ignoreCase);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor(var i = 0; i < arrayOfItems.length; ++i){\r\n\t\t\t\t\tvar match = true;\r\n\t\t\t\t\tvar candidateItem = arrayOfItems[i];\r\n\t\t\t\t\tfor(var key in requestArgs.query){\r\n\t\t\t\t\t\tvar value = requestArgs.query[key];\r\n\t\t\t\t\t\tif(!self._containsValue(candidateItem, key, value, regexpList[key])){\r\n\t\t\t\t\t\t\tmatch = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(match){\r\n\t\t\t\t\t\titems.push(candidateItem);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t// We want a copy to pass back in case the parent wishes to sort the array.  We shouldn't allow resort\r\n\t\t\t\t// of the internal list so that multiple callers can get lists and sort without affecting each other.\r\n\t\t\t\tif(arrayOfItems.length> 0){\r\n\t\t\t\t\titems = arrayOfItems.slice(0,arrayOfItems.length);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfindCallback(items, requestArgs);\r\n\t\t};\r\n\r\n\t\tif(this._loadFinished){\r\n\t\t\tfilter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));\r\n\t\t}else{\r\n\r\n\t\t\t//If fetches come in before the loading has finished, but while\r\n\t\t\t//a load is in progress, we have to defer the fetching to be\r\n\t\t\t//invoked in the callback.\r\n\t\t\tif(this._loadInProgress){\r\n\t\t\t\tthis._queuedFetches.push({args: keywordArgs, filter: filter});\r\n\t\t\t}else{\r\n\t\t\t\tif(this.url !== \"\"){\r\n\t\t\t\t\tthis._loadInProgress = true;\r\n\t\t\t\t\tvar getArgs = {\r\n\t\t\t\t\t\t\turl: self.url,\r\n\t\t\t\t\t\t\thandleAs: \"xml\",\r\n\t\t\t\t\t\t\tpreventCache: self.urlPreventCache\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\tvar getHandler = xhr.get(getArgs);\r\n\t\t\t\t\tgetHandler.addCallback(function(data){\r\n\t\t\t\t\t\tself._processRawXmlTree(data);\r\n\t\t\t\t\t\tfilter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));\r\n\t\t\t\t\t\tself._handleQueuedFetches();\r\n\t\t\t\t\t});\r\n\t\t\t\t\tgetHandler.addErrback(function(error){\r\n\t\t\t\t\t\tthrow error;\r\n\t\t\t\t\t});\r\n\t\t\t\t}else if(this._opmlData){\r\n\t\t\t\t\tthis._processRawXmlTree(this._opmlData);\r\n\t\t\t\t\tthis._opmlData = null;\r\n\t\t\t\t\tfilter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow new Error(\"dojox.data.OpmlStore: No OPML source data was provided as either URL or XML data input.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\r\n\tgetFeatures: function(){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getFeatures()\r\n\t\tvar features = {\r\n\t\t\t'dojo.data.api.Read': true,\r\n\t\t\t'dojo.data.api.Identity': true\r\n\t\t};\r\n\t\treturn features; //Object\r\n\t},\r\n\r\n/***************************************\r\n     dojo/data/api/Identity API\r\n***************************************/\r\n\tgetIdentity: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.getIdentity()\r\n\t\tif(this.isItem(item)){\r\n\t\t\t//No other way to do this other than O(n) without\r\n\t\t\t//complete rework of how the tree stores nodes.\r\n\t\t\tfor(var i in this._identityMap){\r\n\t\t\t\tif(this._identityMap[i] === item){\r\n\t\t\t\t\treturn i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null; //null\r\n\t},\r\n\r\n\tfetchItemByIdentity: function(/* Object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.fetchItemByIdentity()\r\n\r\n\t\t//Hasn't loaded yet, we have to trigger the load.\r\n\t\tif(!this._loadFinished){\r\n\t\t\tvar self = this;\r\n\t\t\tif(this.url !== \"\"){\r\n\t\t\t\t//If fetches come in before the loading has finished, but while\r\n\t\t\t\t//a load is in progress, we have to defer the fetching to be\r\n\t\t\t\t//invoked in the callback.\r\n\t\t\t\tif(this._loadInProgress){\r\n\t\t\t\t\tthis._queuedFetches.push({args: keywordArgs});\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis._loadInProgress = true;\r\n\t\t\t\t\tvar getArgs = {\r\n\t\t\t\t\t\t\turl: self.url,\r\n\t\t\t\t\t\t\thandleAs: \"xml\"\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\tvar getHandler = xhr.get(getArgs);\r\n\t\t\t\t\tgetHandler.addCallback(function(data){\r\n\t\t\t\t\t\tvar scope = keywordArgs.scope ? keywordArgs.scope : kernel.global;\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tself._processRawXmlTree(data);\r\n\t\t\t\t\t\t\tvar item = self._identityMap[keywordArgs.identity];\r\n\t\t\t\t\t\t\tif(!self.isItem(item)){\r\n\t\t\t\t\t\t\t\titem = null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tself._handleQueuedFetches();\r\n\t\t\t\t\t\t}catch(error){\r\n\t\t\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\t\t\tkeywordArgs.onError.call(scope, error);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tgetHandler.addErrback(function(error){\r\n\t\t\t\t\t\tthis._loadInProgress = false;\r\n\t\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\t\tvar scope = keywordArgs.scope ? keywordArgs.scope : kernel.global;\r\n\t\t\t\t\t\t\tkeywordArgs.onError.call(scope, error);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}else if(this._opmlData){\r\n\t\t\t\tthis._processRawXmlTree(this._opmlData);\r\n\t\t\t\tthis._opmlData = null;\r\n\t\t\t\tvar item = this._identityMap[keywordArgs.identity];\r\n\t\t\t\tif(!self.isItem(item)){\r\n\t\t\t\t\titem = null;\r\n\t\t\t\t}\r\n\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\tvar scope = keywordArgs.scope ? keywordArgs.scope : kernel.global;\r\n\t\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t//Already loaded.  We can just look it up and call back.\r\n\t\t\tvar item = this._identityMap[keywordArgs.identity];\r\n\t\t\tif(!this.isItem(item)){\r\n\t\t\t\titem = null;\r\n\t\t\t}\r\n\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\tvar scope = keywordArgs.scope ? keywordArgs.scope : kernel.global;\r\n\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetIdentityAttributes: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.getIdentifierAttributes()\r\n\r\n\t\t//Identity isn't a public attribute in the item, it's the node count.\r\n\t\t//So, return null.\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_handleQueuedFetches: function(){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to execute delayed request in the store.\r\n\t\t\r\n\t\t//Execute any deferred fetches now.\r\n\t\tif(this._queuedFetches.length > 0){\r\n\t\t\tfor(var i = 0; i < this._queuedFetches.length; i++){\r\n\t\t\t\tvar fData = this._queuedFetches[i];\r\n\t\t\t\tvar delayedQuery = fData.args;\r\n\t\t\t\tvar delayedFilter = fData.filter;\r\n\t\t\t\tif(delayedFilter){\r\n\t\t\t\t\tdelayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions));\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.fetchItemByIdentity(delayedQuery);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._queuedFetches = [];\r\n\t\t}\r\n\t},\r\n\r\n\tclose: function(/*dojo/data/api/Request|Object?*/ request){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.close()\r\n\t}\r\n});\r\n//Mix in the simple fetch implementation to this class.\r\nlang.extend(OpmlStore, simpleFetch);\r\n\r\nreturn OpmlStore;\r\n});\r\n\t\r\n"]}