{"version":3,"sources":["data/CsvStore.js"],"names":["define","lang","declare","xhr","kernel","filterUtil","simpleFetch","CsvStore","constructor","keywordParameters","this","_attributes","_attributeIndexes","_dataArray","_arrayOfAllItems","_loadFinished","url","_csvData","data","label","undefined","_storeProp","_idProp","_features","dojo.data.api.Read","dojo.data.api.Identity","_loadInProgress","_queuedFetches","identifier","_idMap","separator","urlPreventCache","_assertIsItem","item","isItem","Error","declaredClass","_getIndex","idx","getIdentity","getValue","attribute","defaultValue","itemValue","ai","getValues","value","getAttributes","attributes","itemData","i","length","push","hasAttribute","attributeIndex","containsValue","regexp","patternToRegExp","_containsValue","values","possibleValue","match","something","identity","isItemLoaded","loadItem","getFeatures","getLabel","getLabelAttributes","_fetchItems","keywordArgs","findCallback","errorCallback","self","filter","requestArgs","arrayOfAllItems","items","query","key","ignoreCase","queryOptions","regexpList","candidateItem","slice","args","getArgs","handleAs","preventCache","getHandler","get","addCallback","_processData","_handleQueuedFetches","e","addErrback","error","oldAbort","abort","df","fired","cancel","call","close","request","_getArrayOfArraysFromCsvFileContents","csvFileContents","isString","leadingWhiteSpaceCharacters","RegExp","trailingWhiteSpaceCharacters","doubleQuotes","arrayOfOutputRecords","arrayOfInputLines","_splitLines","singleLine","listOfFields","split","j","field_space","replace","field","firstChar","charAt","lastChar","secondToLastChar","thirdToLastChar","nextField","splice","shift","csvContent","line","inQuotes","c","id","_createItemFromIdentity","fetchItemByIdentity","scope","global","onItem","onError","getIdentityAttributes","fData","delayedFilter","delayedQuery","extend"],"mappings":"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","file":"../../data/CsvStore.js","sourcesContent":["define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/xhr\", \"dojo/_base/kernel\",\"dojo/data/util/filter\", \"dojo/data/util/simpleFetch\"],\r\n  function(lang, declare, xhr, kernel, filterUtil, simpleFetch) {\r\n\r\nvar CsvStore = declare(\"dojox.data.CsvStore\", null, {\r\n\t// summary:\r\n\t//\t\tThe CsvStore implements the dojo/data/api/Read API and reads\r\n\t//\t\tdata from files in CSV (Comma Separated Values) format.\r\n\t//\t\tAll values are simple string values. References to other items\r\n\t//\t\tare not supported as attribute values in this datastore.\r\n\t//\r\n\t//\t\tExample data file:\r\n\t//\t\tname, color, age, tagline\r\n\t//\t\tKermit, green, 12, \"Hi, I'm Kermit the Frog.\"\r\n\t//\t\tFozzie Bear, orange, 10, \"Wakka Wakka Wakka!\"\r\n\t//\t\tMiss Piggy, pink, 11, \"Kermie!\"\r\n\t//\r\n\t//\t\tNote that values containing a comma must be enclosed with quotes (\"\")\r\n\t//\t\tAlso note that values containing quotes must be escaped with two consecutive quotes (\"\"quoted\"\")\r\n\t//\r\n\t// examples:\r\n\t//\t\tvar csvStore = new dojox.data.CsvStore({url:\"movies.csv\");\r\n\t//\t\tvar csvStore = new dojox.data.CsvStore({url:\"http://example.com/movies.csv\");\r\n\r\n\tconstructor: function(/* Object */ keywordParameters){\r\n\t\t// summary:\r\n\t\t//\t\tinitializer\r\n\t\t// keywordParameters:\r\n\t\t//\t\t- url: String\r\n\t\t//\t\t- data: String\r\n\t\t//\t\t- label: String: The column label for the column to use for the label returned by getLabel.\r\n\t\t//\t\t- identifier: String: The column label for the column to use for the identity.  Optional.  If not set, the identity is the row number.\r\n\t\t\r\n\t\tthis._attributes = [];\t\t\t// e.g. [\"Title\", \"Year\", \"Producer\"]\r\n\t\tthis._attributeIndexes = {};\t// e.g. {Title: 0, Year: 1, Producer: 2}\r\n\t\tthis._dataArray = [];\t\t\t// e.g. [[<Item0>],[<Item1>],[<Item2>]]\r\n\t\tthis._arrayOfAllItems = [];\t\t// e.g. [{_csvId:0,_csvStore:store},...]\r\n\t\tthis._loadFinished = false;\r\n\t\tif(keywordParameters.url){\r\n\t\t\tthis.url = keywordParameters.url;\r\n\t\t}\r\n\t\tthis._csvData = keywordParameters.data;\r\n\t\tif(keywordParameters.label){\r\n\t\t\tthis.label = keywordParameters.label;\r\n\t\t}else if(this.label === \"\"){\r\n\t\t\tthis.label = undefined;\r\n\t\t}\r\n\t\tthis._storeProp = \"_csvStore\";\t// Property name for the store reference on every item.\r\n\t\tthis._idProp = \"_csvId\";\t\t// Property name for the Item Id on every item.\r\n\t\tthis._features = {\r\n\t\t\t'dojo.data.api.Read': true,\r\n\t\t\t'dojo.data.api.Identity': true\r\n\t\t};\r\n\t\tthis._loadInProgress = false;\t//Got to track the initial load to prevent duelling loads of the dataset.\r\n\t\tthis._queuedFetches = [];\r\n\t\tthis.identifier = keywordParameters.identifier;\r\n\t\tif(this.identifier === \"\"){\r\n\t\t\tdelete this.identifier;\r\n\t\t}else{\r\n\t\t\tthis._idMap = {};\r\n\t\t}\r\n\t\tif(\"separator\" in keywordParameters){\r\n\t\t\tthis.separator = keywordParameters.separator;\r\n\t\t}\r\n\t\tif(\"urlPreventCache\" in keywordParameters){\r\n\t\t\tthis.urlPreventCache = keywordParameters.urlPreventCache?true:false;\r\n\t\t}\r\n\t},\r\n\r\n\t// url: [public] string\r\n\t//\t\tDeclarative hook for setting Csv source url.\r\n\turl: \"\",\r\n\r\n\t// label: [public] string\r\n\t//\t\tDeclarative hook for setting the label attribute.\r\n\tlabel: \"\",\r\n\r\n\t// identifier: [public] string\r\n\t//\t\tDeclarative hook for setting the identifier.\r\n\tidentifier: \"\",\r\n\r\n\t// separator: [public] string\r\n\t//\t\tDeclatative and programmatic hook for defining the separator\r\n\t//\t\tcharacter used in the Csv style file.\r\n\tseparator: \",\",\r\n\r\n\t// separator: [public] string\r\n\t//\t\tParameter to allow specifying if preventCache should be passed to\r\n\t//\t\tthe xhrGet call or not when loading data from a url.\r\n\t//\t\tNote this does not mean the store calls the server on each fetch,\r\n\t//\t\tonly that the data load has preventCache set as an option.\r\n\turlPreventCache: false,\r\n\r\n\t_assertIsItem: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tThis function tests whether the item passed in is indeed an item in the store.\r\n\t\t// item:\r\n\t\t//\t\tThe item to test for being contained by the store.\r\n\t\tif(!this.isItem(item)){\r\n\t\t\tthrow new Error(this.declaredClass + \": a function was passed an item argument that was not an item\");\r\n\t\t}\r\n\t},\r\n\t\r\n\t_getIndex: function(item){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to get the internal index to the item data from the item handle\r\n\t\t// item:\r\n\t\t//\t\tThe idem handle to get the index for.\r\n\t\tvar idx = this.getIdentity(item);\r\n\t\tif(this.identifier){\r\n\t\t\tidx = this._idMap[idx];\r\n\t\t}\r\n\t\treturn idx;\r\n\t},\r\n\r\n/***************************************\r\n     dojo/data/api/Read API\r\n***************************************/\r\n\tgetValue: function(\t/* item */ item,\r\n\t\t\t\t\t\t/* attribute|attribute-name-string */ attribute,\r\n\t\t\t\t\t\t/* value? */ defaultValue){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getValue()\r\n\t\t//\t\tNote that for the CsvStore, an empty string value is the same as no value,\r\n\t\t//\t\tso the defaultValue would be returned instead of an empty string.\r\n\t\tthis._assertIsItem(item);\r\n\t\tvar itemValue = defaultValue;\r\n\t\tif(typeof attribute === \"string\"){\r\n\t\t\tvar ai = this._attributeIndexes[attribute];\r\n\t\t\tif(ai != null){\r\n\t\t\t\tvar itemData = this._dataArray[this._getIndex(item)];\r\n\t\t\t\titemValue = itemData[ai] || defaultValue;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tthrow new Error(this.declaredClass + \": a function was passed an attribute argument that was not a string\");\r\n\t\t}\r\n\t\treturn itemValue; //String\r\n\t},\r\n\r\n\tgetValues: function(/* item */ item,\r\n\t\t\t\t\t\t/* attribute|attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getValues()\r\n\t\t//\t\tCSV syntax does not support multi-valued attributes, so this is just a\r\n\t\t//\t\twrapper function for getValue().\r\n\t\tvar value = this.getValue(item, attribute);\r\n\t\treturn (value ? [value] : []); //Array\r\n\t},\r\n\r\n\tgetAttributes: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getAttributes()\r\n\t\tthis._assertIsItem(item);\r\n\t\tvar attributes = [];\r\n\t\tvar itemData = this._dataArray[this._getIndex(item)];\r\n\t\tfor(var i=0; i<itemData.length; i++){\r\n\t\t\t// Check for empty string values. CsvStore treats empty strings as no value.\r\n\t\t\tif(itemData[i] !== \"\"){\r\n\t\t\t\tattributes.push(this._attributes[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn attributes; //Array\r\n\t},\r\n\r\n\thasAttribute: function(\t/* item */ item,\r\n\t\t\t\t\t\t\t/* attribute-name-string */ attribute){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.hasAttribute()\r\n\t\t//\t\tThe hasAttribute test is true if attribute has an index number within the item's array length\r\n\t\t//\t\tAND if the item has a value for that attribute. Note that for the CsvStore, an\r\n\t\t//\t\tempty string value is the same as no value.\r\n\t\tthis._assertIsItem(item);\r\n\t\tif(typeof attribute === \"string\"){\r\n\t\t\tvar attributeIndex = this._attributeIndexes[attribute];\r\n\t\t\tvar itemData = this._dataArray[this._getIndex(item)];\r\n\t\t\treturn (typeof attributeIndex !== \"undefined\" && attributeIndex < itemData.length && itemData[attributeIndex] !== \"\"); //Boolean\r\n\t\t}else{\r\n\t\t\tthrow new Error(this.declaredClass + \": a function was passed an attribute argument that was not a string\");\r\n\t\t}\r\n\t},\r\n\r\n\tcontainsValue: function(/* item */ item,\r\n\t\t\t\t\t\t\t/* attribute|attribute-name-string */ attribute,\r\n\t\t\t\t\t\t\t/* anything */ value){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.containsValue()\r\n\t\tvar regexp = undefined;\r\n\t\tif(typeof value === \"string\"){\r\n\t\t\tregexp = filterUtil.patternToRegExp(value, false);\r\n\t\t}\r\n\t\treturn this._containsValue(item, attribute, value, regexp); //boolean.\r\n\t},\r\n\r\n\t_containsValue: function(\t/* item */ item,\r\n\t\t\t\t\t\t\t\t/* attribute|attribute-name-string */ attribute,\r\n\t\t\t\t\t\t\t\t/* anything */ value,\r\n\t\t\t\t\t\t\t\t/* RegExp?*/ regexp){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function for looking at the values contained by the item.\r\n\t\t// description:\r\n\t\t//\t\tInternal function for looking at the values contained by the item.  This\r\n\t\t//\t\tfunction allows for denoting if the comparison should be case sensitive for\r\n\t\t//\t\tstrings or not (for handling filtering cases where string case should not matter)\r\n\t\t// item:\r\n\t\t//\t\tThe data item to examine for attribute values.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to inspect.\r\n\t\t// value:\r\n\t\t//\t\tThe value to match.\r\n\t\t// regexp:\r\n\t\t//\t\tOptional regular expression generated off value if value was of string type to handle wildcarding.\r\n\t\t//\t\tIf present and attribute values are string, then it can be used for comparison instead of 'value'\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar values = this.getValues(item, attribute);\r\n\t\tfor(var i = 0; i < values.length; ++i){\r\n\t\t\tvar possibleValue = values[i];\r\n\t\t\tif(typeof possibleValue === \"string\" && regexp){\r\n\t\t\t\treturn (possibleValue.match(regexp) !== null);\r\n\t\t\t}else{\r\n\t\t\t\t//Non-string matching.\r\n\t\t\t\tif(value === possibleValue){\r\n\t\t\t\t\treturn true; // Boolean\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false; // Boolean\r\n\t},\r\n\r\n\tisItem: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.isItem()\r\n\t\tif(something && something[this._storeProp] === this){\r\n\t\t\tvar identity = something[this._idProp];\r\n\t\t\t//If an identifier was specified, we have to look it up via that and the mapping,\r\n\t\t\t//otherwise, just use row number.\r\n\t\t\tif(this.identifier){\r\n\t\t\t\tvar data = this._dataArray[this._idMap[identity]];\r\n\t\t\t\tif(data){\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif(identity >= 0 && identity < this._dataArray.length){\r\n\t\t\t\t\treturn true; //Boolean\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false; //Boolean\r\n\t},\r\n\r\n\tisItemLoaded: function(/* anything */ something){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.isItemLoaded()\r\n\t\t//\t\tThe CsvStore always loads all items, so if it's an item, then it's loaded.\r\n\t\treturn this.isItem(something); //Boolean\r\n\t},\r\n\r\n\tloadItem: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.loadItem()\r\n\t\t// description:\r\n\t\t//\t\tThe CsvStore always loads all items, so if it's an item, then it's loaded.\r\n\t\t//\r\n\t\t//\t\tFrom the dojo/data/api/Read.loadItem docs:\r\n\t\t//\t\t\tIf a call to isItemLoaded() returns true before loadItem() is even called,\r\n\t\t//\t\t\tthen loadItem() need not do any work at all and will not even invoke\r\n\t\t//\t\t\tthe callback handlers.\r\n\t},\r\n\r\n\tgetFeatures: function(){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getFeatures()\r\n\t\treturn this._features; //Object\r\n\t},\r\n\r\n\tgetLabel: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getLabel()\r\n\t\tif(this.label && this.isItem(item)){\r\n\t\t\treturn this.getValue(item,this.label); //String\r\n\t\t}\r\n\t\treturn undefined; //undefined\r\n\t},\r\n\r\n\tgetLabelAttributes: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.getLabelAttributes()\r\n\t\tif(this.label){\r\n\t\t\treturn [this.label]; //array\r\n\t\t}\r\n\t\treturn null; //null\r\n\t},\r\n\r\n\r\n\t// The dojo/data/api/Read.fetch() function is implemented as\r\n\t// a mixin from dojo.data.util.simpleFetch.\r\n\t// That mixin requires us to define _fetchItems().\r\n\t_fetchItems: function(\t/* Object */ keywordArgs,\r\n\t\t\t\t\t\t\t/* Function */ findCallback,\r\n\t\t\t\t\t\t\t/* Function */ errorCallback){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo.data.util.simpleFetch.fetch()\r\n\t\t// tags:\r\n\t\t//\t\tprotected\r\n\t\tvar self = this;\r\n\t\tvar filter = function(requestArgs, arrayOfAllItems){\r\n\t\t\tvar items = null;\r\n\t\t\tif(requestArgs.query){\r\n\t\t\t\tvar key, value;\r\n\t\t\t\titems = [];\r\n\t\t\t\tvar ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;\r\n\r\n\t\t\t\t//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the\r\n\t\t\t\t//same value for each item examined.  Much more efficient.\r\n\t\t\t\tvar regexpList = {};\r\n\t\t\t\tfor(key in requestArgs.query){\r\n\t\t\t\t\tvalue = requestArgs.query[key];\r\n\t\t\t\t\tif(typeof value === \"string\"){\r\n\t\t\t\t\t\tregexpList[key] = filterUtil.patternToRegExp(value, ignoreCase);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor(var i = 0; i < arrayOfAllItems.length; ++i){\r\n\t\t\t\t\tvar match = true;\r\n\t\t\t\t\tvar candidateItem = arrayOfAllItems[i];\r\n\t\t\t\t\tfor(key in requestArgs.query){\r\n\t\t\t\t\t\tvalue = requestArgs.query[key];\r\n\t\t\t\t\t\tif(!self._containsValue(candidateItem, key, value, regexpList[key])){\r\n\t\t\t\t\t\t\tmatch = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(match){\r\n\t\t\t\t\t\titems.push(candidateItem);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t// We want a copy to pass back in case the parent wishes to sort the array.  We shouldn't allow resort\r\n\t\t\t\t// of the internal list so that multiple callers can get lists and sort without affecting each other.\r\n\t\t\t\titems = arrayOfAllItems.slice(0,arrayOfAllItems.length);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tfindCallback(items, requestArgs);\r\n\t\t};\r\n\r\n\t\tif(this._loadFinished){\r\n\t\t\tfilter(keywordArgs, this._arrayOfAllItems);\r\n\t\t}else{\r\n\t\t\tif(this.url !== \"\"){\r\n\t\t\t\t//If fetches come in before the loading has finished, but while\r\n\t\t\t\t//a load is in progress, we have to defer the fetching to be\r\n\t\t\t\t//invoked in the callback.\r\n\t\t\t\tif(this._loadInProgress){\r\n\t\t\t\t\tthis._queuedFetches.push({args: keywordArgs, filter: filter});\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis._loadInProgress = true;\r\n\t\t\t\t\tvar getArgs = {\r\n\t\t\t\t\t\t\turl: self.url,\r\n\t\t\t\t\t\t\thandleAs: \"text\",\r\n\t\t\t\t\t\t\tpreventCache: self.urlPreventCache\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\tvar getHandler = xhr.get(getArgs);\r\n\t\t\t\t\tgetHandler.addCallback(function(data){\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tself._processData(data);\r\n\t\t\t\t\t\t\tfilter(keywordArgs, self._arrayOfAllItems);\r\n\t\t\t\t\t\t\tself._handleQueuedFetches();\r\n\t\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\t\terrorCallback(e, keywordArgs);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tgetHandler.addErrback(function(error){\r\n\t\t\t\t\t\tself._loadInProgress = false;\r\n\t\t\t\t\t\tif(errorCallback){\r\n\t\t\t\t\t\t\terrorCallback(error, keywordArgs);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tthrow error;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\t//Wire up the cancel to abort of the request\r\n\t\t\t\t\t//This call cancel on the deferred if it hasn't been called\r\n\t\t\t\t\t//yet and then will chain to the simple abort of the\r\n\t\t\t\t\t//simpleFetch keywordArgs\r\n\t\t\t\t\tvar oldAbort = null;\r\n\t\t\t\t\tif(keywordArgs.abort){\r\n\t\t\t\t\t\toldAbort = keywordArgs.abort;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tkeywordArgs.abort = function(){\r\n\t\t\t\t\t\tvar df = getHandler;\r\n\t\t\t\t\t\tif(df && df.fired === -1){\r\n\t\t\t\t\t\t\tdf.cancel();\r\n\t\t\t\t\t\t\tdf = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(oldAbort){\r\n\t\t\t\t\t\t\toldAbort.call(keywordArgs);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}else if(this._csvData){\r\n\t\t\t\ttry{\r\n\t\t\t\t\tthis._processData(this._csvData);\r\n\t\t\t\t\tthis._csvData = null;\r\n\t\t\t\t\tfilter(keywordArgs, this._arrayOfAllItems);\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\terrorCallback(e, keywordArgs);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tvar error = new Error(this.declaredClass + \": No CSV source data was provided as either URL or String data input.\");\r\n\t\t\t\tif(errorCallback){\r\n\t\t\t\t\terrorCallback(error, keywordArgs);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow error;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\t\r\n\tclose: function(/*dojo/data/api/Request|Object?*/  request){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Read.close()\r\n\t},\r\n\t\r\n\t\r\n\t// -------------------------------------------------------------------\r\n\t// Private methods\r\n\t_getArrayOfArraysFromCsvFileContents: function(/* string */ csvFileContents){\r\n\t\t// summary:\r\n\t\t//\t\tParses a string of CSV records into a nested array structure.\r\n\t\t// description:\r\n\t\t//\t\tGiven a string containing CSV records, this method parses\r\n\t\t//\t\tthe string and returns a data structure containing the parsed\r\n\t\t//\t\tcontent.  The data structure we return is an array of length\r\n\t\t//\t\tR, where R is the number of rows (lines) in the CSV data.  The\r\n\t\t//\t\treturn array contains one sub-array for each CSV line, and each\r\n\t\t//\t\tsub-array contains C string values, where C is the number of\r\n\t\t//\t\tcolumns in the CSV data.\r\n\t\t// example:\r\n\t\t//\t\tFor example, given this CSV string as input:\r\n\t\t// |\t\t\"Title, Year, Producer \\n Alien, 1979, Ridley Scott \\n Blade Runner, 1982, Ridley Scott\"\r\n\t\t//\t\tthis._dataArray will be set to:\r\n\t\t// |\t\t[[\"Alien\", \"1979\", \"Ridley Scott\"],\r\n\t\t// |\t\t[\"Blade Runner\", \"1982\", \"Ridley Scott\"]]\r\n\t\t//\t\tAnd this._attributes will be set to:\r\n\t\t// |\t\t[\"Title\", \"Year\", \"Producer\"]\r\n\t\t//\t\tAnd this._attributeIndexes will be set to:\r\n\t\t// |\t\t{ \"Title\":0, \"Year\":1, \"Producer\":2 }\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tif(lang.isString(csvFileContents)){\r\n\t\t\tvar leadingWhiteSpaceCharacters = new RegExp(\"^\\\\s+\",'g');\r\n\t\t\tvar trailingWhiteSpaceCharacters = new RegExp(\"\\\\s+$\",'g');\r\n\t\t\tvar doubleQuotes = new RegExp('\"\"','g');\r\n\t\t\tvar arrayOfOutputRecords = [];\r\n\t\t\tvar i;\r\n\t\t\t\r\n\t\t\tvar arrayOfInputLines = this._splitLines(csvFileContents);\r\n\t\t\tfor(i = 0; i < arrayOfInputLines.length; ++i){\r\n\t\t\t\tvar singleLine = arrayOfInputLines[i];\r\n\t\t\t\tif(singleLine.length > 0){\r\n\t\t\t\t\tvar listOfFields = singleLine.split(this.separator);\r\n\t\t\t\t\tvar j = 0;\r\n\t\t\t\t\twhile(j < listOfFields.length){\r\n\t\t\t\t\t\tvar space_field_space = listOfFields[j];\r\n\t\t\t\t\t\tvar field_space = space_field_space.replace(leadingWhiteSpaceCharacters, ''); // trim leading whitespace\r\n\t\t\t\t\t\tvar field = field_space.replace(trailingWhiteSpaceCharacters, ''); // trim trailing whitespace\r\n\t\t\t\t\t\tvar firstChar = field.charAt(0);\r\n\t\t\t\t\t\tvar lastChar = field.charAt(field.length - 1);\r\n\t\t\t\t\t\tvar secondToLastChar = field.charAt(field.length - 2);\r\n\t\t\t\t\t\tvar thirdToLastChar = field.charAt(field.length - 3);\r\n\t\t\t\t\t\tif(field.length === 2 && field == \"\\\"\\\"\"){\r\n\t\t\t\t\t\t\tlistOfFields[j] = \"\"; //Special case empty string field.\r\n\t\t\t\t\t\t}else if((firstChar == '\"') &&\r\n\t\t\t\t\t\t\t\t((lastChar != '\"') ||\r\n\t\t\t\t\t\t\t\t((lastChar == '\"') && (secondToLastChar == '\"') && (thirdToLastChar != '\"')))){\r\n\t\t\t\t\t\t\tif(j+1 === listOfFields.length){\r\n\t\t\t\t\t\t\t\t// alert(\"The last field in record \" + i + \" is corrupted:\\n\" + field);\r\n\t\t\t\t\t\t\t\treturn; //null\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar nextField = listOfFields[j+1];\r\n\t\t\t\t\t\t\tlistOfFields[j] = field_space + this.separator + nextField;\r\n\t\t\t\t\t\t\tlistOfFields.splice(j+1, 1); // delete element [j+1] from the list\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tif((firstChar == '\"') && (lastChar == '\"')){\r\n\t\t\t\t\t\t\t\tfield = field.slice(1, (field.length - 1)); // trim the \" characters off the ends\r\n\t\t\t\t\t\t\t\tfield = field.replace(doubleQuotes, '\"'); // replace \"\" with \"\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tlistOfFields[j] = field;\r\n\t\t\t\t\t\t\tj += 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tarrayOfOutputRecords.push(listOfFields);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// The first item of the array must be the header row with attribute names.\r\n\t\t\tthis._attributes = arrayOfOutputRecords.shift();\r\n\t\t\tfor(i = 0; i<this._attributes.length; i++){\r\n\t\t\t\t// Store the index of each attribute\r\n\t\t\t\tthis._attributeIndexes[this._attributes[i]] = i;\r\n\t\t\t}\r\n\t\t\tthis._dataArray = arrayOfOutputRecords; //Array\r\n\t\t}\r\n\t},\r\n\r\n\t_splitLines: function(csvContent){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to split the CSV file contents into separate lines.\r\n\t\t//\t\tSince line breaks can occur inside quotes, a Regexp didn't\r\n\t\t//\t\twork as well.  A quick passover parse should be just as efficient.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar split = [];\r\n\t\tvar i;\r\n\t\tvar line = \"\";\r\n\t\tvar inQuotes = false;\r\n\t\tfor(i = 0; i < csvContent.length; i++){\r\n\t\t\tvar c = csvContent.charAt(i);\r\n\t\t\tswitch(c){\r\n\t\t\t\tcase '\\\"':\r\n\t\t\t\t\tinQuotes = !inQuotes;\r\n\t\t\t\t\tline += c;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '\\r':\r\n\t\t\t\t\tif(inQuotes){\r\n\t\t\t\t\t\tline += c;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tsplit.push(line);\r\n\t\t\t\t\t\tline = \"\";\r\n\t\t\t\t\t\tif(i < (csvContent.length - 1) && csvContent.charAt(i + 1) == '\\n'){\r\n\t\t\t\t\t\t\ti++; //Skip it, it's CRLF\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase '\\n':\r\n\t\t\t\t\tif(inQuotes){\r\n\t\t\t\t\t\tline += c;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tsplit.push(line);\r\n\t\t\t\t\t\tline = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tline +=c;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(line !== \"\"){\r\n\t\t\tsplit.push(line);\r\n\t\t}\r\n\t\treturn split;\r\n\t},\r\n\t\r\n\t_processData: function(/* String */ data){\r\n\t\t// summary:\r\n\t\t//\t\tFunction for processing the string data from the server.\r\n\t\t// data: String\r\n\t\t//\t\tThe CSV data.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tthis._getArrayOfArraysFromCsvFileContents(data);\r\n\t\tthis._arrayOfAllItems = [];\r\n\r\n\t\t//Check that the specified Identifier is actually a column title, if provided.\r\n\t\tif(this.identifier){\r\n\t\t\tif(this._attributeIndexes[this.identifier] === undefined){\r\n\t\t\t\tthrow new Error(this.declaredClass + \": Identity specified is not a column header in the data set.\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor(var i=0; i<this._dataArray.length; i++){\r\n\t\t\tvar id = i;\r\n\t\t\t//Associate the identifier to a row in this case\r\n\t\t\t//for o(1) lookup.\r\n\t\t\tif(this.identifier){\r\n\t\t\t\tvar iData = this._dataArray[i];\r\n\t\t\t\tid = iData[this._attributeIndexes[this.identifier]];\r\n\t\t\t\tthis._idMap[id] = i;\r\n\t\t\t}\r\n\t\t\tthis._arrayOfAllItems.push(this._createItemFromIdentity(id));\r\n\t\t}\r\n\t\tthis._loadFinished = true;\r\n\t\tthis._loadInProgress = false;\r\n\t},\r\n\t\r\n\t_createItemFromIdentity: function(/* String */ identity){\r\n\t\t// summary:\r\n\t\t//\t\tFunction for creating a new item from its identifier.\r\n\t\t// identity: String\r\n\t\t//\t\tThe identity\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar item = {};\r\n\t\titem[this._storeProp] = this;\r\n\t\titem[this._idProp] = identity;\r\n\t\treturn item; //Object\r\n\t},\r\n\t\r\n\t\r\n/***************************************\r\n     dojo/data/api/Identity API\r\n***************************************/\r\n\tgetIdentity: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.getIdentity()\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\t\tif(this.isItem(item)){\r\n\t\t\treturn item[this._idProp]; //String\r\n\t\t}\r\n\t\treturn null; //null\r\n\t},\r\n\r\n\tfetchItemByIdentity: function(/* Object */ keywordArgs){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.fetchItemByIdentity()\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\t\tvar item;\r\n\t\tvar scope = keywordArgs.scope?keywordArgs.scope:kernel.global;\r\n\t\t//Hasn't loaded yet, we have to trigger the load.\r\n\t\tif(!this._loadFinished){\r\n\t\t\tvar self = this;\r\n\t\t\tif(this.url !== \"\"){\r\n\t\t\t\t//If fetches come in before the loading has finished, but while\r\n\t\t\t\t//a load is in progress, we have to defer the fetching to be\r\n\t\t\t\t//invoked in the callback.\r\n\t\t\t\tif(this._loadInProgress){\r\n\t\t\t\t\tthis._queuedFetches.push({args: keywordArgs});\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis._loadInProgress = true;\r\n\t\t\t\t\tvar getArgs = {\r\n\t\t\t\t\t\t\turl: self.url,\r\n\t\t\t\t\t\t\thandleAs: \"text\"\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\tvar getHandler = xhr.get(getArgs);\r\n\t\t\t\t\tgetHandler.addCallback(function(data){\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\tself._processData(data);\r\n\t\t\t\t\t\t\tvar item = self._createItemFromIdentity(keywordArgs.identity);\r\n\t\t\t\t\t\t\tif(!self.isItem(item)){\r\n\t\t\t\t\t\t\t\titem = null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tself._handleQueuedFetches();\r\n\t\t\t\t\t\t}catch(error){\r\n\t\t\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\t\t\tkeywordArgs.onError.call(scope, error);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\tgetHandler.addErrback(function(error){\r\n\t\t\t\t\t\tthis._loadInProgress = false;\r\n\t\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\t\tkeywordArgs.onError.call(scope, error);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}else if(this._csvData){\r\n\t\t\t\ttry{\r\n\t\t\t\t\tself._processData(self._csvData);\r\n\t\t\t\t\tself._csvData = null;\r\n\t\t\t\t\titem = self._createItemFromIdentity(keywordArgs.identity);\r\n\t\t\t\t\tif(!self.isItem(item)){\r\n\t\t\t\t\t\titem = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t\t\t}\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\tif(keywordArgs.onError){\r\n\t\t\t\t\t\tkeywordArgs.onError.call(scope, e);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t//Already loaded.  We can just look it up and call back.\r\n\t\t\titem = this._createItemFromIdentity(keywordArgs.identity);\r\n\t\t\tif(!this.isItem(item)){\r\n\t\t\t\titem = null;\r\n\t\t\t}\r\n\t\t\tif(keywordArgs.onItem){\r\n\t\t\t\tkeywordArgs.onItem.call(scope, item);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tgetIdentityAttributes: function(/* item */ item){\r\n\t\t// summary:\r\n\t\t//\t\tSee dojo/data/api/Identity.getIdentifierAttributes()\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\r\n\t\t// Identity isn't a public attribute in the item, it's the row position index.\r\n\t\t// So, return null.\r\n\t\tif(this.identifier){\r\n\t\t\treturn [this.identifier];\r\n\t\t}else{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t},\r\n\r\n\t_handleQueuedFetches: function(){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to execute delayed request in the store.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\r\n\t\t// Execute any deferred fetches now.\r\n\t\tif(this._queuedFetches.length > 0){\r\n\t\t\tfor(var i = 0; i < this._queuedFetches.length; i++){\r\n\t\t\t\tvar fData = this._queuedFetches[i];\r\n\t\t\t\tvar delayedFilter = fData.filter;\r\n\t\t\t\tvar delayedQuery = fData.args;\r\n\t\t\t\tif(delayedFilter){\r\n\t\t\t\t\tdelayedFilter(delayedQuery, this._arrayOfAllItems);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.fetchItemByIdentity(fData.args);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._queuedFetches = [];\r\n\t\t}\r\n\t}\r\n});\r\n//Mix in the simple fetch implementation to this class.\r\nlang.extend(CsvStore, simpleFetch);\r\n\r\nreturn CsvStore;\r\n});\r\n"]}