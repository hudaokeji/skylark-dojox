{"version":3,"sources":["data/ClientFilter.js"],"names":["define","declare","lang","array","Deferred","filter","addUpdate","store","create","remove","item","_updates","push","ClientFilter","onUpdate","cacheByDefault","constructor","this","onSet","onNew","onDelete","_fetchCache","clearCache","updateResultSet","resultSet","request","isUpdateable","i","_version","length","j","getIdentity","splice","updated","matchesQuery","indexOf","sort","makeComparator","concat","_fullLength","count","Infinity","querySuperSet","argsSuper","argsSub","query","Object","clientQuery","mixin","patternToRegExp","test","serverVersion","cachingFetch","args","self","cachedArgs","defResult","_loading","callback","cacheResults","addCallback","results","clientSideFetch","fullLength","serverArgs","putInCache","queryOptions","cache","fetchCache","undefined","start","_doQuery","addErrback","version","baseResults","value","clientSidePaging","finalResults","slice","ignoreCase","match","getValue","current","shift","attribute","descending","next","a","b","av","bv"],"mappings":"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","file":"../../data/ClientFilter.js","sourcesContent":["define([\"dojo/_base/declare\", \"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/_base/Deferred\", \"dojo/data/util/filter\"], \r\n  function(declare, lang, array, Deferred, filter) {\r\n\r\n// This is an abstract data store module for adding updatable result set functionality to an existing data store class\r\n\r\n\tvar addUpdate = function(store,create,remove){\r\n\t\t// create a handler that adds to the list of notifications\r\n\t\treturn function(item){\r\n\t\t\tstore._updates.push({\r\n\t\t\t\t\tcreate:create && item,\r\n\t\t\t\t\tremove:remove && item\r\n\t\t\t\t});\r\n\t\t\tClientFilter.onUpdate();\r\n\t\t}\r\n\t};\r\n\tvar ClientFilter = declare(\"dojox.data.ClientFilter\", null, {\r\n\t\t\tcacheByDefault: false,\r\n\t\t\tconstructor: function(){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tThis is an abstract class that data stores can extend to add updateable result set functionality\r\n\t\t\t\t//\t\tas well as client side querying capabilities. This enables\r\n\t\t\t\t//\t\twidgets to be aware of how active results change in response to the modifications/notifications.\r\n\t\t\t\t// description:\r\n\t\t\t\t//\t\tTo a update a result set after a notification (onNew, onSet, and onDelete),\r\n\t\t\t\t//\t\twidgets can call the updateResultSet method. Widgets can use the updated\r\n\t\t\t\t//\t\tresult sets to determine how to react to notifications, and how to update their displayed results\r\n\t\t\t\t//\t\tbased on changes.\r\n\t\t\t\t//\r\n\t\t\t\t//\t\tThis module will use the best available information to update result sets, using query attribute\r\n\t\t\t\t//\t\tobjects to determine if items are in a result set, and using the sort arrays to maintain sort\r\n\t\t\t\t//\t\tinformation. However, queries can be opaque strings, and this module can not update\r\n\t\t\t\t//\t\tresults by itself in this case. In this situations, data stores can provide a isUpdateable(request) function\r\n\t\t\t\t//\t\tand matchesQuery(item,request) function. If a data store can handle a query, it can return true from\r\n\t\t\t\t//\t\tisUpdateable and if an item matches a query, it can return true from matchesQuery. Here is\r\n\t\t\t\t//\t\tdefinition of isUpdateable and matchesQuery:\r\n\t\t\t\t//\r\n\t\t\t\t//\t\t- isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.\r\n\t\t\t\t//\t\t- matchesQuery(item,request) - item is the item to test, and request is the value arguments object\r\n\t\t\t\t//\t\tfor the fetch function.\r\n\t\t\t\t//\r\n\t\t\t\t//\t\tYou can define a property on this object instance \"cacheByDefault\" to a value of true that will\r\n\t\t\t\t//\t\tcause all queries to be cached by default unless the cache queryOption is explicitly set to false.\r\n\t\t\t\t//\t\tThis can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.\r\n\t\t\t\t//\r\n\t\t\t\t// example:\r\n\t\t\t\t//\t\tto make a updated-result-set data store from an existing data store:\r\n\t\t\t\t//\t|\tdeclare(\"dojox.data.MyLiveDataStore\",\r\n\t\t\t\t//\t|\t\tdojox.data.MyDataStore,dojox.data.ClientFilter], // subclass LiveResultSets if available\r\n\t\t\t\t//\t|\t\t{}\r\n\t\t\t\t//\t|\t);\r\n\t\t\t\tthis.onSet = addUpdate(this,true,true);\r\n\t\t\t\tthis.onNew = addUpdate(this,true,false);\r\n\t\t\t\tthis.onDelete = addUpdate(this,false,true);\r\n\t\t\t\tthis._updates= [];\r\n\t\t\t\tthis._fetchCache = [];\r\n\t\t\t},\r\n\t\t\tclearCache: function(){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tClears the cache of client side queries\r\n\t\t\t\tthis._fetchCache = [];\r\n\t\t\t},\r\n\t\t\tupdateResultSet: function(/*Array*/ resultSet, /*Object*/ request){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tAttempts to update the given result set based on previous notifications\r\n\t\t\t\t// resultSet:\r\n\t\t\t\t//\t\tThe result set array that should be updated\r\n\t\t\t\t// request:\r\n\t\t\t\t//\t\tThis object follows the same meaning as the keywordArgs passed to a dojo/data/api/Read.fetch.\r\n\t\t\t\t// description:\r\n\t\t\t\t//\t\tThis will attempt to update the provide result based on previous notification, adding new items\r\n\t\t\t\t//\t\tfrom onNew calls, removing deleted items, and updating modified items, and properly removing\r\n\t\t\t\t//\t\tand adding items as required by the query and sort parameters.\r\n\t\t\t\t// returns:\r\n\t\t\t\t//\t\t- 0: Indicates it could not successfully update the result set\r\n\t\t\t\t//\t\t- 1: Indicates it could successfully handle all the notifications, but no changes were made to the result set\r\n\t\t\t\t//\t\t- 2: Indicates it successfully handled all the notifications and result set has been updated.\r\n\t\t\t\tif(this.isUpdateable(request)){\r\n\t\t\t\t\t// we try to avoid rerunning notification updates more than once on the same object for performance\r\n\t\t\t\t\tfor(var i = request._version || 0; i < this._updates.length;i++){\r\n\t\t\t\t\t\t// for each notification,we will update the result set\r\n\t\t\t\t\t\tvar create = this._updates[i].create;\r\n\t\t\t\t\t\tvar remove = this._updates[i].remove;\r\n\t\t\t\t\t\tif(remove){\r\n\t\t\t\t\t\t\tfor(var j = 0; j < resultSet.length;j++){\r\n\t\t\t\t\t\t\t\tif(this.getIdentity(resultSet[j]) == this.getIdentity(remove)){\r\n\t\t\t\t\t\t\t\t\tresultSet.splice(j--,1);\r\n\t\t\t\t\t\t\t\t\tvar updated = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(create && this.matchesQuery(create,request) && // if there is a new/replacement item and it matches the query\r\n\t\t\t\t\t\t\t\tarray.indexOf(resultSet,create) == -1){ // and it doesn't already exist in query\r\n\t\t\t\t\t\t\tresultSet.push(create); // should this go at the beginning by default instead?\r\n\t\t\t\t\t\t\tupdated = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(request.sort && updated){\r\n\t\t\t\t\t\t// do the sort if needed\r\n\t\t\t\t\t\tresultSet.sort(this.makeComparator(request.sort.concat()));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresultSet._fullLength = resultSet.length;\r\n\t\t\t\t\tif(request.count && updated && request.count !== Infinity){\r\n\t\t\t\t\t\t// do we really need to do this?\r\n\t\t\t\t\t\t// make sure we still find within the defined paging set\r\n\t\t\t\t\t\tresultSet.splice(request.count, resultSet.length);\r\n\t\t\t\t\t}\r\n\t\t\t\t\trequest._version = this._updates.length;\r\n\t\t\t\t\treturn updated ? 2 : 1;\r\n\t\t\t\t}\r\n\t\t\t\treturn 0;\r\n\t\t\t},\r\n\t\t\tquerySuperSet: function(argsSuper, argsSub){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tDetermines whether the provided arguments are super/sub sets of each other\r\n\t\t\t\t// argsSuper:\r\n\t\t\t\t//\t\tDojo Data Fetch arguments\r\n\t\t\t\t// argsSub:\r\n\t\t\t\t//\t\tDojo Data Fetch arguments\r\n\t\t\t\tif(argsSuper.query == argsSub.query){\r\n\t\t\t\t\treturn {};\r\n\t\t\t\t}\r\n\t\t\t\tif(!(argsSub.query instanceof Object && // sub query must be an object\r\n\t\t\t\t\t\t// super query must be non-existent or an object\r\n\t\t\t\t\t\t(!argsSuper.query || typeof argsSuper.query == 'object'))){\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tvar clientQuery = lang.mixin({},argsSub.query);\r\n\t\t\t\tfor(var i in argsSuper.query){\r\n\t\t\t\t\tif(clientQuery[i] == argsSuper.query[i]){\r\n\t\t\t\t\t\tdelete clientQuery[i];\r\n\t\t\t\t\t}else if(!(typeof argsSuper.query[i] == 'string' &&\r\n\t\t\t\t\t\t\t// if it is a pattern, we can test to see if it is a sub-pattern\r\n\t\t\t\t\t\t\t// FIXME: This is not technically correct, but it will work for the majority of cases\r\n\t\t\t\t\t\t\tfilter.patternToRegExp(argsSuper.query[i]).test(clientQuery[i]))){\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn clientQuery;\r\n\t\t\t},\r\n\t\t\t//\tThis is the point in the version notification history at which it is known that the server is in sync, this should\r\n\t\t\t//\tbe updated to this._updates.length on commit operations.\r\n\t\t\tserverVersion: 0,\r\n\t\t\t\r\n\t\t\tcachingFetch: function(args){\r\n\t\t\t\tvar self = this;\r\n\t\t\t\tfor(var i = 0; i < this._fetchCache.length;i++){\r\n\t\t\t\t\tvar cachedArgs = this._fetchCache[i];\r\n\t\t\t\t\tvar clientQuery = this.querySuperSet(cachedArgs,args);\r\n\t\t\t\t\tif(clientQuery !== false){\r\n\t\t\t\t\t\tvar defResult = cachedArgs._loading;\r\n\t\t\t\t\t\tif(!defResult){\r\n\t\t\t\t\t\t\tdefResult = new Deferred();\r\n\t\t\t\t\t\t\tdefResult.callback(cachedArgs.cacheResults);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdefResult.addCallback(function(results){\r\n\t\t\t\t\t\t\tresults = self.clientSideFetch(lang.mixin(lang.mixin({}, args),{query:clientQuery}), results);\r\n\t\t\t\t\t\t\tdefResult.fullLength = results._fullLength;\r\n\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\targs._version = cachedArgs._version;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(!defResult){\r\n\t\t\t\t\tvar serverArgs = lang.mixin({}, args);\r\n\t\t\t\t\tvar putInCache = (args.queryOptions || 0).cache;\r\n\t\t\t\t\tvar fetchCache = this._fetchCache;\r\n\t\t\t\t\tif(putInCache === undefined ? this.cacheByDefault : putInCache){\r\n\t\t\t\t\t\t// we are caching this request, so we want to get all the data, and page on the client side\r\n\t\t\t\t\t\tif(args.start || args.count){\r\n\t\t\t\t\t\t\tdelete serverArgs.start;\r\n\t\t\t\t\t\t\tdelete serverArgs.count;\r\n\t\t\t\t\t\t\targs.clientQuery = lang.mixin(args.clientQuery || {}, {\r\n\t\t\t\t\t\t\t\tstart: args.start,\r\n\t\t\t\t\t\t\t\tcount: args.count\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\targs = serverArgs;\r\n\t\t\t\t\t\tfetchCache.push(args);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdefResult= args._loading = this._doQuery(args);\r\n\r\n\t\t\t\t\tdefResult.addErrback(function(){\r\n\t\t\t\t\t\tfetchCache.splice(array.indexOf(fetchCache, args), 1);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tvar version = this.serverVersion;\r\n\t\t\t\t\r\n\t\t\t\tdefResult.addCallback(function(results){\r\n\t\t\t\t\tdelete args._loading;\r\n\t\t\t\t\t// update the result set in case anything changed while we were waiting for the fetch\r\n\t\t\t\t\tif(results){\r\n\t\t\t\t\t\targs._version = typeof args._version == \"number\" ? args._version : version;\r\n\t\t\t\t\t\tself.updateResultSet(results,args);\r\n\t\t\t\t\t\targs.cacheResults = results;\r\n\t\t\t\t\t\tif(!args.count || results.length < args.count){\r\n\t\t\t\t\t\t\tdefResult.fullLength = ((args.start)?args.start:0) + results.length;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn results;\r\n\t\t\t\t});\r\n\t\t\t\treturn defResult;\r\n\t\t\t},\r\n\t\t\tisUpdateable: function(/*Object*/ request){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tReturns whether the provide fetch arguments can be used to update an existing list\r\n\t\t\t\t// request:\r\n\t\t\t\t//\t\tSee dojo/data/api/Read.fetch request\r\n\t\t\t\t\r\n\t\t\t\treturn !request.query || typeof request.query == \"object\";\r\n\t\t\t},\r\n\t\t\tclientSideFetch: function(/*Object*/ request,/*Array*/ baseResults){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tPerforms a query on the client side and returns the results as an array\r\n\t\t\t\t// request:\r\n\t\t\t\t//\t\tSee dojo/data/api/Read.fetch request\r\n\t\t\t\t// baseResults:\r\n\t\t\t\t//\t\tThis provides the result set to start with for client side querying\r\n\t\t\t\tif(request.queryOptions && request.queryOptions.results){\r\n\t\t\t\t\tbaseResults = request.queryOptions.results;\r\n\t\t\t\t}\r\n\t\t\t\tif(request.query){\r\n\t\t\t\t\t// filter by the query\r\n\t\t\t\t\tvar results = [];\r\n\t\t\t\t\tfor(var i = 0; i < baseResults.length; i++){\r\n\t\t\t\t\t\tvar value = baseResults[i];\r\n\t\t\t\t\t\tif(value && this.matchesQuery(value,request)){\r\n\t\t\t\t\t\t\tresults.push(baseResults[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tresults = request.sort ? baseResults.concat() : baseResults; // we don't want to mutate the baseResults if we are doing a sort\r\n\t\t\t\t}\r\n\t\t\t\tif(request.sort){\r\n\t\t\t\t\t// do the sort if needed\r\n\t\t\t\t\tresults.sort(this.makeComparator(request.sort.concat()));\r\n\t\t\t\t}\r\n\t\t\t\treturn this.clientSidePaging(request, results);\r\n\t\t\t},\r\n\t\t\tclientSidePaging: function(/*Object*/ request,/*Array*/ baseResults){\r\n\t\t\t\tvar start = request.start || 0;\r\n\t\t\t\tvar finalResults = (start || request.count) ? baseResults.slice(start,start + (request.count || baseResults.length)) : baseResults;\r\n\t\t\t\tfinalResults._fullLength = baseResults.length;\r\n\t\t\t\treturn finalResults;\r\n\t\t\t},\r\n\t\t\tmatchesQuery: function(item,request){\r\n\t\t\t\tvar query = request.query;\r\n\t\t\t\tvar ignoreCase = request.queryOptions && request.queryOptions.ignoreCase;\r\n\t\t\t\tfor(var i in query){\r\n\t\t\t\t\t// if anything doesn't match, than this should be in the query\r\n\t\t\t\t\tvar match = query[i];\r\n\t\t\t\t\tvar value = this.getValue(item,i);\r\n\t\t\t\t\tif((typeof match == 'string' && (match.match(/[\\*\\.]/) || ignoreCase)) ?\r\n\t\t\t\t\t\t!filter.patternToRegExp(match, ignoreCase).test(value) :\r\n\t\t\t\t\t\tvalue != match){\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t\tmakeComparator: function(sort){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\treturns a comparator function for the given sort order array\r\n\t\t\t\t// sort:\r\n\t\t\t\t//\t\tSee dojox.data.api.Read.fetch\r\n\t\t\t\tvar current = sort.shift();\r\n\t\t\t\tif(!current){\r\n\t\t\t\t\t// sort order for ties and no sort orders\r\n\t\t\t\t\treturn function(){\r\n\t\t\t\t\t\treturn 0;// keep the order unchanged\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tvar attribute = current.attribute;\r\n\t\t\t\tvar descending = !!current.descending;\r\n\t\t\t\tvar next = this.makeComparator(sort);\r\n\t\t\t\tvar store = this;\r\n\t\t\t\treturn function(a,b){\r\n\t\t\t\t\tvar av = store.getValue(a,attribute);\r\n\t\t\t\t\tvar bv = store.getValue(b,attribute);\r\n\t\t\t\t\tif(av != bv){\r\n\t\t\t\t\t\treturn av < bv == descending ? 1 : -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn next(a,b);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n\tClientFilter.onUpdate = function(){};\r\n\r\n\treturn ClientFilter;\r\n});\r\n"]}