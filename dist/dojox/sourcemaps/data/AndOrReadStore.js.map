{"version":3,"sources":["data/AndOrReadStore.js"],"names":["define","declare","lang","ItemFileReadStore","filterUtil","array","json","_containsValue","item","attribute","value","regexp","some","this","getValues","possibleValue","isString","eval","isObject","toString","match","filter","requestArgs","arrayOfItems","findCallback","items","query","fromJson","toJson","count","p","complexQuery","cq","wrapped","v","ignoreCase","queryOptions","replace","trim","pos2","i","quotes","pos1","colon","flag","length","indexOf","complexQuerySave","begRegExp","sQuery","op","val","pos","err","key","tok","candidateItem","toUpperCase","opsRegex","matches","shift","regex","substring","getValue","patternToRegExp","pos3","Array","j","Math","min","console","log","push"],"mappings":"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","file":"../../data/AndOrReadStore.js","sourcesContent":["define([\"dojo/_base/declare\", \"dojo/_base/lang\", \"dojo/data/ItemFileReadStore\", \"dojo/data/util/filter\", \"dojo/_base/array\", \"dojo/_base/json\"],\r\n  function(declare, lang, ItemFileReadStore, filterUtil, array, json) {\r\n  \r\n// module:\r\n//\t\tdojox/data/AndOrReadStore\r\n// summary:\r\n//\t\tTODOC\r\n\r\nreturn declare(\"dojox.data.AndOrReadStore\", [ItemFileReadStore], {\r\n\t// summary:\r\n\t//\t\tAndOrReadStore uses ItemFileReadStore as a base, modifying only the query (_fetchItems) section.\r\n\t//\t\tSupports queries of the form: query:\"id:1* OR dept:'Sales Department' || (id:2* && NOT dept:S*)\"\r\n\t//\t\tIncludes legacy/widget support via:\r\n\t// |\t\tquery:{complexQuery:\"id:1* OR dept:'Sales Department' || (id:2* && NOT dept:S*)\"}\r\n\t//\t\tThe ItemFileReadStore implements the dojo/data/api/Read API and reads\r\n\t//\t\tdata from JSON files that have contents in this format --\r\n\t// |\t{ items: [\r\n\t// |\t\t{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},\r\n\t// |\t\t{ name:'Fozzie Bear', wears:['hat', 'tie']},\r\n\t// |\t\t{ name:'Miss Piggy', pets:'Foo-Foo'}\r\n\t// |\t]}\r\n\t//\t\tNote that it can also contain an 'identifier' property that specified which attribute on the items\r\n\t//\t\tin the array of items that acts as the unique identifier for that item.\r\n\r\n\t_containsValue: function(/*dojo/data/api/Item*/ item, /*attribute-name-string */ attribute, /*anything*/ value,\r\n\t\t\t/*String|RegExp?*/ regexp){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function for looking at the values contained by the item.\r\n\t\t// description:\r\n\t\t//\t\tInternal function for looking at the values contained by the item.  This\r\n\t\t//\t\tfunction allows for denoting if the comparison should be case sensitive for\r\n\t\t//\t\tstrings or not (for handling filtering cases where string case should not matter)\r\n\t\t// item:\r\n\t\t//\t\tThe data item to examine for attribute values.\r\n\t\t// attribute:\r\n\t\t//\t\tThe attribute to inspect.\r\n\t\t// value:\r\n\t\t//\t\tThe value to match.\r\n\t\t// regexp:\r\n\t\t//\t\tOptional string or regular expression generated off value if value was of string type to handle wildcarding.\r\n\t\t//\t\tIf present and attribute values are string, then it can be used for comparison instead of 'value'\r\n\t\t//\t\tIf RegExp is a string, it is treated as an comparison statement and eval for number comparisons\r\n\t\treturn array.some(this.getValues(item, attribute), function(possibleValue){\r\n\t\t\t// if string... eval for math operator comparisons\r\n\t\t\tif(lang.isString(regexp)){\r\n\t\t\t\treturn eval(regexp);\r\n\t\t\t}else if(possibleValue !== null && !lang.isObject(possibleValue) && regexp){\r\n\t\t\t\tif(possibleValue.toString().match(regexp)){\r\n\t\t\t\t\treturn true; // Boolean\r\n\t\t\t\t}\r\n\t\t\t} else if(value === possibleValue){\r\n\t\t\t\treturn true; // Boolean\r\n\t\t\t} else {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tfilter: function(requestArgs, arrayOfItems, findCallback){\r\n\t\tvar items = [];\r\n\t\tif(requestArgs.query){\r\n\t\t\t//Complete copy, we may have to mess with it.\r\n\t\t\t//Safer than clone, which does a shallow copy, I believe.\r\n\t\t\tvar query = json.fromJson(json.toJson(requestArgs.query));\r\n\t\t\t//Okay, object form query, we have to check to see if someone mixed query methods (such as using FilteringSelect\r\n\t\t\t//with a complexQuery).  In that case, the params need to be anded to the complex query statement.\r\n\t\t\t//See defect #7980\r\n\t\t\tif(typeof query == \"object\" ){\r\n\t\t\t\tvar count = 0;\r\n\t\t\t\tvar p;\r\n\t\t\t\tfor(p in query){\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t\tif(count > 1 && query.complexQuery){\r\n\t\t\t\t\tvar cq = query.complexQuery;\r\n\t\t\t\t\tvar wrapped = false;\r\n\t\t\t\t\tfor(p in query){\r\n\t\t\t\t\t\tif(p !== \"complexQuery\"){\r\n\t\t\t\t\t\t\t//We should wrap this in () as it should and with the entire complex query\r\n\t\t\t\t\t\t\t//Not just part of it.\r\n\t\t\t\t\t\t\tif(!wrapped){\r\n\t\t\t\t\t\t\t\tcq = \"( \" + cq + \" )\";\r\n\t\t\t\t\t\t\t\twrapped = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t//Make sure strings are quoted when going into complexQuery merge.\r\n\t\t\t\t\t\t\tvar v = requestArgs.query[p];\r\n\t\t\t\t\t\t\tif(lang.isString(v)){\r\n\t\t\t\t\t\t\t\tv = \"'\" + v + \"'\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcq += \" AND \" + p + \":\" + v;\r\n\t\t\t\t\t\t\tdelete query[p];\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tquery.complexQuery = cq;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;\r\n\t\t\t//for complex queries only:  pattern = query[:|=]\"NOT id:23* AND (type:'test*' OR dept:'bob') && !filed:true\"\r\n\t\t\t//logical operators are case insensitive:  , NOT AND OR ( ) ! && ||  // \",\" included for quoted/string legacy queries.\r\n\t\t\tif(typeof query != \"string\"){\r\n\t\t\t\tquery = json.toJson(query);\r\n\t\t\t\tquery = query.replace(/\\\\\\\\/g,\"\\\\\"); //counter toJson expansion of backslashes, e.g., foo\\\\*bar test.\r\n\t\t\t}\r\n\t\t\tquery = query.replace(/\\\\\"/g,\"\\\"\");   //ditto, for embedded \\\" in lieu of \" availability.\r\n\t\t\tvar complexQuery = lang.trim(query.replace(/{|}/g,\"\")); //we can handle these, too.\r\n\t\t\tvar pos2, i;\r\n\t\t\tif(complexQuery.match(/\"? *complexQuery *\"?:/)){ //case where widget required a json object, so use complexQuery:'the real query'\r\n\t\t\t\tcomplexQuery = lang.trim(complexQuery.replace(/\"?\\s*complexQuery\\s*\"?:/,\"\"));\r\n\t\t\t\tvar quotes = [\"'\",'\"'];\r\n\t\t\t\tvar pos1,colon;\r\n\t\t\t\tvar flag = false;\r\n\t\t\t\tfor(i = 0; i<quotes.length; i++){\r\n\t\t\t\t\tpos1 = complexQuery.indexOf(quotes[i]);\r\n\t\t\t\t\tpos2 = complexQuery.indexOf(quotes[i],1);\r\n\t\t\t\t\tcolon = complexQuery.indexOf(\":\",1);\r\n\t\t\t\t\tif(pos1 === 0 && pos2 != -1 && colon < pos2){\r\n\t\t\t\t\t\tflag = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t} //first two sets of quotes don't occur before the first colon.\r\n\t\t\t\t}\r\n\t\t\t\tif(flag){\t//dojo.toJson, and maybe user, adds surrounding quotes, which we need to remove.\r\n\t\t\t\t\tcomplexQuery = complexQuery.replace(/^\\\"|^\\'|\\\"$|\\'$/g,\"\");\r\n\t\t\t\t}\r\n\t\t\t} //end query=\"{complexQuery:'id:1* || dept:Sales'}\" parsing (for when widget required json object query).\r\n\t\t\tvar complexQuerySave = complexQuery;\r\n\t\t\t//valid logical operators.\r\n\t\t\tvar begRegExp = /^>=|^<=|^<|^>|^,|^NOT |^AND |^OR |^\\(|^\\)|^!|^&&|^\\|\\|/i; //trailing space on some tokens on purpose.\r\n\t\t\tvar sQuery = \"\"; //will be eval'ed for each i-th candidateItem, based on query components.\r\n\t\t\tvar op = \"\";\r\n\t\t\tvar val = \"\";\r\n\t\t\tvar pos = -1;\r\n\t\t\tvar err = false;\r\n\t\t\tvar key = \"\";\r\n\t\t\tvar value = \"\";\r\n\t\t\tvar tok = \"\";\r\n\t\t\tpos2 = -1;\r\n\t\t\tfor(i = 0; i < arrayOfItems.length; ++i){\r\n\t\t\t\tvar match = true;\r\n\t\t\t\tvar candidateItem = arrayOfItems[i];\r\n\t\t\t\tif(candidateItem === null){\r\n\t\t\t\t\tmatch = false;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//process entire string for this i-th candidateItem.\r\n\t\t\t\t\tcomplexQuery = complexQuerySave; //restore query for next candidateItem.\r\n\t\t\t\t\tsQuery = \"\";\r\n\t\t\t\t\t//work left to right, finding either key:value pair or logical operator at the beginning of the complexQuery string.\r\n\t\t\t\t\t//when found, concatenate to sQuery and remove from complexQuery and loop back.\r\n\t\t\t\t\twhile(complexQuery.length > 0 && !err){\r\n\t\t\t\t\t\top = complexQuery.match(begRegExp);\r\n\r\n\t\t\t\t\t\t//get/process/append one or two leading logical operators.\r\n\t\t\t\t\t\twhile(op && !err){ //look for leading logical operators.\r\n\t\t\t\t\t\t\tcomplexQuery = lang.trim(complexQuery.replace(op[0],\"\"));\r\n\t\t\t\t\t\t\top = lang.trim(op[0]).toUpperCase();\r\n\t\t\t\t\t\t\t//convert some logical operators to their javascript equivalents for later eval.\r\n\t\t\t\t\t\t\top = op == \"NOT\" ? \"!\" : op == \"AND\" || op == \",\" ? \"&&\" : op == \"OR\" ? \"||\" : op;\r\n\t\t\t\t\t\t\top = \" \" + op + \" \";\r\n\t\t\t\t\t\t\tsQuery += op;\r\n\t\t\t\t\t\t\top = complexQuery.match(begRegExp);\r\n\t\t\t\t\t\t}//end op && !err\r\n\r\n\t\t\t\t\t\t//now get/process/append one key:value pair.\r\n\t\t\t\t\t\tif(complexQuery.length > 0){\r\n\t\t\t\t\t\t\tvar opsRegex = /:|>=|<=|>|</g,\r\n\t\t\t\t\t\t\t\tmatches = complexQuery.match(opsRegex),\r\n\t\t\t\t\t\t\t\tmatch = matches && matches.shift(),\r\n\t\t\t\t\t\t\t\tregex;\r\n\r\n\t\t\t\t\t\t\tpos = complexQuery.indexOf(match);\r\n\t\t\t\t\t\t\tif(pos == -1){\r\n\t\t\t\t\t\t\t\terr = true;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tkey = lang.trim(complexQuery.substring(0,pos).replace(/\\\"|\\'/g,\"\"));\r\n\t\t\t\t\t\t\t\tcomplexQuery = lang.trim(complexQuery.substring(pos + match.length));\r\n\t\t\t\t\t\t\t\ttok = complexQuery.match(/^\\'|^\\\"/);\t//quoted?\r\n\t\t\t\t\t\t\t\tif(tok){\r\n\t\t\t\t\t\t\t\t\ttok = tok[0];\r\n\t\t\t\t\t\t\t\t\tpos = complexQuery.indexOf(tok);\r\n\t\t\t\t\t\t\t\t\tpos2 = complexQuery.indexOf(tok,pos + 1);\r\n\t\t\t\t\t\t\t\t\tif(pos2 == -1){\r\n\t\t\t\t\t\t\t\t\t\terr = true;\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tvalue = complexQuery.substring(pos + match.length,pos2);\r\n\t\t\t\t\t\t\t\t\tif(pos2 == complexQuery.length - 1){ //quote is last character\r\n\t\t\t\t\t\t\t\t\t\tcomplexQuery = \"\";\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\tcomplexQuery = lang.trim(complexQuery.substring(pos2 + 1));\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif (match != ':') {\r\n\t\t\t\t\t\t\t\t\t\tregex = this.getValue(candidateItem, key) + match + value;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tregex = filterUtil.patternToRegExp(value, ignoreCase);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tsQuery += this._containsValue(candidateItem, key, value, regex);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse{ //not quoted, so a space, comma, or closing parens (or the end) will be the break.\r\n\t\t\t\t\t\t\t\t\ttok = complexQuery.match(/\\s|\\)|,/);\r\n\t\t\t\t\t\t\t\t\tif(tok){\r\n\t\t\t\t\t\t\t\t\t\tvar pos3 = new Array(tok.length);\r\n\t\t\t\t\t\t\t\t\t\tfor(var j = 0;j<tok.length;j++){\r\n\t\t\t\t\t\t\t\t\t\t\tpos3[j] = complexQuery.indexOf(tok[j]);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tpos = pos3[0];\r\n\t\t\t\t\t\t\t\t\t\tif(pos3.length > 1){\r\n\t\t\t\t\t\t\t\t\t\t\tfor(var j=1;j<pos3.length;j++){\r\n\t\t\t\t\t\t\t\t\t\t\t\tpos = Math.min(pos,pos3[j]);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\tvalue = lang.trim(complexQuery.substring(0,pos));\r\n\t\t\t\t\t\t\t\t\t\tcomplexQuery = lang.trim(complexQuery.substring(pos));\r\n\t\t\t\t\t\t\t\t\t}else{ //not a space, so must be at the end of the complexQuery.\r\n\t\t\t\t\t\t\t\t\t\tvalue = lang.trim(complexQuery);\r\n\t\t\t\t\t\t\t\t\t\tcomplexQuery = \"\";\r\n\t\t\t\t\t\t\t\t\t} //end  inner if(tok) else\r\n\t\t\t\t\t\t\t\t\tif (match != ':') {\r\n\t\t\t\t\t\t\t\t\t\tregex = this.getValue(candidateItem, key) + match + value;\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tregex = filterUtil.patternToRegExp(value, ignoreCase);\r\n\t\t\t\t\t\t\t\t\t\tconsole.log(\"regex value: \", value, \" regex pattern: \", regex);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tsQuery += this._containsValue(candidateItem, key, value, regex);\r\n\t\t\t\t\t\t\t\t} //end outer if(tok) else\r\n\t\t\t\t\t\t\t} //end found \":\"\r\n\t\t\t\t\t\t} //end if(complexQuery.length > 0)\r\n\t\t\t\t\t} //end while complexQuery.length > 0 && !err, so finished the i-th item.\r\n\t\t\t\t\tmatch = eval(sQuery);\r\n\t\t\t\t} //end else is non-null candidateItem.\r\n\t\t\t\tif(match){\r\n\t\t\t\t\titems.push(candidateItem);\r\n\t\t\t\t}\r\n\t\t\t} //end for/next of all items.\r\n\t\t\tif(err){\r\n\t\t\t\t//soft fail.\r\n\t\t\t\titems = [];\r\n\t\t\t\tconsole.log(\"The store's _fetchItems failed, probably due to a syntax error in query.\");\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// No query...\r\n\t\t\t// We want a copy to pass back in case the parent wishes to sort the array.\r\n\t\t\t// We shouldn't allow resort of the internal list, so that multiple callers\r\n\t\t\t// can get lists and sort without affecting each other.  We also need to\r\n\t\t\t// filter out any null values that have been left as a result of deleteItem()\r\n\t\t\t// calls in ItemFileWriteStore.\r\n\t\t\tfor(var i = 0; i < arrayOfItems.length; ++i){\r\n\t\t\t\tvar item = arrayOfItems[i];\r\n\t\t\t\tif(item !== null){\r\n\t\t\t\t\titems.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} //end if there is a query.\r\n\t\tfindCallback(items, requestArgs);\r\n\t} //end filter function\r\n\r\n});\r\n\r\n});\r\n"]}