{"version":3,"sources":["encoding/digests/SHA1.js"],"names":["define","base","chrsz","mask","R","n","c","FT","t","b","d","KT","core","x","len","w","Array","a","e","i","length","olda","oldb","oldc","oldd","olde","j","addWords","toWord","s","wa","l","charCodeAt","toHex","h","push","charAt","join","_toString","String","fromCharCode","toBase64","SHA1","data","outputType","out","outputTypes","Base64","Raw","Hex","_hmac","key","ipad","opad","hash","concat","hmac"],"mappings":"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","file":"../../../encoding/digests/SHA1.js","sourcesContent":["define([\"./_base\"], function(base){\r\n/*\r\n * A port of Paul Johnstone's SHA1 implementation\r\n *\r\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for details.\r\n *\r\n * Dojo port by Tom Trenka\r\n */\r\n\r\n\tvar chrsz=8,\t//\tchange to 16 for unicode.\r\n\t\tmask=(1<<chrsz)-1;\r\n\r\n\tfunction R(n,c){ return (n<<c)|(n>>>(32-c)); }\r\n\tfunction FT(t,b,c,d){\r\n\t\tif(t<20){ return (b&c)|((~b)&d); }\r\n\t\tif(t<40){ return b^c^d; }\r\n\t\tif(t<60){ return (b&c)|(b&d)|(c&d); }\r\n\t\treturn b^c^d;\r\n\t}\r\n\tfunction KT(t){ return (t<20)?1518500249:(t<40)?1859775393:(t<60)?-1894007588:-899497514; }\r\n\r\n\tfunction core(x,len){\r\n\t\tx[len>>5]|=0x80<<(24-len%32);\r\n\t\tx[((len+64>>9)<<4)+15]=len;\r\n\r\n\t\tvar w=new Array(80), a=1732584193, b=-271733879, c=-1732584194, d=271733878, e=-1009589776;\r\n\t\tfor(var i=0; i<x.length; i+=16){\r\n\t\t\tvar olda=a, oldb=b, oldc=c, oldd=d, olde=e;\r\n\t\t\tfor(var j=0;j<80;j++){\r\n\t\t\t\tif(j<16){ w[j]=x[i+j]; }\r\n\t\t\t\telse { w[j]=R(w[j-3]^w[j-8]^w[j-14]^w[j-16],1); }\r\n\t\t\t\tvar t = base.addWords(base.addWords(R(a,5),FT(j,b,c,d)),base.addWords(base.addWords(e,w[j]),KT(j)));\r\n\t\t\t\te=d; d=c; c=R(b,30); b=a; a=t;\r\n\t\t\t}\r\n\t\t\ta=base.addWords(a,olda);\r\n\t\t\tb=base.addWords(b,oldb);\r\n\t\t\tc=base.addWords(c,oldc);\r\n\t\t\td=base.addWords(d,oldd);\r\n\t\t\te=base.addWords(e,olde);\r\n\t\t}\r\n\t\treturn [a, b, c, d, e];\r\n\t}\r\n\r\n\tfunction hmac(data, key){\r\n\t\tvar wa=toWord(key);\r\n\t\tif(wa.length>16){ wa=core(wa, key.length*chrsz); }\r\n\r\n\t\tvar ipad=new Array(16), opad=new Array(16);\r\n\t\tfor(var i=0;i<16;i++){\r\n\t\t\tipad[i]=wa[i]^0x36363636;\r\n\t\t\topad[i]=wa[i]^0x5c5c5c5c;\r\n\t\t}\r\n\r\n\t\tvar hash=core(ipad.concat(toWord(data)),512+data.length*chrsz);\r\n\t\treturn core(opad.concat(hash), 512+160);\r\n\t}\r\n\r\n\tfunction toWord(s){\r\n\t\tvar wa=[];\r\n\t\tfor(var i=0, l=s.length*chrsz; i<l; i+=chrsz){\r\n\t\t\twa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(32-chrsz-i%32);\r\n\t\t}\r\n\t\treturn wa;\t//\tword[]\r\n\t}\r\n\r\n\tfunction toHex(wa){\r\n\t\t//\tslightly different than the common one.\r\n\t\tvar h=\"0123456789abcdef\", s=[];\r\n\t\tfor(var i=0, l=wa.length*4; i<l; i++){\r\n\t\t\ts.push(h.charAt((wa[i>>2]>>((3-i%4)*8+4))&0xF), h.charAt((wa[i>>2]>>((3-i%4)*8))&0xF));\r\n\t\t}\r\n\t\treturn s.join(\"\");\t//\tstring\r\n\t}\r\n\r\n\tfunction _toString(wa){\r\n\t\tvar s=[];\r\n\t\tfor(var i=0, l=wa.length*32; i<l; i+=chrsz){\r\n\t\t\ts.push(String.fromCharCode((wa[i>>5]>>>(32-chrsz-i%32))&mask));\r\n\t\t}\r\n\t\treturn s.join(\"\");\t//\tstring\r\n\t}\r\n\r\n\tfunction toBase64(/* word[] */wa){\r\n\t\t// summary:\r\n\t\t//\t\tconvert an array of words to base64 encoding, should be more efficient\r\n\t\t//\t\tthan using dojox.encoding.base64\r\n\t\tvar p=\"=\", tab=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", s=[];\r\n\t\tfor(var i=0, l=wa.length*4; i<l; i+=3){\r\n\t\t\tvar t=(((wa[i>>2]>>8*(3-i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*(3-(i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*(3-(i+2)%4))&0xFF);\r\n\t\t\tfor(var j=0; j<4; j++){\r\n\t\t\t\tif(i*8+j*6>wa.length*32){\r\n\t\t\t\t\ts.push(p);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ts.push(tab.charAt((t>>6*(3-j))&0x3F));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn s.join(\"\");\t//\tstring\r\n\t};\r\n\r\n\t//\tpublic function\r\n\tbase.SHA1=function(/* String */data, /* dojox.encoding.digests.outputTypes? */outputType){\r\n\t\t// summary:\r\n\t\t//\t\tComputes the SHA1 digest of the data, and returns the result according to output type.\r\n\t\tvar out=outputType||base.outputTypes.Base64;\r\n\t\tvar wa=core(toWord(data), data.length*chrsz);\r\n\t\tswitch(out){\r\n\t\t\tcase base.outputTypes.Raw:{\r\n\t\t\t\treturn wa;\t//\tword[]\r\n\t\t\t}\r\n\t\t\tcase base.outputTypes.Hex:{\r\n\t\t\t\treturn toHex(wa);\t//\tstring\r\n\t\t\t}\r\n\t\t\tcase base.outputTypes.String:{\r\n\t\t\t\treturn _toString(wa);\t//\tstring\r\n\t\t\t}\r\n\t\t\tdefault:{\r\n\t\t\t\treturn toBase64(wa);\t//\tstring\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t//\tmake this private, for later use with a generic HMAC calculator.\r\n\tbase.SHA1._hmac=function(/* string */data, /* string */key, /* dojox.encoding.digests.outputTypes? */outputType){\r\n\t\t// summary:\r\n\t\t//\t\tcomputes the digest of data, and returns the result according to type outputType\r\n\t\tvar out=outputType || base.outputTypes.Base64;\r\n\t\tvar wa=hmac(data, key);\r\n\t\tswitch(out){\r\n\t\t\tcase base.outputTypes.Raw:{\r\n\t\t\t\treturn wa;\t//\tword[]\r\n\t\t\t}\r\n\t\t\tcase base.outputTypes.Hex:{\r\n\t\t\t\treturn toHex(wa);\t//\tstring\r\n\t\t\t}\r\n\t\t\tcase base.outputTypes.String:{\r\n\t\t\t\treturn _toString(wa);\t//\tstring\r\n\t\t\t}\r\n\t\t\tdefault:{\r\n\t\t\t\treturn toBase64(wa);\t//\tstring\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\treturn base.SHA1;\r\n});\r\n"]}