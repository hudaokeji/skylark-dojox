{"version":3,"sources":["encoding/digests/_sha2.js"],"names":["define","_sha","_keyLength","_blockSize","_hash","hasher","data","outputType","outputTypes","Base64","wa","digest","toWord","length","Raw","Hex","toHex","String","_toString","toBase64","hmac","key","numWords","ipad","Array","opad","i","r1","concat","r2","_hmac"],"mappings":";;;;;;;AAAAA,UAAW,WAGV,OAAO,SAAwBC,EAAkBC,EAA2BC,EAAuBC,GAClG,SAASC,EAAmBC,EAAgCC,GAC3DA,EAAaA,GAAcN,EAAKO,YAAYC,OAC5C,IAAIC,EAAKT,EAAKU,OAAOV,EAAKW,OAAON,GAAqB,EAAdA,EAAKO,OAAYT,EAAOF,GAEhE,OAAOK,GACN,KAAKN,EAAKO,YAAYM,IACrB,OAAOJ,EAER,KAAKT,EAAKO,YAAYO,IACrB,OAAOd,EAAKe,MAAMN,GAEnB,KAAKT,EAAKO,YAAYS,OACrB,OAAOhB,EAAKiB,UAAUR,GAEvB,QACC,OAAOT,EAAKkB,SAAST,IA+CxB,OA1CAL,EAAOe,KAAO,SAAsBd,EAAkBe,EAAgCd,GACrFA,EAAaA,GAAcN,EAAKO,YAAYC,OAG5C,IAAIC,EAAKT,EAAKW,OAAOS,GAClBX,EAAGG,OAAS,KACdH,EAAKT,EAAKU,OAAOD,EAAiB,EAAbW,EAAIR,OAAYT,EAAOF,IAO7C,IAHA,IAAIoB,EAAWnB,EAAa,GAC3BoB,EAAO,IAAIC,MAAMF,GACjBG,EAAO,IAAID,MAAMF,GACVI,EAAE,EAAGA,EAAEJ,EAAUI,IACxBH,EAAKG,GAAa,UAARhB,EAAGgB,GACbD,EAAKC,GAAa,WAARhB,EAAGgB,GAId,IAAIC,EAAK1B,EAAKU,OAAOY,EAAKK,OAAO3B,EAAKW,OAAON,IAAQH,EAA2B,EAAdG,EAAKO,OAAYT,EAAOF,GACtF2B,EAAK5B,EAAKU,OAAOc,EAAKG,OAAOD,GAAKxB,EAAaD,EAAYE,EAAOF,GAGtE,OAAOK,GACN,KAAKN,EAAKO,YAAYM,IACrB,OAAOe,EAER,KAAK5B,EAAKO,YAAYO,IACrB,OAAOd,EAAKe,MAAMa,GAEnB,KAAK5B,EAAKO,YAAYS,OACrB,OAAOhB,EAAKiB,UAAUW,GAEvB,QACC,OAAO5B,EAAKkB,SAASU,KAMxBxB,EAAOyB,MAAQzB,EAAOe,KAEff","file":"../../../encoding/digests/_sha2.js","sourcesContent":["define([], function () {\r\n\t// Return a hashing function for a _sha helper (_sha-32 or _sha-64), a key length, a block size, and a set\r\n\t// of constants.\r\n\treturn function (/* sha32/64 */_sha, /* Number */_keyLength, /* Blocksize */_blockSize, /* Array */_hash) {\r\n\t\tfunction hasher(/* String */data, /* sha32/64.outputTypes */outputType) {\r\n\t\t\toutputType = outputType || _sha.outputTypes.Base64;\r\n\t\t\tvar wa = _sha.digest(_sha.toWord(data), data.length * 8, _hash, _keyLength);\r\n\r\n\t\t\tswitch(outputType){\r\n\t\t\t\tcase _sha.outputTypes.Raw: {\r\n\t\t\t\t\treturn wa;\r\n\t\t\t\t}\r\n\t\t\t\tcase _sha.outputTypes.Hex: {\r\n\t\t\t\t\treturn _sha.toHex(wa);\r\n\t\t\t\t}\r\n\t\t\t\tcase _sha.outputTypes.String: {\r\n\t\t\t\t\treturn _sha._toString(wa);\r\n\t\t\t\t}\r\n\t\t\t\tdefault: {\r\n\t\t\t\t\treturn _sha.toBase64(wa);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thasher.hmac = function (/* String */data, /* String */key, /* sha32/64.outputTypes? */outputType) {\r\n\t\t\toutputType = outputType || _sha.outputTypes.Base64;\r\n\r\n\t\t\t//\tprepare the key\r\n\t\t\tvar wa = _sha.toWord(key);\r\n\t\t\tif(wa.length > 16){\r\n\t\t\t\twa = _sha.digest(wa, key.length * 8, _hash, _keyLength);\r\n\t\t\t}\r\n\r\n\t\t\t//\tset up the pads\r\n\t\t\tvar numWords = _blockSize / 32,\r\n\t\t\t\tipad = new Array(numWords),\r\n\t\t\t\topad = new Array(numWords);\r\n\t\t\tfor(var i=0; i<numWords; i++){\r\n\t\t\t\tipad[i] = wa[i] ^ 0x36363636;\r\n\t\t\t\topad[i] = wa[i] ^ 0x5c5c5c5c;\r\n\t\t\t}\r\n\r\n\t\t\t//\tmake the final digest\r\n\t\t\tvar r1 = _sha.digest(ipad.concat(_sha.toWord(data)), _blockSize + data.length * 8, _hash, _keyLength);\r\n\t\t\tvar r2 = _sha.digest(opad.concat(r1), _blockSize + _keyLength, _hash, _keyLength);\r\n\r\n\t\t\t//\treturn the output\r\n\t\t\tswitch(outputType){\r\n\t\t\t\tcase _sha.outputTypes.Raw: {\r\n\t\t\t\t\treturn r2;\r\n\t\t\t\t}\r\n\t\t\t\tcase _sha.outputTypes.Hex: {\r\n\t\t\t\t\treturn _sha.toHex(r2);\r\n\t\t\t\t}\r\n\t\t\t\tcase _sha.outputTypes.String: {\r\n\t\t\t\t\treturn _sha._toString(r2);\r\n\t\t\t\t}\r\n\t\t\t\tdefault: {\r\n\t\t\t\t\treturn _sha.toBase64(r2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// for backwards compatibility\r\n\t\thasher._hmac = hasher.hmac;\r\n\r\n\t\treturn hasher;\r\n\t};\r\n});\r\n"]}