{"version":3,"sources":["encoding/crypto/SimpleAES.js"],"names":["define","base64","crypto","Sbox","Rcon","Cipher","input","w","Nr","length","state","i","Math","floor","AddRoundKey","round","MixColumns","ShiftRows","SubBytes","output","Array","s","Nb","r","c","t","a","b","rnd","KeyExpansion","key","Nk","temp","SubWord","RotWord","stringToHex","ret","replace","str","push","parseInt","SimpleAES","this","encrypt","plaintext","password","nBits","nBytes","pwBytes","charCodeAt","concat","slice","counterBlock","nonce","Date","getTime","keySchedule","blockCount","ceil","ciphertext","cipherCntr","blockLength","ct","cipherByte","toString","ctrTxt","join","AESEncryptCtr","decrypt","split","pt","tmp","plaintextByte","String","fromCharCode","AESDecryptCtr"],"mappings":";;;;;;;AAAAA,QAAQ,YAAa,WACpB,SAASC,EAAQC,GAGjB,IAAIC,GAAQ,GAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAK,EAAK,IAAK,GAAK,IAAK,IAAK,IAAK,IACnF,IAAK,IAAK,IAAK,IAAK,IAAK,GAAK,GAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAC3E,IAAK,IAAK,IAAK,GAAK,GAAK,GAAK,IAAK,IAAK,GAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAK,GAC3E,EAAK,IAAK,GAAK,IAAK,GAAK,IAAK,EAAK,IAAK,EAAK,GAAK,IAAK,IAAK,IAAK,GAAK,IAAK,IAC3E,EAAK,IAAK,GAAK,GAAK,GAAK,IAAK,GAAK,IAAK,GAAK,GAAK,IAAK,IAAK,GAAK,IAAK,GAAK,IAC3E,GAAK,IAAK,EAAK,IAAK,GAAK,IAAK,IAAK,GAAK,IAAK,IAAK,IAAK,GAAK,GAAK,GAAK,GAAK,IAC3E,IAAK,IAAK,IAAK,IAAK,GAAK,GAAK,GAAK,IAAK,GAAK,IAAK,EAAK,IAAK,GAAK,GAAK,IAAK,IAC3E,GAAK,IAAK,GAAK,IAAK,IAAK,IAAK,GAAK,IAAK,IAAK,IAAK,IAAK,GAAK,GAAK,IAAK,IAAK,IAC3E,IAAK,GAAK,GAAK,IAAK,GAAK,IAAK,GAAK,GAAK,IAAK,IAAK,IAAK,GAAK,IAAK,GAAK,GAAK,IAC3E,GAAK,IAAK,GAAK,IAAK,GAAK,GAAK,IAAK,IAAK,GAAK,IAAK,IAAK,GAAK,IAAK,GAAK,GAAK,IAC3E,IAAK,GAAK,GAAK,GAAK,GAAK,EAAK,GAAK,GAAK,IAAK,IAAK,IAAK,GAAK,IAAK,IAAK,IAAK,IAC3E,IAAK,IAAK,GAAK,IAAK,IAAK,IAAK,GAAK,IAAK,IAAK,GAAK,IAAK,IAAK,IAAK,IAAK,IAAK,EAC3E,IAAK,IAAK,GAAK,GAAK,GAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAK,GAAK,IAAK,IAAK,IAC3E,IAAK,GAAK,IAAK,IAAK,GAAK,EAAK,IAAK,GAAK,GAAK,GAAK,GAAK,IAAK,IAAK,IAAK,GAAK,IAC3E,IAAK,IAAK,IAAK,GAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAK,IAAK,IAAK,IAAK,GAAK,GAAK,IAC3E,IAAK,IAAK,IAAK,GAAK,IAAK,IAAK,GAAK,IAAK,GAAK,IAAK,GAAK,GAAK,IAAK,GAAK,IAAK,IAG3EC,IAAU,EAAM,EAAM,EAAM,IAC3B,EAAM,EAAM,EAAM,IAClB,EAAM,EAAM,EAAM,IAClB,EAAM,EAAM,EAAM,IAClB,EAAM,EAAM,EAAM,IAClB,GAAM,EAAM,EAAM,IAClB,GAAM,EAAM,EAAM,IAClB,GAAM,EAAM,EAAM,IAClB,IAAM,EAAM,EAAM,IAClB,GAAM,EAAM,EAAM,IAClB,GAAM,EAAM,EAAM,IAYvB,SAASC,EAAOC,EAAOC,GAKrB,IAJA,IACIC,EAAKD,EAAEE,OADF,EACc,EAEnBC,gBACKC,EAAE,EAAGA,EAAE,GAAMA,IAAKD,EAAMC,EAAE,GAAGC,KAAKC,MAAMF,EAAE,IAAML,EAAMK,GAE/DD,EAAQI,EAAYJ,EAAOH,EAAG,EANrB,GAQT,IAAK,IAAIQ,EAAM,EAAGA,EAAMP,EAAIO,IAI7BL,EAAQI,EADRJ,EAAQM,EADRN,EAAQO,EADRP,EAAQQ,EAASR,EATP,GAAA,GAAA,GAYiBH,EAAGQ,EAZpB,GAiBTL,EAAQI,EADRJ,EAAQO,EADRP,EAAQQ,EAASR,EAfR,GAAA,GAiBkBH,EAAGC,EAjBrB,GAmBT,IAAIW,EAAS,IAAIC,MAAM,IACvB,IAAST,EAAE,EAAGA,EAAE,GAAMA,IAAKQ,EAAOR,GAAKD,EAAMC,EAAE,GAAGC,KAAKC,MAAMF,EAAE,IAC/D,OAAOQ,EAIT,SAASD,EAASG,EAAGC,GACnB,IAAK,IAAIC,EAAE,EAAGA,EAAE,EAAGA,IACpB,IAAK,IAAIC,EAAE,EAAGA,EAAEF,EAAIE,IAAKH,EAAEE,GAAGC,GAAKrB,EAAKkB,EAAEE,GAAGC,IAE5C,OAAOH,EAIT,SAASJ,EAAUI,EAAGC,GAEpB,IADA,IAAIG,EAAI,IAAIL,MAAM,GACTG,EAAE,EAAGA,EAAE,EAAGA,IAAK,CACzB,IAAK,IAAIC,EAAE,EAAGA,EAAE,EAAGA,IAAKC,EAAED,GAAKH,EAAEE,IAAIC,EAAED,GAAGD,GAC1C,IAASE,EAAE,EAAGA,EAAE,EAAGA,IAAKH,EAAEE,GAAGC,GAAKC,EAAED,GAEnC,OAAOH,EAIT,SAASL,EAAWK,EAAGC,GACrB,IAAK,IAAIE,EAAE,EAAGA,EAAE,EAAGA,IAAK,CAGzB,IAFA,IAAIE,EAAI,IAAIN,MAAM,GACdO,EAAI,IAAIP,MAAM,GACTT,EAAE,EAAGA,EAAE,EAAGA,IACjBe,EAAEf,GAAKU,EAAEV,GAAGa,GACZG,EAAEhB,GAAa,IAARU,EAAEV,GAAGa,GAAUH,EAAEV,GAAGa,IAAI,EAAI,IAASH,EAAEV,GAAGa,IAAI,EAGvDH,EAAE,GAAGG,GAAKG,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKA,EAAE,GACxCL,EAAE,GAAGG,GAAKE,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GAAKD,EAAE,GACxCL,EAAE,GAAGG,GAAKE,EAAE,GAAKA,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKC,EAAE,GACxCN,EAAE,GAAGG,GAAKE,EAAE,GAAKC,EAAE,GAAKD,EAAE,GAAKA,EAAE,GAAKC,EAAE,GAEvC,OAAON,EAIT,SAASP,EAAYJ,EAAOH,EAAGqB,EAAKN,GAClC,IAAK,IAAIC,EAAE,EAAGA,EAAE,EAAGA,IACpB,IAAK,IAAIC,EAAE,EAAGA,EAAEF,EAAIE,IAAKd,EAAMa,GAAGC,IAAMjB,EAAM,EAAJqB,EAAMJ,GAAGD,GAElD,OAAOb,EAIT,SAASmB,EAAaC,GAQpB,IAPA,IACIC,EAAKD,EAAIrB,OAAO,EAChBD,EAAKuB,EAAK,EAEVxB,EAAI,IAAIa,MAJH,GAIaZ,EAAG,IACrBwB,EAAO,IAAIZ,MAAM,GAEZT,EAAE,EAAGA,EAAEoB,EAAIpB,IAAK,CAC1B,IAAIY,GAAKO,EAAI,EAAEnB,GAAImB,EAAI,EAAEnB,EAAE,GAAImB,EAAI,EAAEnB,EAAE,GAAImB,EAAI,EAAEnB,EAAE,IACnDJ,EAAEI,GAAKY,EAGN,IAASZ,EAAEoB,EAAIpB,EAZN,GAYaH,EAAG,GAAKG,IAAK,CACpCJ,EAAEI,GAAK,IAAIS,MAAM,GACjB,IAAK,IAAIK,EAAE,EAAGA,EAAE,EAAGA,IAAKO,EAAKP,GAAKlB,EAAEI,EAAE,GAAGc,GACzC,GAAId,EAAIoB,GAAM,EAAG,CACfC,EAAOC,EAAQC,EAAQF,IACvB,IAASP,EAAE,EAAGA,EAAE,EAAGA,IAAKO,EAAKP,IAAMrB,EAAKO,EAAEoB,GAAIN,QACrCM,EAAK,GAAKpB,EAAEoB,GAAM,IAC3BC,EAAOC,EAAQD,IAEjB,IAASP,EAAE,EAAGA,EAAE,EAAGA,IAAKlB,EAAEI,GAAGc,GAAKlB,EAAEI,EAAEoB,GAAIN,GAAKO,EAAKP,GAGnD,OAAOlB,EAGT,SAAS0B,EAAQ1B,GACf,IAAK,IAAII,EAAE,EAAGA,EAAE,EAAGA,IAAKJ,EAAEI,GAAKR,EAAKI,EAAEI,IACtC,OAAOJ,EAGT,SAAS2B,EAAQ3B,GACfA,EAAE,GAAKA,EAAE,GACT,IAAK,IAAII,EAAE,EAAGA,EAAE,EAAGA,IAAKJ,EAAEI,GAAKJ,EAAEI,EAAE,GACnC,OAAOJ,EAyET,SAAS4B,EAAYd,GACpB,IAAIe,KAIJ,OAHAf,EAAEgB,QAAQ,QAAS,SAASC,GAC3BF,EAAIG,KAAKC,SAASF,EAAK,OAEjBF,EAwGR,OAnCAlC,EAAOuC,UAAY,IAAI,WAqBtBC,KAAKC,QAAU,SAAqBC,EAAuBd,GAI1D,OAhKF,SAAuBc,EAAWC,EAAUC,GAC1C,GAAa,KAAPA,GAAqB,KAAPA,GAAqB,KAAPA,EAAa,MAAO,GAMtD,IAFA,IAAIC,EAASD,EAAM,EACfE,EAAU,IAAI5B,MAAM2B,GACfpC,EAAE,EAAGA,EAAEoC,EAAQpC,IAAKqC,EAAQrC,GAA8B,IAAzBkC,EAASI,WAAWtC,GAE9D,IAAImB,EAAMzB,EAAO2C,EAASnB,EAAamB,IAEvClB,EAAMA,EAAIoB,OAAOpB,EAAIqB,MAAM,EAAGJ,EAAO,KAIrC,IACIK,EAAe,IAAIhC,MADP,IAEZiC,GAAQ,IAAKC,MAAQC,UAGzB,IAAS5C,EAAE,EAAGA,EAAE,EAAGA,IAAKyC,EAAazC,GAAM0C,IAAY,EAAF1C,EAAO,IAC5D,IAASA,EAAE,EAAGA,EAAE,EAAGA,IAAKyC,EAAazC,EAAE,GAAM0C,EAAM,aAAkB,EAAF1C,EAAO,IAQ1E,IALA,IAAI6C,EAAc3B,EAAaC,GAE3B2B,EAAa7C,KAAK8C,KAAKd,EAAUnC,OAXrB,IAYZkD,EAAa,IAAIvC,MAAMqC,GAElB9B,EAAE,EAAGA,EAAE8B,EAAY9B,IAAK,CAGlC,IAAK,IAAIH,EAAE,EAAGA,EAAE,EAAGA,IAAK4B,EAAa,GAAG5B,GAAMG,IAAQ,EAAFH,EAAO,IAC3D,IAASA,EAAE,EAAGA,EAAE,EAAGA,IAAK4B,EAAa,GAAG5B,EAAE,GAAMG,EAAE,aAAkB,EAAFH,EAElE,IAAIoC,EAAavD,EAAO+C,EAAcI,GAGlCK,EAAclC,EAAE8B,EAAW,EAvBd,IAuB+Bb,EAAUnC,OAAO,GAvBhD,GAuB6D,EAE1EqD,EAAK,GACT,IAASnD,EAAE,EAAGA,EAAEkD,EAAalD,IAAK,CAChC,IACIoD,EADgBnB,EAAUK,WA3Bf,GA2B0BtB,EAAYhB,GACpBiD,EAAWjD,GAE5CmD,IAAQC,EAAa,GAAM,IAAM,IAAMA,EAAWC,SAAS,IAI7DL,EAAWhC,GAAKmC,EAIf,IAAIG,EAAS,GACb,IAAStD,EAAE,EAAGA,EAAE,EAAGA,IAAKsD,IAAYb,EAAazC,GAAK,GAAM,IAAM,IAAMyC,EAAazC,GAAGqD,SAAS,IAIjG,OAAOC,EAAS,IAAMN,EAAWO,KAAK,KAsG/BC,CAAcvB,EAAWd,EAAK,MAEtCY,KAAK0B,QAAU,SAAqBT,EAAwB7B,GAI3D,OA1FF,SAAuB6B,EAAYd,EAAUC,GAC3C,GAAa,KAAPA,GAAqB,KAAPA,GAAqB,KAAPA,EAAa,MAAO,GAItD,IAFA,IAAIC,EAASD,EAAM,EACfE,EAAU,IAAI5B,MAAM2B,GACfpC,EAAE,EAAGA,EAAEoC,EAAQpC,IAAKqC,EAAQrC,GAA8B,IAAzBkC,EAASI,WAAWtC,GAC9D,IACImB,EAAMzB,EAAO2C,EADGnB,EAAamB,IAI7BQ,EAAc3B,EAFlBC,EAAMA,EAAIoB,OAAOpB,EAAIqB,MAAM,EAAGJ,EAAO,MAIrCY,EAAaA,EAAWU,MAAM,KAG9B,IACIjB,EAAe,IAAIhC,MADP,IAGhBgC,EAAejB,EADFwB,EAAW,IAKxB,IAFA,IAAIf,EAAY,IAAIxB,MAAMuC,EAAWlD,OAAO,GAEnCkB,EAAE,EAAGA,EAAEgC,EAAWlD,OAAQkB,IAAK,CAEzC,IAAK,IAAIH,EAAE,EAAGA,EAAE,EAAGA,IAAK4B,EAAa,GAAG5B,GAAOG,EAAE,IAAS,EAAFH,EAAO,IAC/D,IAASA,EAAE,EAAGA,EAAE,EAAGA,IAAK4B,EAAa,GAAG5B,EAAE,GAAOG,EAAE,WAAY,IAAS,EAAFH,EAAO,IAE7E,IAAIoC,EAAavD,EAAO+C,EAAcI,GAIlCc,EAAK,GACLC,EAAMpC,EAAYwB,EAAWhC,IACjC,IAAShB,EAAE,EAAGA,EAAE4D,EAAI9D,OAAQE,IAAK,CAEVgD,EAAWhC,GAAGsB,WAAWtC,GAA9C,IACI6D,EAAgBD,EAAI5D,GAAKiD,EAAWjD,GACxC2D,GAAMG,OAAOC,aAAaF,GAI5B5B,EAAUjB,EAAE,GAAK2C,EAGhB,OAAO1B,EAAUsB,KAAK,IA8CfS,CAAchB,EAAY7B,EAAK,OAIjC5B,EAAOuC","file":"../../../encoding/crypto/SimpleAES.js","sourcesContent":["define([\"../base64\", \"./_base\"], \r\n function(base64, crypto){\r\n\r\n\t// Sbox is pre-computed multiplicative inverse in GF(2^8) used in SubBytes and KeyExpansion [5.1.1]\r\n\tvar Sbox =\t[0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,\r\n\t\t\t\t 0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,\r\n\t\t\t\t 0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,\r\n\t\t\t\t 0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,\r\n\t\t\t\t 0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,\r\n\t\t\t\t 0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,\r\n\t\t\t\t 0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,\r\n\t\t\t\t 0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,\r\n\t\t\t\t 0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,\r\n\t\t\t\t 0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,\r\n\t\t\t\t 0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,\r\n\t\t\t\t 0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,\r\n\t\t\t\t 0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,\r\n\t\t\t\t 0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,\r\n\t\t\t\t 0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,\r\n\t\t\t\t 0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16];\r\n\r\n\t// Rcon is Round Constant used for the Key Expansion [1st col is 2^(r-1) in GF(2^8)] [5.2]\r\n\tvar Rcon = [ [0x00, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x01, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x02, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x04, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x08, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x10, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x20, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x40, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x80, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x1b, 0x00, 0x00, 0x00],\r\n\t\t\t\t [0x36, 0x00, 0x00, 0x00] ];\r\n\r\n\t/*\r\n\t * AES Cipher function: encrypt 'input' with Rijndael algorithm\r\n\t *\r\n\t *\t takes\t byte-array 'input' (16 bytes)\r\n\t *\t\t\t 2D byte-array key schedule 'w' (Nr+1 x Nb bytes)\r\n\t *\r\n\t *\t applies Nr rounds (10/12/14) using key schedule w for 'add round key' stage\r\n\t *\r\n\t *\t returns byte-array encrypted value (16 bytes)\r\n\t */\r\n\tfunction Cipher(input, w) {\t   // main Cipher function [��5.1]\r\n\t  var Nb = 4;\t\t\t\t// block size (in words): no of columns in state (fixed at 4 for AES)\r\n\t  var Nr = w.length/Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys\r\n\r\n\t  var state = [[],[],[],[]];  // initialise 4xNb byte-array 'state' with input [3.4]\r\n\t  for (var i=0; i<4*Nb; i++) state[i%4][Math.floor(i/4)] = input[i];\r\n\r\n\t  state = AddRoundKey(state, w, 0, Nb);\r\n\r\n\t  for (var round=1; round<Nr; round++) {\r\n\t\tstate = SubBytes(state, Nb);\r\n\t\tstate = ShiftRows(state, Nb);\r\n\t\tstate = MixColumns(state, Nb);\r\n\t\tstate = AddRoundKey(state, w, round, Nb);\r\n\t  }\r\n\r\n\t  state = SubBytes(state, Nb);\r\n\t  state = ShiftRows(state, Nb);\r\n\t  state = AddRoundKey(state, w, Nr, Nb);\r\n\r\n\t  var output = new Array(4*Nb);\t // convert state to 1-d array before returning [3.4]\r\n\t  for (var i=0; i<4*Nb; i++) output[i] = state[i%4][Math.floor(i/4)];\r\n\t  return output;\r\n\t}\r\n\r\n\r\n\tfunction SubBytes(s, Nb) {\t  // apply SBox to state S [5.1.1]\r\n\t  for (var r=0; r<4; r++) {\r\n\t\tfor (var c=0; c<Nb; c++) s[r][c] = Sbox[s[r][c]];\r\n\t  }\r\n\t  return s;\r\n\t}\r\n\r\n\r\n\tfunction ShiftRows(s, Nb) {\t   // shift row r of state S left by r bytes [5.1.2]\r\n\t  var t = new Array(4);\r\n\t  for (var r=1; r<4; r++) {\r\n\t\tfor (var c=0; c<4; c++) t[c] = s[r][(c+r)%Nb];\t// shift into temp copy\r\n\t\tfor (var c=0; c<4; c++) s[r][c] = t[c];\t\t\t// and copy back\r\n\t  }\t\t\t // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):\r\n\t  return s;\t // see fp.gladman.plus.com/cryptography_technology/rijndael/aes.spec.311.pdf\r\n\t}\r\n\r\n\r\n\tfunction MixColumns(s, Nb) {   // combine bytes of each col of state S [5.1.3]\r\n\t  for (var c=0; c<4; c++) {\r\n\t\tvar a = new Array(4);  // 'a' is a copy of the current column from 's'\r\n\t\tvar b = new Array(4);  // 'b' is a�ށ{02} in GF(2^8)\r\n\t\tfor (var i=0; i<4; i++) {\r\n\t\t  a[i] = s[i][c];\r\n\t\t  b[i] = s[i][c]&0x80 ? s[i][c]<<1 ^ 0x011b : s[i][c]<<1;\r\n\t\t}\r\n\t\t// a[n] ^ b[n] is a�ށ{03} in GF(2^8)\r\n\t\ts[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]; // 2*a0 + 3*a1 + a2 + a3\r\n\t\ts[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]; // a0 * 2*a1 + 3*a2 + a3\r\n\t\ts[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]; // a0 + a1 + 2*a2 + 3*a3\r\n\t\ts[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]; // 3*a0 + a1 + a2 + 2*a3\r\n\t  }\r\n\t  return s;\r\n\t}\r\n\r\n\r\n\tfunction AddRoundKey(state, w, rnd, Nb) {  // xor Round Key into state S [5.1.4]\r\n\t  for (var r=0; r<4; r++) {\r\n\t\tfor (var c=0; c<Nb; c++) state[r][c] ^= w[rnd*4+c][r];\r\n\t  }\r\n\t  return state;\r\n\t}\r\n\r\n\r\n\tfunction KeyExpansion(key) {  // generate Key Schedule (byte-array Nr+1 x Nb) from Key [5.2]\r\n\t  var Nb = 4;\t\t\t // block size (in words): no of columns in state (fixed at 4 for AES)\r\n\t  var Nk = key.length/4\t // key length (in words): 4/6/8 for 128/192/256-bit keys\r\n\t  var Nr = Nk + 6;\t\t // no of rounds: 10/12/14 for 128/192/256-bit keys\r\n\r\n\t  var w = new Array(Nb*(Nr+1));\r\n\t  var temp = new Array(4);\r\n\r\n\t  for (var i=0; i<Nk; i++) {\r\n\t\tvar r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]];\r\n\t\tw[i] = r;\r\n\t  }\r\n\r\n\t  for (var i=Nk; i<(Nb*(Nr+1)); i++) {\r\n\t\tw[i] = new Array(4);\r\n\t\tfor (var t=0; t<4; t++) temp[t] = w[i-1][t];\r\n\t\tif (i % Nk == 0) {\r\n\t\t  temp = SubWord(RotWord(temp));\r\n\t\t  for (var t=0; t<4; t++) temp[t] ^= Rcon[i/Nk][t];\r\n\t\t} else if (Nk > 6 && i%Nk == 4) {\r\n\t\t  temp = SubWord(temp);\r\n\t\t}\r\n\t\tfor (var t=0; t<4; t++) w[i][t] = w[i-Nk][t] ^ temp[t];\r\n\t  }\r\n\r\n\t  return w;\r\n\t}\r\n\r\n\tfunction SubWord(w) {\t // apply SBox to 4-byte word w\r\n\t  for (var i=0; i<4; i++) w[i] = Sbox[w[i]];\r\n\t  return w;\r\n\t}\r\n\r\n\tfunction RotWord(w) {\t // rotate 4-byte word w left by one byte\r\n\t  w[4] = w[0];\r\n\t  for (var i=0; i<4; i++) w[i] = w[i+1];\r\n\t  return w;\r\n\t}\r\n\r\n\t/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n\t/*\r\n\t * Use AES to encrypt 'plaintext' with 'password' using 'nBits' key, in 'Counter' mode of operation\r\n\t *\t\t\t\t\t\t\t - see http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf\r\n\t *\t for each block\r\n\t *\t - outputblock = cipher(counter, key)\r\n\t *\t - cipherblock = plaintext xor outputblock\r\n\t */\r\n\tfunction AESEncryptCtr(plaintext, password, nBits) {\r\n\t  if (!(nBits==128 || nBits==192 || nBits==256)) return '';\t // standard allows 128/192/256 bit keys\r\n\r\n\t  // for this example script, generate the key by applying Cipher to 1st 16/24/32 chars of password;\r\n\t  // for real-world applications, a more secure approach would be to hash the password e.g. with SHA-1\r\n\t  var nBytes = nBits/8;\t // no bytes in key\r\n\t  var pwBytes = new Array(nBytes);\r\n\t  for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;\r\n\r\n\t  var key = Cipher(pwBytes, KeyExpansion(pwBytes));\r\n\r\n\t  key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long\r\n\r\n\t  // initialise counter block (NIST SP800-38A B.2): millisecond time-stamp for nonce in 1st 8 bytes,\r\n\t  // block counter in 2nd 8 bytes\r\n\t  var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\r\n\t  var counterBlock = new Array(blockSize);\t// block size fixed at 16 bytes / 128 bits (Nb=4) for AES\r\n\t  var nonce = (new Date()).getTime();  // milliseconds since 1-Jan-1970\r\n\r\n\t  // encode nonce in two stages to cater for JavaScript 32-bit limit on bitwise ops\r\n\t  for (var i=0; i<4; i++) counterBlock[i] = (nonce >>> i*8) & 0xff;\r\n\t  for (var i=0; i<4; i++) counterBlock[i+4] = (nonce/0x100000000 >>> i*8) & 0xff;\r\n\r\n\t  // generate key schedule - an expansion of the key into distinct Key Rounds for each round\r\n\t  var keySchedule = KeyExpansion(key);\r\n\r\n\t  var blockCount = Math.ceil(plaintext.length/blockSize);\r\n\t  var ciphertext = new Array(blockCount);  // ciphertext as array of strings\r\n\r\n\t  for (var b=0; b<blockCount; b++) {\r\n\t\t// set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)\r\n\t\t// again done in two stages for 32-bit ops\r\n\t\tfor (var c=0; c<4; c++) counterBlock[15-c] = (b >>> c*8) & 0xff;\r\n\t\tfor (var c=0; c<4; c++) counterBlock[15-c-4] = (b/0x100000000 >>> c*8)\r\n\r\n\t\tvar cipherCntr = Cipher(counterBlock, keySchedule);\t // -- encrypt counter block --\r\n\r\n\t\t// calculate length of final block:\r\n\t\tvar blockLength = b<blockCount-1 ? blockSize : (plaintext.length-1)%blockSize+1;\r\n\r\n\t\tvar ct = '';\r\n\t\tfor (var i=0; i<blockLength; i++) {\t // -- xor plaintext with ciphered counter byte-by-byte --\r\n\t\t  var plaintextByte = plaintext.charCodeAt(b*blockSize+i);\r\n\t\t  var cipherByte = plaintextByte ^ cipherCntr[i];\r\n\t\t  //ct += String.fromCharCode(cipherByte);\r\n\t\t  ct += ((cipherByte < 16) ? \"0\" : \"\") + cipherByte.toString(16);\r\n\t\t}\r\n\t\t// ct is now ciphertext for this block\r\n\r\n\t\tciphertext[b] = ct; // escCtrlChars(ct);  // escape troublesome characters in ciphertext\r\n\t  }\r\n\r\n\t  // convert the nonce to a string to go on the front of the ciphertext\r\n\t  var ctrTxt = '';\r\n\t  for (var i=0; i<8; i++) ctrTxt += ((counterBlock[i] < 16) ? \"0\" : \"\") + counterBlock[i].toString(16); //String.fromCharCode(counterBlock[i]);\r\n\t  //ctrTxt = escCtrlChars(ctrTxt);\r\n\r\n\t  // use '-' to separate blocks, use Array.join to concatenate arrays of strings for efficiency\r\n\t  return ctrTxt + ' ' + ciphertext.join(' ');\r\n\t}\r\n\r\n\tfunction stringToHex(s){\r\n\t\tvar ret = [];\r\n\t\ts.replace(/(..)/g, function(str){\r\n\t\t\tret.push(parseInt(str, 16));\r\n\t\t});\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t/*\r\n\t * Use AES to decrypt 'ciphertext' with 'password' using 'nBits' key, in Counter mode of operation\r\n\t *\r\n\t *\t for each block\r\n\t *\t - outputblock = cipher(counter, key)\r\n\t *\t - cipherblock = plaintext xor outputblock\r\n\t */\r\n\tfunction AESDecryptCtr(ciphertext, password, nBits) {\r\n\t  if (!(nBits==128 || nBits==192 || nBits==256)) return '';\t // standard allows 128/192/256 bit keys\r\n\r\n\t  var nBytes = nBits/8;\t // no bytes in key\r\n\t  var pwBytes = new Array(nBytes);\r\n\t  for (var i=0; i<nBytes; i++) pwBytes[i] = password.charCodeAt(i) & 0xff;\r\n\t  var pwKeySchedule = KeyExpansion(pwBytes);\r\n\t  var key = Cipher(pwBytes, pwKeySchedule);\r\n\t  key = key.concat(key.slice(0, nBytes-16));  // key is now 16/24/32 bytes long\r\n\r\n\t  var keySchedule = KeyExpansion(key);\r\n\r\n\t  ciphertext = ciphertext.split(' ');  // split ciphertext into array of block-length strings\r\n\r\n\t  // recover nonce from 1st element of ciphertext\r\n\t  var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES\r\n\t  var counterBlock = new Array(blockSize);\r\n\t  var ctrTxt = ciphertext[0]; //unescCtrlChars(ciphertext[0]);\r\n\t  counterBlock = stringToHex(ctrTxt);\r\n\r\n\t  var plaintext = new Array(ciphertext.length-1);\r\n\r\n\t  for (var b=1; b<ciphertext.length; b++) {\r\n\t\t// set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)\r\n\t\tfor (var c=0; c<4; c++) counterBlock[15-c] = ((b-1) >>> c*8) & 0xff;\r\n\t\tfor (var c=0; c<4; c++) counterBlock[15-c-4] = ((b/0x100000000-1) >>> c*8) & 0xff;\r\n\r\n\t\tvar cipherCntr = Cipher(counterBlock, keySchedule);\t // encrypt counter block\r\n\r\n\t\t//ciphertext[b] = ciphertext[b]; //unescCtrlChars(ciphertext[b]);\r\n\r\n\t\tvar pt = '';\r\n\t\tvar tmp = stringToHex(ciphertext[b]);\r\n\t\tfor (var i=0; i<tmp.length; i++) {\r\n\t\t  // -- xor plaintext with ciphered counter byte-by-byte --\r\n\t\t  var ciphertextByte = ciphertext[b].charCodeAt(i);\r\n\t\t  var plaintextByte = tmp[i] ^ cipherCntr[i];\r\n\t\t  pt += String.fromCharCode(plaintextByte);\r\n\t\t}\r\n\t\t// pt is now plaintext for this block\r\n\r\n\t\tplaintext[b-1] = pt;  // b-1 'cos no initial nonce block in plaintext\r\n\t  }\r\n\r\n\t  return plaintext.join('');\r\n\t}\r\n\r\n\t/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n\tfunction escCtrlChars(str) {  // escape control chars which might cause problems handling ciphertext\r\n\t  return str.replace(/[\\0\\t\\n\\v\\f\\r\\xa0!-]/g, function(c) { return '!' + c.charCodeAt(0) + '!'; });\r\n\t}  // \\xa0 to cater for bug in Firefox; include '-' to leave it free for use as a block marker\r\n\r\n\tfunction unescCtrlChars(str) {\t// unescape potentially problematic control characters\r\n\t  return str.replace(/!\\d\\d?\\d?!/g, function(c) { return String.fromCharCode(c.slice(1,-1)); });\r\n\t}\r\n\r\n\t/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\r\n\r\n\tcrypto.SimpleAES = new (function(){\r\n\t\t// summary:\r\n\t\t//\t\tSimpleAES, ported from dojox.sql, and done without the need for\r\n\t\t//\t\ta Google Gears worker pool.\r\n\t\t// description:\r\n\t\t//\t\tTaken from http://www.movable-type.co.uk/scripts/aes.html by\r\n\t\t//\t\tChris Veness (CLA signed); adapted for Dojo by Brad Neuberg\r\n\t\t//\t\t(bkn3 AT columbia.edu) and moved to DojoX crypto by Tom Trenka\r\n\t\t//\t\t(ttrenka AT gmail.com).\r\n\t\t//\r\n\t\t//\t\tA few notes:\r\n\t\t//\t\t1) This algorithm uses a customized version of CBC mode by creating\r\n\t\t//\t\ta nonce, using it as an initialization vector, and storing the\r\n\t\t//\t\tIV as the first portion of the encrypted text.  Because of this, it\r\n\t\t//\t\tis HIGHLY PROBABLE that it will NOT be usable by other AES implementations.\r\n\t\t//\t\t2) All encoding is done in hex format; other encoding formats (such\r\n\t\t//\t\tas base 64) are not supported.\r\n\t\t//\t\t3) The bit depth of the key is hardcoded at 256, despite the ability\r\n\t\t//\t\tof the code to handle all three recommended bit depths.\r\n\t\t//\t\t4) The passed key will be padded (as opposed to enforcing a strict\r\n\t\t//\t\tlength) with null bytes.\r\n\t\tthis.encrypt = function(/* String */plaintext, /* String */key){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEncrypt the passed plaintext using the key, with a\r\n\t\t\t//\t\thardcoded bit depth of 256.\r\n\t\t\treturn AESEncryptCtr(plaintext, key, 256);\t//\tString\r\n\t\t};\r\n\t\tthis.decrypt = function(/* String */ciphertext, /* String */key){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDecrypt the passed ciphertext using the key at a fixed\r\n\t\t\t//\t\tbit depth of 256.\r\n\t\t\treturn AESDecryptCtr(ciphertext, key, 256);\t//\tString\r\n\t\t};\r\n\t})();\r\n\r\n\treturn crypto.SimpleAES;\r\n});\r\n"]}