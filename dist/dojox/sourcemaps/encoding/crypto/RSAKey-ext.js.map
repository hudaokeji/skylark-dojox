{"version":3,"sources":["encoding/crypto/RSAKey-ext.js"],"names":["define","kernel","lang","RSAKey","BigInteger","experimental","extend","setPrivate","N","E","D","length","Error","this","n","e","parseInt","d","setPrivateEx","P","Q","DP","DQ","C","p","q","dmp1","dmq1","coeff","generate","B","rng","rngf","qs","ee","subtract","ONE","gcd","compareTo","isProbablePrime","t","p1","q1","phi","multiply","modInverse","mod","destroy","decrypt","ctext","m","c","cp","modPow","cq","add","b","toByteArray","i","len","ret","String","fromCharCode","pkcs1unpad2","bitLength"],"mappings":";;;;;;;AAAAA,QACC,oBACA,kBACA,WACA,6BACE,SAASC,EAAQC,EAAMC,EAAQC,GAoHjC,OAlHAH,EAAOI,aAAa,oCAqBpBH,EAAKI,OAAOH,GACXI,WAAY,SAASC,EAAGC,EAAGC,GAG1B,KAAGF,GAAKC,GAAKD,EAAEG,QAAUF,EAAEE,QAK1B,MAAM,IAAIC,MAAM,2BAJhBC,KAAKC,EAAI,IAAIV,EAAWI,EAAG,IAC3BK,KAAKE,EAAIC,SAASP,EAAG,IACrBI,KAAKI,EAAI,IAAIb,EAAWM,EAAG,KAK7BQ,aAAc,SAASV,EAAGC,EAAGC,EAAGS,EAAGC,EAAGC,EAAIC,EAAIC,GAG7C,KAAGf,GAAKC,GAAKD,EAAEG,QAAUF,EAAEE,QAU1B,MAAM,IAAIC,MAAM,2BAThBC,KAAKC,EAAI,IAAIV,EAAWI,EAAG,IAC3BK,KAAKE,EAAIC,SAASP,EAAG,IACrBI,KAAKI,EAAI,IAAIb,EAAWM,EAAG,IAC3BG,KAAKW,EAAI,IAAIpB,EAAWe,EAAG,IAC3BN,KAAKY,EAAI,IAAIrB,EAAWgB,EAAG,IAC3BP,KAAKa,KAAO,IAAItB,EAAWiB,EAAI,IAC/BR,KAAKc,KAAO,IAAIvB,EAAWkB,EAAI,IAC/BT,KAAKe,MAAQ,IAAIxB,EAAWmB,EAAG,KAKjCM,SAAU,SAASC,EAAGrB,GAGrB,IAAIsB,EAAMlB,KAAKmB,OAAQC,EAAKH,GAAK,EACjCjB,KAAKE,EAAIC,SAASP,EAAG,IAErB,IADA,IAAIyB,EAAK,IAAI9B,EAAWK,EAAG,MACnB,CACP,KACCI,KAAKW,EAAI,IAAIpB,EAAW0B,EAAIG,EAAI,EAAGF,GAC/BlB,KAAKW,EAAEW,SAAS/B,EAAWgC,KAAKC,IAAIH,GAAII,UAAUlC,EAAWgC,OAAQvB,KAAKW,EAAEe,gBAAgB,MAIjG,KACC1B,KAAKY,EAAI,IAAIrB,EAAW6B,EAAI,EAAGF,GAC3BlB,KAAKY,EAAEU,SAAS/B,EAAWgC,KAAKC,IAAIH,GAAII,UAAUlC,EAAWgC,OAAQvB,KAAKY,EAAEc,gBAAgB,MAIjG,GAAG1B,KAAKW,EAAEc,UAAUzB,KAAKY,IAAM,EAAG,CACjC,IAAIe,EAAI3B,KAAKW,EACbX,KAAKW,EAAIX,KAAKY,EACdZ,KAAKY,EAAIe,EAEV,IAAIC,EAAK5B,KAAKW,EAAEW,SAAS/B,EAAWgC,KAChCM,EAAK7B,KAAKY,EAAEU,SAAS/B,EAAWgC,KAChCO,EAAMF,EAAGG,SAASF,GACtB,IAAIC,EAAIN,IAAIH,GAAII,UAAUlC,EAAWgC,KAAM,CAC1CvB,KAAKC,EAAID,KAAKW,EAAEoB,SAAS/B,KAAKY,GAC9BZ,KAAKI,EAAIiB,EAAGW,WAAWF,GACvB9B,KAAKa,KAAOb,KAAKI,EAAE6B,IAAIL,GACvB5B,KAAKc,KAAOd,KAAKI,EAAE6B,IAAIJ,GACvB7B,KAAKe,MAAQf,KAAKY,EAAEoB,WAAWhC,KAAKW,GACpC,OAGFO,EAAIgB,WAGLC,QAAS,SAASC,GAOjB,IAAmCC,EAA/BC,EAAI,IAAI/C,EAAW6C,EAAO,IAC9B,GAAIpC,KAAKW,GAAMX,KAAKY,EAEf,CAIJ,IAFA,IAAI2B,EAAKD,EAAEL,IAAIjC,KAAKW,GAAG6B,OAAOxC,KAAKa,KAAMb,KAAKW,GAC7C8B,EAAKH,EAAEL,IAAIjC,KAAKY,GAAG4B,OAAOxC,KAAKc,KAAMd,KAAKY,GACrC2B,EAAGd,UAAUgB,GAAM,GACxBF,EAAKA,EAAGG,IAAI1C,KAAKW,GAElB0B,EAAIE,EAAGjB,SAASmB,GAAIV,SAAS/B,KAAKe,OAAOkB,IAAIjC,KAAKW,GAAGoB,SAAS/B,KAAKY,GAAG8B,IAAID,QAR1EJ,EAAIC,EAAEE,OAAOxC,KAAKI,EAAGJ,KAAKC,GAU3B,OAAIoC,EAxGN,SAAqBjC,EAAGH,GAEvB,IADA,IAAI0C,EAAIvC,EAAEwC,cACFC,EAAI,EAAGC,EAAMH,EAAE7C,OAAQ+C,EAAIC,IAAQH,EAAEE,KAAMA,GACnD,GAAGF,EAAE7C,OAAS+C,GAAM5C,EAAI,GAAc,IAAT0C,EAAEE,GAC9B,OAAO,KAER,MAAMA,EAAGF,EAAEE,IACV,KAAKA,GAAKC,EACT,OAAO,KAIT,IADA,IAAIC,EAAM,KACFF,EAAIC,GACXC,GAAOC,OAAOC,aAAaN,EAAEE,IAE9B,OAAOE,EA4FCG,CAAYb,EAAIrC,KAAKC,EAAEkD,YAAc,GAAM,GAF1C,QAMH7D","file":"../../../encoding/crypto/RSAKey-ext.js","sourcesContent":["define([\r\n\t\"dojo/_base/kernel\", // dojo.experimental\r\n\t\"dojo/_base/lang\", // dojo.extend\r\n\t\"./RSAKey\",\r\n\t\"../../math/BigInteger-ext\"\r\n], function(kernel, lang, RSAKey, BigInteger) {\r\n\r\n\tkernel.experimental(\"dojox.encoding.crypto.RSAKey-ext\");\r\n\r\n\t// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext\r\n\tfunction pkcs1unpad2(d, n){\r\n\t\tvar b = d.toByteArray();\r\n\t\tfor(var i = 0, len = b.length; i < len && !b[i]; ++i);\r\n\t\tif(b.length - i !== n - 1 || b[i] !== 2){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tfor(++i; b[i];){\r\n\t\t\tif(++i >= len){\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar ret = \"\";\r\n\t\twhile(++i < len){\r\n\t\t\tret += String.fromCharCode(b[i]);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tlang.extend(RSAKey, {\r\n\t\tsetPrivate: function(N, E, D){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet the private key fields N, e, d and CRT params from hex strings\r\n\t\t\tif(N && E && N.length && E.length){\r\n\t\t\t\tthis.n = new BigInteger(N, 16);\r\n\t\t\t\tthis.e = parseInt(E, 16);\r\n\t\t\t\tthis.d = new BigInteger(D, 16);\r\n\t\t\t}else{\r\n\t\t\t\tthrow new Error(\"Invalid RSA private key\");\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetPrivateEx: function(N, E, D, P, Q, DP, DQ, C) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet the private key fields N, e, d and CRT params from hex strings\r\n\t\t\tif(N && E && N.length && E.length){\r\n\t\t\t\tthis.n = new BigInteger(N, 16);\r\n\t\t\t\tthis.e = parseInt(E, 16);\r\n\t\t\t\tthis.d = new BigInteger(D, 16);\r\n\t\t\t\tthis.p = new BigInteger(P, 16);\r\n\t\t\t\tthis.q = new BigInteger(Q, 16);\r\n\t\t\t\tthis.dmp1 = new BigInteger(DP, 16);\r\n\t\t\t\tthis.dmq1 = new BigInteger(DQ, 16);\r\n\t\t\t\tthis.coeff = new BigInteger(C, 16);\r\n\t\t\t}else{\r\n\t\t\t\tthrow new Error(\"Invalid RSA private key\");\r\n\t\t\t}\r\n\t\t},\r\n\t\tgenerate: function(B, E){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGenerate a new random private key B bits long, using public expt E\r\n\t\t\tvar rng = this.rngf(), qs = B >> 1;\r\n\t\t\tthis.e = parseInt(E, 16);\r\n\t\t\tvar ee = new BigInteger(E, 16);\r\n\t\t\tfor(;;) {\r\n\t\t\t\tfor(;;) {\r\n\t\t\t\t\tthis.p = new BigInteger(B - qs, 1, rng);\r\n\t\t\t\t\tif(!this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) && this.p.isProbablePrime(10)){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tfor(;;) {\r\n\t\t\t\t\tthis.q = new BigInteger(qs, 1, rng);\r\n\t\t\t\t\tif(!this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) && this.q.isProbablePrime(10)){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(this.p.compareTo(this.q) <= 0) {\r\n\t\t\t\t\tvar t = this.p;\r\n\t\t\t\t\tthis.p = this.q;\r\n\t\t\t\t\tthis.q = t;\r\n\t\t\t\t}\r\n\t\t\t\tvar p1 = this.p.subtract(BigInteger.ONE);\r\n\t\t\t\tvar q1 = this.q.subtract(BigInteger.ONE);\r\n\t\t\t\tvar phi = p1.multiply(q1);\r\n\t\t\t\tif(!phi.gcd(ee).compareTo(BigInteger.ONE)) {\r\n\t\t\t\t\tthis.n = this.p.multiply(this.q);\r\n\t\t\t\t\tthis.d = ee.modInverse(phi);\r\n\t\t\t\t\tthis.dmp1 = this.d.mod(p1);\r\n\t\t\t\t\tthis.dmq1 = this.d.mod(q1);\r\n\t\t\t\t\tthis.coeff = this.q.modInverse(this.p);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trng.destroy();\r\n\t\t},\r\n\r\n\t\tdecrypt: function(ctext){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn the PKCS#1 RSA decryption of \"ctext\".\r\n\t\t\t// ctext: String\r\n\t\t\t//\t\tan even-length hex string\r\n\t\t\t// returns:\r\n\t\t\t//\t\ta plain string.\r\n\t\t\tvar c = new BigInteger(ctext, 16), m;\r\n\t\t\tif(!this.p || !this.q){\r\n\t\t\t\tm = c.modPow(this.d, this.n);\r\n\t\t\t}else{\r\n\t\t\t\t// TODO: re-calculate any missing CRT params\r\n\t\t\t\tvar cp = c.mod(this.p).modPow(this.dmp1, this.p),\r\n\t\t\t\t\tcq = c.mod(this.q).modPow(this.dmq1, this.q);\r\n\t\t\t\twhile(cp.compareTo(cq) < 0){\r\n\t\t\t\t\tcp = cp.add(this.p);\r\n\t\t\t\t}\r\n\t\t\t\tm = cp.subtract(cq).multiply(this.coeff).mod(this.p).multiply(this.q).add(cq);\r\n\t\t\t}\r\n\t\t\tif(!m){\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\treturn pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn RSAKey;\r\n});\r\n"]}