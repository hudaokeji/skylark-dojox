{"version":3,"sources":["treemap/_utils.js"],"names":["define","arr","utils","group","items","groupingFunctions","measureFunction","response","children","merge","obj","entry","__treeValue","forEach","r","groupingFunction","j","data","child","find","item","__treeName","push","__treeID","Math","random","length","array","callback","l","i","call","solve","width","height","areaFunc","rtl","treeMapElements","initElements","dataTotal","total","elements","realSize","rects","element","size","sizeTmp","sort","b","a","_compute","index","result","map","x","y","w","h","rectangles","Error","valueScale","aspectLast","start","end","aspectCurr","offsetX","offsetY","tmp_width","tmp_height","vert","_trySolution","currX","currY","n","widthTmp","heightTmp","currX1","currY1","aspect","localWidth","localHeight","undefined","max"],"mappings":"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","file":"../../treemap/_utils.js","sourcesContent":["define([\"dojo/_base/array\"], function(arr){\r\n\tvar utils = {\r\n\t\tgroup: function(/*Array*/items, /*Array*/groupingFunctions,  /*Function*/measureFunction){\r\n\t\t\tvar response = {\r\n\t\t\t\tchildren: []\r\n\t\t\t};\r\n\t\t\tvar merge = function(obj, entry){\r\n\t\t\t\tif(!obj.__treeValue){\r\n\t\t\t\t\tobj.__treeValue = 0;\r\n\t\t\t\t}\r\n\t\t\t\tobj.__treeValue += measureFunction(entry);\r\n\t\t\t\treturn obj;\r\n\t\t\t};\r\n\t\t\t// we go over each entry in the array\r\n\t\t\tarr.forEach(items, function(entry){\r\n\t\t\t\tvar r = response;\r\n\t\t\t\t// for this entry, for each rowField we\r\n\t\t\t\t// look at the actual value for this rowField\r\n\t\t\t\t// and create a holding object for this\r\n\t\t\t\t// value in response if it does not exist\r\n\t\t\t\tarr.forEach(groupingFunctions, function(groupingFunction, j){\r\n\t\t\t\t\t// actual value for the rowField\r\n\t\t\t\t\tvar data = groupingFunction(entry);\r\n\t\t\t\t\t// create child if undefined\r\n\t\t\t\t\tvar child = utils.find(r.children, function(item){\r\n\t\t\t\t\t\treturn (item.__treeName == data);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tif(!child){\r\n\t\t\t\t\t\tr.children.push(child = {\r\n\t\t\t\t\t\t\t__treeName: data,\r\n\t\t\t\t\t\t\t__treeID: data+Math.random(),\r\n\t\t\t\t\t\t\tchildren: []\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tchild = merge(child, entry);\r\n\t\t\t\t\tif(j != groupingFunctions.length - 1){\r\n\t\t\t\t\t\t// branch & prepare response for \r\n\t\t\t\t\t\t// next call\r\n\t\t\t\t\t\tr = child;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// add the entry to the leaf!\r\n\t\t\t\t\t\tchild.children.push(entry);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\tr = merge(r, entry);\r\n\t\t\t});\r\n\t\t\treturn response;\r\n\t\t},\r\n\t\tfind: function(/*Array*/array, /*Function*/callback){\r\n\t\t\tvar l = array.length;\r\n\t\t\tfor (var i = 0; i < l; ++i) {\r\n\t\t\t\tif (callback.call(null, array[i])){ \t\t\t\t\t\r\n\t\t\t\t\treturn array[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\tsolve: function(items, width, height, areaFunc, rtl){\r\n\t\t\t//\r\n\t\t\t// Create temporary TreeMap elements\r\n\t\t\t//\r\n\t\t\tvar treeMapElements = utils.initElements(items, areaFunc);\r\n\t\t\tvar dataTotal = treeMapElements.total;\r\n\t\t\tvar elements = treeMapElements.elements;\r\n\t\r\n\t\t\tvar realSize = dataTotal;\r\n\t\r\n\t\t\tif(dataTotal == 0){\r\n\t\t\t\tif(elements.length == 0){\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\titems: items, rects: [], total: 0\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tarr.forEach(elements, function(element){\r\n\t\t\t\t\telement.size = element.sizeTmp = 100;\r\n\t\t\t\t});\r\n\t\t\t\tdataTotal = elements.length * 100;\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\t\t// \tSort the TreeMap elements\r\n\t\t\t//\r\n\t\t\telements.sort(function(b, a){\r\n\t\t\t\treturn a.size - b.size;\r\n\t\t\t});\r\n\t\r\n\t\t\tutils._compute(width, height, elements, dataTotal);\r\n\t\r\n\t\t\t//\r\n\t\t\t// Restore initial Sort order\r\n\t\t\t// \r\n\t\t\telements.sort(function(a, b){\r\n\t\t\t\treturn a.index - b.index;\r\n\t\t\t});\r\n\t\r\n\t\t\tvar result = {};\r\n\t\t\tresult.elements = elements;\r\n\t\t\tresult.size = realSize;\r\n\t\r\n\t\t\trects = arr.map(elements, function(element){\r\n\t\t\t\treturn {\r\n\t\t\t\t\tx: rtl?width - element.x - element.width:element.x, y: element.y, w: element.width, h: element.height\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\r\n\t\t\tresult.rectangles = rects;\r\n\t\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tinitElements: function(items, areaFunc){\r\n\t\t\tvar total = 0;\r\n\t\t\tvar elements = arr.map(items, function(item, index){\r\n\t\t\t\tvar size = areaFunc != null ? areaFunc(item) : 0;\r\n\t\t\t\tif(size < 0){\r\n\t\t\t\t\tthrow new Error(\"item size dimension must be positive\");\r\n\t\t\t\t}\r\n\t\t\t\ttotal += size;\r\n\t\t\t\treturn {\r\n\t\t\t\t\tindex: index, size: size, sizeTmp: size\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t\treturn {\r\n\t\t\t\telements: elements, total: total\r\n\t\t\t};\r\n\t\t},\r\n\t\t_compute: function(width, height, elements, total){\r\n\t\t\tvar valueScale = ((width * height) / total) / 100;\r\n\t\r\n\t\t\tarr.forEach(elements, function(element){\r\n\t\t\t\telement.sizeTmp *= valueScale;\r\n\t\t\t});\r\n\t\r\n\t\t\tvar start = 0;\r\n\t\t\tvar end = 0;\r\n\t\t\tvar aspectCurr = -1 >>> 1; // int.MaxValue;\r\n\t\t\tvar aspectLast;\r\n\t\t\tvar offsetX = 0;\r\n\t\t\tvar offsetY = 0;\r\n\t\t\tvar tmp_width = width;\r\n\t\t\tvar tmp_height = height;\r\n\t\r\n\t\t\tvar vert = tmp_width > tmp_height;\r\n\t\r\n\t\t\twhile(end != elements.length){\r\n\t\t\t\taspectLast = utils._trySolution(elements, start, end, vert, tmp_width, tmp_height);\r\n\t\r\n\t\t\t\tif((aspectLast > aspectCurr) || (aspectLast < 1)){\r\n\t\t\t\t\tvar currX = 0;\r\n\t\t\t\t\tvar currY = 0;\r\n\t\r\n\t\t\t\t\tfor(var n = start; n < end; n++){\r\n\t\t\t\t\t\telements[n].x = offsetX + currX;\r\n\t\t\t\t\t\telements[n].y = offsetY + currY;\r\n\t\t\t\t\t\tif(vert){\r\n\t\t\t\t\t\t\tcurrY += elements[n].height;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tcurrX += elements[n].width;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif(vert){\r\n\t\t\t\t\t\toffsetX += elements[start].width;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\toffsetY += elements[start].height;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttmp_width = width - offsetX;\r\n\t\t\t\t\ttmp_height = height - offsetY;\r\n\t\r\n\t\t\t\t\tvert = tmp_width > tmp_height;\r\n\t\r\n\t\t\t\t\tstart = end;\r\n\t\t\t\t\tend = start;\r\n\t\r\n\t\t\t\t\taspectCurr = -1 >>> 1; // int.MaxValue;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfor(var n = start; n <= end; n++){\r\n\t\t\t\t\t\telements[n].width = elements[n].widthTmp;\r\n\t\t\t\t\t\telements[n].height = elements[n].heightTmp;\r\n\t\t\t\t\t}\r\n\t\t\t\t\taspectCurr = aspectLast;\r\n\t\t\t\t}\r\n\t\t\t\tend++;\r\n\t\t\t}\r\n\t\r\n\t\t\tvar currX1 = 0;\r\n\t\t\tvar currY1 = 0;\r\n\t\r\n\t\t\tfor(var n = start; n < end; n++){\r\n\t\t\t\telements[n].x = offsetX + currX1;\r\n\t\t\t\telements[n].y = offsetY + currY1;\r\n\t\t\t\tif(vert){\r\n\t\t\t\t\tcurrY1 += elements[n].height;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcurrX1 += elements[n].width;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\t_trySolution: function(elements, start, end, vert, tmp_width, tmp_height){\r\n\t\t\tvar total = 0;\r\n\t\t\tvar aspect = 0;\r\n\t\t\tvar localWidth = 0;\r\n\t\t\tvar localHeight = 0;\r\n\t\r\n\t\t\tfor(var n = start; n <= end; n++){\r\n\t\t\t\ttotal += elements[n].sizeTmp;\r\n\t\t\t}\r\n\t\r\n\t\t\tif(vert){\r\n\t\t\t\tif(tmp_height == 0){\r\n\t\t\t\t\tlocalWidth = localHeight = 0;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlocalWidth = total / tmp_height * 100;\r\n\t\t\t\t\tlocalHeight = tmp_height;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif(tmp_width == 0){\r\n\t\t\t\t\tlocalWidth = localHeight = 0;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlocalHeight = total / tmp_width * 100;\r\n\t\t\t\t\tlocalWidth = tmp_width;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tfor(var n = start; n <= end; n++){\r\n\t\t\t\tif(vert){\r\n\t\t\t\t\telements[n].widthTmp = localWidth;\r\n\t\t\t\t\tif(total == 0){\r\n\t\t\t\t\t\telements[n].heightTmp = 0;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\telements[n].heightTmp = localHeight * elements[n].sizeTmp / total;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(total == 0){\r\n\t\t\t\t\t\telements[n].widthTmp = 0;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\telements[n].widthTmp = localWidth * elements[n].sizeTmp / total;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telements[n].heightTmp = localHeight;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\taspect = Math.max(elements[end].heightTmp / elements[end].widthTmp, elements[end].widthTmp\r\n\t\t\t\t\t/ elements[end].heightTmp);\r\n\t\t\tif(aspect == undefined){\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\treturn aspect;\r\n\t\t}\r\n\t};\r\n\treturn utils;\r\n});\r\n"]}