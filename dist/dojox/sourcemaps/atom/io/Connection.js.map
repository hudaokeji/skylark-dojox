{"version":3,"sources":["atom/io/Connection.js"],"names":["define","declare","kernel","xhrUtil","model","constructor","sync","preventCache","this","alertsEnabled","getFeed","url","callback","errorCallback","scope","_getXmlDoc","Feed","_Constants","ATOM_NS","getService","Service","APP_NS","getEntry","Entry","nodeName","newNode","namespace","global","ae","xhrArgs","handleAs","load","data","args","nodes","node","evaldObj","getElementsByTagNameNS","length","item","lastChild","getElementsByTagName","i","namespaceURI","call","buildFromDom","Error","user","password","error","get","updateEntry","entry","retrieveUpdated","xmethod","updated","Date","getEditHref","self","contentType","location","xhr","getResponseHeader","dom","postData","toString","headers","X-Method-Override","post","putData","put","addEntry","retrieveEntry","published","feedUrl","deleteEntry","dhxr","del"],"mappings":"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","file":"../../../atom/io/Connection.js","sourcesContent":["define([\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/kernel\",\r\n\t\"dojo/_base/xhr\",\r\n\t\"./model\"\r\n], function (declare, kernel, xhrUtil, model){\r\n\r\nreturn declare(\"dojox.atom.io.Connection\",null,{\r\n\t// summary:\r\n\t//\t\tThis object implements a transport layer for working with ATOM feeds and ATOM publishing protocols.\r\n\t// description:\r\n\t//\t\tThis object implements a transport layer for working with ATOM feeds and ATOM publishing protocols.\r\n\t//\t\tSpecifically, it provides a mechanism by which feeds can be fetched and entries can be fetched, created\r\n\t//\t\tdeleted, and modified.  It also provides access to the introspection data.\r\n\r\n\tconstructor: function(/* Boolean */sync, /* Boolean */preventCache){\r\n\t\t// summary:\r\n\t\t//\t\tinitializer\r\n\t\tthis.sync = sync;\r\n\t\tthis.preventCache = preventCache;\r\n\t},\r\n\r\n\tpreventCache: false, //Flag to denote if the instance should use the xhr prevent cache mechanism\r\n\r\n\talertsEnabled: false, //Flag to turn on alerts instead of throwing errors.\r\n\r\n\tgetFeed: function(/*String*/url, /*Function*/callback, /*Function*/errorCallback, scope){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to obtain a s specific ATOM feed from a given ATOM Feed url.\r\n\t\t// description:\r\n\t\t//\t\tThis function takes the URL for a specific ATOM feed and returns\r\n\t\t//\t\tthe data from that feed to the caller through the use of a callback\r\n\t\t//\t\thandler.\r\n\t\t// url: String\r\n\t\t//\t\tThe URL of the ATOM feed to fetch.\r\n\t\t// callback:\r\n\t\t//\t\tFunction\r\n\t\t//\t\tA function reference that will handle the feed when it has been retrieved.\r\n\t\t//\t\tThe callback should accept two parameters:  The feed object and the original complete DOM object.\r\n\t\t// scope: Object\r\n\t\t//\t\tThe scope to use for all callbacks.\r\n\t\t// returns:\r\n\t\t//\t\tNothing. The return is handled through the callback handler.\r\n\t\tthis._getXmlDoc(url, \"feed\", new model.Feed(), model._Constants.ATOM_NS, callback, /*handleDocumentRetrieved,*/ errorCallback, scope);\r\n\t},\r\n\t\r\n\tgetService: function(url, callback, errorCallback, scope){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to retrieve an introspection document from the given URL.\r\n\t\t// description:\r\n\t\t//\t\tThis function takes the URL for an ATOM item and feed and returns\r\n\t\t//\t\tthe introspection document.\r\n\t\t// url:\r\n\t\t//\t\tString\r\n\t\t//\t\tThe URL of the ATOM document to obtain the introspection document of.\r\n\t\t// callback:\r\n\t\t//\t\tFunction\r\n\t\t//\t\tA function reference that will handle the introspection document when it has been retrieved.\r\n\t\t//\t\tThe callback should accept two parameters:  The introspection document object and the original complete DOM object.\r\n\t\t// returns:\r\n\t\t//\t\tNothing. The return is handled through the callback handler.\r\n\t\tthis._getXmlDoc(url, \"service\", new model.Service(url), model._Constants.APP_NS, callback, errorCallback, scope);\r\n\t},\r\n\t\r\n\tgetEntry: function(url, callback, errorCallback, scope){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to retrieve a single entry from an ATOM feed from the given URL.\r\n\t\t// description:\r\n\t\t//\t\tThis function takes the URL for an ATOM entry and returns the constructed dojox.atom.io.model.Entry object through\r\n\t\t//\t\tthe specified callback.\r\n\t\t// url:\r\n\t\t//\t\tString\r\n\t\t//\t\tThe URL of the ATOM Entry document to parse.\r\n\t\t// callback:\r\n\t\t//\t\tFunction\r\n\t\t//\t\tA function reference that will handle the Entry object obtained.\r\n\t\t//\t\tThe callback should accept two parameters, the dojox.atom.io.model.Entry object and the original dom.\r\n\t\t// returns:\r\n\t\t//\t\tNothing. The return is handled through the callback handler.\r\n\t\tthis._getXmlDoc(url, \"entry\", new model.Entry(), model._Constants.ATOM_NS, callback, errorCallback, scope);\r\n\t},\r\n\r\n\t_getXmlDoc: function(url, nodeName, newNode, namespace, callback, errorCallback, scope){\r\n\t\t// summary:\r\n\t\t//\t\tInternal Function to retrieve an XML document and pass the results to a callback.\r\n\t\t// description:\r\n\t\t//\t\tThis internal function takes the URL for an XML document and and passes the\r\n\t\t//\t\tparsed contents to a specified callback.\r\n\t\t// url:\r\n\t\t//\t\tString\r\n\t\t//\t\tThe URL of the XML document to retrieve\r\n\t\t// callback:\r\n\t\t//\t\tFunction\r\n\t\t//\t\tA function reference that will handle the retrieved XML data.\r\n\t\t//\t\tThe callback should accept one parameter, the DOM of the parsed XML document.\r\n\t\t// returns:\r\n\t\t//\t\tNothing. The return is handled through the callback handler.\r\n\t\tif(!scope){\r\n\t\t\tscope = kernel.global;\r\n\t\t}\r\n\t\tvar ae = this.alertsEnabled;\r\n\t\tvar xhrArgs = {\r\n\t\t\turl: url,\r\n\t\t\thandleAs: \"xml\",\r\n\t\t\tsync: this.sync,\r\n\t\t\tpreventCache: this.preventCache,\r\n\t\t\tload: function(data, args){\r\n\t\t\t\tvar node\t = null;\r\n\t\t\t\tvar evaldObj = data;\r\n\t\t\t\tvar nodes;\r\n\t\t\t\tif(evaldObj){\r\n\t\t\t\t\t//find the first node of the appropriate name\r\n\t\t\t\t\tif(typeof(evaldObj.getElementsByTagNameNS)!= \"undefined\"){\r\n\t\t\t\t\t\tnodes = evaldObj.getElementsByTagNameNS(namespace,nodeName);\r\n\t\t\t\t\t\tif(nodes && nodes.length > 0){\r\n\t\t\t\t\t\t\tnode = nodes.item(0);\r\n\t\t\t\t\t\t}else if(evaldObj.lastChild){\r\n\t\t\t\t\t\t\t// name_spaces can be used without declaration of atom (for example\r\n\t\t\t\t\t\t\t// gooogle feeds often returns iTunes name_space qualifiers on elements)\r\n\t\t\t\t\t\t\t// Treat this situation like name_spaces not enabled.\r\n\t\t\t\t\t\t\tnode = evaldObj.lastChild;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(typeof(evaldObj.getElementsByTagName)!= \"undefined\"){\r\n\t\t\t\t\t\t// Find the first eith the correct tag name and correct namespace.\r\n\t\t\t\t\t\tnodes = evaldObj.getElementsByTagName(nodeName);\r\n\t\t\t\t\t\tif(nodes && nodes.length > 0){\r\n\t\t\t\t\t\t\tfor(var i=0; i<nodes.length; i++){\r\n\t\t\t\t\t\t\t\tif(nodes[i].namespaceURI == namespace){\r\n\t\t\t\t\t\t\t\t\tnode = nodes[i];\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else if(evaldObj.lastChild){\r\n\t\t\t\t\t\t\tnode = evaldObj.lastChild;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(evaldObj.lastChild){\r\n\t\t\t\t\t\tnode = evaldObj.lastChild;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tcallback.call(scope, null, null, args);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnewNode.buildFromDom(node);\r\n\t\t\t\t\tif(callback){\r\n\t\t\t\t\t\tcallback.call(scope, newNode, evaldObj, args);\r\n\t\t\t\t\t}else if(ae){\r\n\t\t\t\t\t\tthrow new Error(\"The callback value does not exist.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tcallback.call(scope, null, null, args);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(this.user && this.user !== null){\r\n\t\t\txhrArgs.user = this.user;\r\n\t\t}\r\n\t\tif(this.password && this.password !== null){\r\n\t\t\txhrArgs.password = this.password;\r\n\t\t}\r\n\r\n\t\tif(errorCallback){\r\n\t\t\txhrArgs.error = function(error, args){errorCallback.call(scope, error, args);};\r\n\t\t}else{\r\n\t\t\txhrArgs.error = function(){\r\n\t\t\t\tthrow new Error(\"The URL requested cannot be accessed\");\r\n\t\t\t};\r\n\t\t}\r\n\t\txhrUtil.get(xhrArgs);\r\n\t},\r\n\r\n\tupdateEntry: function(entry, callback, errorCallback, retrieveUpdated, xmethod, scope){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to update a specific ATOM entry by putting the new changes via APP.\r\n\t\t// description:\r\n\t\t//\t\tThis function takes a specific dojox.atom.io.model.Entry object and pushes the\r\n\t\t//\t\tchanges back to the provider of the Entry.\r\n\t\t//\t\tThe entry MUST have a link tag with rel=\"edit\" for this to work.\r\n\t\t// entry:\r\n\t\t//\t\tObject\r\n\t\t//\t\tThe dojox.atom.io.model.Entry object to update.\r\n\t\t// callback:\r\n\t\t//\t\tFunction\r\n\t\t//\t\tA function reference that will handle the results from the entry update.\r\n\t\t//\t\tThe callback should accept two parameters:  The first is an Entry object, and the second is the URL of that Entry\r\n\t\t//\t\tEither can be null, depending on the value of retrieveUpdated.\r\n\t\t// retrieveUpdated:\r\n\t\t//\t\tboolean\r\n\t\t//\t\tA boolean flag denoting if the entry that was updated should then be\r\n\t\t//\t\tretrieved and returned to the caller via the callback.\r\n\t\t// xmethod:\r\n\t\t//\t\tboolean\r\n\t\t//\t\tWhether to use POST for PUT/DELETE items and send the X-Method-Override header.\r\n\t\t// scope:\r\n\t\t//\t\tObject\r\n\t\t//\t\tThe scope to use for all callbacks.\r\n\t\t// returns:\r\n\t\t//\t\tNothing. The return is handled through the callback handler.\r\n\t\tif(!scope){\r\n\t\t\tscope = kernel.global;\r\n\t\t}\r\n\t\tentry.updated = new Date();\r\n\t\tvar url = entry.getEditHref();\r\n\t\tif(!url){\r\n\t\t\tthrow new Error(\"A URL has not been specified for editing this entry.\");\r\n\t\t}\r\n\r\n\t\tvar self = this;\r\n\t\tvar ae = this.alertsEnabled;\r\n\t\tvar xhrArgs = {\r\n\t\t\turl: url,\r\n\t\t\thandleAs: \"text\",\r\n\t\t\tcontentType: \"text/xml\",\r\n\t\t\tsync: this.sync,\r\n\t\t\tpreventCache: this.preventCache,\r\n\t\t\tload: function(data, args){\r\n\t\t\t\tvar location = null;\r\n\t\t\t\tif(retrieveUpdated){\r\n\t\t\t\t\tlocation = args.xhr.getResponseHeader(\"Location\");\r\n\t\t\t\t\tif(!location){location = url;}\r\n\r\n\t\t\t\t\t//Function to handle the callback mapping of a getEntry after an update to return the\r\n\t\t\t\t\t//entry and location.\r\n\t\t\t\t\tvar handleRetrieve = function(entry, dom, args){\r\n\t\t\t\t\t\tif(callback){\r\n\t\t\t\t\t\t\tcallback.call(scope, entry, location, args);\r\n\t\t\t\t\t\t}else if(ae){\r\n\t\t\t\t\t\t\tthrow new Error(\"The callback value does not exist.\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\tself.getEntry(location,handleRetrieve);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(callback){\r\n\t\t\t\t\t\tcallback.call(scope, entry, args.xhr.getResponseHeader(\"Location\"), args);\r\n\t\t\t\t\t}else if(ae){\r\n\t\t\t\t\t\tthrow new Error(\"The callback value does not exist.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn data;\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tif(this.user && this.user !== null){\r\n\t\t\txhrArgs.user = this.user;\r\n\t\t}\r\n\t\tif(this.password && this.password !== null){\r\n\t\t\txhrArgs.password = this.password;\r\n\t\t}\r\n\r\n\t\tif(errorCallback){\r\n\t\t\txhrArgs.error = function(error, args){errorCallback.call(scope, error, args);};\r\n\t\t}else{\r\n\t\t\txhrArgs.error = function(){\r\n\t\t\t\tthrow new Error(\"The URL requested cannot be accessed\");\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif(xmethod){\r\n\t\t\txhrArgs.postData = entry.toString(true); //Set the content to send.\r\n\t\t\txhrArgs.headers = {\"X-Method-Override\": \"PUT\"};\r\n\t\t\txhrUtil.post(xhrArgs);\r\n\t\t}else{\r\n\t\t\txhrArgs.putData = entry.toString(true); //Set the content to send.\r\n\t\t\tvar xhr = xhrUtil.put(xhrArgs);\r\n\t\t}\r\n\t},\r\n\r\n\taddEntry: function(entry, url, callback, errorCallback, retrieveEntry, scope){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to add a new ATOM entry by posting the new entry via APP.\r\n\t\t// description:\r\n\t\t//\t\tThis function takes a specific dojox.atom.io.model.Entry object and pushes the\r\n\t\t//\t\tchanges back to the provider of the Entry.\r\n\t\t// entry:\r\n\t\t//\t\tObject\r\n\t\t//\t\tThe dojox.atom.io.model.Entry object to publish.\r\n\t\t// callback:\r\n\t\t//\t\tFunction\r\n\t\t//\t\tA function reference that will handle the results from the entry publish.\r\n\t\t//\t\tThe callback should accept two parameters:   The first is an dojox.atom.io.model.Entry object, and the second is the location of the entry\r\n\t\t//\t\tEither can be null, depending on the value of retrieveUpdated.\r\n\t\t// retrieveEntry:\r\n\t\t//\t\tboolean\r\n\t\t//\t\tA boolean flag denoting if the entry that was created should then be\r\n\t\t//\t\tretrieved and returned to the caller via the callback.\r\n\t\t// scope:\r\n\t\t//\t\tObject\r\n\t\t//\t \tThe scope to use for all callbacks.\r\n\t\t// returns:\r\n\t\t//\t\tNothing. The return is handled through the callback handler.\r\n\t\tif(!scope){\r\n\t\t\tscope = kernel.global;\r\n\t\t}\r\n\r\n\t\tentry.published = new Date();\r\n\t\tentry.updated = new Date();\r\n\r\n\t\tvar feedUrl = entry.feedUrl;\r\n\t\tvar ae = this.alertsEnabled;\r\n\r\n\t\t//Determine which URL to use for the post.\r\n\t\tif(!url && feedUrl){url = feedUrl;}\r\n\t\tif(!url){\r\n\t\t\tif(ae){\r\n\t\t\t\tthrow new Error(\"The request cannot be processed because the URL parameter is missing.\");\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tvar self = this;\r\n\t\tvar xhrArgs = {\r\n\t\t\turl: url,\r\n\t\t\thandleAs: \"text\",\r\n\t\t\tcontentType: \"text/xml\",\r\n\t\t\tsync: this.sync,\r\n\t\t\tpreventCache: this.preventCache,\r\n\t\t\tpostData: entry.toString(true),\r\n\t\t\tload: function(data, args){\r\n\t\t\t\tvar location = args.xhr.getResponseHeader(\"Location\");\r\n\t\t\t\tif(!location){\r\n\t\t\t\t\tlocation = url;\r\n\t\t\t\t}\r\n\t\t\t\tif(!args.retrieveEntry){\r\n\t\t\t\t\tif(callback){\r\n\t\t\t\t\t\tcallback.call(scope, entry, location, args);\r\n\t\t\t\t\t}else if(ae){\r\n\t\t\t\t\t\tthrow new Error(\"The callback value does not exist.\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//Function to handle the callback mapping of a getEntry after an update to return the\r\n\t\t\t\t\t//entry and location.\r\n\t\t\t\t\tvar handleRetrieve = function(entry, dom, args){\r\n\t\t\t\t\t\tif(callback){\r\n\t\t\t\t\t\t\tcallback.call(scope, entry, location, args);\r\n\t\t\t\t\t\t}else if(ae){\r\n\t\t\t\t\t\t\tthrow new Error(\"The callback value does not exist.\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\tself.getEntry(location,handleRetrieve);\r\n\t\t\t\t}\r\n\t\t\t\treturn data;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(this.user && this.user !== null){\r\n\t\t\txhrArgs.user = this.user;\r\n\t\t}\r\n\t\tif(this.password && this.password !== null){\r\n\t\t\txhrArgs.password = this.password;\r\n\t\t}\r\n\r\n\t\tif(errorCallback){\r\n\t\t\txhrArgs.error = function(error, args){errorCallback.call(scope, error, args);};\r\n\t\t}else{\r\n\t\t\txhrArgs.error = function(){\r\n\t\t\t\tthrow new Error(\"The URL requested cannot be accessed\");\r\n\t\t\t};\r\n\t\t}\r\n\t\txhrUtil.post(xhrArgs);\r\n\t},\r\n\r\n\tdeleteEntry: function(entry,callback,errorCallback,xmethod,scope){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to delete a specific ATOM entry via APP.\r\n\t\t// description:\r\n\t\t//\t\tThis function takes a specific dojox.atom.io.model.Entry object and calls for a delete on the\r\n\t\t//\t\tservice housing the ATOM Entry database.\r\n\t\t//\t\tThe entry MUST have a link tag with rel=\"edit\" for this to work.\r\n\t\t// entry:\r\n\t\t//\t\tObject\r\n\t\t//\t\tThe dojox.atom.io.model.Entry object to delete.\r\n\t\t// callback:\r\n\t\t//\t\tFunction\r\n\t\t//\t\tA function reference that will handle the results from the entry delete.\r\n\t\t//\t\tThe callback is called only if the delete is successful.\r\n\t\t// returns:\r\n\t\t//\t\tNothing. The return is handled through the callback handler.\r\n\t\tif(!scope){\r\n\t\t\tscope = kernel.global;\r\n\t\t}\r\n\r\n\t\tvar url = null;\r\n\t\tif(typeof(entry) == \"string\"){\r\n\t\t\turl = entry;\r\n\t\t}else{\r\n\t\t\turl = entry.getEditHref();\r\n\t\t}\r\n\t\tif(!url){\r\n\t\t\tcallback.call(scope, false, null);\r\n\t\t\tthrow new Error(\"The request cannot be processed because the URL parameter is missing.\");\r\n\t\t}\r\n\r\n\t\tvar xhrArgs = {\r\n\t\t\turl: url,\r\n\t\t\thandleAs: \"text\",\r\n\t\t\tsync: this.sync,\r\n\t\t\tpreventCache: this.preventCache,\r\n\t\t\tload: function(data, args){\r\n\t\t\t\tcallback.call(scope, args);\r\n\t\t\t\treturn data;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tif(this.user && this.user !== null){\r\n\t\t\txhrArgs.user = this.user;\r\n\t\t}\r\n\t\tif(this.password && this.password !== null){\r\n\t\t\txhrArgs.password = this.password;\r\n\t\t}\r\n\r\n\t\tif(errorCallback){\r\n\t\t\txhrArgs.error = function(error, args){errorCallback.call(scope, error, args);};\r\n\t\t}else{\r\n\t\t\txhrArgs.error = function(){\r\n\t\t\t\tthrow new Error(\"The URL requested cannot be accessed\");\r\n\t\t\t};\r\n\t\t}\r\n\t\tif(xmethod){\r\n\t\t\txhrArgs.headers = {\"X-Method-Override\": \"DELETE\"};\r\n\t\t\tdhxr.post(xhrArgs);\r\n\t\t}else{\r\n\t\t\txhrUtil.del(xhrArgs);\r\n\t\t}\r\n\t}\r\n});\r\n});"]}