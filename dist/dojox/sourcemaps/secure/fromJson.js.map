{"version":3,"sources":["secure/fromJson.js"],"names":["dojo","provide","dojox","secure","fromJson","JSON","parse","jsonToken","RegExp","escapeSequence","escapes","\"","/","\\","b","f","n","r","t","unescapeOne","_","ch","hex","String","fromCharCode","parseInt","EMPTY_STRING","hop","Object","Array","hasOwnProperty","json","opt_reviver","result","key","toks","match","tok","topLevelPrimitive","stack","i","length","cont","charCodeAt","substring","indexOf","replace","unshift","shift","Error","walk","holder","value","toDelete","k","call","v","push",""],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,yBAQbC,MAAMC,OAAOC,SAA0B,oBAARC,KAAsBA,KAAKC,MAkD1D,WACC,IAWIC,EAAY,IAAIC,OAClB,mLAGO,KAGLC,EAAiB,IAAID,OAAO,yBAA0B,KAGtDE,GACHC,IAAK,IACLC,IAAK,IACLC,KAAM,KACNC,EAAK,KACLC,EAAK,KACLC,EAAK,KACLC,EAAK,KACLC,EAAK,MAEN,SAASC,EAAYC,EAAGC,EAAIC,GAC3B,OAAOD,EAAKX,EAAQW,GAAME,OAAOC,aAAaC,SAASH,EAAK,KAI7D,IAAII,EAAe,IAAIH,OAAO,IAM1BI,GAFyBC,OAAaC,MAEhCD,OAAOE,gBAEjB,OAAO,SAAUC,EAAMC,GAEtB,IAEIC,EAiBAC,EAnBAC,EAAOJ,EAAKK,MAAM7B,GAGlB8B,EAAMF,EAAK,GACXG,GAAoB,EACpB,MAAQD,EACXJ,KACU,MAAQI,EAClBJ,MAKAA,KACAK,GAAoB,GASrB,IADA,IAAIC,GAASN,GACJO,EAAI,EAAIF,EAAmBtB,EAAImB,EAAKM,OAAQD,EAAIxB,IAAKwB,EAAG,CAGhE,IAAIE,EACJ,QAHAL,EAAMF,EAAKK,IAGCG,WAAW,IACtB,SACCD,EAAOH,EAAM,IACRL,GAAOQ,EAAKD,SAAW,EAC5BP,OAAM,EACN,MACD,KAAK,GAMJ,IAJ4B,KAD5BG,EAAMA,EAAIO,UAAU,EAAGP,EAAII,OAAS,IAC5BI,QA5CA,QA6CPR,EAAMA,EAAIS,QAAQrC,EAAgBU,IAEnCuB,EAAOH,EAAM,IACRL,EAAK,CACT,KAAIQ,aAAgBb,OAEb,CACNK,EAAMG,GAAOX,EACb,MAHAQ,EAAMQ,EAAKD,OAMbC,EAAKR,GAAOG,EACZH,OAAM,EACN,MACD,KAAK,GACJQ,EAAOH,EAAM,GACbA,EAAMQ,QAAQL,EAAKR,GAAOQ,EAAKD,YAC/BP,OAAM,EACN,MACD,KAAK,GACJK,EAAMS,QACN,MACD,KAAK,KACJN,EAAOH,EAAM,IACRL,GAAOQ,EAAKD,SAAU,EAC3BP,OAAM,EACN,MACD,KAAK,KACJQ,EAAOH,EAAM,IACRL,GAAOQ,EAAKD,QAAU,KAC3BP,OAAM,EACN,MACD,KAAK,KACJQ,EAAOH,EAAM,IACRL,GAAOQ,EAAKD,SAAU,EAC3BP,OAAM,EACN,MACD,KAAK,IACJQ,EAAOH,EAAM,GACbA,EAAMQ,QAAQL,EAAKR,GAAOQ,EAAKD,YAC/BP,OAAM,EACN,MACD,KAAK,IACJK,EAAMS,SAKT,GAAIV,EAAmB,CACtB,GAAqB,IAAjBC,EAAME,OAAgB,MAAM,IAAIQ,MACpChB,EAASA,EAAO,QAEhB,GAAIM,EAAME,OAAU,MAAM,IAAIQ,MAG/B,GAAIjB,EAAa,CAEhB,IAAIkB,EAAO,SAAUC,EAAQjB,GAC5B,IAAIkB,EAAQD,EAAOjB,GACnB,GAAIkB,GAA0B,iBAAVA,EAAoB,CACvC,IAAIC,EAAW,KACf,IAAK,IAAIC,KAAKF,EACb,GAAIzB,EAAI4B,KAAKH,EAAOE,IAAMF,IAAUD,EAAQ,CAW3C,IAAIK,EAAIN,EAAKE,EAAOE,QACV,IAANE,EACHJ,EAAME,GAAKE,GAINH,IAAYA,MACjBA,EAASI,KAAKH,IAIjB,GAAID,EACH,IAAK,IAAIb,EAAIa,EAASZ,SAAUD,GAAK,UAC7BY,EAAMC,EAASb,IAIzB,OAAOR,EAAYuB,KAAKJ,EAAQjB,EAAKkB,IAEtCnB,EAASiB,GAAOQ,GAAIzB,GAAU,IAG/B,OAAOA,GAlLT","file":"../../secure/fromJson.js","sourcesContent":["dojo.provide(\"dojox.secure.fromJson\");\r\n\r\n// Used with permission from Mike Samuel of Google (has CCLA), from the json-sans-eval project:\r\n// http://code.google.com/p/json-sans-eval/\r\n//\tMike Samuel <mikesamuel@gmail.com>\r\n\r\n\r\n\r\ndojox.secure.fromJson = typeof JSON != \"undefined\" ? JSON.parse :\r\n// summary:\r\n//\t\tParses a string of well-formed JSON text.\r\n// description:\r\n//\t\tParses a string of well-formed JSON text. If the input is not well-formed,\r\n//\t\tthen behavior is undefined, but it is\r\n//\t\tdeterministic and is guaranteed not to modify any object other than its\r\n//\t\treturn value.\r\n//\r\n//\t\tThis does not use `eval` so is less likely to have obscure security bugs than\r\n//\t\tjson2.js.\r\n//\t\tIt is optimized for speed, so is much faster than json_parse.js.\r\n//\r\n//\t\tThis library should be used whenever security is a concern (when JSON may\r\n//\t\tcome from an untrusted source), speed is a concern, and erroring on malformed\r\n//\t\tJSON is *not* a concern.\r\n//\r\n//\t\tjson2.js is very fast, but potentially insecure since it calls `eval` to\r\n//\t\tparse JSON data, so an attacker might be able to supply strange JS that\r\n//\t\tlooks like JSON, but that executes arbitrary javascript.\r\n//\r\n//\t\tTo configure dojox.secure.fromJson as the JSON parser for all Dojo\r\n//\t\tJSON parsing, simply do:\r\n//\t\t|\tdojo.require(\"dojox.secure.fromJson\");\r\n//\t\t|\tdojo.fromJson = dojox.secure.fromJson;\r\n//\t\tor alternately you could configure dojox.secure.fromJson to only handle\r\n//\t\tXHR responses:\r\n//\t\t|\tdojo._contentHandlers.json = function(xhr){\r\n//\t\t|\t\treturn dojox.secure.fromJson.fromJson(xhr.responseText);\r\n//\t\t|\t};\r\n// json: String\r\n//\t\tper RFC 4627\r\n// optReviver: Function (this:Object, string, *)\r\n//\t\toptional function\r\n//\t\tthat reworks JSON objects post-parse per Chapter 15.12 of EcmaScript3.1.\r\n//\t\tIf supplied, the function is called with a string key, and a value.\r\n//\t\tThe value is the property of 'this'.\tThe reviver should return\r\n//\t\tthe value to use in its place.\tSo if dates were serialized as\r\n//\t\t`{ \"type\": \"Date\", \"time\": 1234 }`, then a reviver might look like\r\n// |\tfunction (key, value) {\r\n// |\t\tif (value && typeof value === 'object' && 'Date' === value.type) {\r\n// |\t\t\treturn new Date(value.time);\r\n// |\t\t} else {\r\n// |\t\t\treturn value;\r\n// |\t\t}\r\n// |\t}}.\r\n//\t\tIf the reviver returns {@code undefined} then the property named by key\r\n//\t\twill be deleted from its container.\r\n//\t\t`this` is bound to the object containing the specified property.\r\n// returns: Object|Array\r\n(function () {\r\n\tvar number\r\n\t\t\t= '(?:-?\\\\b(?:0|[1-9][0-9]*)(?:\\\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\\\b)';\r\n\tvar oneChar = '(?:[^\\\\0-\\\\x08\\\\x0a-\\\\x1f\\\"\\\\\\\\]'\r\n\t\t\t+ '|\\\\\\\\(?:[\\\"/\\\\\\\\bfnrt]|u[0-9A-Fa-f]{4}))';\r\n\tvar string = '(?:\\\"' + oneChar + '*\\\")';\r\n\r\n\t// Will match a value in a well-formed JSON file.\r\n\t// If the input is not well-formed, may match strangely, but not in an unsafe\r\n\t// way.\r\n\t// Since this only matches value tokens, it does not match whitespace, colons,\r\n\t// or commas.\r\n\tvar jsonToken = new RegExp(\r\n\t\t\t'(?:false|true|null|[\\\\{\\\\}\\\\[\\\\]]'\r\n\t\t\t+ '|' + number\r\n\t\t\t+ '|' + string\r\n\t\t\t+ ')', 'g');\r\n\r\n\t// Matches escape sequences in a string literal\r\n\tvar escapeSequence = new RegExp('\\\\\\\\(?:([^u])|u(.{4}))', 'g');\r\n\r\n\t// Decodes escape sequences in object literals\r\n\tvar escapes = {\r\n\t\t'\"': '\"',\r\n\t\t'/': '/',\r\n\t\t'\\\\': '\\\\',\r\n\t\t'b': '\\b',\r\n\t\t'f': '\\f',\r\n\t\t'n': '\\n',\r\n\t\t'r': '\\r',\r\n\t\t't': '\\t'\r\n\t};\r\n\tfunction unescapeOne(_, ch, hex) {\r\n\t\treturn ch ? escapes[ch] : String.fromCharCode(parseInt(hex, 16));\r\n\t}\r\n\r\n\t// A non-falsy value that coerces to the empty string when used as a key.\r\n\tvar EMPTY_STRING = new String('');\r\n\tvar SLASH = '\\\\';\r\n\r\n\t// Constructor to use based on an open token.\r\n\tvar firstTokenCtors = { '{': Object, '[': Array };\r\n\r\n\tvar hop = Object.hasOwnProperty;\r\n\r\n\treturn function (json, opt_reviver) {\r\n\t\t// Split into tokens\r\n\t\tvar toks = json.match(jsonToken);\r\n\t\t// Construct the object to return\r\n\t\tvar result;\r\n\t\tvar tok = toks[0];\r\n\t\tvar topLevelPrimitive = false;\r\n\t\tif ('{' === tok) {\r\n\t\t\tresult = {};\r\n\t\t} else if ('[' === tok) {\r\n\t\t\tresult = [];\r\n\t\t} else {\r\n\t\t\t// The RFC only allows arrays or objects at the top level, but the JSON.parse\r\n\t\t\t// defined by the EcmaScript 5 draft does allow strings, booleans, numbers, and null\r\n\t\t\t// at the top level.\r\n\t\t\tresult = [];\r\n\t\t\ttopLevelPrimitive = true;\r\n\t\t}\r\n\r\n\t\t// If undefined, the key in an object key/value record to use for the next\r\n\t\t// value parsed.\r\n\t\tvar key;\r\n\t\t// Loop over remaining tokens maintaining a stack of uncompleted objects and\r\n\t\t// arrays.\r\n\t\tvar stack = [result];\r\n\t\tfor (var i = 1 - topLevelPrimitive, n = toks.length; i < n; ++i) {\r\n\t\t\ttok = toks[i];\r\n\r\n\t\t\tvar cont;\r\n\t\t\tswitch (tok.charCodeAt(0)) {\r\n\t\t\t\tdefault:\t// sign or digit\r\n\t\t\t\t\tcont = stack[0];\r\n\t\t\t\t\tcont[key || cont.length] = +(tok);\r\n\t\t\t\t\tkey = void 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0x22:\t// '\"'\r\n\t\t\t\t\ttok = tok.substring(1, tok.length - 1);\r\n\t\t\t\t\tif (tok.indexOf(SLASH) !== -1) {\r\n\t\t\t\t\t\ttok = tok.replace(escapeSequence, unescapeOne);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcont = stack[0];\r\n\t\t\t\t\tif (!key) {\r\n\t\t\t\t\t\tif (cont instanceof Array) {\r\n\t\t\t\t\t\t\tkey = cont.length;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tkey = tok || EMPTY_STRING;\t// Use as key for next value seen.\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcont[key] = tok;\r\n\t\t\t\t\tkey = void 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0x5b:\t// '['\r\n\t\t\t\t\tcont = stack[0];\r\n\t\t\t\t\tstack.unshift(cont[key || cont.length] = []);\r\n\t\t\t\t\tkey = void 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0x5d:\t// ']'\r\n\t\t\t\t\tstack.shift();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0x66:\t// 'f'\r\n\t\t\t\t\tcont = stack[0];\r\n\t\t\t\t\tcont[key || cont.length] = false;\r\n\t\t\t\t\tkey = void 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0x6e:\t// 'n'\r\n\t\t\t\t\tcont = stack[0];\r\n\t\t\t\t\tcont[key || cont.length] = null;\r\n\t\t\t\t\tkey = void 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0x74:\t// 't'\r\n\t\t\t\t\tcont = stack[0];\r\n\t\t\t\t\tcont[key || cont.length] = true;\r\n\t\t\t\t\tkey = void 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0x7b:\t// '{'\r\n\t\t\t\t\tcont = stack[0];\r\n\t\t\t\t\tstack.unshift(cont[key || cont.length] = {});\r\n\t\t\t\t\tkey = void 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 0x7d:\t// '}'\r\n\t\t\t\t\tstack.shift();\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Fail if we've got an uncompleted object.\r\n\t\tif (topLevelPrimitive) {\r\n\t\t\tif (stack.length !== 1) { throw new Error(); }\r\n\t\t\tresult = result[0];\r\n\t\t} else {\r\n\t\t\tif (stack.length) { throw new Error(); }\r\n\t\t}\r\n\r\n\t\tif (opt_reviver) {\r\n\t\t\t// Based on walk as implemented in http://www.json.org/json2.js\r\n\t\t\tvar walk = function (holder, key) {\r\n\t\t\t\tvar value = holder[key];\r\n\t\t\t\tif (value && typeof value === 'object') {\r\n\t\t\t\t\tvar toDelete = null;\r\n\t\t\t\t\tfor (var k in value) {\r\n\t\t\t\t\t\tif (hop.call(value, k) && value !== holder) {\r\n\t\t\t\t\t\t\t// Recurse to properties first.\tThis has the effect of causing\r\n\t\t\t\t\t\t\t// the reviver to be called on the object graph depth-first.\r\n\r\n\t\t\t\t\t\t\t// Since 'this' is bound to the holder of the property, the\r\n\t\t\t\t\t\t\t// reviver can access sibling properties of k including ones\r\n\t\t\t\t\t\t\t// that have not yet been revived.\r\n\r\n\t\t\t\t\t\t\t// The value returned by the reviver is used in place of the\r\n\t\t\t\t\t\t\t// current value of property k.\r\n\t\t\t\t\t\t\t// If it returns undefined then the property is deleted.\r\n\t\t\t\t\t\t\tvar v = walk(value, k);\r\n\t\t\t\t\t\t\tif (v !== void 0) {\r\n\t\t\t\t\t\t\t\tvalue[k] = v;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// Deleting properties inside the loop has vaguely defined\r\n\t\t\t\t\t\t\t\t// semantics in ES3 and ES3.1.\r\n\t\t\t\t\t\t\t\tif (!toDelete) { toDelete = []; }\r\n\t\t\t\t\t\t\t\ttoDelete.push(k);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (toDelete) {\r\n\t\t\t\t\t\tfor (var i = toDelete.length; --i >= 0;) {\r\n\t\t\t\t\t\t\tdelete value[toDelete[i]];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn opt_reviver.call(holder, key, value);\r\n\t\t\t};\r\n\t\t\tresult = walk({ '': result }, '');\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t};\r\n})();"]}