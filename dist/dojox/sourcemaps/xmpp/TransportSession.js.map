{"version":3,"sources":["xmpp/TransportSession.js"],"names":["dojo","provide","require","dojox","xmpp","TransportSession","props","this","sendTimeout","wait","isObject","mixin","useScriptSrcTransport","transportIframes","extend","rid","hold","polling","secure","lang","submitContentType","serviceUrl","defaultResource","domain","keepAliveTimer","state","transmitState","protocolPacketQueue","outboundQueue","outboundRequests","inboundQueue","deferredRequests","matchTypeIdAttribute","open","status","Math","round","random","setTimeout","hitch","bosh","initialize","iframes","load","_sendLogin","req","content","to","xml:lang","xmpp:version","xmlns","BODY_NS","xmlns:xmpp","msg","util","createElement","addToOutboundQueue","_sendRestart","sid","xmpp:restart","processScriptSrc","msgDom","xml","parser","parse","processDocument","_keepAlive","isTerminated","_dispatchPacket","close","protocolMsg","type","envelope","string","Builder","append","toString","dispatchPacket","protocolMatchType","matchId","matchProperty","push","def","Deferred","dispatchTimer","clearTimeout","authId","length","processProtocolPacketQueue","lastPollTime","now","Date","getTime","console","debug","redispatchPacket","env","sendXml","removeFromOutboundQueue","i","splice","packets","message","get","url","encodeURIComponent","error","res","io","setState","timeout","rawXhrPost","contentType","postData","handleAs","processError","xhr","responseXML","addCallback","doc","firstChild","body","nodeName","expectedId","processResponse","processInboundQueue","addToInboundQueue","item","shift","getAttribute","errorMessage","Error","authRetries","terminateSession","parseInt","inactivity","forEach","childNodes","node","processProtocolResponse","onProcessProtocolResponse","key","callback","err","httpStatusCode","dojoType","reasonNode","onTerminate","newState","oldState","onReady"],"mappings":"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","file":"../../xmpp/TransportSession.js","sourcesContent":["dojo.provide(\"dojox.xmpp.TransportSession\");\r\ndojo.require(\"dojox.xmpp.bosh\");\r\ndojo.require(\"dojox.xmpp.util\");\r\ndojo.require(\"dojox.data.dom\");\r\n\r\ndojox.xmpp.TransportSession = function(props) {\r\n\t// we have to set this here because \"this\" doesn't work\r\n\t// in the dojo.extend call.\r\n\tthis.sendTimeout = (this.wait+20)*1000;\r\n\r\n\t//mixin any options that we want to provide to this service\r\n\tif (props && dojo.isObject(props)) {\r\n\t\tdojo.mixin(this, props);\r\n\t\tif(this.useScriptSrcTransport){\r\n\t\t\tthis.transportIframes = [];\r\n\t\t}\r\n\t}\r\n\t\r\n};\r\n\r\ndojo.extend(dojox.xmpp.TransportSession, {\r\n\r\n\t\t/* options/defaults */\r\n\t\trid: 0,\r\n\t\thold: 1,\r\n\t\tpolling:1000,\r\n\t\tsecure: false,\r\n\t\twait: 60,\r\n\t\tlang: 'en',\r\n\t\tsubmitContentType: 'text/xml; charset=utf=8',\r\n\t\tserviceUrl: '/httpbind',\r\n\t\tdefaultResource: \"dojoIm\",\r\n\t\tdomain: 'imserver.com',\r\n\t\tsendTimeout: 0, //(this.wait+20)*1000\r\n\t\t\r\n\t\tuseScriptSrcTransport:false,\r\n\t\t\r\n\t\t\r\n\t\tkeepAliveTimer:null,\r\n\r\n\t\t//status\r\n\t\tstate: \"NotReady\",\r\n\t\ttransmitState: \"Idle\",\r\n\r\n\t\tprotocolPacketQueue: [],\r\n\t\toutboundQueue: [],\r\n\t\toutboundRequests: {},\r\n\t\tinboundQueue: [],\r\n\t\tdeferredRequests: {},\r\n\t\tmatchTypeIdAttribute: {},\r\n\r\n\t\topen: function() {\r\n\t\t\tthis.status = \"notReady\";\r\n\t\t\tthis.rid = Math.round(Math.random() * 1000000000);\r\n\t\t\tthis.protocolPacketQueue = [];\r\n\t\t\tthis.outboundQueue = [];\r\n\t\t\tthis.outboundRequests = {};\r\n\t\t\tthis.inboundQueue = [];\r\n\t\t\tthis.deferredRequests = {};\r\n\t\t\tthis.matchTypeIdAttribute = {};\r\n\t\t\t\r\n\t\t\r\n\t\t\tthis.keepAliveTimer = setTimeout(dojo.hitch(this, \"_keepAlive\"), 10000);\r\n\t\t\t\r\n\t\t\tif(this.useScriptSrcTransport){\r\n\t\t\t\tdojox.xmpp.bosh.initialize({\r\n\t\t\t\t\tiframes: this.hold+1,\r\n\t\t\t\t\tload: dojo.hitch(this, function(){\r\n\t\t\t\t\t\tthis._sendLogin();\r\n\t\t\t\t\t})\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tthis._sendLogin();\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t_sendLogin: function() {\r\n\t\t\t\tvar rid = this.rid++;\r\n\t\t\t\tvar req = {\r\n\t\t\t\t\tcontent: this.submitContentType,\r\n\t\t\t\t\thold: this.hold,\r\n\t\t\t\t\trid: rid,\r\n\t\t\t\t\tto: this.domain,\r\n\t\t\t\t\tsecure: this.secure,\r\n\t\t\t\t\twait: this.wait,\r\n\t\t\t\t\t\"xml:lang\": this.lang,\r\n\t\t\t\t\t\"xmpp:version\": \"1.0\",\r\n\t\t\t\t\txmlns: dojox.xmpp.xmpp.BODY_NS,\r\n\t\t\t\t\t\"xmlns:xmpp\": \"urn:xmpp:xbosh\"\r\n\t\t\t\t};\r\n\r\n\t\t\t\tvar msg = dojox.xmpp.util.createElement(\"body\", req, true);\r\n\t\t\t\tthis.addToOutboundQueue(msg, rid);\r\n\t\t},\r\n\r\n\t\t_sendRestart: function(){\r\n\t\t\tvar rid = this.rid++;\r\n\t\t\tvar req = {\r\n\t\t\t\trid: rid,\r\n\t\t\t\tsid: this.sid,\r\n\t\t\t\tto: this.domain,\r\n\t\t\t\t\"xmpp:restart\": \"true\",\r\n\t\t\t\t\"xml:lang\": this.lang,\r\n\t\t\t\txmlns: dojox.xmpp.xmpp.BODY_NS,\r\n\t\t\t\t\"xmlns:xmpp\": \"urn:xmpp:xbosh\"\r\n\t\t\t};\r\n\r\n\t\t\tvar msg = dojox.xmpp.util.createElement(\"body\", req, true);\r\n\t\t\tthis.addToOutboundQueue(msg, rid);\r\n\t\t},\r\n\t\t\r\n\t\tprocessScriptSrc: function(msg, rid) {\r\n\t\t\t//console.log(\"processScriptSrc::\", rid, msg);\r\n\t\t//\tvar msgDom = dojox.xml.DomParser.parse(msg);\r\n\t\t\tvar msgDom = dojox.xml.parser.parse(msg, \"text/xml\");\r\n\t\t\t//console.log(\"parsed mgs\", msgDom);\r\n\t\t\t//console.log(\"Queue\", this.outboundQueue);\r\n\t\t\tif(msgDom) {\r\n\t\t\t\tthis.processDocument(msgDom, rid);\r\n\t\t\t} else {\r\n\t\t\t\t//console.log(\"Received bad document from server\",msg);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t_keepAlive: function(){\r\n\t\t\tif (this.state==\"wait\" || this.isTerminated()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis._dispatchPacket();\r\n\t\t\tthis.keepAliveTimer = setTimeout(dojo.hitch(this, \"_keepAlive\"), 10000);\r\n\t\t},\r\n\t\t\r\n\t\t\r\n\t\tclose: function(protocolMsg){\r\n\r\n\t\r\n\t\t\tvar rid = this.rid++;\r\n\t\t\tvar req = {\r\n\t\t\t\t\r\n\t\t\t\tsid: this.sid,\r\n\t\t\t\trid: rid,\r\n\t\t\t\ttype: \"terminate\"\r\n\t\t\t};\r\n\t\t\tvar envelope = null;\r\n\r\n\t\t\tif (protocolMsg) {\r\n\t\t\t\tenvelope = new dojox.string.Builder(dojox.xmpp.util.createElement(\"body\", req, false));\r\n\t\t\t\tenvelope.append(protocolMsg);\r\n\t\t\t\tenvelope.append(\"</body>\");\r\n\t\t\t} else {\r\n\t\t\t\tenvelope = new dojox.string.Builder(dojox.xmpp.util.createElement(\"body\", req, false));\r\n\t\t\t}\r\n\r\n\t\t//\tthis.sendXml(envelope,rid);\r\n\t\t\tthis.addToOutboundQueue(envelope.toString(), rid);\r\n\t\t\tthis.state==\"Terminate\";\r\n\t\t},\r\n\r\n\t\tdispatchPacket: function(msg, protocolMatchType, matchId, matchProperty){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tMain Packet dispatcher, most calls should be made with this other\r\n\t\t\t//\t\tthan a few setup calls which use add items to the queue directly\r\n\t\t\t//\t\tprotocolMatchType, matchId, and matchProperty are optional params\r\n\t\t\t//\t\tthat allow a deferred to be tied to a protocol response instad of the whole\r\n\t\t\t//\t\trid\r\n\t\r\n\t\t//\t//console.log(\"In dispatchPacket \", msg, protocolMatchType, matchId, matchProperty);\r\n\t\t\tif (msg){\r\n\t\t\t\tthis.protocolPacketQueue.push(msg);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar def = new dojo.Deferred();\r\n\t\t\t//def.rid = req.rid;\r\n\r\n\t\t\tif (protocolMatchType && matchId){\r\n\t\t\t\tdef.protocolMatchType = protocolMatchType;\r\n\t\t\t\tdef.matchId = matchId;\r\n\t\t\t\tdef.matchProperty = matchProperty || \"id\";\r\n\t\t\t\tif(def.matchProperty != \"id\") {\r\n\t\t\t\t\tthis.matchTypeIdAttribute[protocolMatchType] = def.matchProperty;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.deferredRequests[def.protocolMatchType + \"-\" +def.matchId]=def;\r\n\t\t\tif(!this.dispatchTimer) {\r\n\t\t\t\tthis.dispatchTimer = setTimeout(dojo.hitch(this, \"_dispatchPacket\"), 600);\r\n\t\t\t}\r\n\t\t\treturn def;\r\n\t\t},\r\n\t\r\n\t\t_dispatchPacket: function(){\r\n\t\t\t\r\n\t\t\tclearTimeout(this.dispatchTimer);\r\n\t\t\tdelete this.dispatchTimer;\r\n\t\t\t\r\n\t\t\tif (!this.sid){\r\n\t\t\t\tconsole.debug(\"TransportSession::dispatchPacket() No SID, packet dropped.\")\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.authId){\r\n\t\t\t\t//FIXME according to original nodes, this should wait a little while and try\r\n\t\t\t\t//\t\tagain up to three times to see if we get this data.\r\n\t\t\t\tconsole.debug(\"TransportSession::dispatchPacket() No authId, packet dropped [FIXME]\")\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\r\n\r\n\t\t\t//if there is a pending request with the server, don't poll\r\n\t\t\tif (this.transmitState != \"error\" && (this.protocolPacketQueue.length == 0) && (this.outboundQueue.length > 0)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.state==\"wait\" || this.isTerminated()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tvar req = {\r\n\t\t\t\tsid: this.sid,\r\n\t\t\t\txmlns: dojox.xmpp.xmpp.BODY_NS\r\n\t\t\t}\r\n\r\n\t\t\tvar envelope\r\n\t\t\tif (this.protocolPacketQueue.length > 0){\r\n\t\t\t\treq.rid= this.rid++;\r\n\t\t\t\tenvelope = new dojox.string.Builder(dojox.xmpp.util.createElement(\"body\", req, false));\r\n\t\t\t\tenvelope.append(this.processProtocolPacketQueue());\r\n\t\t\t\tenvelope.append(\"</body>\");\r\n\t\t\t\tdelete this.lastPollTime;\r\n\t\t\t} else {\r\n\t\t\t\t//console.log(\"Nothing to send, I'm just polling.\");\r\n\t\t\t\tif(this.lastPollTime) {\r\n\t\t\t\t\tvar now = new Date().getTime();\r\n\t\t\t\t\tif(now - this.lastPollTime < this.polling) {\r\n\t\t\t\t\t\t//console.log(\"Waiting to poll \", this.polling - (now - this.lastPollTime)+10);\r\n\t\t\t\t\t\tthis.dispatchTimer = setTimeout(dojo.hitch(this, \"_dispatchPacket\"), this.polling - (now - this.lastPollTime)+10);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\treq.rid= this.rid++;\r\n\t\t\t\tthis.lastPollTime = new Date().getTime();\r\n\t\t\t\tenvelope = new dojox.string.Builder(dojox.xmpp.util.createElement(\"body\", req, true));\r\n\r\n\t\t\t}\r\n\r\n\t\t\r\n\t\t\tthis.addToOutboundQueue(envelope.toString(),req.rid);\r\n\r\n\t\t},\r\n\r\n\t\tredispatchPacket: function(rid){\r\n\t\t\tvar env = this.outboundRequests[rid];\r\n\t\t\tthis.sendXml(env, rid);\r\n\t\t},\r\n\r\n\t\taddToOutboundQueue: function(msg, rid){\r\n\t\t\tthis.outboundQueue.push({msg: msg,rid: rid});\r\n\t\t\tthis.outboundRequests[rid]=msg;\r\n\t\t\tthis.sendXml(msg, rid);\r\n\t\t},\r\n\r\n\t\tremoveFromOutboundQueue: function(rid){\r\n\t\t\tfor(var i=0; i<this.outboundQueue.length;i++){\r\n\t\t\t\tif (rid == this.outboundQueue[i][\"rid\"]){\r\n\t\t\t\t\tthis.outboundQueue.splice(i, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdelete this.outboundRequests[rid];\r\n\t\t},\r\n\r\n\t\tprocessProtocolPacketQueue: function(){\r\n\t\t\tvar packets = new dojox.string.Builder();\r\n\t\t\tfor(var i=0; i<this.protocolPacketQueue.length;i++){\r\n\t\t\t\tpackets.append(this.protocolPacketQueue[i]);\r\n\t\t\t}\r\n\t\t\tthis.protocolPacketQueue=[];\r\n\t\t\treturn packets.toString();\r\n\t\t},\r\n\r\n\t\tsendXml: function(message, rid){\r\n\t\t\tif(this.isTerminated()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t//console.log(\"TransportSession::sendXml()\"+ new Date().getTime() + \" RID: \", rid, \" MSG: \", message);\r\n\t\t\tthis.transmitState = \"transmitting\";\r\n\t\t\tvar def = null;\r\n\t\t\tif(this.useScriptSrcTransport) {\r\n\t\t\t\t//console.log(\"using script src to transmit\");\r\n\t\t\t\tdef = dojox.xmpp.bosh.get({\r\n\t\t\t\t\trid: rid,\r\n\t\t\t\t\turl: this.serviceUrl+'?'+encodeURIComponent(message),\r\n\t\t\t\t\terror: dojo.hitch(this, function(res, io){\r\n\t\t\t\t\t\tthis.setState(\"Terminate\", \"error\");\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}),\r\n\t\t\t\t\ttimeout: this.sendTimeout\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tdef = dojo.rawXhrPost({\r\n\t\t\t\t\tcontentType: \"text/xml\",\r\n\t\t\t\t\turl: this.serviceUrl,\r\n\t\t\t\t\tpostData: message,\r\n\t\t\t\t\thandleAs: \"xml\",\r\n\t\t\t\t\terror: dojo.hitch(this, function(res, io) {\r\n\t\t\t\t\t\t////console.log(\"foo\", res, io.xhr.responseXML, io.xhr.status);\r\n\t\t\t\t\t\treturn this.processError(io.xhr.responseXML, io.xhr.status , rid);\r\n\t\t\t\t\t}),\r\n\t\t\t\t\ttimeout: this.sendTimeout\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t//process the result document\r\n\t\t\tdef.addCallback(this, function(res){\r\n\t\t\t\treturn this.processDocument(res, rid);\r\n\t\t\t});\r\n\t\t\treturn def;\r\n\t\t},\r\n\r\n\t\tprocessDocument: function(doc, rid){\r\n\t\t\tif(this.isTerminated() || !doc.firstChild) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t//console.log(\"TransportSession:processDocument() \", doc, rid);\r\n\t\t\tthis.transmitState = \"idle\";\r\n\r\n\t\t\tvar body = doc.firstChild;\r\n\t\t\tif (body.nodeName != 'body'){\r\n\t\t\t\t//console.log(\"TransportSession::processDocument() firstChild is not <body> element \", doc, \" RID: \", rid);\r\n\t\t\t}\r\n\r\n\t\t\tif (this.outboundQueue.length<1){return false;}\r\n\r\n\t\t\tvar expectedId = this.outboundQueue[0][\"rid\"];\r\n\t\t\t//console.log(\"expectedId\", expectedId);\r\n\t\t\tif (rid==expectedId){\r\n\t\t\t\tthis.removeFromOutboundQueue(rid);\r\n\t\t\t\tthis.processResponse(body, rid);\r\n\t\t\t\tthis.processInboundQueue();\r\n\t\t\t}else{\r\n\t\t\t\t//console.log(\"TransportSession::processDocument() rid: \", rid, \" expected: \", expectedId);\r\n\t\t\t\tvar gap = rid-expectedId;\r\n\t\t\t\r\n\t\t\t\tif (gap < this.hold + 2){\r\n\t\t\t\t\tthis.addToInboundQueue(doc,rid);\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//console.log(\"TransportSession::processDocument() RID is outside of the expected response window\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn doc;\r\n\t\t},\r\n\r\n\t\tprocessInboundQueue: function(){\r\n\t\t\twhile (this.inboundQueue.length > 0) {\r\n\t\t\t\tvar item = this.inboundQueue.shift();\r\n\t\t\t\tthis.processDocument(item[\"doc\"], item[\"rid\"]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\taddToInboundQueue: function(doc,rid){\r\n\t\t\tfor (var i=0; i<this.inboundQueue.length;i++){\r\n\t\t\t\tif (rid < this.inboundQueue[i][\"rid\"]){continue;}\r\n\t\t\t\tthis.inboundQueue.splice(i,0,{doc: doc, rid: rid});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tprocessResponse: function(body,rid){\r\n\t\t\t////console.log(\"TransportSession:processResponse() \", body, \" RID: \", rid);\r\n\r\n\t\t\tif (body.getAttribute(\"type\")=='terminate'){\r\n\t\t\t\tvar reasonNode = body.firstChild.firstChild;\r\n\t\t\t\tvar errorMessage = \"\";\r\n\t\t\t\t\tif(reasonNode.nodeName == \"conflict\") {\r\n\t\t\t\t\t\terrorMessage = \"conflict\"\r\n\t\t\t\t\t}\r\n\t\t\t\tthis.setState(\"Terminate\", errorMessage);\r\n\t\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ((this.state != 'Ready')&&(this.state != 'Terminate')) {\r\n\t\t\t\tvar sid=body.getAttribute(\"sid\");\r\n\t\t\t\tif (sid){\r\n\t\t\t\t\tthis.sid=sid;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error(\"No sid returned during xmpp session startup\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.authId = body.getAttribute(\"authid\");\r\n\t\t\t\tif (this.authId == \"\") {\r\n\t\t\t\t\tif (this.authRetries-- < 1) {\r\n\t\t\t\t\t\tconsole.error(\"Unable to obtain Authorization ID\");\r\n\t\t\t\t\t\tthis.terminateSession();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tthis.wait= body.getAttribute(\"wait\");\r\n\t\t\t\tif( body.getAttribute(\"polling\")){\r\n\t\t\t\t\tthis.polling= parseInt(body.getAttribute(\"polling\"))*1000;\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\t//console.log(\"Polling value \", this.polling);\r\n\t\t\t\tthis.inactivity = body.getAttribute(\"inactivity\");\r\n\t\t\t\tthis.setState(\"Ready\");\r\n\t\t\t}\r\n\r\n\t\t\tdojo.forEach(body.childNodes, function(node){\r\n\t\t\t\tthis.processProtocolResponse(node, rid);\r\n\t\t\t}, this);\r\n\r\n\t\t\t//need to make sure, since if you use sendXml directly instead of using\r\n\t\t\t//dispatch packets, there wont' be a call back function here\r\n\t\t\t//normally the deferred will get fired by a child message at the protocol level\r\n\t\t\t//but if it hasn't fired by now, go ahead and fire it with the full body\r\n\t\t\t/*if (this.deferredRequests[rid] && this.deferredRequests[rid].fired==-1){\r\n\t\t\t\tthis.deferredRequests[rid].callback(body);\r\n\t\t\t}*/\r\n\r\n\t\t\t//delete from the list of outstanding requests\r\n\t\t\t//delete this.deferredRequests[rid];\r\n\r\n\t\t\tif (this.transmitState == \"idle\"){\r\n\t\t\t\tthis.dispatchPacket();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\r\n\t\tprocessProtocolResponse: function(msg, rid){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tprocess the individual protocol messages and if there\r\n\t\t\t//\t\tis a matching set of protocolMatchType, matchId, and matchPropery\r\n\t\t\t//\t\tfire off the deferred\r\n\r\n\t\t\tthis.onProcessProtocolResponse(msg);\r\n\t\t\tvar key = msg.nodeName + \"-\" +msg.getAttribute(\"id\");\r\n\t\t\tvar def = this.deferredRequests[key];\r\n\t\t\tif (def){\r\n\t\t\t\tdef.callback(msg);\r\n\t\t\t\tdelete this.deferredRequests[key];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tsetState: function(state, message){\r\n\t\t\tif (this.state != state) {\r\n\t\t\t\tif (this[\"on\"+state]){\r\n\t\t\t\t\tthis[\"on\"+state](state, this.state, message);\r\n\t\t\t\t}\r\n\t\t\t\tthis.state=state;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tisTerminated: function() {\r\n\t\t\t\r\n\t\t\treturn this.state==\"Terminate\";\r\n\t\t},\r\n\r\n\t\tprocessError: function(err, httpStatusCode,rid){\r\n\t\t\t//console.log(\"Processing server error \", err, httpStatusCode,rid);\r\n\t\t\tif(this.isTerminated()) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(httpStatusCode != 200) {\r\n\t\t\t\tif(httpStatusCode >= 400 && httpStatusCode < 500){\r\n\t\t\t\t\t/* Any status code between 400 and 500 should terminate\r\n\t\t\t\t\t * the connection */\r\n\t\t\t\t\tthis.setState(\"Terminate\", errorMessage);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.removeFromOutboundQueue(rid);\r\n\t\t\t\t\tsetTimeout(dojo.hitch(this, function(){ this.dispatchPacket(); }), 200);\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (err && err.dojoType && err.dojoType==\"timeout\"){\r\n\t\t\t\t//console.log(\"Wait timeout\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.removeFromOutboundQueue(rid);\r\n\t\t\t//FIXME conditional processing if request will be needed based on type of error.\r\n\t\t\tif(err && err.firstChild) {\r\n\t\t\t//console.log(\"Error \", err.firstChild.getAttribute(\"type\") + \" status code \" + httpStatusCode);\r\n\t\t\t\r\n\t\t\t\tif (err.firstChild.getAttribute(\"type\")=='terminate'){\r\n\t\t\t\t\tvar reasonNode = err.firstChild.firstChild;\r\n\t\t\t\t\tvar errorMessage = \"\";\r\n\t\t\t\t\tif(reasonNode && reasonNode.nodeName == \"conflict\") {\r\n\t\t\t\t\t\terrorMessage = \"conflict\"\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.setState(\"Terminate\", errorMessage);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.transmitState = \"error\";\r\n\t\t\tsetTimeout(dojo.hitch(this, function(){ this.dispatchPacket(); }), 200);\r\n\t\t\t//console.log(\"Error: \", arguments);\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t//events\r\n\t\tonTerminate: function(newState, oldState, message){ },\r\n\t\tonProcessProtocolResponse: function(msg){},\r\n\t\tonReady: function(newState, oldState){}\r\n});\r\n"]}