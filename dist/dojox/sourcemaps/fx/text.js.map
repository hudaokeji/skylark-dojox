{"version":3,"sources":["fx/text.js"],"names":["define","lang","dojoxFx","baseFx","coreFx","easingLib","dom","domStyle","htmlLib","connectUtil","textFx","getObject","_split","args","node","byId","s","style","cs","getComputedStyle","nodeCoords","coords","duration","words","originalHTML","text","innerHTML","originalHeight","height","originalWidth","width","animations","set","tagReg","reg","pieces","match","html","numPieces","number","i","length","piece","animatePieces","next","nextSibling","tagName","childNodes","firstChild","nodeType","pieceCoords","padding","margin","top","crop","t","left","l","display","pieceAnimation","isArray","concat","anim","combine","connect","onPlay","onEnd","explode","distance","random","fade","sync","Math","abs","pieceHeight","h","pieceWidth","w","startTop","parseFloat","startLeft","delay","randomX","randomY","seed","max","unhide","distanceY","y","distanceX","x","distanceXY","sqrt","pow","endTop","endLeft","pieceSlide","animateProperty","easing","sinOut","circOut","beforeBegin","position","properties","start","end","pieceFade","fadeEasing","quadOut","opacity","converge","disintegrate","interval","randomDelay","uniformDelay","reverseOrder","sinIn","circIn","build","blockFadeOut","sinInOut","undefined","blockFadeIn","backspace","textContent","innerText","whitespace","wordDelay","fixed","lastIndexOf","type"],"mappings":"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","file":"../../fx/text.js","sourcesContent":["define([\"dojo/_base/lang\", \"./_base\", \"dojo/_base/fx\", \"dojo/fx\",\"dojo/fx/easing\", \"dojo/dom\", \"dojo/dom-style\", \"dojo/_base/html\", \"dojo/_base/connect\"],\r\nfunction(lang, dojoxFx, baseFx, coreFx, easingLib, dom, domStyle, htmlLib, connectUtil ){\r\nvar textFx = lang.getObject(\"dojox.fx.text\", true);\r\ntextFx._split = function(/*Object*/ args){\r\n\t// summary:\r\n\t//\t\tSplit a block of text into words or letters\r\n\t// description:\r\n\t//\t\tReturns an animation that will split the node into a grid\r\n\t//\t\tof pieces that move independently.\r\n\t//\r\n\t//\t\tNOTE:\r\n\t//\t\tIn some rendering engines, the text will appear to \"jump\" from its initial position\r\n\t//\t\twhen the animation begins.\tTo work around this bug, enclose the node's text in a `<p>` or `<div>`.\r\n\t// args:\r\n\t//\t\t- args.crop: Boolean - If true, pieces will be positioned relatively rather than absolutely\r\n\t//\t\t- args.text: String - Text to place inside the node (otherwise node.innerHTML is used)\r\n\t//\t\t- args.words: Boolean - If true, the text will be split into words rather than characters\r\n\t//\t\t- args.pieceAnimation: Function(piece, pieceCoords, nodeCoords, number, numPieces)\r\n\t//\t\t\tReturns either the dojo.Animation or an array of dojo.Animation objects for the piece.\r\n\t//\t\t\tThe arguments:\r\n\t//\t\t\t- pieceCoords is the result of dojo.coords(piece, true);\r\n\t//\t\t\t- nodeCoords is the result of dojo.coords(args.node, true);\r\n\t//\t\t\t- number is the piece's position in the array of pieces, and numPieces is the array.length\r\n\r\n\tvar node = args.node = dom.byId(args.node),\r\n\t\ts = node.style,\r\n\t\tcs = domStyle.getComputedStyle(node),\r\n\t\tnodeCoords = htmlLib.coords(node, true);\r\n\t\t\r\n\targs.duration = args.duration || 1000;\r\n\targs.words = args.words || false;\r\n\t\r\n\tvar originalHTML = (args.text && typeof(args.text) == \"string\") ? args.text : node.innerHTML,\r\n\t\toriginalHeight = s.height,\r\n\t\toriginalWidth = s.width,\r\n\t\tanimations = [];\r\n\r\n\tdomStyle.set(node, {\r\n\t\theight: cs.height,\r\n\t\twidth: cs.width\r\n\t});\r\n\r\n\t// The following regular expression courtesy of Phil Haack\r\n\t// http://haacked.com/archive/2004/10/25/usingregularexpressionstomatchhtml.aspx\r\n\tvar tagReg = /(<\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)\\/?>)/g;\r\n\r\n\t// Translation: /(HTML tag plus spaces)|(word/letter without '<' plus spaces)/g\r\n\tvar reg = (args.words ?\r\n\t\t/(<\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)\\/?>)\\s*|([^\\s<]+\\s*)/g :\r\n\t\t/(<\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)\\/?>)\\s*|([^\\s<]\\s*)/g\r\n\t);\r\n\r\n\t// Split the text into pieces\r\n\tvar pieces = (typeof args.text == \"string\") ? args.text.match(reg) : node.innerHTML.match(reg);\r\n\tvar html = \"\";\r\n\tvar numPieces = 0;\r\n\tvar number = 0;\r\n\tfor(var i = 0; i < pieces.length; i++){\r\n\t\tvar piece = pieces[i];\r\n\t\tif(!piece.match(tagReg)){\r\n\t\t\thtml += \"<span>\" + piece + \"</span>\";\r\n\t\t\tnumPieces++;\r\n\t\t}else{\r\n\t\t\thtml += piece;\r\n\t\t}\r\n\t}\r\n\tnode.innerHTML = html;\r\n\r\n\t// Find the newly-created spans and create their animations\r\n\tfunction animatePieces(piece){\r\n\t\tvar next = piece.nextSibling;\r\n\t\tif(piece.tagName == \"SPAN\" && piece.childNodes.length == 1 && piece.firstChild.nodeType == 3){\r\n\t\t\tvar pieceCoords = htmlLib.coords(piece, true);\r\n\t\t\tnumber++;\r\n\t\t\tdomStyle.set(piece, {\r\n\t\t\t\tpadding: 0,\r\n\t\t\t\tmargin: 0,\r\n\t\t\t\ttop: (args.crop ? \"0px\" : pieceCoords.t + \"px\"),\r\n\t\t\t\tleft: (args.crop ? \"0px\" : pieceCoords.l + \"px\"),\r\n\t\t\t\tdisplay: \"inline\"\r\n\t\t\t});\r\n\t\t\tvar pieceAnimation = args.pieceAnimation(piece, pieceCoords, nodeCoords, number, numPieces);\r\n\t\t\tif(lang.isArray(pieceAnimation)){\r\n\t\t\t\t// if pieceAnimation is an array, append its elements\r\n\t\t\t\tanimations = animations.concat(pieceAnimation);\r\n\t\t\t}else{\r\n\t\t\t\t// otherwise, append it\r\n\t\t\t\tanimations[animations.length] = pieceAnimation;\r\n\t\t\t}\r\n\t\t}else if(piece.firstChild){\r\n\t\t\tanimatePieces(piece.firstChild);\r\n\t\t}\r\n\r\n\t\tif(next){\r\n\t\t\tanimatePieces(next);\r\n\t\t}\r\n\t}\r\n\r\n\tanimatePieces(node.firstChild);\r\n\tvar anim = coreFx.combine(animations);\r\n\tconnectUtil.connect(anim, \"onEnd\", anim, function(){\r\n\t\tnode.innerHTML = originalHTML;\r\n\t\tdomStyle.set(node, {\r\n\t\t\theight: originalHeight,\r\n\t\t\twidth: originalWidth\r\n\t\t});\r\n\t});\r\n\tif(args.onPlay){\r\n\t\tconnectUtil.connect(anim, \"onPlay\", anim, args.onPlay);\r\n\t}\r\n\tif(args.onEnd){\r\n\t\tconnectUtil.connect(anim, \"onEnd\", anim, args.onEnd);\r\n\t}\r\n\treturn anim; // dojo.Animation\r\n};\r\n\r\ntextFx.explode = function(/*Object*/ args){\r\n\t// summary:\r\n\t//\t\tExplode a block of text into words or letters\r\n\t// description:\r\n\t//\t\tReturns an animation that will split the text into a spans\r\n\t//\t\tof words or characters that fly away from the center.\r\n\t// args:\r\n\t//\t\t- args.crop: Boolean - If true, pieces will be positioned relatively rather than absolutely\r\n\t//\t\t- args.words: Boolean - If true, text will be split into words rather than characters\r\n\t//\t\t- args.random: Float - If set, pieces fly to random distances, for random durations,\r\n\t//\t\t\t\t\t\t\t   and in slightly random directions. The value defines how much\r\n\t//\t\t\t\t\t\t\t   randomness is introduced.\r\n\t//\t\t- args.distance: Float - Multiplier for the distance the pieces fly (even when random)\r\n\t//\t\t- args.fade: Boolean - If true, pieces fade out while in motion (default is true)\r\n\t//\t\t- args.fadeEasing: Function - If args.fade is true, the fade animations use this easing function\r\n\t//\t\t- args.unhide: Boolean - If true, the animation is reversed\r\n\t//\t\t- args.sync: Boolean - If args.unhide is true, all the pieces converge at the same time\r\n\t//\t\t\t\t\t\t\t   (default is true)\r\n\r\n\tvar node = args.node = dom.byId(args.node);\r\n\tvar s = node.style;\r\n\r\n\targs.distance = args.distance || 1;\r\n\targs.duration = args.duration || 1000;\r\n\targs.random = args.random || 0;\r\n\tif(typeof(args.fade) == \"undefined\"){\r\n\t\targs.fade = true;\r\n\t}\r\n\tif(typeof(args.sync) == \"undefined\"){\r\n\t\targs.sync = true;\r\n\t}\r\n\targs.random = Math.abs(args.random);\r\n\r\n\t// Returns the animation object for each piece\r\n\targs.pieceAnimation = function(piece, pieceCoords, coords, number, numPieces){\r\n\t\tvar pieceHeight = pieceCoords.h;\r\n\t\tvar pieceWidth = pieceCoords.w;\r\n\t\tvar distance = args.distance * 2;\r\n\t\tvar duration = args.duration;\r\n\t\tvar startTop = parseFloat(piece.style.top);\r\n\t\tvar startLeft = parseFloat(piece.style.left);\r\n\t\tvar delay = 0;\r\n\t\tvar randomX = 0;\r\n\t\tvar randomY = 0;\r\n\t\tif(args.random){\r\n\t\t\tvar seed = (Math.random() * args.random) + Math.max(1 - args.random, 0);\r\n\t\t\tdistance *= seed;\r\n\t\t\tduration *= seed;\r\n\t\t\t// To syncronize, give each piece an appropriate delay so they end together\r\n\t\t\tdelay = ((args.unhide && args.sync) || (!args.unhide && !args.sync)) ? (args.duration - duration) : 0;\r\n\r\n\t\t\t// Slightly randomize the direction of each piece\r\n\t\t\trandomX = Math.random() - 0.5;\r\n\t\t\trandomY = Math.random() - 0.5;\r\n\t\t}\r\n\t\tvar distanceY = ((coords.h - pieceHeight) / 2 - (pieceCoords.y - coords.y));\r\n\t\tvar distanceX = ((coords.w - pieceWidth) / 2 - (pieceCoords.x - coords.x));\r\n\t\tvar distanceXY = Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2));\r\n\t\tvar endTop = startTop - distanceY * distance + distanceXY * randomY;\r\n\t\tvar endLeft = startLeft - distanceX * distance + distanceXY * randomX;\r\n\r\n\t\t// Create the animation objects for the piece\r\n\t\t// These are separate anim objects so they can have different curves\r\n\t\tvar pieceSlide = baseFx.animateProperty({\r\n\t\t\tnode: piece,\r\n\t\t\tduration: duration,\r\n\t\t\tdelay: delay,\r\n\t\t\teasing: (args.easing || (args.unhide ? easingLib.sinOut : easingLib.circOut)),\r\n\t\t\tbeforeBegin: (args.unhide ? function(){\r\n\t\t\t\t\tif(args.fade){\r\n\t\t\t\t\t\t//piece.style.opacity = 0;\r\n\t\t\t\t\t\tdomStyle.set(piece,\"opacity\", 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpiece.style.position = args.crop ? \"relative\" : \"absolute\";\r\n\t\t\t\t\tpiece.style.top = endTop + \"px\";\r\n\t\t\t\t\tpiece.style.left = endLeft + \"px\";\r\n\t\t\t\t} : function(){piece.style.position = args.crop ? \"relative\" : \"absolute\";}),\r\n\t\t\tproperties: {\r\n\t\t\t\ttop: (args.unhide ? { start: endTop, end: startTop } : { start: startTop, end: endTop }),\r\n\t\t\t\tleft: (args.unhide ? { start: endLeft, end: startLeft } : { start: startLeft, end: endLeft })\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif(args.fade){\r\n\t\t\tvar pieceFade = baseFx.animateProperty({\r\n\t\t\t\tnode: piece,\r\n\t\t\t\tduration: duration,\r\n\t\t\t\tdelay: delay,\r\n\t\t\t\teasing: (args.fadeEasing || easingLib.quadOut),\r\n\t\t\t\tproperties: {\r\n\t\t\t\t\topacity: (args.unhide ? {start: 0, end: 1} : {end: 0})\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// return both animations as an array\r\n\t\t\treturn (args.unhide ? [pieceFade, pieceSlide] : [pieceSlide, pieceFade]);\r\n\t\t}else{\r\n\t\t\t// Otherwise return only the slide animation\r\n\t\t\treturn pieceSlide;\r\n\t\t}\r\n\t};\r\n\r\n\tvar anim = textFx._split(args);\r\n\treturn anim; // dojo.Animation\r\n};\r\n\r\ntextFx.converge = function(/*Object*/ args){\r\n\targs.unhide = true;\r\n\treturn textFx.explode(args);\r\n};\r\n\r\ntextFx.disintegrate = function(/*Object*/ args){\r\n\t// summary:\r\n\t//\t\tSplit a block of text into words or letters and let them fall\r\n\t// description:\r\n\t//\t\tReturns an animation that will split the text into spans of words\r\n\t//\t\tor characters that drop.\r\n\t// args:\r\n\t//\t\t- args.crop: Boolean - If true, pieces will be positioned relatively rather than absolutely\r\n\t//\t\t- args.words: Boolean - If true, text will be split into words rather than characters\r\n\t//\t\t- args.interval: Float - The number of milliseconds between each piece's animation\r\n\t//\t\t- args.distance: Float - The number of the node's heights to drop (default is 1.5)\r\n\t//\t\t- args.fade: Boolean - If true, pieces fade out while in motion (default is true)\r\n\t//\t\t- args.random: Float - If set, pieces fall in random order. The value defines how much\r\n\t//\t\t\t\t\t\t\t   randomness is introduced\r\n\t//\t\t- args.reverseOrder: Boolean - If true, pieces animate in reversed order\r\n\t//\t\t- args.unhide: Boolean - If true, the peices fall from above and land in place\r\n\r\n\tvar node = args.node = dom.byId(args.node);\r\n\tvar s = node.style;\r\n\r\n\targs.duration = args.duration || 1500;\r\n\targs.distance = args.distance || 1.5;\r\n\targs.random = args.random || 0;\r\n\tif(!args.fade){\r\n\t\targs.fade = true;\r\n\t}\r\n\tvar random = Math.abs(args.random);\r\n\r\n\t// Returns the animation object for each piece\r\n\targs.pieceAnimation = function(piece, pieceCoords, coords, number, numPieces){\r\n\t\tvar pieceHeight = pieceCoords.h;\r\n\t\tvar pieceWidth = pieceCoords.w;\r\n\r\n\t\tvar interval = args.interval || (args.duration / (1.5 * numPieces));\r\n\t\tvar duration = (args.duration - numPieces * interval);\r\n\r\n\t\tvar randomDelay = Math.random() * numPieces * interval;\r\n\t\t// If distance is negative, start from the top right instead of bottom left\r\n\t\tvar uniformDelay = (args.reverseOrder || args.distance < 0) ?\r\n\t\t\t(number * interval) : ((numPieces - number) * interval);\r\n\t\tvar delay = randomDelay * random + Math.max(1 - random, 0) * uniformDelay;\r\n\r\n\t\t// Create the animation object for the piece\r\n\t\tvar properties = {};\r\n\t\tif(args.unhide){\r\n\t\t\tproperties.top = {\r\n\t\t\t\tstart: (parseFloat(piece.style.top) - coords.h * args.distance),\r\n\t\t\t\tend: parseFloat(piece.style.top)\r\n\t\t\t};\r\n\t\t\tif(args.fade){\r\n\t\t\t\tproperties.opacity = {start: 0, end: 1};\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tproperties.top = {end: (parseFloat(piece.style.top) + coords.h * args.distance)};\r\n\t\t\tif(args.fade){\r\n\t\t\t\tproperties.opacity = {end: 0};\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar pieceAnimation = baseFx.animateProperty({\r\n\t\t\tnode: piece,\r\n\t\t\tduration: duration,\r\n\t\t\tdelay: delay,\r\n\t\t\teasing: (args.easing || (args.unhide ? easingLib.sinIn : easingLib.circIn)),\r\n\t\t\tproperties: properties,\r\n\t\t\tbeforeBegin: (args.unhide ? function(){\r\n\t\t\t\tif(args.fade){\r\n\t\t\t\t\t// piece.style.opacity = 0;\r\n\t\t\t\t\tdomStyle.set(piece, \"opacity\", 0);\r\n\t\t\t\t}\r\n\t\t\t\tpiece.style.position = args.crop ? \"relative\" : \"absolute\";\r\n\t\t\t\tpiece.style.top = properties.top.start + \"px\";\r\n\t\t\t} : function(){ piece.style.position = args.crop ? \"relative\" : \"absolute\";})\r\n\t\t});\r\n\r\n\t\treturn pieceAnimation;\r\n\t};\r\n\r\n\tvar anim = textFx._split(args);\r\n\treturn anim; // dojo.Animation\r\n};\r\n\r\ntextFx.build = function(/*Object*/ args){\r\n\targs.unhide = true;\r\n\treturn textFx.disintegrate(args);\r\n};\r\n\r\ntextFx.blockFadeOut = function(/*Object*/ args){\r\n\t// summary:\r\n\t//\t\tSplit a block of text into words or letters and fade them\r\n\t// description:\r\n\t//\t\tReturns an animation that will split the text into spans of words\r\n\t//\t\tor characters that fade in or out.\r\n\t// args:\r\n\t//\t\t- args.words: Boolean - If true, text will be split into words rather than characters\r\n\t//\t\t- args.interval: Float - The number of milliseconds between each piece's animation (default is 0)\r\n\t//\t\t- args.random: Float - If true, pieces have a random delay. The value defines how much\r\n\t//\t\t\t\t\t\t\t   randomness is introduced\r\n\t//\t\t- args.reverseOrder: Boolean - If true, pieces animate in reversed order\r\n\t//\t\t- args.unhide: Boolean - If true, the animation is reversed\r\n\r\n\tvar node = args.node = dom.byId(args.node);;\r\n\tvar s = node.style;\r\n\r\n\targs.duration = args.duration || 1000;\r\n\targs.random = args.random || 0;\r\n\tvar random = Math.abs(args.random);\r\n\r\n\t// Returns the animation object for each piece\r\n\targs.pieceAnimation = function(piece, pieceCoords, coords, number, numPieces){\r\n\t\tvar interval = args.interval || (args.duration / (1.5 * numPieces));\r\n\t\tvar duration = (args.duration - numPieces * interval);\r\n\r\n\t\tvar randomDelay = Math.random() * numPieces * interval;\r\n\t\t// If interval or random is negative, start from the bottom instead of top\r\n\t\tvar uniformDelay = (args.reverseOrder) ?\r\n\t\t\t((numPieces - number) * interval) : (number * interval);\r\n\t\tvar delay = randomDelay * random + Math.max(1 - random, 0) * uniformDelay;\r\n\r\n\t\t// Create the animation object for the piece\r\n\t\tvar pieceAnimation = baseFx.animateProperty({\r\n\t\t\tnode: piece,\r\n\t\t\tduration: duration,\r\n\t\t\tdelay: delay,\r\n\t\t\teasing: (args.easing || easingLib.sinInOut),\r\n\t\t\tproperties: {\r\n\t\t\t\topacity: (args.unhide ? {start: 0, end: 1} : {end:0})\r\n\t\t\t},\r\n\t\t\tbeforeBegin: (args.unhide ? function(){ domStyle.set(piece,\"opacity\",0); } : undefined)\r\n\t\t});\r\n\r\n\t\treturn pieceAnimation;\r\n\t};\r\n\r\n\tvar anim = textFx._split(args);\r\n\treturn anim; // dojo.Animation\r\n};\r\n\r\ntextFx.blockFadeIn = function(/*Object*/ args){\r\n\targs.unhide = true;\r\n\treturn textFx.blockFadeOut(args);\r\n};\r\n\r\ntextFx.backspace = function(/*Object*/ args){\r\n\t// summary:\r\n\t//\t\tSplit a block of text into words or letters and backspace them in sequence\r\n\t// description:\r\n\t//\t\tReturns an animation that will split the text into spans of words\r\n\t//\t\tor characters that appear as if they were being backspaced (or typed) in real-time.\r\n\t// args:\r\n\t//\t\t- args.interval: Float - The number of milliseconds between each piece's animation\r\n\t//\t\t  (default is determined by text length and args.duration);\r\n\t//\t\t- args.wordDelay: Integer - The number of milliseconds between each word\r\n\t//\t\t  (only effective when args.unhide = true)\r\n\t//\t\t- args.fixed: Boolean - If true, only style.opacity changes; otherwise, style.display\r\n\t//\t\t  changes between none and inline, adding realism (default = false)\r\n\t//\t\t- args.random: Float - If true, pieces have a random delay. The value defines how much\r\n\t//\t\t  randomness is introduced (only effective when args.unhide = true)\r\n\t//\t\t- args.unhide: Boolean - If true, the animation is reversed\r\n\r\n\tvar node = args.node = dom.byId(args.node);\r\n\tvar s = node.style;\r\n\r\n\targs.words = false;\r\n\targs.duration = args.duration || 2000;\r\n\targs.random = args.random || 0;\r\n\tvar random = Math.abs(args.random);\r\n\tvar delay = 10;\r\n\r\n\t// Returns the animation object for each piece\r\n\targs.pieceAnimation = function(piece, pieceCoords, coords, number, numPieces){\r\n\t\tvar interval = args.interval || (args.duration / (1.5 * numPieces)),\r\n\t\t\ttext = (\"textContent\" in piece) ? piece.textContent : piece.innerText,\r\n\t\t\twhitespace = text.match(/\\s/g);\r\n\r\n\t\tif(typeof(args.wordDelay) == \"undefined\"){\r\n\t\t\targs.wordDelay = interval * 2;\r\n\t\t}\r\n\r\n\t\tif(!args.unhide){\r\n\t\t\tdelay = (numPieces - number - 1) * interval;\r\n\t\t}\r\n\r\n\t\tvar beforeBegin, onEnd;\r\n\r\n\t\tif(args.fixed){\r\n\t\t\tif(args.unhide){\r\n\t\t\t\tvar beforeBegin = function(){ domStyle.set(piece,\"opacity\",0); };\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif(args.unhide){\r\n\t\t\t\tvar beforeBegin = function(){piece.style.display = \"none\";};\r\n\t\t\t\tvar onEnd = function(){piece.style.display = \"inline\";};\r\n\t\t\t}else{\r\n\t\t\t\tvar onEnd = function(){piece.style.display = \"none\";};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Create the animation object for the piece\r\n\t\tvar pieceAnimation = baseFx.animateProperty({\r\n\t\t\tnode: piece,\r\n\t\t\tduration: 1,\r\n\t\t\tdelay: delay,\r\n\t\t\teasing: (args.easing || easingLib.sinInOut),\r\n\t\t\tproperties: {\r\n\t\t\t\topacity: (args.unhide ? {start: 0, end: 1} : {end:0})\r\n\t\t\t},\r\n\t\t\tbeforeBegin: beforeBegin,\r\n\t\t\tonEnd: onEnd\r\n\t\t});\r\n\r\n\t\tif(args.unhide){\r\n\t\t\tvar randomDelay = Math.random() * text.length * interval;\r\n\t\t\tvar wordDelay = randomDelay * random / 2 + Math.max(1 - random / 2, 0) * args.wordDelay;\r\n\r\n\t\t\tdelay += randomDelay * random + Math.max(1 - random, 0) * interval * text.length +\r\n\t\t\t\t(wordDelay * (whitespace && text.lastIndexOf(whitespace[whitespace.length-1]) == text.length - 1));\r\n\t\t}\r\n\r\n\t\treturn pieceAnimation;\r\n\t};\r\n\r\n\tvar anim = textFx._split(args);\r\n\treturn anim; // dojo.Animation\r\n};\r\n\r\ntextFx.type = function(/*Object*/ args){\r\n\targs.unhide = true;\r\n\treturn textFx.backspace(args);\r\n};\r\nreturn textFx;\r\n});\r\n"]}