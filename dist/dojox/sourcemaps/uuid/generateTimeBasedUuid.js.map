{"version":3,"sources":["uuid/generateTimeBasedUuid.js"],"names":["define","lang","dojox","uuid","generateTimeBasedUuid","node","_generator","generateUuidString","isValidNode","integer","parseInt","isString","length","isFinite","setNode","assert","this","_uniformNode","getNode","GREGORIAN_CHANGE_OFFSET_IN_HOURS","_uuidPseudoNodeString","_uuidClockSeqString","_dateValueOfPreviousUuid","_nextIntraMillisecondIncrement","_cachedMillisecondsBetween1582and1970","_cachedHundredNanosecondIntervalsPerMillisecond","HEX_RADIX","_carry","arrayA","_get64bitArrayFromFloat","x","result","Array","_multiplyTwo64bitArrays","arrayB","isArray","overflow","_padWithLeadingZeros","string","desiredLength","leftmost4HexCharacters","Math","floor","random","pow","toString","eightCharacterString","_generateRandomEightCharacterHexString","random14bitNumber","now","Date","nowArray","valueOf","arraySecondsPerHour","arraySecondsBetween1582and1970","arrayMillisecondsPerSecond","arrayHundredNanosecondIntervalsSince1582","_addTwo64bitArrays","hexTimeLowLeftHalf","hexTimeLowRightHalf","hexTimeLow","hexTimeMid","hexTimeHigh","resultUuid","toLowerCase"],"mappings":"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","file":"../../uuid/generateTimeBasedUuid.js","sourcesContent":["define([ 'dojo/_base/lang', './_base'], function(lang){\r\n\r\ndojox.uuid.generateTimeBasedUuid = function(/*String?*/ node){\r\n\t// summary:\r\n\t//\t\tThis function generates time-based UUIDs, meaning \"version 1\" UUIDs.\r\n\t// description:\r\n\t//\t\tFor more info, see\r\n\t//\t\thttp://www.webdav.org/specs/draft-leach-uuids-guids-01.txt\r\n\t//\t\thttp://www.infonuovo.com/dma/csdocs/sketch/instidid.htm\r\n\t//\t\thttp://kruithof.xs4all.nl/uuid/uuidgen\r\n\t//\t\thttp://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20\r\n\t//\t\thttp://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html\r\n\t// node:\r\n\t//\t\tA 12-character hex string representing either a pseudo-node or\r\n\t//\t\thardware-node (an IEEE 802.3 network node).  A hardware-node\r\n\t//\t\twill be something like \"017bf397618a\", always with the first bit\r\n\t//\t\tbeing 0.  A pseudo-node will be something like \"f17bf397618a\",\r\n\t//\t\talways with the first bit being 1.\r\n\t// examples:\r\n\t//\t\tstring = dojox.uuid.generateTimeBasedUuid();\r\n\t//\t\tstring = dojox.uuid.generateTimeBasedUuid(\"017bf397618a\");\r\n\t//\t\tdojox.uuid.generateTimeBasedUuid.setNode(\"017bf397618a\");\r\n\t//\t\tstring = dojox.uuid.generateTimeBasedUuid(); // the generated UUID has node == \"017bf397618a\"\r\n\tvar uuidString = dojox.uuid.generateTimeBasedUuid._generator.generateUuidString(node);\r\n\treturn uuidString; // String\r\n};\r\n\r\ndojox.uuid.generateTimeBasedUuid.isValidNode = function(/*String?*/ node){\r\n\tvar HEX_RADIX = 16;\r\n\tvar integer = parseInt(node, HEX_RADIX);\r\n\tvar valid = lang.isString(node) && node.length == 12 && isFinite(integer);\r\n\treturn valid; // Boolean\r\n};\r\n\r\ndojox.uuid.generateTimeBasedUuid.setNode = function(/*String?*/ node){\r\n\t// summary:\r\n\t//\t\tSets the 'node' value that will be included in generated UUIDs.\r\n\t// node: A 12-character hex string representing a pseudoNode or hardwareNode.\r\n\tdojox.uuid.assert((node === null) || this.isValidNode(node));\r\n\tthis._uniformNode = node;\r\n};\r\n\r\ndojox.uuid.generateTimeBasedUuid.getNode = function(){\r\n\t// summary:\r\n\t//\t\tReturns the 'node' value that will be included in generated UUIDs.\r\n\treturn this._uniformNode; // String (a 12-character hex string representing a pseudoNode or hardwareNode)\r\n};\r\n\r\n\t\r\ndojox.uuid.generateTimeBasedUuid._generator = new function(){\r\n\t// Number of hours between October 15, 1582 and January 1, 1970:\r\n\tthis.GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;\r\n\t\r\n\t// Number of seconds between October 15, 1582 and January 1, 1970:\r\n\t//\t dojox.uuid.generateTimeBasedUuid.GREGORIAN_CHANGE_OFFSET_IN_SECONDS = 12219292800;\r\n\t\r\n\t// --------------------------------------------------\r\n\t// Private variables:\r\n\tvar _uuidPseudoNodeString = null;\r\n\tvar _uuidClockSeqString = null;\r\n\tvar _dateValueOfPreviousUuid = null;\r\n\tvar _nextIntraMillisecondIncrement = 0;\r\n\tvar _cachedMillisecondsBetween1582and1970 = null;\r\n\tvar _cachedHundredNanosecondIntervalsPerMillisecond = null;\r\n\t\r\n\t// --------------------------------------------------\r\n\t// Private constants:\r\n\tvar HEX_RADIX = 16;\r\n\r\n\tfunction _carry(/* array */ arrayA){\r\n\t\t// summary:\r\n\t\t//\t\tGiven an array which holds a 64-bit number broken into 4 16-bit\r\n\t\t//\t\telements, this method carries any excess bits (greater than 16-bits)\r\n\t\t//\t\tfrom each array element into the next.\r\n\t\t// arrayA: An array with 4 elements, each of which is a 16-bit number.\r\n\t\tarrayA[2] += arrayA[3] >>> 16;\r\n\t\tarrayA[3] &= 0xFFFF;\r\n\t\tarrayA[1] += arrayA[2] >>> 16;\r\n\t\tarrayA[2] &= 0xFFFF;\r\n\t\tarrayA[0] += arrayA[1] >>> 16;\r\n\t\tarrayA[1] &= 0xFFFF;\r\n\t\tdojox.uuid.assert((arrayA[0] >>> 16) === 0);\r\n\t}\r\n\r\n\tfunction _get64bitArrayFromFloat(/* float */ x){\r\n\t\t// summary:\r\n\t\t//\t\tGiven a floating point number, this method returns an array which\r\n\t\t//\t\tholds a 64-bit number broken into 4 16-bit elements.\r\n\t\tvar result = new Array(0, 0, 0, 0);\r\n\t\tresult[3] = x % 0x10000;\r\n\t\tx -= result[3];\r\n\t\tx /= 0x10000;\r\n\t\tresult[2] = x % 0x10000;\r\n\t\tx -= result[2];\r\n\t\tx /= 0x10000;\r\n\t\tresult[1] = x % 0x10000;\r\n\t\tx -= result[1];\r\n\t\tx /= 0x10000;\r\n\t\tresult[0] = x;\r\n\t\treturn result; // Array with 4 elements, each of which is a 16-bit number.\r\n\t}\r\n\r\n\tfunction _addTwo64bitArrays(/* array */ arrayA, /* array */ arrayB){\r\n\t\t// summary:\r\n\t\t//\t\tTakes two arrays, each of which holds a 64-bit number broken into 4\r\n\t\t//\t\t16-bit elements, and returns a new array that holds a 64-bit number\r\n\t\t//\t\tthat is the sum of the two original numbers.\r\n\t\t// arrayA: An array with 4 elements, each of which is a 16-bit number.\r\n\t\t// arrayB: An array with 4 elements, each of which is a 16-bit number.\r\n\t\tdojox.uuid.assert(lang.isArray(arrayA));\r\n\t\tdojox.uuid.assert(lang.isArray(arrayB));\r\n\t\tdojox.uuid.assert(arrayA.length == 4);\r\n\t\tdojox.uuid.assert(arrayB.length == 4);\r\n\t\r\n\t\tvar result = new Array(0, 0, 0, 0);\r\n\t\tresult[3] = arrayA[3] + arrayB[3];\r\n\t\tresult[2] = arrayA[2] + arrayB[2];\r\n\t\tresult[1] = arrayA[1] + arrayB[1];\r\n\t\tresult[0] = arrayA[0] + arrayB[0];\r\n\t\t_carry(result);\r\n\t\treturn result; // Array with 4 elements, each of which is a 16-bit number.\r\n\t}\r\n\r\n\tfunction _multiplyTwo64bitArrays(/* array */ arrayA, /* array */ arrayB){\r\n\t\t// summary:\r\n\t\t//\t\tTakes two arrays, each of which holds a 64-bit number broken into 4\r\n\t\t//\t\t16-bit elements, and returns a new array that holds a 64-bit number\r\n\t\t//\t\tthat is the product of the two original numbers.\r\n\t\t// arrayA: An array with 4 elements, each of which is a 16-bit number.\r\n\t\t// arrayB: An array with 4 elements, each of which is a 16-bit number.\r\n\t\tdojox.uuid.assert(lang.isArray(arrayA));\r\n\t\tdojox.uuid.assert(lang.isArray(arrayB));\r\n\t\tdojox.uuid.assert(arrayA.length == 4);\r\n\t\tdojox.uuid.assert(arrayB.length == 4);\r\n\t\r\n\t\tvar overflow = false;\r\n\t\tif(arrayA[0] * arrayB[0] !== 0){ overflow = true; }\r\n\t\tif(arrayA[0] * arrayB[1] !== 0){ overflow = true; }\r\n\t\tif(arrayA[0] * arrayB[2] !== 0){ overflow = true; }\r\n\t\tif(arrayA[1] * arrayB[0] !== 0){ overflow = true; }\r\n\t\tif(arrayA[1] * arrayB[1] !== 0){ overflow = true; }\r\n\t\tif(arrayA[2] * arrayB[0] !== 0){ overflow = true; }\r\n\t\tdojox.uuid.assert(!overflow);\r\n\t\r\n\t\tvar result = new Array(0, 0, 0, 0);\r\n\t\tresult[0] += arrayA[0] * arrayB[3];\r\n\t\t_carry(result);\r\n\t\tresult[0] += arrayA[1] * arrayB[2];\r\n\t\t_carry(result);\r\n\t\tresult[0] += arrayA[2] * arrayB[1];\r\n\t\t_carry(result);\r\n\t\tresult[0] += arrayA[3] * arrayB[0];\r\n\t\t_carry(result);\r\n\t\tresult[1] += arrayA[1] * arrayB[3];\r\n\t\t_carry(result);\r\n\t\tresult[1] += arrayA[2] * arrayB[2];\r\n\t\t_carry(result);\r\n\t\tresult[1] += arrayA[3] * arrayB[1];\r\n\t\t_carry(result);\r\n\t\tresult[2] += arrayA[2] * arrayB[3];\r\n\t\t_carry(result);\r\n\t\tresult[2] += arrayA[3] * arrayB[2];\r\n\t\t_carry(result);\r\n\t\tresult[3] += arrayA[3] * arrayB[3];\r\n\t\t_carry(result);\r\n\t\treturn result; // Array with 4 elements, each of which is a 16-bit number.\r\n\t}\r\n\r\n\tfunction _padWithLeadingZeros(/* string */ string, /* int */ desiredLength){\r\n\t\t// summary:\r\n\t\t//\t\tPads a string with leading zeros and returns the result.\r\n\t\t// string: A string to add padding to.\r\n\t\t// desiredLength: The number of characters the return string should have.\r\n\r\n\t\t// examples:\r\n\t\t//\t\tresult = _padWithLeadingZeros(\"abc\", 6);\r\n\t\t//\t\tdojox.uuid.assert(result == \"000abc\");\r\n\t\twhile(string.length < desiredLength){\r\n\t\t\tstring = \"0\" + string;\r\n\t\t}\r\n\t\treturn string; // string\r\n\t}\r\n\r\n\tfunction _generateRandomEightCharacterHexString() {\r\n\t\t// summary:\r\n\t\t//\t\tReturns a randomly generated 8-character string of hex digits.\r\n\r\n\t\t// FIXME: This probably isn't a very high quality random number.\r\n\t\r\n\t\t// Make random32bitNumber be a randomly generated floating point number\r\n\t\t// between 0 and (4,294,967,296 - 1), inclusive.\r\n\t\tvar random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );\r\n\t\r\n\t\tvar eightCharacterString = random32bitNumber.toString(HEX_RADIX);\r\n\t\twhile(eightCharacterString.length < 8){\r\n\t\t\teightCharacterString = \"0\" + eightCharacterString;\r\n\t\t}\r\n\t\treturn eightCharacterString; // String (an 8-character hex string)\r\n\t}\r\n\t\r\n\tthis.generateUuidString = function(/*String?*/ node){\r\n\t\t// summary:\r\n\t\t//\t\tGenerates a time-based UUID, meaning a version 1 UUID.\r\n\t\t// description:\r\n\t\t//\t\tJavaScript code running in a browser doesn't have access to the\r\n\t\t//\t\tIEEE 802.3 address of the computer, so if a node value isn't\r\n\t\t//\t\tsupplied, we generate a random pseudonode value instead.\r\n\t\t// node: An optional 12-character string to use as the node in the new UUID.\r\n\t\tif(node){\r\n\t\t\tdojox.uuid.assert(dojox.uuid.generateTimeBasedUuid.isValidNode(node));\r\n\t\t}else{\r\n\t\t\tif(dojox.uuid.generateTimeBasedUuid._uniformNode){\r\n\t\t\t\tnode = dojox.uuid.generateTimeBasedUuid._uniformNode;\r\n\t\t\t}else{\r\n\t\t\t\tif(!_uuidPseudoNodeString){\r\n\t\t\t\t\tvar pseudoNodeIndicatorBit = 0x8000;\r\n\t\t\t\t\tvar random15bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 15) );\r\n\t\t\t\t\tvar leftmost4HexCharacters = (pseudoNodeIndicatorBit | random15bitNumber).toString(HEX_RADIX);\r\n\t\t\t\t\t_uuidPseudoNodeString = leftmost4HexCharacters + _generateRandomEightCharacterHexString();\r\n\t\t\t\t}\r\n\t\t\t\tnode = _uuidPseudoNodeString;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!_uuidClockSeqString){\r\n\t\t\tvar variantCodeForDCEUuids = 0x8000; // 10--------------, i.e. uses only first two of 16 bits.\r\n\t\t\tvar random14bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 14) );\r\n\t\t\t_uuidClockSeqString = (variantCodeForDCEUuids | random14bitNumber).toString(HEX_RADIX);\r\n\t\t}\r\n\t\r\n\t\t// Maybe we should think about trying to make the code more readable to\r\n\t\t// newcomers by creating a class called \"WholeNumber\" that encapsulates\r\n\t\t// the methods and data structures for working with these arrays that\r\n\t\t// hold 4 16-bit numbers?  And then these variables below have names\r\n\t\t// like \"wholeSecondsPerHour\" rather than \"arraySecondsPerHour\"?\r\n\t\tvar now = new Date();\r\n\t\tvar millisecondsSince1970 = now.valueOf(); // milliseconds since midnight 01 January, 1970 UTC.\r\n\t\tvar nowArray = _get64bitArrayFromFloat(millisecondsSince1970);\r\n\t\tif(!_cachedMillisecondsBetween1582and1970){\r\n\t\t\tvar arraySecondsPerHour = _get64bitArrayFromFloat(60 * 60);\r\n\t\t\tvar arrayHoursBetween1582and1970 = _get64bitArrayFromFloat(dojox.uuid.generateTimeBasedUuid._generator.GREGORIAN_CHANGE_OFFSET_IN_HOURS);\r\n\t\t\tvar arraySecondsBetween1582and1970 = _multiplyTwo64bitArrays(arrayHoursBetween1582and1970, arraySecondsPerHour);\r\n\t\t\tvar arrayMillisecondsPerSecond = _get64bitArrayFromFloat(1000);\r\n\t\t\t_cachedMillisecondsBetween1582and1970 = _multiplyTwo64bitArrays(arraySecondsBetween1582and1970, arrayMillisecondsPerSecond);\r\n\t\t\t_cachedHundredNanosecondIntervalsPerMillisecond = _get64bitArrayFromFloat(10000);\r\n\t\t}\r\n\t\tvar arrayMillisecondsSince1970 = nowArray;\r\n\t\tvar arrayMillisecondsSince1582 = _addTwo64bitArrays(_cachedMillisecondsBetween1582and1970, arrayMillisecondsSince1970);\r\n\t\tvar arrayHundredNanosecondIntervalsSince1582 = _multiplyTwo64bitArrays(arrayMillisecondsSince1582, _cachedHundredNanosecondIntervalsPerMillisecond);\r\n\t\r\n\t\tif(now.valueOf() == _dateValueOfPreviousUuid){\r\n\t\t\tarrayHundredNanosecondIntervalsSince1582[3] += _nextIntraMillisecondIncrement;\r\n\t\t\t_carry(arrayHundredNanosecondIntervalsSince1582);\r\n\t\t\t_nextIntraMillisecondIncrement += 1;\r\n\t\t\tif (_nextIntraMillisecondIncrement == 10000) {\r\n\t\t\t\t// If we've gotten to here, it means we've already generated 10,000\r\n\t\t\t\t// UUIDs in this single millisecond, which is the most that the UUID\r\n\t\t\t\t// timestamp field allows for.  So now we'll just sit here and wait\r\n\t\t\t\t// for a fraction of a millisecond, so as to ensure that the next\r\n\t\t\t\t// time this method is called there will be a different millisecond\r\n\t\t\t\t// value in the timestamp field.\r\n\t\t\t\twhile (now.valueOf() == _dateValueOfPreviousUuid) {\r\n\t\t\t\t\tnow = new Date();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t_dateValueOfPreviousUuid = now.valueOf();\r\n\t\t\t_nextIntraMillisecondIncrement = 1;\r\n\t\t}\r\n\t\r\n\t\tvar hexTimeLowLeftHalf  = arrayHundredNanosecondIntervalsSince1582[2].toString(HEX_RADIX);\r\n\t\tvar hexTimeLowRightHalf = arrayHundredNanosecondIntervalsSince1582[3].toString(HEX_RADIX);\r\n\t\tvar hexTimeLow = _padWithLeadingZeros(hexTimeLowLeftHalf, 4) + _padWithLeadingZeros(hexTimeLowRightHalf, 4);\r\n\t\tvar hexTimeMid = arrayHundredNanosecondIntervalsSince1582[1].toString(HEX_RADIX);\r\n\t\thexTimeMid = _padWithLeadingZeros(hexTimeMid, 4);\r\n\t\tvar hexTimeHigh = arrayHundredNanosecondIntervalsSince1582[0].toString(HEX_RADIX);\r\n\t\thexTimeHigh = _padWithLeadingZeros(hexTimeHigh, 3);\r\n\t\tvar hyphen = \"-\";\r\n\t\tvar versionCodeForTimeBasedUuids = \"1\"; // binary2hex(\"0001\")\r\n\t\tvar resultUuid = hexTimeLow + hyphen + hexTimeMid + hyphen +\r\n\t\t\t\t\tversionCodeForTimeBasedUuids + hexTimeHigh + hyphen +\r\n\t\t\t\t\t_uuidClockSeqString + hyphen + node;\r\n\t\tresultUuid = resultUuid.toLowerCase();\r\n\t\treturn resultUuid; // String (a 36 character string, which will look something like \"b4308fb0-86cd-11da-a72b-0800200c9a66\")\r\n\t}\r\n\r\n}();\r\n\r\nreturn dojox.uuid.generateTimeBasedUuid;\r\n\r\n});\r\n"]}