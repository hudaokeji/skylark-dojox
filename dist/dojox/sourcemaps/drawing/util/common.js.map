{"version":3,"sources":["drawing/util/common.js"],"names":["define","dojo","round","uidMap","start","radToDeg","n","Math","PI","degToRad","angle","obj","snap","radians","this","seg","new_radian","oppAngle","ang","o","atan2","y","x","length","sqrt","pow","lineSub","x1","y1","x2","y2","amt","len","distance","argsToObj","apply","arguments","pc","a","abs","slope","p1","p2","pointOnCircle","cx","cy","radius","cos","sin","constrainAngle","min","max","new_angle","snapAngle","ca","idSetStart","num","uid","str","undefined","abbr","type","substring","lastIndexOf","charAt","toLowerCase","mixin","o1","o2","objects","register","id","byId","attr","elem","prop","value","squelchErrors","shape","util","target","parentNode","rawNode","args","Array","prototype","slice","call","e"],"mappings":"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","file":"../../../drawing/util/common.js","sourcesContent":["define([\"dojo\", \"dojox/math/round\"], function(dojo, round){\r\n\r\n\tvar uidMap = {};\r\n\tvar start = 0;\r\n\t//dojox.drawing.util.common\t= \r\n\treturn {\r\n\t\t// summary:\r\n\t\t//\t\tA collection of common methods used for DojoX Drawing.\r\n\t\t//\t\tThis singleton is accessible in most Drawing classes\r\n\t\t//\t\tas this.util\r\n\r\n\t\t// NOTE:\r\n\t\t//\t\tA lot of functions use a EventObject\r\n\t\t//\t\tas an argument. An attempt was made to accept\r\n\t\t//\t\teither that object or a list of numbers. That wasn't\r\n\t\t//\t\tfinished (it didn't work well in all cases) but is\r\n\t\t//\t\tlikely to happen in the future.\r\n\t\t//\t\tIn cases where you are not sending a Mouse object,\r\n\t\t//\t\tform your argument like so:\r\n\t\t//\t\tvar obj = {\r\n\t\t//\t\t\tstart:{\r\n\t\t//\t\t\t\t\tx:Number,  \t// start x\r\n\t\t//\t\t\t\t\ty:Number\t// start y\r\n\t\t//\t\t\t\t},\r\n\t\t//\t\t\t\tx: Number,\t\t// end x\r\n\t\t//\t\t\t\ty:Number\t\t// end y\r\n\t\t//\t\t\t}\r\n\r\n\r\n\t\tradToDeg: function(/*Number*/n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConvert the passed number to degrees.\r\n\t\t\treturn (n*180)/Math.PI;\t//\tNumber\r\n\t\t},\r\n\t\t\r\n\t\tdegToRad: function(/*Number*/n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConvert the passed number to radians.\r\n\t\t\treturn (n*Math.PI)/180;\t// Number\r\n\t\t},\r\n\t\t\r\n\t\tangle: function(/*EventObject*/obj, /*Float?*/snap){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn angle based on mouse object\r\n\t\t\t// obj:\r\n\t\t\t//\t\tManager.Mouse event.\r\n\t\t\t// snap:\r\n\t\t\t//\t\tReturns nearest angle within snap limits\r\n\r\n\t\t\t//obj = this.argsToObj.apply(this, arguments);\r\n\t\t\tif(snap){\r\n\t\t\t\tsnap = snap/180;\r\n\t\t\t\tvar radians = this.radians(obj),\r\n\t\t\t\t\tseg = Math.PI * snap,\r\n\t\t\t\t\trnd = round(radians/seg),\r\n\t\t\t\t\tnew_radian = rnd*seg;\r\n\t\t\t\treturn round(this.radToDeg(new_radian)); // Whole Number\r\n\t\t\t\r\n\t\t\t}else{\r\n\t\t\t\treturn this.radToDeg(this.radians(obj)); // Float\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\toppAngle: function(/*Angle*/ang){\r\n\t\t\t(ang+=180) > 360 ? ang = ang - 360 : ang;\r\n\t\t\treturn ang;\r\n\t\t},\r\n\t\t\r\n\t\tradians: function(/*EventObject*/o){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn the radians derived from the coordinates\r\n\t\t\t//\t\tin the Mouse object.\r\n\r\n\t\t\t//var o = this.argsToObj.apply(this, arguments);\r\n\t\t\treturn Math.atan2(o.start.y-o.y,o.x-o.start.x);\r\n\t\t},\r\n\t\t\r\n\t\tlength: function(/*EventObject*/o){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn the length derived from the coordinates\r\n\t\t\t//\t\tin the Mouse object.\r\n\r\n\t\t\treturn Math.sqrt(Math.pow(o.start.x-o.x, 2)+Math.pow(o.start.y-o.y, 2));\r\n\t\t},\r\n\t\t\r\n\t\tlineSub: function(/*Number*/x1, /*Number*/y1, /*Number*/x2, /*Number*/y2, /*Number*/amt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSubtract an amount from a line\r\n\t\t\t// description:\r\n\t\t\t//\t\tx1,y1,x2,y2 represents the Line. 'amt' represents the amount\r\n\t\t\t//\t\tto subtract from it.\r\n\r\n\t\t\tvar len = this.distance(this.argsToObj.apply(this, arguments));\r\n\t\t\tlen = len < amt ? amt : len;\r\n\t\t\tvar pc = (len-amt)/len;\r\n\t\t\tvar x = x1 - (x1-x2) * pc;\r\n\t\t\tvar y = y1 - (y1-y2) * pc;\r\n\t\t\treturn {x:x, y:y}; // Object\r\n\t\t},\r\n\t\t\r\n\t\targsToObj: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAttempts to determine in a Mouse Object\r\n\t\t\t//\t\twas passed or indiviual numbers. Returns\r\n\t\t\t//\t\tan object.\r\n\r\n\t\t\tvar a = arguments;\r\n\t\t\tif(a.length < 4){ return a[0]; }\r\n\t\t\treturn {\r\n\t\t\t\tstart:{\r\n\t\t\t\t\tx:a[0],\r\n\t\t\t\t\ty:a[1]\r\n\t\t\t\t},\r\n\t\t\t\tx:a[2],\r\n\t\t\t\ty:a[3]//,\r\n\t\t\t\t//snap:a[4]\r\n\t\t\t}; // Object\r\n\t\t},\r\n\t\t\r\n\t\tdistance: function(/*EventObject or x1,y1,x2,y2*/){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn the length derived from the coordinates\r\n\t\t\t//\t\tin the Mouse object. Different from util.length\r\n\t\t\t//\t\tin that this always returns an absolute value.\r\n\r\n\t\t\tvar o = this.argsToObj.apply(this, arguments);\r\n\t\t\treturn Math.abs(Math.sqrt(Math.pow(o.start.x-o.x, 2)+Math.pow(o.start.y-o.y, 2))); // Number\r\n\t\t},\r\n\t\t\r\n\t\tslope:function(/*Object*/p1, /*Object*/p2){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGiven two poits of a line, returns the slope.\r\n\t\t\tif(!(p1.x-p2.x)){ return 0; }\r\n\t\t\treturn ((p1.y-p2.y)/(p1.x-p2.x)); // Number\r\n\t\t},\r\n\t\t\r\n\t\tpointOnCircle: function(/*Number*/cx, /*Number*/cy, /*Number*/radius, /*Number*/angle){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tA *very* helpful method. If you know the center\r\n\t\t\t//\t\t(or starting) point, length and angle, find the\r\n\t\t\t//\t\tx,y point at the end of that line.\r\n\r\n\t\t\tvar radians =  angle * Math.PI / 180.0;\r\n\t\t\tvar x = radius * Math.cos(radians);\r\n\t\t\tvar y = radius * Math.sin(radians);\r\n\t\t\treturn {\r\n\t\t\t\tx:cx+x,\r\n\t\t\t\ty:cy-y\r\n\t\t\t}; // Object\r\n\t\t},\r\n\t\t\r\n\t\tconstrainAngle: function(/*EventObject*/obj, /*Number*/min, /*Number*/max){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEnsures the angle in the Mouse Object is within the\r\n\t\t\t//\t\tmin and max limits. If not one of those limits is used.\r\n\t\t\t//\t\tReturns an x,y point for the angle used.\r\n\r\n\t\t\tvar angle = this.angle(obj);\r\n\t\t\tif(angle >= min && angle <= max){\r\n\t\t\t\treturn obj;\t // Object\r\n\t\t\t}\r\n\t\t\tvar radius = this.length(obj);\r\n\t\t\tvar new_angle = angle > max ? max : min - angle < 100 ? min : max;\r\n\t\t\treturn this.pointOnCircle(obj.start.x,obj.start.y,radius, new_angle); // Object\r\n\t\t},\r\n\t\t\r\n\t\tsnapAngle: function(/*EventObject*/ obj, /*Float*/ ca){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSnaps a line to the nearest angle\r\n\t\t\t// obj: Mouse object (see dojox.drawing.Mouse)\r\n\t\t\t// ca: Fractional amount to snap to\r\n\t\t\t//\t\tA decimal number fraction of a half circle.\r\n\t\t\t//\r\n\t\t\t//\t\t- .5 would snap to 90 degrees\r\n\t\t\t//\t\t- .25  would snap to 45 degrees\r\n\t\t\t//\t\t- .125 would snap to 22.5 degrees, etc.\r\n\r\n\t\t\tvar radians = this.radians(obj),\r\n\t\t\t\tradius = this.length(obj),\r\n\t\t\t\tseg = Math.PI * ca,\r\n\t\t\t\trnd = Math.round(radians/seg),\r\n\t\t\t\tnew_radian = rnd*seg,\r\n\t\t\t\tnew_angle = this.radToDeg(new_radian),\r\n\t\t\t\tpt = this.pointOnCircle(obj.start.x,obj.start.y,radius,new_angle);\r\n\t\t\treturn pt;  // Object\r\n\t\t},\r\n\t\t\r\n\t\t// helpers\r\n\t\tidSetStart: function(num){\r\n\t\t\tstart=num;\r\n\t\t},\r\n\t\t\r\n\t\tuid: function(/*String?*/ str){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreates a unique ID.\r\n\t\t\t// str: String\r\n\t\t\t//\t\tIf provided, kept in a map, incremented\r\n\t\t\t//\t\tand used in the id. Otherwise 'shape' is used.\r\n\r\n\t\t\tstr = str || \"shape\";\r\n\t\t\tuidMap[str] = uidMap[str]===undefined ? start : uidMap[str] + 1;\r\n\t\t\treturn str + uidMap[str]; // String\r\n\t\t},\r\n\t\t\r\n\t\tabbr: function(type){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConverts a namespace (typically a tool or a stencil) into\r\n\t\t\t//\t\tan abbreviation\r\n\t\t\treturn type.substring(type.lastIndexOf(\".\")+1).charAt(0).toLowerCase()\r\n\t\t\t\t+ type.substring(type.lastIndexOf(\".\")+2);\r\n\t\t},\r\n\t\tmixin: function(o1, o2){\r\n\t\t\t// TODO: make faster\r\n\t\t\t//return dojo.mixin(dojo.clone(o1), dojo.clone(o2));\r\n\t\t},\r\n\t\t\r\n\t\tobjects:{}, //private?\r\n\t\tregister: function(/*Object*/obj){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSince util is the only Singleton in Drawing (besides\r\n\t\t\t//\t\tkeys) it is used to help connect the Drawing object\r\n\t\t\t//\t\tthe Toolbar. Since multiple drawings can be on one\r\n\t\t\t//\t\tpage, this function serves a little more use than\r\n\t\t\t//\t\ton first apearance.\r\n\t\t\tthis.objects[obj.id] = obj;\r\n\t\t},\r\n\t\tbyId: function(/*String*/id){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet an object that was registered with util.register\r\n\r\n\t\t\treturn this.objects[id];\r\n\t\t},\r\n\t\tattr: function(/* Object */ elem, /* property */ prop, /* ? value */ value, squelchErrors){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tHelper function to attach attributes to SVG and VML raw nodes.\r\n\r\n\t\t\t\r\n\t\t\tif(!elem){ return false; }\r\n\t\t\ttry{\r\n\t\t\t\t\r\n\t\t\t\t// util is a crappy check, but we need to tell the diff\r\n\t\t\t\t// between a Drawing shape and a GFX shape\r\n\t\t\t\tif(elem.shape && elem.util){\r\n\t\t\t\t\telem = elem.shape;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(!value && prop==\"id\" && elem.target){\r\n\t\t\t\r\n\t\t\t\t\tvar n = elem.target;\r\n\t\t\t\t\twhile(n && !dojo.attr(n, \"id\")){\r\n\t\t\t\t\t\tn = n.parentNode;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn n && dojo.attr(n, \"id\");\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(elem.rawNode || elem.target){\r\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\r\n\t\t\t\t\targs[0] = elem.rawNode || elem.target;\r\n\t\t\t\t\treturn dojo.attr.apply(dojo, args);\r\n\t\t\t\t}\r\n\t\t\t\treturn dojo.attr(elem, \"id\");\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}catch(e){\r\n\t\t\t\tif(!squelchErrors){\r\n\t\t\t\t\t// For debugging only. These errors actually cause errors in IE's console\r\n\t\t\t\t\t//console.error(\"BAD ATTR: prop:\", prop, \"el:\", elem)\r\n\t\t\t\t\t//console.error(e)\r\n\t\t\t\t\t//console.trace();\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n});\r\n"]}