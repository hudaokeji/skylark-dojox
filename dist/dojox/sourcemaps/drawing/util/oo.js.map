{"version":3,"sources":["drawing/util/oo.js"],"names":["define","declare","f","o","ext","a","arguments","n","length","console","error","Array","prototype","slice","call","pop","unshift","this","extend","apply","sub","i","constructor"],"mappings":";;;;;;;AAAAA,UAAW,WAIX,OAeCC,QAAS,WAsCR,IAAIC,EAAGC,EAAGC,EAAI,EAAGC,EAAIC,UAWrB,IAAI,IAAIC,KATLF,EAAEG,OAAO,GAAIC,QAAQC,MAAM,iDACjB,GAAVL,EAAEG,QACJN,EAAIG,EAAE,GAAIF,EAAIE,EAAE,KAGhBF,GADAE,EAAIM,MAAMC,UAAUC,MAAMC,KAAKR,YACzBS,MACNb,EAAIG,EAAEU,MACNX,EAAM,GAEMD,EACZD,EAAEU,UAAUL,GAAKJ,EAAEI,GAMpB,OAJGH,IACFC,EAAEW,QAAQd,GACVA,EAAIe,KAAKC,OAAOC,MAAMF,KAAMZ,IAEtBH,GAERgB,OAAQ,WAqBP,IAAIb,EAAIC,UAAWc,EAAMf,EAAE,GACxBA,EAAEG,OAAO,GAAIC,QAAQC,MAAM,gDAS9B,IARA,IAAIR,EAAI,WACP,IAAI,IAAImB,EAAE,EAAEA,EAAEhB,EAAEG,OAAOa,IACtBhB,EAAEgB,GAAGT,UAAUU,YAAYH,MAAMF,KAAMX,WAGxCc,EAAIR,UAAUU,YAAYH,MAAMF,KAAMX,YAG/Be,EAAE,EAAEA,EAAEhB,EAAEG,OAAOa,IACtB,IAAI,IAAId,KAAKF,EAAEgB,GAAGT,UACjBV,EAAEU,UAAUL,GAAKF,EAAEgB,GAAGT,UAAUL,GAIlC,IAAIA,KAAKa,EAAIR,UACZV,EAAEU,UAAUL,GAAKa,EAAIR,UAAUL,GAEhC,OAAOL","file":"../../../drawing/util/oo.js","sourcesContent":["define([], function(){\r\n// TODO:\r\n// allow a declare without a mixin\r\n\r\nreturn {\r\n\t// summary:\r\n\t//\t\tInheritance utilities used in DojoX Drawing\r\n\t// description:\r\n\t//\t\tInheritance utilities used in DojoX Drawing.\r\n\t//\t\tThere were designed in a effort to make Drawing as\r\n\t//\t\tfast as possible - especially in a case where thousands\r\n\t//\t\tof objects are being loaded. Drawing declare performs\r\n\t//\t\tabout 3 times faster than declare and 2 times\r\n\t//\t\tfaster than Dojox declare. This is not to say Drawing\r\n\t//\t\tdeclare is without limitations. It doesn't have the same\r\n\t//\t\tsyntactic sugar and extensibility of the other two. You\r\n\t//\t\tcan't inherit methods. It won't work with Dijit. But it\r\n\t//\t\tis simple and effective.\r\n\r\n\tdeclare: function(){\r\n\t\t// summary:\r\n\t\t//\t\tCreates a constructor Function from a\r\n\t\t//\t\tFunction, and collection of methods, and\r\n\t\t//\t\tmore Functions that are extended.\r\n\t\t// description:\r\n\t\t//\t\tSimilar in look and feel to declare as\r\n\t\t//\t\tfar as order and number of arguments, although\r\n\t\t//\t\tconstructed a little closer to prototypical\r\n\t\t//\t\tinheritance. All arguments passed into the\r\n\t\t//\t\tconstructor are passed into all sub constructors.\r\n\t\t//\r\n\t\t//\t\tArguments are: Function, [Object|Function....]\r\n\t\t//\t\tThe first argument is always the base\r\n\t\t//\t\tconstructor. The last argument is always\r\n\t\t//\t\tan object of methods (or empty object) to\r\n\t\t//\t\tbe mixed in (in the future would like to\r\n\t\t//\t\tmake that object optional). Remaining\r\n\t\t//\t\targuments are other constructors mixed in\r\n\t\t//\t\tusing extend() (See below).\r\n\t\t// example:\r\n\t\t//\t\t|\tMyFunction = dojox.drawing.util.oo.declare(\r\n\t\t//\t\t|\t\tMyOtherFunction,\r\n\t\t//\t\t|\t\tYetAnotherFunction,\r\n\t\t//\t\t|\t\tfunction(options){\r\n\t\t//\t\t|\t\t\t// This is my constructor. It will fire last.\r\n\t\t//\t\t|\t\t\t// The other constructors will fire before this.\r\n\t\t//\t\t|\t\t},\r\n\t\t//\t\t|\t\t{\r\n\t\t//\t\t|\t\t\tcustomType:\"equation\", // mixed in property\r\n\t\t//\t\t|\t\t\tdoThing: function(){   // mixed in method\r\n\t\t//\t\t|\r\n\t\t//\t\t|\t\t\t}\r\n\t\t//\t\t|\t\t}\r\n\t\t//\t\t|\t);\r\n\t\t//\t\t|\r\n\t\t//\t\t|\tvar f = new MyFunction();\r\n\r\n\t\tvar f, o, ext=0, a = arguments;\r\n\t\t\t\t\r\n\t\tif(a.length<2){ console.error(\"drawing.util.oo.declare; not enough arguments\")}\r\n\t\tif(a.length==2){\r\n\t\t\tf = a[0]; o = a[1];\r\n\t\t}else{\r\n\t\t\ta = Array.prototype.slice.call(arguments);\r\n\t\t\to = a.pop();\r\n\t\t\tf = a.pop();\r\n\t\t\text = 1;\r\n\t\t}\r\n\t\tfor(var n in o){\r\n\t\t\tf.prototype[n] = o[n];\r\n\t\t}\r\n\t\tif(ext){\r\n\t\t\ta.unshift(f);\r\n\t\t\tf = this.extend.apply(this, a);\r\n\t\t}\r\n\t\treturn f; // Function\r\n\t},\r\n\textend: function(){\r\n\t\t// summary:\r\n\t\t//\t\tExtends constructors to inherit from other\r\n\t\t//\t\tconstructors .\r\n\t\t// description:\r\n\t\t//\t\tTypically not used by itself - it's used as\r\n\t\t//\t\tpart of declare(). Could be used by itself\r\n\t\t//\t\thowever, to mix together two or more\r\n\t\t//\t\tconstructors.\r\n\t\t//\r\n\t\t//\t\tAny number of arguments, all must be\r\n\t\t//\t\tfunction constructors. The first is\r\n\t\t//\t\tconsidered the base object and its\r\n\t\t//\t\tconstructor will fire first.\r\n\t\t// example:\r\n\t\t//\t\t|\tvar A = function(){};\r\n\t\t//\t\t|\tvar B = function(){};\r\n\t\t//\t\t|\tvar C = function(){};\r\n\t\t//\t\t|\tvar D = dojox.drawing.util.oo.extend(A, B, C);\r\n\t\t//\t\t|\tvar e = new D();\r\n\r\n\t\tvar a = arguments, sub = a[0];\r\n\t\tif(a.length<2){ console.error(\"drawing.util.oo.extend; not enough arguments\")}\r\n\t\tvar f = function (){\r\n\t\t\tfor(var i=1;i<a.length;i++){\r\n\t\t\t\ta[i].prototype.constructor.apply(this, arguments);\r\n\t\t\t}\r\n\t\t\t// sub should fire last\r\n\t\t\tsub.prototype.constructor.apply(this, arguments);\r\n\t\t\t\r\n\t\t};\r\n\t\tfor(var i=1;i<a.length;i++){\r\n\t\t\tfor(var n in a[i].prototype){\r\n\t\t\t\tf.prototype[n] = a[i].prototype[n];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t\r\n\t\tfor(n in sub.prototype){\r\n\t\t\tf.prototype[n] = sub.prototype[n];\r\n\t\t}\r\n\t\treturn f; // Function\r\n\t}\r\n};\r\n});\r\n"]}