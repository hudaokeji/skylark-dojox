{"version":3,"sources":["html/format.js"],"names":["define","lang","Entities","ArrayUtil","Window","has","dhf","getObject","prettyPrint","html","indentBy","maxLineLength","map","xhtml","i","content","indentDepth","closeTags","iTxt","textContent","inlineStyle","rgxp_fixIEAttrs","rgxp_styleMatch","rgxp_attrsMatch","contentDiv","doc","createElement","innerHTML","encode","decode","div","ownerDocument","indent","push","newline","processTextNode","n","nodeValue","formatText","txt","_iTxt","_lines","split","length","trim","join","lines","indentSize","sizeIndent","maxLine","charAt","line","substring","formatScript","t","c","scriptLines","replace","processScriptText","newLines","hasNewlines","indexOf","iLevel","ch","openTag","node","name","nodeName","toLowerCase","nText","clone","cloneNode","appendChild","outerHTML","tag","attrs","match","sL","style","closure","trimmedStyles","forEach","s","sort","ts","attr","inline","isInlineFormat","closeTag","pop","ct","processCommentNode","commentText","processNode","children","childNodes","nodeType","tg","tagName","parentNode","preTxt"],"mappings":"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","file":"../../html/format.js","sourcesContent":["define([\"dojo/_base/kernel\", \"./entities\", \"dojo/_base/array\", \"dojo/_base/window\", \"dojo/_base/sniff\"], \r\n\tfunction(lang, Entities, ArrayUtil, Window, has) {\r\n\tvar dhf = lang.getObject(\"dojox.html.format\",true);\r\n\t\r\n\tdhf.prettyPrint = function(html/*String*/, indentBy /*Integer?*/, maxLineLength /*Integer?*/, map/*Array?*/, /*boolean*/ xhtml){\r\n\t\t// summary:\r\n\t\t//\t\tFunction for providing a 'pretty print' version of HTML content from\r\n\t\t//\t\tthe provided string.  It's nor perfect by any means, but it does\r\n\t\t//\t\ta 'reasonable job'.\r\n\t\t// html: String\r\n\t\t//\t\tThe string of HTML to try and generate a 'pretty' formatting.\r\n\t\t// indentBy:  Integer\r\n\t\t//\t\tOptional input for the number of spaces to use when indenting.\r\n\t\t//\t\tIf not defined, zero, negative, or greater than 10, will just use tab\r\n\t\t//\t\tas the indent.\r\n\t\t// maxLineLength: Integer\r\n\t\t//\t\tOptional input for the number of characters a text line should use in\r\n\t\t//\t\tthe document, including the indent if possible.\r\n\t\t// map:\tArray\r\n\t\t//\t\tOptional array of entity mapping characters to use when processing the\r\n\t\t//\t\tHTML Text content.  By default it uses the default set used by the\r\n\t\t//\t\tdojox.html.entities.encode function.\r\n\t\t// xhtml: boolean\r\n\t\t//\t\tOptional parameter that declares that the returned HTML should try to be 'xhtml' compatible.\r\n\t\t//\t\tThis means normally unclosed tags are terminated with /> instead of >.  Example: `<hr>` -> `<hr />`\r\n\t\tvar content = [];\r\n\t\tvar indentDepth = 0;\r\n\t\tvar closeTags = [];\r\n\t\tvar iTxt = \"\\t\";\r\n\t\tvar textContent = \"\";\r\n\t\tvar inlineStyle = [];\r\n\t\tvar i;\r\n\t\r\n\t\t// Compile regexps once for this call.\r\n\t\tvar rgxp_fixIEAttrs = /[=]([^\"']+?)(\\s|>)/g;\r\n\t\tvar rgxp_styleMatch = /style=(\"[^\"]*\"|'[^']*'|\\S*)/gi;\r\n\t\tvar rgxp_attrsMatch = /[\\w-]+=(\"[^\"]*\"|'[^']*'|\\S*)/gi;\r\n\t\r\n\t\t// Check to see if we want to use spaces for indent instead\r\n\t\t// of tab.\r\n\t\tif(indentBy && indentBy > 0 && indentBy < 10){\r\n\t\t\tiTxt = \"\";\r\n\t\t\tfor(i = 0; i < indentBy; i++){\r\n\t\t\t\tiTxt += \" \";\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t//Build the content outside of the editor so we can walk\r\n\t\t//via DOM and build a 'pretty' output.\r\n\t\tvar contentDiv = Window.doc.createElement(\"div\");\r\n\t\tcontentDiv.innerHTML = html;\r\n\t\r\n\t\t// Use the entity encode/decode functions, they cache on the map,\r\n\t\t// so it won't multiprocess a map.\r\n\t\tvar encode = Entities.encode;\r\n\t\tvar decode = Entities.decode;\r\n\t\r\n\t\t/** Define a bunch of formatters to format the output. **/\r\n\t\tvar isInlineFormat = function(tag){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to determine if the current tag is an inline\r\n\t\t\t//\t\telement that does formatting, as we don't want to\r\n\t\t\t//\t\tbreak/indent around it, as it can screw up text.\r\n\t\t\t// tag:\r\n\t\t\t//\t\tThe tag to examine\r\n\t\t\tswitch(tag){\r\n\t\t\t\tcase \"a\":\r\n\t\t\t\tcase \"b\":\r\n\t\t\t\tcase \"strong\":\r\n\t\t\t\tcase \"s\":\r\n\t\t\t\tcase \"strike\":\r\n\t\t\t\tcase \"i\":\r\n\t\t\t\tcase \"u\":\r\n\t\t\t\tcase \"em\":\r\n\t\t\t\tcase \"sup\":\r\n\t\t\t\tcase \"sub\":\r\n\t\t\t\tcase \"span\":\r\n\t\t\t\tcase \"font\":\r\n\t\t\t\tcase \"big\":\r\n\t\t\t\tcase \"cite\":\r\n\t\t\t\tcase \"q\":\r\n\t\t\t\tcase \"small\":\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t//Create less divs.\r\n\t\tvar div = contentDiv.ownerDocument.createElement(\"div\");\r\n\t\tvar outerHTML =  function(node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to return the outer HTML of a node.\r\n\t\t\t//\t\tYes, IE has a function like this, but using cloneNode\r\n\t\t\t//\t\tallows avoiding looking at any child nodes, because in this\r\n\t\t\t//\t\tcase, we don't want them.\r\n\t\t\tvar clone = node.cloneNode(false);\r\n\t\t\tdiv.appendChild(clone);\r\n\t\t\tvar html = div.innerHTML;\r\n\t\t\tdiv.innerHTML = \"\";\r\n\t\t\treturn html;\r\n\t\t};\r\n\t\r\n\t\tvar sizeIndent = function(){\r\n\t\t\tvar i, txt = \"\";\r\n\t\t\tfor(i = 0; i < indentDepth; i++){\r\n\t\t\t\ttxt += iTxt;\r\n\t\t\t}\r\n\t\t\treturn txt.length;\r\n\t\t}\r\n\t\r\n\t\tvar indent = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to handle indent depth.\r\n\t\t\tvar i;\r\n\t\t\tfor(i = 0; i < indentDepth; i++){\r\n\t\t\t\tcontent.push(iTxt);\r\n\t\t\t}\r\n\t\t};\r\n\t\tvar newline = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to handle newlining.\r\n\t\t\tcontent.push(\"\\n\");\r\n\t\t};\r\n\t\r\n\t\tvar processTextNode = function(n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to process the text content for doc\r\n\t\t\t//\t\tinsertion\r\n\t\t\t// n:\r\n\t\t\t//\t\tThe text node to process.\r\n\t\t\ttextContent += encode(n.nodeValue, map);\r\n\t\t};\r\n\t\r\n\t\tvar formatText = function(txt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction for processing the text content encountered up to a\r\n\t\t\t//\t\tpoint and inserting it into the formatted document output.\r\n\t\t\t// txt:\r\n\t\t\t//\t\tThe text to format.\r\n\t\t\tvar i;\r\n\t\t\tvar _iTxt;\r\n\t\r\n\t\t\t// Clean up any indention organization since we're going to rework it\r\n\t\t\t// anyway.\r\n\t\t\tvar _lines = txt.split(\"\\n\");\r\n\t\t\tfor(i = 0; i < _lines.length; i++){\r\n\t\t\t\t_lines[i] = lang.trim(_lines[i]);\r\n\t\t\t}\r\n\t\t\ttxt = _lines.join(\" \");\r\n\t\t\ttxt = lang.trim(txt);\r\n\t\t\tif(txt !== \"\"){\r\n\t\t\t\tvar lines = [];\r\n\t\t\t\tif(maxLineLength && maxLineLength > 0){\r\n\t\t\t\t\tvar indentSize = sizeIndent();\r\n\t\t\t\t\tvar maxLine = maxLineLength;\r\n\t\t\t\t\tif(maxLineLength > indentSize){\r\n\t\t\t\t\t\tmaxLine -= indentSize;\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile(txt){\r\n\t\t\t\t\t\tif(txt.length > maxLineLength){\r\n\t\t\t\t\t\t\tfor(i = maxLine; (i > 0 && txt.charAt(i) !== \" \"); i--){\r\n\t\t\t\t\t\t\t\t// Do nothing, we're just looking for a space to split at.\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(!i){\r\n\t\t\t\t\t\t\t\t// Couldn't find a split going back, so go forward.\r\n\t\t\t\t\t\t\t\tfor(i = maxLine; (i < txt.length && txt.charAt(i) !== \" \"); i++){\r\n\t\t\t\t\t\t\t\t\t// Do nothing, we're just looking for a space to split at.\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar line = txt.substring(0, i);\r\n\t\t\t\t\t\t\tline = lang.trim(line);\r\n\t\t\t\t\t\t\t// Shift up the text string to the next chunk.\r\n\t\t\t\t\t\t\ttxt = lang.trim(txt.substring((i == txt.length)?txt.length:i + 1, txt.length));\r\n\t\t\t\t\t\t\tif(line){\r\n\t\t\t\t\t\t\t\t_iTxt = \"\";\r\n\t\t\t\t\t\t\t\tfor(i = 0; i < indentDepth; i++){\r\n\t\t\t\t\t\t\t\t\t_iTxt += iTxt;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tline = _iTxt + line + \"\\n\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tlines.push(line);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// Line is shorter than out desired length, so use it.\r\n\t\t\t\t\t\t\t// as/is\r\n\t\t\t\t\t\t\t_iTxt = \"\";\r\n\t\t\t\t\t\t\tfor(i = 0; i < indentDepth; i++){\r\n\t\t\t\t\t\t\t\t_iTxt += iTxt;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttxt = _iTxt + txt + \"\\n\";\r\n\t\t\t\t\t\t\tlines.push(txt);\r\n\t\t\t\t\t\t\ttxt = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn lines.join(\"\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\t_iTxt = \"\";\r\n\t\t\t\t\tfor(i = 0; i < indentDepth; i++){\r\n\t\t\t\t\t\t_iTxt += iTxt;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttxt = _iTxt + txt + \"\\n\";\r\n\t\t\t\t\treturn txt;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\treturn \"\";\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\tvar processScriptText = function(txt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to clean up potential escapes in the script code.\r\n\t\t\tif(txt){\r\n\t\t\t\ttxt = txt.replace(/&quot;/gi, \"\\\"\");\r\n\t\t\t\ttxt = txt.replace(/&gt;/gi, \">\");\r\n\t\t\t\ttxt = txt.replace(/&lt;/gi, \"<\");\r\n\t\t\t\ttxt = txt.replace(/&amp;/gi, \"&\");\r\n\t\t\t}\r\n\t\t\treturn txt;\r\n\t\t};\r\n\t\r\n\t\tvar formatScript = function(txt){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to rudimentary formatting of script text.\r\n\t\t\t//\t\tNot perfect, but it helps get some level of organization\r\n\t\t\t//\t\tin there.\r\n\t\t\t// txt:\r\n\t\t\t//\t\tThe script text to try to format a bit.\r\n\t\t\tif(txt){\r\n\t\t\t\ttxt = processScriptText(txt);\r\n\t\t\t\tvar i, t, c, _iTxt;\r\n\t\t\t\tvar indent = 0;\r\n\t\t\t\tvar scriptLines = txt.split(\"\\n\");\r\n\t\t\t\tvar newLines = [];\r\n\t\t\t\tfor (i = 0; i < scriptLines.length; i++){\r\n\t\t\t\t\tvar line = scriptLines[i];\r\n\t\t\t\t\tvar hasNewlines = (line.indexOf(\"\\n\") > -1);\r\n\t\t\t\t\tline = lang.trim(line);\r\n\t\t\t\t\tif(line){\r\n\t\t\t\t\t\tvar iLevel = indent;\r\n\t\t\t\t\t\t// Not all blank, so we need to process.\r\n\t\t\t\t\t\tfor(c = 0; c < line.length; c++){\r\n\t\t\t\t\t\t\tvar ch = line.charAt(c);\r\n\t\t\t\t\t\t\tif(ch === \"{\"){\r\n\t\t\t\t\t\t\t\tindent++;\r\n\t\t\t\t\t\t\t}else if(ch === \"}\"){\r\n\t\t\t\t\t\t\t\tindent--;\r\n\t\t\t\t\t\t\t\t// We want to back up a bit before the\r\n\t\t\t\t\t\t\t\t// line is written.\r\n\t\t\t\t\t\t\t\tiLevel = indent;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t_iTxt = \"\";\r\n\t\t\t\t\t\tfor(t = 0; t < indentDepth + iLevel; t++){\r\n\t\t\t\t\t\t\t_iTxt += iTxt;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnewLines.push(_iTxt + line + \"\\n\");\r\n\t\t\t\t\t}else if(hasNewlines && i === 0){\r\n\t\t\t\t\t\t// Just insert a newline for blank lines as\r\n\t\t\t\t\t\t// long as it's not the first newline (we\r\n\t\t\t\t\t\t// already inserted that in the openTag handler)\r\n\t\t\t\t\t\tnewLines.push(\"\\n\");\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\t// Okay, create the script text, hopefully reasonably\r\n\t\t\t\t// formatted.\r\n\t\t\t\ttxt = newLines.join(\"\");\r\n\t\t\t}\r\n\t\t\treturn txt;\r\n\t\t};\r\n\t\r\n\t\tvar openTag = function(node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to open a new tag for writing content.\r\n\t\t\tvar name = node.nodeName.toLowerCase();\r\n\t\t\t// Generate the outer node content (tag with attrs)\r\n\t\t\tvar nText = lang.trim(outerHTML(node));\r\n\t\t\tvar tag = nText.substring(0, nText.indexOf(\">\") + 1);\r\n\t\r\n\t\t\t// Also thanks to IE, we need to check for quotes around\r\n\t\t\t// attributes and insert if missing.\r\n\t\t\ttag = tag.replace(rgxp_fixIEAttrs,'=\"$1\"$2');\r\n\t\r\n\t\t\t// And lastly, thanks IE for changing style casing and end\r\n\t\t\t// semi-colon and webkit adds spaces, so lets clean it up by\r\n\t\t\t// sorting, etc, while we're at it.\r\n\t\t\ttag = tag.replace(rgxp_styleMatch, function(match){\r\n\t\t\t\tvar sL = match.substring(0,6);\r\n\t\t\t\tvar style = match.substring(6, match.length);\r\n\t\t\t\tvar closure = style.charAt(0);\r\n\t\t\t\tstyle = lang.trim(style.substring(1,style.length -1));\r\n\t\t\t\tstyle = style.split(\";\");\r\n\t\t\t\tvar trimmedStyles = [];\r\n\t\t\t\tArrayUtil.forEach(style, function(s){\r\n\t\t\t\t\ts = lang.trim(s);\r\n\t\t\t\t\tif(s){\r\n\t\t\t\t\t\t// Lower case the style name, leave the value alone.  Mainly a fixup for IE.\r\n\t\t\t\t\t\ts = s.substring(0, s.indexOf(\":\")).toLowerCase() + s.substring(s.indexOf(\":\"), s.length);\r\n\t\t\t\t\t\ttrimmedStyles.push(s);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\ttrimmedStyles = trimmedStyles.sort();\r\n\t\t\t\t\r\n\t\t\t\t// Reassemble and return the styles in sorted order.\r\n\t\t\t\tstyle = trimmedStyles.join(\"; \");\r\n\t\t\t\tvar ts = lang.trim(style);\r\n\t\t\t\tif(!ts || ts === \";\"){\r\n\t\t\t\t\t// Just remove any style attrs that are empty.\r\n\t\t\t\t\treturn \"\";\r\n\t\t\t\t}else{\r\n\t\t\t\t\tstyle += \";\";\r\n\t\t\t\t\treturn sL + closure + style + closure;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\r\n\t\t\t// Try and sort the attributes while we're at it.\r\n\t\t\tvar attrs = [];\r\n\t\t\ttag = tag.replace(rgxp_attrsMatch, function(attr){\r\n\t\t\t\tattrs.push(lang.trim(attr));\r\n\t\t\t\treturn \"\";\r\n\t\t\t});\r\n\t\t\tattrs = attrs.sort();\r\n\t\r\n\t\t\t// Reassemble the tag with sorted attributes!\r\n\t\t\ttag = \"<\" + name;\r\n\t\t\tif(attrs.length){\r\n\t\t\t\t tag += \" \" + attrs.join(\" \");\r\n\t\t\t}\r\n\t\r\n\t\t\t// Determine closure status.  If xhtml,\r\n\t\t\t// then close the tag properly as needed.\r\n\t\t\tif(nText.indexOf(\"</\") != -1){\r\n\t\t\t\tcloseTags.push(name);\r\n\t\t\t\ttag += \">\";\r\n\t\t\t}else{\r\n\t\t\t\tif(xhtml){\r\n\t\t\t\t\ttag += \" />\";\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttag += \">\";\r\n\t\t\t\t}\r\n\t\t\t\tcloseTags.push(false);\r\n\t\t\t}\r\n\t\r\n\t\t\tvar inline = isInlineFormat(name);\r\n\t\t\tinlineStyle.push(inline);\r\n\t\t\tif(textContent && !inline){\r\n\t\t\t\t// Process any text content we have that occurred\r\n\t\t\t\t// before the open tag of a non-inline.\r\n\t\t\t\tcontent.push(formatText(textContent));\r\n\t\t\t\ttextContent = \"\";\r\n\t\t\t}\r\n\t\r\n\t\t\t// Determine if this has a closing tag or not!\r\n\t\t\tif(!inline){\r\n\t\t\t\tindent();\r\n\t\t\t\tcontent.push(tag);\r\n\t\t\t\tnewline();\r\n\t\t\t\tindentDepth++;\r\n\t\t\t}else{\r\n\t\t\t\ttextContent += tag;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t};\r\n\t\t\r\n\t\tvar closeTag = function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to close out a tag if necessary.\r\n\t\t\tvar inline = inlineStyle.pop();\r\n\t\t\tif(textContent && !inline){\r\n\t\t\t\t// Process any text content we have that occurred\r\n\t\t\t\t// before the close tag.\r\n\t\t\t\tcontent.push(formatText(textContent));\r\n\t\t\t\ttextContent = \"\";\r\n\t\t\t}\r\n\t\t\tvar ct = closeTags.pop();\r\n\t\t\tif(ct){\r\n\t\t\t\tct = \"</\" + ct + \">\";\r\n\t\t\t\tif(!inline){\r\n\t\t\t\t\tindentDepth--;\r\n\t\t\t\t\tindent();\r\n\t\t\t\t\tcontent.push(ct);\r\n\t\t\t\t\tnewline();\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttextContent += ct;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tindentDepth--;\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\tvar processCommentNode = function(n){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFunction to handle processing a comment node.\r\n\t\t\t// n:\r\n\t\t\t//\t\tThe comment node to process.\r\n\t\r\n\t\t\t//Make sure contents aren't double-encoded.\r\n\t\t\tvar commentText = decode(n.nodeValue, map);\r\n\t\t\tindent();\r\n\t\t\tcontent.push(\"<!--\");\r\n\t\t\tnewline();\r\n\t\t\tindentDepth++;\r\n\t\t\tcontent.push(formatText(commentText));\r\n\t\t\tindentDepth--;\r\n\t\t\tindent();\r\n\t\t\tcontent.push(\"-->\");\r\n\t\t\tnewline();\r\n\t\t};\r\n\t\r\n\t\tvar processNode = function(node) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tEntrypoint for processing all the text!\r\n\t\t\tvar children = node.childNodes;\r\n\t\t\tif(children){\r\n\t\t\t\tvar i;\r\n\t\t\t\tfor(i = 0; i < children.length; i++){\r\n\t\t\t\t\tvar n = children[i];\r\n\t\t\t\t\tif(n.nodeType === 1){\r\n\t\t\t\t\t\tvar tg = lang.trim(n.tagName.toLowerCase());\r\n\t\t\t\t\t\tif(has(\"ie\") && n.parentNode != node){\r\n\t\t\t\t\t\t\t// IE is broken.  DOMs are supposed to be a tree.\r\n\t\t\t\t\t\t\t// But in the case of malformed HTML, IE generates a graph\r\n\t\t\t\t\t\t\t// meaning one node ends up with multiple references\r\n\t\t\t\t\t\t\t// (multiple parents).  This is totally wrong and invalid, but\r\n\t\t\t\t\t\t\t// such is what it is.  We have to keep track and check for\r\n\t\t\t\t\t\t\t// this because otherwise the source output HTML will have dups.\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(tg && tg.charAt(0) === \"/\"){\r\n\t\t\t\t\t\t\t// IE oddity.  Malformed HTML can put in odd tags like:\r\n\t\t\t\t\t\t\t// </ >, </span>.  It treats a mismatched closure as a new\r\n\t\t\t\t\t\t\t// start tag.  So, remove them.\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t//Process non-dup, seemingly well formed elements!\r\n\t\t\t\t\t\t\topenTag(n);\r\n\t\t\t\t\t\t\tif(tg === \"script\"){\r\n\t\t\t\t\t\t\t\tcontent.push(formatScript(n.innerHTML));\r\n\t\t\t\t\t\t\t}else if(tg === \"pre\"){\r\n\t\t\t\t\t\t\t\tvar preTxt = n.innerHTML;\r\n\t\t\t\t\t\t\t\tif(has(\"mozilla\")){\r\n\t\t\t\t\t\t\t\t\t//Mozilla screws this up, so fix it up.\r\n\t\t\t\t\t\t\t\t\tpreTxt = preTxt.replace(\"<br>\", \"\\n\");\r\n\t\t\t\t\t\t\t\t\tpreTxt = preTxt.replace(\"<pre>\", \"\");\r\n\t\t\t\t\t\t\t\t\tpreTxt = preTxt.replace(\"</pre>\", \"\");\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// Add ending newline, if needed.\r\n\t\t\t\t\t\t\t\tif(preTxt.charAt(preTxt.length - 1) !== \"\\n\"){\r\n\t\t\t\t\t\t\t\t\tpreTxt += \"\\n\";\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcontent.push(preTxt);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tprocessNode(n);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcloseTag();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(n.nodeType === 3 || n.nodeType === 4){\r\n\t\t\t\t\t\tprocessTextNode(n);\r\n\t\t\t\t\t}else if(n.nodeType === 8){\r\n\t\t\t\t\t\tprocessCommentNode(n);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\t//Okay, finally process the input string.\r\n\t\tprocessNode(contentDiv);\r\n\t\tif(textContent){\r\n\t\t\t// Insert any trailing text.  See: #10854\r\n\t\t\tcontent.push(formatText(textContent));\r\n\t\t\ttextContent = \"\";\r\n\t\t}\r\n\t\treturn content.join(\"\"); //String\r\n\t};\r\n\treturn dhf;\r\n});\r\n\r\n"]}