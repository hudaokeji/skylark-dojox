{"version":3,"sources":["dgauges/LogScaler.js"],"names":["define","lang","declare","Stateful","minimum","maximum","multiplier","majorTicks","_computedMultiplier","NaN","constructor","this","watchedProperties","_buildMajorTickItems","majorTickCache","_computedMinimum","getComputedMinimum","_computedMaximum","getComputedMaximum","getComputedMultiplier","data","start","Math","max","floor","log","LN10","end","i","value","pow","position","push","computeTicks","concat","positionForValue","isNaN","sv","valueForPosition","ev"],"mappings":";;;;;;;AAAAA,QAAQ,kBAAmB,qBAAsB,iBAAkB,SAASC,EAAMC,EAASC,GAC1F,OAAOD,EAAQ,0BAA2BC,GAUzCC,QAAS,EAGTC,QAAS,IAGTC,WAAY,GAIZC,WAAY,KAEZC,oBAAqBC,IAErBC,YAAa,WACZC,KAAKC,mBAAqB,UAAW,UAAW,eAEjDC,qBAAsB,WAKrB,IAAIC,KAKJ,GAJAH,KAAKI,iBAAmBJ,KAAKK,qBAC7BL,KAAKM,iBAAmBN,KAAKO,qBAC7BP,KAAKH,oBAAsBG,KAAKQ,wBAE7BR,KAAKM,iBAAmBN,KAAKI,iBAI/B,IAHA,IAEIK,EAFAC,EAAQC,KAAKC,IAAI,EAAGD,KAAKE,MAAMF,KAAKG,IAAId,KAAKI,iBAAmB,MAAeO,KAAKI,OACpFC,EAAML,KAAKC,IAAI,EAAGD,KAAKE,MAAMF,KAAKG,IAAId,KAAKM,iBAAmB,MAAeK,KAAKI,OAE9EE,EAAIP,EAAOO,GAAKD,EAAKC,GAAKjB,KAAKH,qBACtCY,MACKS,MAAQP,KAAKQ,IAAI,GAAIF,GAC1BR,EAAKW,UAAYH,EAAIP,IAAUM,EAAMN,GACrCP,EAAekB,KAAKZ,GAGtB,OAAON,GAGRE,mBAAoB,WAKnB,OAAOM,KAAKQ,IAAI,GAAIR,KAAKC,IAAI,EAAGD,KAAKE,MAAMF,KAAKG,IAAId,KAAKP,QAAU,MAAekB,KAAKI,SAGxFR,mBAAoB,WAKnB,OAAOI,KAAKQ,IAAI,GAAIR,KAAKC,IAAI,EAAGD,KAAKE,MAAMF,KAAKG,IAAId,KAAKN,QAAU,MAAeiB,KAAKI,SAIxFP,sBAAuB,WAKtB,OAAOG,KAAKC,IAAI,EAAGD,KAAKE,MAAMF,KAAKG,IAAId,KAAKL,WAAa,MAAegB,KAAKI,QAI9EO,aAAc,WAMb,OADAtB,KAAKJ,WAAaI,KAAKE,uBAChBF,KAAKJ,WAAW2B,UAGxBC,iBAAkB,SAASN,IAQvBlB,KAAKM,iBAAmBN,KAAKI,kBAAoBc,GAASlB,KAAKI,kBAAoBc,EAAQ,GAAKO,MAAMP,MACxGA,EAAQlB,KAAKI,kBAEXc,GAASlB,KAAKM,mBAChBY,EAAQlB,KAAKM,kBAEdY,EAAQP,KAAKG,IAAII,GAASP,KAAKI,KAC/B,IAAIW,EAAKf,KAAKG,IAAId,KAAKI,kBAAoBO,KAAKI,KAEhD,OAAQG,EAAQQ,IADPf,KAAKG,IAAId,KAAKM,kBAAoBK,KAAKI,KACpBW,IAG7BC,iBAAkB,SAASP,GAO1B,IAAIM,EAAKf,KAAKG,IAAId,KAAKI,kBAAoBO,KAAKI,KAC5Ca,EAAKjB,KAAKG,IAAId,KAAKM,kBAAoBK,KAAKI,KAChD,OAAOJ,KAAKQ,IAAI,GAAIO,EAAKN,GAAYQ,EAAKF","file":"../../dgauges/LogScaler.js","sourcesContent":["define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/Stateful\"], function(lang, declare, Stateful){\r\n\treturn declare(\"dojox.dgauges.LogScaler\", Stateful, {\r\n\t\t// summary:\r\n\t\t//\t\tThe LogScaler maps numeric values evenly\r\n\t\t//\t\tbetween a minimum and a maximum value along a gauge scale.\r\n\t\t//\t\tIf no multiplier is specified, the scale will place\r\n\t\t//\t\ta tick on each power of 10 value (1, 10, 100, 1000, and so on) between\r\n\t\t//\t\tthe minimum and maximum values.\r\n\t\t\r\n\t\t// minimum: Number\r\n\t\t//\t\tThe minimum value of the scaler. Default is 0.\r\n\t\tminimum: 0,\r\n\t\t// maximum: Number\r\n\t\t//\t\tThe maximum value of the scaler. Default is 1000.\r\n\t\tmaximum: 1000,\r\n\t\t// multiplier: Number\r\n\t\t//\t\tThe interval between two major ticks.\r\n\t\tmultiplier: 10,\r\n\t\t// majorTicks:\r\n\t\t//\t\tThe array of generated major ticks. You should not set this\r\n\t\t//\t\tproperty when using the scaler.\r\n\t\tmajorTicks: null,\r\n\t\t\r\n\t\t_computedMultiplier: NaN,\r\n\t\t\r\n\t\tconstructor: function(){\r\n\t\t\tthis.watchedProperties = [\"minimum\", \"maximum\", \"multiplier\"];\r\n\t\t},\r\n\t\t_buildMajorTickItems: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInternal method.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar majorTickCache = [];\r\n\t\t\tthis._computedMinimum = this.getComputedMinimum();\r\n\t\t\tthis._computedMaximum = this.getComputedMaximum();\r\n\t\t\tthis._computedMultiplier = this.getComputedMultiplier();\r\n\t\t\t\r\n\t\t\tif(this._computedMaximum > this._computedMinimum){\r\n\t\t\t\tvar start = Math.max(0, Math.floor(Math.log(this._computedMinimum + 0.000000001) / Math.LN10));\r\n\t\t\t\tvar end = Math.max(0, Math.floor(Math.log(this._computedMaximum + 0.000000001) / Math.LN10));\r\n\t\t\t\tvar data;\r\n\t\t\t\tfor(var i = start; i <= end; i += this._computedMultiplier){\r\n\t\t\t\t\tdata = {};\r\n\t\t\t\t\tdata.value = Math.pow(10, i);\r\n\t\t\t\t\tdata.position = (i - start) / (end - start);\r\n\t\t\t\t\tmajorTickCache.push(data);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn majorTickCache;\r\n\t\t},\r\n\t\t\r\n\t\tgetComputedMinimum: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe computed minimum value of the scale. If the minimum value is not\r\n\t\t\t//\t\tan even power of 10, the scale computes a new minimum so that it maps to \r\n\t\t\t//\t\tan even power of 10.\r\n\t\t\treturn Math.pow(10, Math.max(0, Math.floor(Math.log(this.minimum + 0.000000001) / Math.LN10)));\r\n\t\t},\r\n\t\t\r\n\t\tgetComputedMaximum: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe computed maximum value of the scale. If the maximum value is not\r\n\t\t\t//\t\tan even power of 10, the scale computes a new maximum so that it maps to \r\n\t\t\t//\t\tan even power of 10.\r\n\t\t\treturn Math.pow(10, Math.max(0, Math.floor(Math.log(this.maximum + 0.000000001) / Math.LN10)));\r\n\t\t},\r\n\t\t\r\n\t\t\r\n\t\tgetComputedMultiplier: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe computed multiplier value of the scale. If the multiplier value is not\r\n\t\t\t//\t\tan even power of 10, the scale computes a new multiplier so that it maps to \r\n\t\t\t//\t\tan even power of 10.\r\n\t\t\treturn Math.max(1, Math.floor(Math.log(this.multiplier + 0.000000001) / Math.LN10));\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tcomputeTicks: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreates or re-creates the ticks for this scaler.\r\n\t\t\t// returns: Array\r\n\t\t\t//\t\tAn array containing ticks.\r\n\t\t\tthis.majorTicks = this._buildMajorTickItems();\r\n\t\t\treturn this.majorTicks.concat();\r\n\t\t},\r\n\t\t\r\n\t\tpositionForValue: function(value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTransforms a value into a relative position between 0 and 1.\r\n\t\t\t// value: Number\r\n\t\t\t//\t\tA value to transform.\r\n\t\t\t// returns: Number\r\n\t\t\t//\t\tThe position between 0 and 1.\r\n\t\t\t\r\n\t\t\tif(this._computedMaximum < this._computedMinimum || value <= this._computedMinimum || value < 1 || isNaN(value)){\r\n\t\t\t\tvalue = this._computedMinimum;\r\n\t\t\t}\r\n\t\t\tif(value >= this._computedMaximum){\r\n\t\t\t\tvalue = this._computedMaximum;\r\n\t\t\t}\r\n\t\t\tvalue = Math.log(value) / Math.LN10;\r\n\t\t\tvar sv = Math.log(this._computedMinimum) / Math.LN10;\r\n\t\t\tvar ev = Math.log(this._computedMaximum) / Math.LN10;\r\n\t\t\treturn (value - sv) / (ev - sv);\r\n\t\t},\r\n\t\t\r\n\t\tvalueForPosition: function(position){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTransforms a relative position (between 0 and 1) into a value.\r\n\t\t\t// position: Number\r\n\t\t\t//\t\tA relative position to transform.\r\n\t\t\t// returns: Number\r\n\t\t\t//\t\tThe transformed value between minimum and maximum.\r\n\t\t\tvar sv = Math.log(this._computedMinimum) / Math.LN10;\r\n\t\t\tvar ev = Math.log(this._computedMaximum) / Math.LN10;\r\n\t\t\treturn Math.pow(10, sv + position * (ev - sv));\r\n\t\t}\r\n\t});\r\n});\r\n"]}