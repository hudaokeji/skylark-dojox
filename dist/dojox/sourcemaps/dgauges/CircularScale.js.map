{"version":3,"sources":["dgauges/CircularScale.js"],"names":["define","declare","gfx","ScaleBase","_circularUtils","originX","originY","radius","startAngle","endAngle","orientation","constructor","this","labelPosition","addInvalidatingProperties","_getOrientationNum","positionForValue","value","totalAngle","computeTotalAngle","relativePos","scaler","modAngle","_positionForTickItem","tickItem","position","valueForPosition","angle","positionInRange","pos","min1","min2","max1","max2","Math","min","_distance","x1","y1","x2","y2","sqrt","_layoutLabel","label","txt","ox","oy","lrad","labelPlacement","side","dif","font","_getFont","tw","_base","_getTextBox","makeFontString","makeParameters","defaultFont","w","fz","size","th","normalizedLength","tfx","cos","tfy","sin","intersections","ipx","ipy","tan","push","x","y","it","length","ip","setTransform","dx","dy","refreshRendering","inherited","arguments","_gfxGroup","renderer","labelText","_ticksGroup","clear","tickBB","allTicks","computeTicks","i","a","tickShapeFunc","_gauge","_computeBoundingBox","matrix","rotateg","width","tickLabelFunc","createText","text","align","setFont","setFill","color","rad","labelGap","toRadians","key","_indicatorsIndex","_indicatorsRenderers","invalidateRendering"],"mappings":"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","file":"../../dgauges/CircularScale.js","sourcesContent":["define([\"dojo/_base/declare\", \"dojox/gfx\", \"./ScaleBase\", \"./_circularUtils\"], function(declare, gfx, ScaleBase, _circularUtils){\r\n\treturn declare(\"dojox.dgauges.CircularScale\", ScaleBase, {\r\n\t\t// summary:\r\n\t\t//\t\tThe circular scale. A scaler must be set to use this class.\r\n\r\n\t\t// originX: Number\r\n\t\t//\t\tThe origin x-coordinate of the scale in pixels.\r\n\t\toriginX: 50,\r\n\t\t// originY: Number\r\n\t\t//\t\tThe origin y-coordinate of the scale in pixels.\r\n\t\toriginY: 50,\r\n\t\t// radius: Number\r\n\t\t//\t\tThe outer radius in pixels of the scale.\r\n\t\tradius: 50,\r\n\t\t// startAngle: Number\r\n\t\t//\t\tThe start angle of the scale in degrees.\r\n\t\tstartAngle: 0,\r\n\t\t// endAngle: Number\r\n\t\t//\t\tThe end angle of the scale in degrees.\r\n\t\tendAngle: 180,\r\n\t\t// orientation: String\r\n\t\t//\t\tThe orientation of the scale. Can be \"clockwise\" or \"cclockwise\".\r\n\t\t//\t\tThe default value is \"clockwise\".\r\n\t\torientation: \"clockwise\",\r\n\t\t\r\n\t\tconstructor: function(){\r\n\r\n\t\t\tthis.labelPosition = \"inside\";\r\n\t\t\t\r\n\t\t\tthis.addInvalidatingProperties([\"originX\", \"originY\", \"radius\", \"startAngle\", \"endAngle\", \"orientation\"]);\r\n\t\t},\r\n\t\t\r\n\t\t_getOrientationNum: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInternal method.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\treturn this.orientation == \"cclockwise\" ? -1 : 1;\r\n\t\t},\r\n\t\t\r\n\t\tpositionForValue: function(/* Number */value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTransforms a value into an angle using the associated scaler.\r\n\t\t\t// returns: Number\r\n\t\t\t//\t\tAn angle in degrees.\r\n\t\t\tvar totalAngle = _circularUtils.computeTotalAngle(this.startAngle, this.endAngle, this.orientation);\r\n\t\t\tvar relativePos = this.scaler.positionForValue(value);\r\n\t\t\treturn _circularUtils.modAngle(this.startAngle + this._getOrientationNum() * totalAngle * relativePos, 360);\r\n\t\t},\r\n\t\t\r\n\t\t_positionForTickItem: function(tickItem){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInternal method.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar totalAngle = _circularUtils.computeTotalAngle(this.startAngle, this.endAngle, this.orientation);\r\n\t\t\treturn _circularUtils.modAngle(this.startAngle + this._getOrientationNum() * totalAngle * tickItem.position, 360);\r\n\t\t},\r\n\t\t\r\n\t\tvalueForPosition: function(/* Number */angle){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTransforms an angle in degrees into a value using the associated scaler.\r\n\t\t\t// returns: Number\r\n\t\t\t//\t\tThe value represented by angle. \r\n\t\t\tif(!this.positionInRange(angle)){\r\n\t\t\t\tvar min1 = _circularUtils.modAngle(this.startAngle - angle, 360);\r\n\t\t\t\tvar min2 = 360 - min1;\r\n\t\t\t\tvar max1 = _circularUtils.modAngle(this.endAngle - angle, 360);\r\n\t\t\t\tvar max2 = 360 - max1;\r\n\t\t\t\tvar pos;\r\n\t\t\t\tif(Math.min(min1, min2) < Math.min(max1, max2)){\r\n\t\t\t\t\tpos = 0;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tpos = 1;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tvar relativeAngle = _circularUtils.modAngle(this._getOrientationNum() * (angle - this.startAngle), 360);\r\n\t\t\t\tvar totalAngle = _circularUtils.computeTotalAngle(this.startAngle, this.endAngle, this.orientation);\r\n\t\t\t\tpos = relativeAngle / totalAngle;\r\n\t\t\t}\r\n\t\t\treturn this.scaler.valueForPosition(pos);\r\n\t\t},\r\n\t\t\r\n\t\tpositionInRange: function(/* Number */value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns true if the value parameter is between the accepted scale positions.\r\n\t\t\t// returns: Boolean\r\n\t\t\t//\t\tTrue if the value parameter is between the accepted scale positions.\r\n\t\t\tif(this.startAngle == this.endAngle){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tvalue = _circularUtils.modAngle(value, 360);\r\n\t\t\tif(this._getOrientationNum() == 1){\r\n\t\t\t\tif(this.startAngle < this.endAngle){\r\n\t\t\t\t\treturn value >= this.startAngle && value <= this.endAngle;\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn !(value > this.endAngle && value < this.startAngle);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif(this.startAngle < this.endAngle){\r\n\t\t\t\t\treturn !(value > this.startAngle && value < this.endAngle);\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn value >= this.endAngle && value <= this.startAngle;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t_distance: function(x1, y1, x2, y2){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInternal method.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\treturn Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\r\n\t\t},\r\n\t\t\r\n\t\t_layoutLabel: function(label, txt, ox, oy, lrad, angle, labelPlacement){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInternal method.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar font = this._getFont();\r\n\t\t\tvar box = gfx._base._getTextBox(txt, {\r\n\t\t\t\tfont: gfx.makeFontString(gfx.makeParameters(gfx.defaultFont, font))\r\n\t\t\t});\r\n\t\t\tvar tw = box.w;\r\n\t\t\tvar fz = font.size;\r\n\t\t\tvar th = gfx.normalizedLength(fz);\r\n\t\t\t\r\n\t\t\tvar tfx = ox + Math.cos(angle) * lrad - tw / 2;\r\n\t\t\tvar tfy = oy - Math.sin(angle) * lrad - th / 2;\r\n\t\t\tvar side;\r\n\t\t\t\r\n\t\t\tvar intersections = [];\r\n\t\t\t\r\n\t\t\t// Intersection with top segment\r\n\t\t\tside = tfx;\r\n\t\t\tvar ipx = side;\r\n\t\t\tvar ipy = -Math.tan(angle) * side + oy + Math.tan(angle) * ox;\r\n\t\t\t// Verify if intersection is on segment\r\n\t\t\tif(ipy >= tfy && ipy <= tfy + th){\r\n\t\t\t\tintersections.push({\r\n\t\t\t\t\tx: ipx,\r\n\t\t\t\t\ty: ipy\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Intersection with bottom segment\r\n\t\t\tside = tfx + tw;\r\n\t\t\tipx = side;\r\n\t\t\tipy = -Math.tan(angle) * side + oy + Math.tan(angle) * ox;\r\n\t\t\t// Verify if intersection is on segment\r\n\t\t\tif(ipy >= tfy && ipy <= tfy + th){\r\n\t\t\t\tintersections.push({\r\n\t\t\t\t\tx: ipx,\r\n\t\t\t\t\ty: ipy\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Intersection with left segment\r\n\t\t\tside = tfy;\r\n\t\t\tipx = -1 / Math.tan(angle) * side + ox + 1 / Math.tan(angle) * oy;\r\n\t\t\tipy = side;\r\n\t\t\t// Verify if intersection is on segment\r\n\t\t\tif(ipx >= tfx && ipx <= tfx + tw){\r\n\t\t\t\tintersections.push({\r\n\t\t\t\t\tx: ipx,\r\n\t\t\t\t\ty: ipy\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// Intersection with right segment\r\n\t\t\tside = tfy + th;\r\n\t\t\tipx = -1 / Math.tan(angle) * side + ox + 1 / Math.tan(angle) * oy;\r\n\t\t\tipy = side;\r\n\t\t\t// Verify if intersection is on segment\r\n\t\t\tif(ipx >= tfx && ipx <= tfx + tw){\r\n\t\t\t\tintersections.push({\r\n\t\t\t\t\tx: ipx,\r\n\t\t\t\t\ty: ipy\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tvar dif;\r\n\t\t\tif(labelPlacement == \"inside\"){\r\n\t\t\t\tfor(var it = 0; it < intersections.length; it++){\r\n\t\t\t\t\tvar ip = intersections[it];\r\n\t\t\t\t\tdif = this._distance(ip.x, ip.y, ox, oy) - lrad;\r\n\t\t\t\t\tif(dif >= 0){\r\n\t\t\t\t\t\t// Place reference intersection point on reference circle\r\n\t\t\t\t\t\ttfx = ox + Math.cos(angle) * (lrad - dif) - tw / 2;\r\n\t\t\t\t\t\ttfy = oy - Math.sin(angle) * (lrad - dif) - th / 2;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{// \"outside\" placement\r\n\t\t\t\tfor(it = 0; it < intersections.length; it++){\r\n\t\t\t\t\tip = intersections[it];\r\n\t\t\t\t\tdif = this._distance(ip.x, ip.y, ox, oy) - lrad;\r\n\t\t\t\t\tif(dif <= 0){\r\n\t\t\t\t\t\t// Place reference intersection point on reference circle\r\n\t\t\t\t\t\ttfx = ox + Math.cos(angle) * (lrad - dif) - tw / 2;\r\n\t\t\t\t\t\ttfy = oy - Math.sin(angle) * (lrad - dif) - th / 2;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(label){\r\n\t\t\t\tlabel.setTransform([{\r\n\t\t\t\t\tdx: tfx + tw / 2,\r\n\t\t\t\t\tdy: tfy + th\r\n\t\t\t\t}]);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\trefreshRendering: function(){\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tif(!this._gfxGroup || !this.scaler){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Normalize angles\r\n\t\t\tthis.startAngle = _circularUtils.modAngle(this.startAngle, 360);\r\n\t\t\tthis.endAngle = _circularUtils.modAngle(this.endAngle, 360);\r\n\t\t\t\r\n\t\t\tthis._ticksGroup.clear();\r\n\t\t\t\r\n\t\t\tvar renderer;\r\n\t\t\tvar label;\r\n\t\t\tvar labelText;\r\n\t\t\t\r\n\t\t\t// Layout ticks\r\n\t\t\tvar allTicks = this.scaler.computeTicks();\r\n\t\t\t\r\n\t\t\tvar tickBB;\r\n\t\t\tfor(var i = 0; i < allTicks.length; i++){\r\n\t\t\t\tvar tickItem = allTicks[i];\r\n\t\t\t\trenderer = this.tickShapeFunc(this._ticksGroup, this, tickItem);\r\n\t\t\t\t\r\n\t\t\t\ttickBB = this._gauge._computeBoundingBox(renderer);\r\n\t\t\t\tvar a;\r\n\t\t\t\tif(tickItem.position){\r\n\t\t\t\t\ta = this._positionForTickItem(tickItem);\r\n\t\t\t\t}else{\r\n\t\t\t\t\ta = this.positionForValue(tickItem.value);\r\n\t\t\t\t}\r\n\t\t\t\tif(renderer){\r\n\t\t\t\t\trenderer.setTransform([{\r\n\t\t\t\t\t\tdx: this.originX,\r\n\t\t\t\t\t\tdy: this.originY\r\n\t\t\t\t\t}, gfx.matrix.rotateg(a), {\r\n\t\t\t\t\t\tdx: this.radius - tickBB.width - 2 * tickBB.x,\r\n\t\t\t\t\t\tdy: 0\r\n\t\t\t\t\t}]);\r\n\t\t\t\t}\r\n\t\t\t\tlabelText = this.tickLabelFunc(tickItem);\r\n\t\t\t\tif(labelText){\r\n\t\t\t\t\tlabel = this._ticksGroup.createText({\r\n\t\t\t\t\t\tx: 0,\r\n\t\t\t\t\t\ty: 0,\r\n\t\t\t\t\t\ttext: labelText,\r\n\t\t\t\t\t\talign: \"middle\"\r\n\t\t\t\t\t}).setFont(this._getFont()).setFill(this._getFont().color ? this._getFont().color : \"black\");\r\n\t\t\t\t\tvar rad = this.radius;\r\n\t\t\t\t\tif(this.labelPosition == \"inside\"){\r\n\t\t\t\t\t\trad -= (tickBB.width + this.labelGap);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\trad += this.labelGap;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._layoutLabel(label, labelText, this.originX, this.originY, rad, _circularUtils.toRadians(360 - a), this.labelPosition);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var key in this._indicatorsIndex){\r\n\t\t\t\tthis._indicatorsRenderers[key] = this._indicatorsIndex[key].invalidateRendering();\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n});\r\n"]}