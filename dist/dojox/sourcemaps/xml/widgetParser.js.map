{"version":3,"sources":["xml/widgetParser.js"],"names":["define","dojo","window","has","query","parser","dxparser","dXml","lang","getObject","xXml","widgetParser","d","this","parseNode","node","toBuild","forEach","script","push","apply","_processScript","orphan","instantiate","text","src","_getText","innerHTML","firstChild","nodeValue","htmlNode","toHTML","dojox","xml","parse","ret","place","parentNode","removeChild","newNode","nodeName","dd","doc","type","nodeType","createTextNode","localName","split","pop","namespace","namespaceURI","getNamespaceUri","createElement","dojoType","setAttribute","attributes","attr","name","value","indexOf","style","childNodes","cn","childNode","appendChild"],"mappings":";;;;;;;AAAAA,QACC,kBACA,oBACA,mBACA,aACA,cACA,oBACE,SAASC,EAAMC,EAAQC,EAAKC,EAAOC,EAAQC,GAE9C,IAAIC,EAAOC,KAAKC,UAAU,aAAa,GAsKvC,OA7HAC,KAAKC,aAAe,IAAI,WAEvB,IAAIC,EAAIX,EAERY,KAAKC,UAAY,SAASC,GAEzB,IAAIC,KAOJ,OALAJ,EAAER,MAAM,0BAA2BW,GAAME,QAAQ,SAASC,GACzDF,EAAQG,KAAKC,MAAMJ,EAASH,KAAKQ,eAAeH,KAC9CL,MAAMS,SAGFV,EAAEP,OAAOkB,YAAYP,IAG7BH,KAAKQ,eAAiB,SAASH,GAG9B,IAAIM,EAAON,EAAOO,IAAOb,EAAEc,SAASR,EAAOO,KAAOP,EAAOS,WAAaT,EAAOU,WAAWC,UACpFC,EAAWjB,KAAKkB,OAAQC,MAAMC,IAAI5B,OAAO6B,MAAMV,GAAMI,YAIrDO,EAAMvB,EAAER,MAAM,aAAc0B,GAIhC,OAFA1B,EAAM,IAAK0B,GAAUM,MAAMlB,EAAQ,UACnCA,EAAOmB,WAAWC,YAAYpB,GACvBiB,GAQRtB,KAAKkB,OAAS,SAAsBhB,GACnC,IAAIwB,EACAC,EAAWzB,EAAKyB,SAChBC,EAAKvC,EAAOwC,IACZC,EAAO5B,EAAK6B,SAIhB,GAAGD,GAAQ,EACV,OAAOF,EAAGI,eAAyB,GAARF,GAAqB,GAARA,EAAa5B,EAAKc,UAAY,IAGvE,IAAIiB,EAAY/B,EAAK+B,WAAWN,EAASO,MAAM,KAAKC,MAKhDC,EAAYlC,EAAKmC,eAAiBnC,EAAKoC,gBAAkBpC,EAAKoC,kBAAoB,IAGtF,GAAgB,QAAbF,EACFV,EAAUE,EAAGW,cAAcN,OACvB,CACJ,IAAIO,EAAWJ,EAAY,IAAMH,GAqBjCP,EAAUA,GAAWE,EAAGW,cAA2B,uBAAZC,EAAqC,SAAW,QAC/EC,aAAa,WAAYD,GAuClC,OAhCAzC,EAAEK,QAAQF,EAAKwC,WAAY,SAASC,GAEnC,IAAIC,EAAOD,EAAKC,MAAQD,EAAKhB,SACzBkB,EAAQF,EAAKE,OAASF,EAAK3B,UACH,GAAzB4B,EAAKE,QAAQ,WASZxD,EAAI,OAAiB,SAARsD,EACflB,EAAQqB,MAAMN,aAAa,UAAWI,GAEtCnB,EAAQe,aAAaG,EAAMC,MAI9B9C,EAAEK,QAAQF,EAAK8C,WAAY,SAASC,GACnC,IAAIC,EAAYlD,KAAKkB,OAAO+B,GAKZ,UAAbhB,EACFP,EAAQf,MAAQuC,EAAUlC,UAE1BU,EAAQyB,YAAYD,IAEnBlD,MACI0B,IAKFhC,EAAKI","file":"../../xml/widgetParser.js","sourcesContent":["define([\r\n\t\"dojo/_base/lang\",\t// dojo.getObject\r\n\t\"dojo/_base/window\",\t// dojo.doc\r\n\t\"dojo/_base/sniff\",\t// dojo.isIE\r\n\t\"dojo/query\",\r\n\t\"dojo/parser\",\r\n\t\"dojox/xml/parser\"\r\n], function(dojo, window, has, query, parser, dxparser){\r\n\r\nvar dXml = lang.getObject(\"dojox.xml\", true);\r\n\r\n/**\r\nTake some sort of xml block\r\n* like <dojo.button caption=\"blah\"/> and turn\r\n* it into a widget..\r\n*/\r\n\r\n\t/**\r\n\t * We want to support something like:\r\n\t * <body>\r\n\t * \t<script>\r\n\t * \t<dijit.layout.SplitContainer>\r\n\t * \t\t<dijit.button/>\r\n\t * \t\t<div>...</div>\r\n\t * \t</dijit.layout.SplitContainer>\r\n\t * </body>\r\n\t *\r\n\t * This is very tricky because if we parse this as XML then the <div> tag\r\n\t * is actually an XML tag, not an XML tag, which is problematic in at least\r\n\t * IE.\r\n\t *\r\n\t * So the strategy is this, silly as it may be: Convert EVERYTHING to HTML\r\n\t * nodes, including the dijit.layout.SplitContainer by converting it to a\r\n\t * div with the dojoType. Then run it through the standard parser.\r\n\t * The more HTML you have relative to XML the less extra overhead this is.\r\n\t *\r\n\t * For something that is all XML we could have a different approach,\r\n\t * perhaps signified by a different type of script tag. In that case we\r\n\t * could just instantiate all the elements without a sourceNodeRef and then\r\n\t * add the top level components to the app.\r\n\t *\r\n\t * That is very straightforward but I haven't done it.\r\n\t *\r\n\t * Right now there is no mechanism to have an intermediary bridge between\r\n\t * the XML and the widget, because we are relying on dojo.parser\r\n\t * to do the instantiation. It isn't clear to me why we would want\r\n\t * those bridges in this approach and not in that approach.\r\n\t *\r\n\t */\r\n\r\nxXml.widgetParser = new function(){\r\n\t\r\n\tvar d = dojo;\r\n\t\r\n\tthis.parseNode = function(node){\r\n\t\t\r\n\t\tvar toBuild = [];\r\n\t\t//TODO figure out the proper type\r\n\t\td.query(\"script[type='text/xml']\", node).forEach(function(script){\r\n\t\t\ttoBuild.push.apply(toBuild, this._processScript(script));\r\n\t\t}, this).orphan();\r\n\t\t\r\n\t\t//instantiate everything at the end, doing it piecewise can give ID conflicts\r\n\t\treturn d.parser.instantiate(toBuild);\r\n\t};\r\n\r\n\tthis._processScript = function(script){\r\n\t\t//the text is either loaded from a separate file by the src\r\n\t\t//attribute or underneath the src tag\r\n\t\tvar text = script.src ?  d._getText(script.src) : script.innerHTML || script.firstChild.nodeValue;\r\n\t\tvar htmlNode = this.toHTML( dojox.xml.parser.parse(text).firstChild );\r\n\t\t\r\n\t\t//make the list BEFORE we copy things over to keep the query scope as\r\n\t\t//small as possible\r\n\t\tvar ret = d.query('[dojoType]', htmlNode);\r\n\t\t//remove the script tag and replace with new HTML block\r\n\t\tquery(\">\", htmlNode).place(script, \"before\")\r\n\t\tscript.parentNode.removeChild(script);\r\n\t\treturn ret;\r\n\t};\r\n\t\r\n\t/**\r\n\t * Given an XML node converts it to HTML where the existing HTML\r\n\t * is preserved and the dojo widget tags are converted to divs\r\n\t * with dojoType on them.\r\n\t */\r\n\tthis.toHTML = function (/*XmlNode*/ node){\r\n\t\tvar newNode;\r\n\t\tvar nodeName = node.nodeName;\r\n\t\tvar dd = window.doc;\r\n\t\tvar type = node.nodeType;\r\n\t\t\r\n\t\t\r\n\t\t///node type 3 and 4 are text and cdata\r\n\t\tif(type >= 3){\r\n\t\t\treturn dd.createTextNode( (type == 3 || type == 4) ? node.nodeValue : \"\" );\r\n\t\t}\r\n\t\t\r\n\t\tvar localName = node.localName||nodeName.split(\":\").pop();\r\n\t\t\r\n\t\t//TODO:\r\n\t\t//\t\tonly check for namespace ONCE ever, instead of each time here,\r\n\t\t//\t\tby mixing in the right check for each browser?\r\n\t\tvar namespace = node.namespaceURI || (node.getNamespaceUri ? node.getNamespaceUri() : \"\");\r\n\t\t\r\n\t\t//TODO check for some real namespace\r\n\t\tif(namespace == \"html\"){\r\n\t\t\tnewNode = dd.createElement(localName);\r\n\t\t}else{\r\n\t\t\tvar dojoType = namespace + \".\" + localName;\r\n\t\t\t\r\n\t\t\t/**\r\n\t\t\t * This is a horrible hack we need because creating a <div>\r\n\t\t\t * with <option> children doesn't work well. Specifically with\r\n\t\t\t * dojo.Declaration at some point the <option> tags get lost\r\n\t\t\t * entirely so we need the parent of <option> tags to be <select>\r\n\t\t\t * tags. (Not a problem outside of dojo.Delcaration)\r\n\t\t\t * There are a couple other ways we could do this:\r\n\t\t\t * 1. Look at the first element child to see if it is an option and\r\n\t\t\t * if so create a <select> here.\r\n\t\t\t * 2. When we add a child to parent fix up the parent then if the\r\n\t\t\t * child is an <option> and the parent isn't a <select>.\r\n\t\t\t * Both of those are a bit messy and slower than this.\r\n\t\t\t *\r\n\t\t\t * This is potentially a problem for other tag combinations as well,\r\n\t\t\t * such as <tr> under a <table> or <li> under a <ul>/<ol>.\r\n\t\t\t * (dojox.widget.SortList for example). Probably need a robust strategy for\r\n\t\t\t * dealing with this. Worst case scenario for now is that user has to use\r\n\t\t\t * html tag with dojoType for misbehaving widget.\r\n\t\t\t */\r\n\t\t\tnewNode = newNode || dd.createElement((dojoType == \"dijit.form.ComboBox\") ? \"select\" : \"div\");\r\n\t\t\tnewNode.setAttribute(\"dojoType\", dojoType);\r\n\t\t}\r\n\t\t\r\n\t\t// TODO:\r\n\t\t//\t\twe should probably set this up different, mixin a function\r\n\t\t//\t\tdepending on if it is IE rather than checking every time here\r\n\t\t//\t\tthe xmlns problem and the style problem are both IE specific\r\n\t\td.forEach(node.attributes, function(attr){\r\n\t\t\t// NOTE: IE always iterates *all* properties!!!\r\n\t\t\tvar name = attr.name || attr.nodeName;\r\n\t\t\tvar value = attr.value || attr.nodeValue;\r\n\t\t\tif(name.indexOf(\"xmlns\") != 0){\r\n\t\t\t\t// style=blah blah blah is a problem, in IE if you use\r\n\t\t\t\t// setAttribute here you get all sorts of problems. Maybe it\r\n\t\t\t\t// would be better to just create a giant string of HTML\r\n\t\t\t\t// instead of an object graph, then set innerHTML on something\r\n\t\t\t\t// to get the object graph? That might be cleaner...  that way\r\n\t\t\t\t// is uses the browser HTML parsing exactly at is and won't\r\n\t\t\t\t// cause any sort of issues. We could just special case style\r\n\t\t\t\t// as well?\r\n\t\t\t\tif(has(\"ie\") && name == \"style\"){\r\n\t\t\t\t\tnewNode.style.setAttribute(\"cssText\", value);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tnewNode.setAttribute(name, value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\td.forEach(node.childNodes, function(cn){\r\n\t\t\tvar childNode = this.toHTML(cn);\r\n\t\t\t\r\n\t\t\t// script tags in IE don't like appendChild, innerHTML or innerText\r\n\t\t\t// so if we are creating one programatically set text instead\r\n\t\t\t// could special case this for IE only\r\n\t\t\tif(localName == \"script\"){\r\n\t\t\t\tnewNode.text += childNode.nodeValue;\r\n\t\t\t}else{\r\n\t\t\t\tnewNode.appendChild(childNode);\r\n\t\t\t}\r\n\t\t}, this);\r\n\t\treturn newNode;\r\n\t};\r\n\t\r\n}();\r\n\r\nreturn dXml.widgetParser;\r\n\r\n});\r\n"]}