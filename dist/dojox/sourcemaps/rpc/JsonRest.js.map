{"version":3,"sources":["rpc/JsonRest.js"],"names":["define","dojo","dojox","jr","dirtyObjects","Rest","rpc","resolveJson","service","deferred","value","defaultId","timeStamp","ioArgs","xhr","getResponseHeader","_timeStamps","hrefProperty","_schema","json","ref","refAttribute","index","_index","timeStamps","time","idPrefix","_store","allowNoTrailingSlash","servicePath","replace","idAttribute","getIdAttribute","schemas","loader","_loader","idAsRef","assignAbsoluteIds","JsonRest","serviceClass","conflictDateHeader","commit","kwArgs","actions","alreadyRecorded","savingObjects","i","length","dirty","object","old","__id","indexOf","save","__isDirty","pathParts","match","incrementalUpdates","incremental","j","hasOwnProperty","push","method","target","content","getServiceAndId","alwaysPostNewItems","splice","connect","revertOnError","postCommitDirtyObjects","revert","forEach","obj","changing","sendToServer","contentLocation","plainXhr","left","this","args","headers","apply","arguments","action","_contentId","isPost","Date","serviceAndId","dfd","id","toJson","addCallback","newId","startIndex","substring","e","onComplete","call","scope","addErrback","onError","getDirtyObjects","store","data","_getStoreForItem","onSet","onNew","onDelete","_deleting","_saveNotNeeded","Array","deleteObject","getConstructor","schema","registerService","_constructor","properties","initializeCalled","self","addDefaults","propDef","prototype","initialize","mixin","__clientId","Math","random","toString","Client","clientId","mustBeValid","validate","load","fetch","absoluteId","byId","idAttr","_idAttr","identity","link","serviceName","services","parts","result","_loadObject","Deferred","callback","query","nodeType","cloneNode","start","count","undefined","addBoth","$ref","isDirty","item","some"],"mappings":"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","file":"../../rpc/JsonRest.js","sourcesContent":["define(\"dojox/rpc/JsonRest\", [\"dojo\", \"dojox\", \"dojox/json/ref\", \"dojox/rpc/Rest\"], function(dojo, dojox) {\r\n\tvar dirtyObjects = [];\r\n\tvar Rest = dojox.rpc.Rest;\r\n\tvar jr;\r\n\tfunction resolveJson(service, deferred, value, defaultId){\r\n\t\tvar timeStamp = deferred.ioArgs && deferred.ioArgs.xhr && deferred.ioArgs.xhr.getResponseHeader(\"Last-Modified\");\r\n\t\tif(timeStamp && Rest._timeStamps){\r\n\t\t\tRest._timeStamps[defaultId] = timeStamp;\r\n\t\t}\r\n\t\tvar hrefProperty = service._schema && service._schema.hrefProperty;\r\n\t\tif(hrefProperty){\r\n\t\t\tdojox.json.ref.refAttribute = hrefProperty;\r\n\t\t}\r\n\t\tvalue = value && dojox.json.ref.resolveJson(value, {\r\n\t\t\tdefaultId: defaultId,\r\n\t\t\tindex: Rest._index,\r\n\t\t\ttimeStamps: timeStamp && Rest._timeStamps,\r\n\t\t\ttime: timeStamp,\r\n\t\t\tidPrefix: service._store.allowNoTrailingSlash ? service.servicePath + '/' : service.servicePath.replace(/[^\\/]*$/,''),\r\n\t\t\tidAttribute: jr.getIdAttribute(service),\r\n\t\t\tschemas: jr.schemas,\r\n\t\t\tloader:\tjr._loader,\r\n\t\t\tidAsRef: service.idAsRef,\r\n\t\t\tassignAbsoluteIds: true\r\n\t\t});\r\n\t\tdojox.json.ref.refAttribute  = \"$ref\";\r\n\t\treturn value;\r\n\t}\r\n\tjr = dojox.rpc.JsonRest={\r\n\t\tserviceClass: dojox.rpc.Rest,\r\n\t\tconflictDateHeader: \"If-Unmodified-Since\",\r\n\t\tcommit: function(kwArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSaves the dirty data using REST Ajax methods\r\n\r\n\t\t\tkwArgs = kwArgs || {};\r\n\t\t\tvar actions = [];\r\n\t\t\tvar alreadyRecorded = {};\r\n\t\t\tvar savingObjects = [];\r\n\t\t\tfor(var i = 0; i < dirtyObjects.length; i++){\r\n\t\t\t\tvar dirty = dirtyObjects[i];\r\n\t\t\t\tvar object = dirty.object;\r\n\t\t\t\tvar old = dirty.old;\r\n\t\t\t\tvar append = false;\r\n\t\t\t\tif(!(kwArgs.service && (object || old) &&\r\n\t\t\t\t\t\t(object || old).__id.indexOf(kwArgs.service.servicePath)) && dirty.save){\r\n\t\t\t\t\tdelete object.__isDirty;\r\n\t\t\t\t\tif(object){\r\n\t\t\t\t\t\tif(old){\r\n\t\t\t\t\t\t\t// changed object\r\n\t\t\t\t\t\t\tvar pathParts;\r\n\t\t\t\t\t\t\tif((pathParts = object.__id.match(/(.*)#.*/))){ // it is a path reference\r\n\t\t\t\t\t\t\t\t// this means it is a sub object, we must go to the parent object and save it\r\n\t\t\t\t\t\t\t\tobject = Rest._index[pathParts[1]];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(!(object.__id in alreadyRecorded)){// if it has already been saved, we don't want to repeat it\r\n\t\t\t\t\t\t\t\t// record that we are saving\r\n\t\t\t\t\t\t\t\talreadyRecorded[object.__id] = object;\r\n\t\t\t\t\t\t\t\tif(kwArgs.incrementalUpdates\r\n\t\t\t\t\t\t\t\t\t&& !pathParts){ // I haven't figured out how we would do incremental updates on sub-objects yet\r\n\t\t\t\t\t\t\t\t\t// make an incremental update using a POST\r\n\t\t\t\t\t\t\t\t\tvar incremental = (typeof kwArgs.incrementalUpdates == 'function' ?\r\n\t\t\t\t\t\t\t\t\t\tkwArgs.incrementalUpdates : function(){\r\n\t\t\t\t\t\t\t\t\t\t\tincremental = {};\r\n\t\t\t\t\t\t\t\t\t\t\tfor(var j in object){\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(object.hasOwnProperty(j)){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(object[j] !== old[j]){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tincremental[j] = object[j];\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}else if(old.hasOwnProperty(j)){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// we can't use incremental updates to remove properties\r\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn null;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\treturn incremental;\r\n\t\t\t\t\t\t\t\t\t\t})(object, old);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif(incremental){\r\n\t\t\t\t\t\t\t\t\tactions.push({method:\"post\",target:object, content: incremental});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t\t\tactions.push({method:\"put\",target:object,content:object});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// new object\r\n\t\t\t\t\t\t\tvar service = jr.getServiceAndId(object.__id).service;\r\n\t\t\t\t\t\t\tvar idAttribute = jr.getIdAttribute(service);\r\n\t\t\t\t\t\t\tif((idAttribute in object) && !kwArgs.alwaysPostNewItems){\r\n\t\t\t\t\t\t\t\t// if the id attribute is specified, then we should know the location\r\n\t\t\t\t\t\t\t\tactions.push({method:\"put\",target:object, content:object});\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tactions.push({method:\"post\",target:{__id:service.servicePath},\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontent:object});\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(old){\r\n\t\t\t\t\t\t// deleted object\r\n\t\t\t\t\t\tactions.push({method:\"delete\",target:old});\r\n\t\t\t\t\t}//else{ this would happen if an object is created and then deleted, don't do anything\r\n\t\t\t\t\tsavingObjects.push(dirty);\r\n\t\t\t\t\tdirtyObjects.splice(i--,1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdojo.connect(kwArgs,\"onError\",function(){\r\n\t\t\t\tif(kwArgs.revertOnError !== false){\r\n\t\t\t\t\tvar postCommitDirtyObjects = dirtyObjects;\r\n\t\t\t\t\tdirtyObjects = savingObjects;\r\n\t\t\t\t\tvar numDirty = 0; // make sure this doesn't do anything if it is called again\r\n\t\t\t\t\tjr.revert(); // revert if there was an error\r\n\t\t\t\t\tdirtyObjects = postCommitDirtyObjects;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tdojo.forEach(savingObjects, function(obj) {\r\n\t\t\t\t\t\tjr.changing(obj.object, !obj.object);\r\n\t\t\t\t    });\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tjr.sendToServer(actions, kwArgs);\r\n\t\t\treturn actions;\r\n\t\t},\r\n\t\tsendToServer: function(actions, kwArgs){\r\n\t\t\tvar xhrSendId;\r\n\t\t\tvar plainXhr = dojo.xhr;\r\n\t\t\tvar left = actions.length;// this is how many changes are remaining to be received from the server\r\n\t\t\tvar i, contentLocation;\r\n\t\t\tvar timeStamp;\r\n\t\t\tvar conflictDateHeader = this.conflictDateHeader;\r\n\t\t\t// add headers for extra information\r\n\t\t\tdojo.xhr = function(method,args){\r\n\t\t\t\t// keep the transaction open as we send requests\r\n\t\t\t\targs.headers = args.headers || {};\r\n\t\t\t\t// the last one should commit the transaction\r\n\t\t\t\targs.headers['Transaction'] = actions.length - 1 == i ? \"commit\" : \"open\";\r\n\t\t\t\tif(conflictDateHeader && timeStamp){\r\n\t\t\t\t\targs.headers[conflictDateHeader] = timeStamp;\r\n\t\t\t\t}\r\n\t\t\t\tif(contentLocation){\r\n\t\t\t\t\targs.headers['Content-ID'] = '<' + contentLocation + '>';\r\n\t\t\t\t}\r\n\t\t\t\treturn plainXhr.apply(dojo,arguments);\r\n\t\t\t};\r\n\t\t\tfor(i =0; i < actions.length;i++){ // iterate through the actions to execute\r\n\t\t\t\tvar action = actions[i];\r\n\t\t\t\tdojox.rpc.JsonRest._contentId = action.content && action.content.__id; // this is used by OfflineRest\r\n\t\t\t\tvar isPost = action.method == 'post';\r\n\t\t\t\ttimeStamp = action.method == 'put' && Rest._timeStamps[action.content.__id];\r\n\t\t\t\tif(timeStamp){\r\n\t\t\t\t\t// update it now\r\n\t\t\t\t\tRest._timeStamps[action.content.__id] = (new Date()) + '';\r\n\t\t\t\t}\r\n\t\t\t\t// send the content location to the server\r\n\t\t\t\tcontentLocation = isPost && dojox.rpc.JsonRest._contentId;\r\n\t\t\t\tvar serviceAndId = jr.getServiceAndId(action.target.__id);\r\n\t\t\t\tvar service = serviceAndId.service;\r\n\t\t\t\tvar dfd = action.deferred = service[action.method](\r\n\t\t\t\t\t\t\t\t\tserviceAndId.id.replace(/#/,''), // if we are using references, we need eliminate #\r\n\t\t\t\t\t\t\t\t\tdojox.json.ref.toJson(action.content, false, service.servicePath, true)\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t(function(object, dfd, service){\r\n\t\t\t\t\tdfd.addCallback(function(value){\r\n\t\t\t\t\t\ttry{\r\n\t\t\t\t\t\t\t// Implements id assignment per the HTTP specification\r\n\t\t\t\t\t\t\tvar newId = dfd.ioArgs.xhr && dfd.ioArgs.xhr.getResponseHeader(\"Location\");\r\n\t\t\t\t\t\t\t//TODO: match URLs if the servicePath is relative...\r\n\t\t\t\t\t\t\tif(newId){\r\n\t\t\t\t\t\t\t\t// if the path starts in the middle of an absolute URL for Location, we will use the just the path part\r\n\t\t\t\t\t\t\t\tvar startIndex = newId.match(/(^\\w+:\\/\\/)/) && newId.indexOf(service.servicePath);\r\n\t\t\t\t\t\t\t\tnewId = startIndex > 0 ? newId.substring(startIndex) : (service.servicePath + newId).\r\n\t\t\t\t\t\t\t\t\t\t// now do simple relative URL resolution in case of a relative URL.\r\n\t\t\t\t\t\t\t\t\t\treplace(/^(.*\\/)?(\\w+:\\/\\/)|[^\\/\\.]+\\/\\.\\.\\/|^.*\\/(\\/)/,'$2$3');\r\n\t\t\t\t\t\t\t\tobject.__id = newId;\r\n\t\t\t\t\t\t\t\tRest._index[newId] = object;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvalue = resolveJson(service, dfd, value, object && object.__id);\r\n\t\t\t\t\t\t}catch(e){}\r\n\t\t\t\t\t\tif(!(--left)){\r\n\t\t\t\t\t\t\tif(kwArgs.onComplete){\r\n\t\t\t\t\t\t\t\tkwArgs.onComplete.call(kwArgs.scope, actions);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn value;\r\n\t\t\t\t\t});\r\n\t\t\t\t})(action.content, dfd, service);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\tdfd.addErrback(function(value){\r\n\t\t\t\t\t\r\n\t\t\t\t\t// on an error we want to revert, first we want to separate any changes that were made since the commit\r\n\t\t\t\t\tleft = -1; // first make sure that success isn't called\r\n\t\t\t\t\tkwArgs.onError.call(kwArgs.scope, value);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t// revert back to the normal XHR handler\r\n\t\t\tdojo.xhr = plainXhr;\r\n\t\t\t\r\n\t\t},\r\n\t\tgetDirtyObjects: function(){\r\n\t\t\treturn dirtyObjects;\r\n\t\t},\r\n\t\trevert: function(service){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReverts all the changes made to JSON/REST data\r\n\t\t\tfor(var i = dirtyObjects.length; i > 0;){\r\n\t\t\t\ti--;\r\n\t\t\t\tvar dirty = dirtyObjects[i];\r\n\t\t\t\tvar object = dirty.object;\r\n\t\t\t\tvar old = dirty.old;\r\n\t\t\t\tvar store = dojox.data._getStoreForItem(object || old);\r\n\t\t\t\t\r\n\t\t\t\tif(!(service && (object || old) &&\r\n\t\t\t\t\t(object || old).__id.indexOf(service.servicePath))){\r\n\t\t\t\t\t// if we are in the specified store or if this is a global revert\r\n\t\t\t\t\tif(object && old){\r\n\t\t\t\t\t\t// changed\r\n\t\t\t\t\t\tfor(var j in old){\r\n\t\t\t\t\t\t\tif(old.hasOwnProperty(j) && object[j] !== old[j]){\r\n\t\t\t\t\t\t\t\tif(store){\r\n\t\t\t\t\t\t\t\t\tstore.onSet(object, j, object[j], old[j]);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tobject[j] = old[j];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor(j in object){\r\n\t\t\t\t\t\t\tif(!old.hasOwnProperty(j)){\r\n\t\t\t\t\t\t\t\tif(store){\r\n\t\t\t\t\t\t\t\t\tstore.onSet(object, j, object[j]);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdelete object[j];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(!old){\r\n\t\t\t\t\t\t// was an addition, remove it\r\n\t\t\t\t\t\tif(store){\r\n\t\t\t\t\t\t\tstore.onDelete(object);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// was a deletion, we will add it back\r\n\t\t\t\t\t\tif(store){\r\n\t\t\t\t\t\t\tstore.onNew(old);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdelete (object || old).__isDirty;\r\n\t\t\t\t\tdirtyObjects.splice(i, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tchanging: function(object,_deleting){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tadds an object to the list of dirty objects.  This object\r\n\t\t\t//\t\tcontains a reference to the object itself as well as a\r\n\t\t\t//\t\tcloned and trimmed version of old object for use with\r\n\t\t\t//\t\trevert.\r\n\t\t\tif(!object.__id){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tobject.__isDirty = true;\r\n\t\t\t//if an object is already in the list of dirty objects, don't add it again\r\n\t\t\t//or it will overwrite the premodification data set.\r\n\t\t\tfor(var i=0; i<dirtyObjects.length; i++){\r\n\t\t\t\tvar dirty = dirtyObjects[i];\r\n\t\t\t\tif(object==dirty.object){\r\n\t\t\t\t\tif(_deleting){\r\n\t\t\t\t\t\t// we are deleting, no object is an indicator of deletiong\r\n\t\t\t\t\t\tdirty.object = false;\r\n\t\t\t\t\t\tif(!this._saveNotNeeded){\r\n\t\t\t\t\t\t\tdirty.save = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar old = object instanceof Array ? [] : {};\r\n\t\t\tfor(i in object){\r\n\t\t\t\tif(object.hasOwnProperty(i)){\r\n\t\t\t\t\told[i] = object[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdirtyObjects.push({object: !_deleting && object, old: old, save: !this._saveNotNeeded});\r\n\t\t},\r\n\t\tdeleteObject: function(object){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tdeletes an object\r\n\t\t\t// object:\r\n\t\t\t//\t\tobject to delete\r\n\t\t\tthis.changing(object,true);\r\n\t\t},\r\n\t\tgetConstructor: function(/*Function|String*/service, schema){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreates or gets a constructor for objects from this service\r\n\t\t\tif(typeof service == 'string'){\r\n\t\t\t\tvar servicePath = service;\r\n\t\t\t\tservice = new dojox.rpc.Rest(service,true);\r\n\t\t\t\tthis.registerService(service, servicePath, schema);\r\n\t\t\t}\r\n\t\t\tif(service._constructor){\r\n\t\t\t\treturn service._constructor;\r\n\t\t\t}\r\n\t\t\tservice._constructor = function(data){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tcreates a new object for this table\r\n\t\t\t\t// data:\r\n\t\t\t\t//\t\tobject to mixed in\r\n\t\t\t\tvar self = this;\r\n\t\t\t\tvar args = arguments;\r\n\t\t\t\tvar properties;\r\n\t\t\t\tvar initializeCalled;\r\n\t\t\t\tfunction addDefaults(schema){\r\n\t\t\t\t\tif(schema){\r\n\t\t\t\t\t\taddDefaults(schema['extends']);\r\n\t\t\t\t\t\tproperties = schema.properties;\r\n\t\t\t\t\t\tfor(var i in properties){\r\n\t\t\t\t\t\t\tvar propDef = properties[i];\r\n\t\t\t\t\t\t\tif(propDef && (typeof propDef == 'object') && (\"default\" in propDef)){\r\n\t\t\t\t\t\t\t\tself[i] = propDef[\"default\"];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(schema && schema.prototype && schema.prototype.initialize){\r\n\t\t\t\t\t\tinitializeCalled = true;\r\n\t\t\t\t\t\tschema.prototype.initialize.apply(self, args);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\taddDefaults(service._schema);\r\n\t\t\t\tif(!initializeCalled && data && typeof data == 'object'){\r\n\t\t\t\t\tdojo.mixin(self,data);\r\n\t\t\t\t}\r\n\t\t\t\tvar idAttribute = jr.getIdAttribute(service);\r\n\t\t\t\tRest._index[this.__id = this.__clientId =\r\n\t\t\t\t\t\tservice.servicePath + (this[idAttribute] ||\r\n\t\t\t\t\t\t\tMath.random().toString(16).substring(2,14) + '@' + ((dojox.rpc.Client && dojox.rpc.Client.clientId) || \"client\"))] = this;\r\n\t\t\t\tif(dojox.json.schema && properties){\r\n\t\t\t\t\tdojox.json.schema.mustBeValid(dojox.json.schema.validate(this, service._schema));\r\n\t\t\t\t}\r\n\t\t\t\tdirtyObjects.push({object:this, save: true});\r\n\t\t\t};\r\n\t\t\treturn dojo.mixin(service._constructor, service._schema, {load:service});\r\n\t\t},\r\n\t\tfetch: function(absoluteId){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFetches a resource by an absolute path/id and returns a dojo.Deferred.\r\n\t\t\tvar serviceAndId = jr.getServiceAndId(absoluteId);\r\n\t\t\treturn this.byId(serviceAndId.service,serviceAndId.id);\r\n\t\t},\r\n\t\tgetIdAttribute: function(service){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn the ids attribute used by this service (based on it's schema).\r\n\t\t\t//\t\tDefaults to \"id\", if not other id is defined\r\n\t\t\tvar schema = service._schema;\r\n\t\t\tvar idAttr;\r\n\t\t\tif(schema){\r\n\t\t\t\tif(!(idAttr = schema._idAttr)){\r\n\t\t\t\t\tfor(var i in schema.properties){\r\n\t\t\t\t\t\tif(schema.properties[i].identity || (schema.properties[i].link == \"self\")){\r\n\t\t\t\t\t\t\tschema._idAttr = idAttr = i;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn idAttr || 'id';\r\n\t\t},\r\n\t\tgetServiceAndId: function(/*String*/absoluteId){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the REST service and the local id for the given absolute id. The result\r\n\t\t\t//\t\tis returned as an object with a service property and an id property\r\n\t\t\t// absoluteId:\r\n\t\t\t//\t\tThis is the absolute id of the object\r\n\t\t\tvar serviceName = '';\r\n\t\t\t\r\n\t\t\tfor(var service in jr.services){\r\n\t\t\t\tif((absoluteId.substring(0, service.length) == service) && (service.length >= serviceName.length)){\r\n\t\t\t\t\tserviceName = service;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (serviceName){\r\n\t\t\t\treturn {service: jr.services[serviceName], id:absoluteId.substring(serviceName.length)};\r\n\t\t\t}\r\n\t\t\tvar parts = absoluteId.match(/^(.*\\/)([^\\/]*)$/);\r\n\t\t\treturn {service: new jr.serviceClass(parts[1], true), id:parts[2]};\r\n\t\t},\r\n\t\tservices:{},\r\n\t\tschemas:{},\r\n\t\tregisterService: function(/*Function*/ service, /*String*/ servicePath, /*Object?*/ schema){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRegisters a service for as a JsonRest service, mapping it to a path and schema\r\n\t\t\t// service:\r\n\t\t\t//\t\tThis is the service to register\r\n\t\t\t// servicePath:\r\n\t\t\t//\t\tThis is the path that is used for all the ids for the objects returned by service\r\n\t\t\t// schema:\r\n\t\t\t//\t\tThis is a JSON Schema object to associate with objects returned by this service\r\n\t\t\tservicePath = service.servicePath = servicePath || service.servicePath;\r\n\t\t\tservice._schema = jr.schemas[servicePath] = schema || service._schema || {};\r\n\t\t\tjr.services[servicePath] = service;\r\n\t\t},\r\n\t\tbyId: function(service, id){\r\n\t\t\t// if caching is allowed, we look in the cache for the result\r\n\t\t\tvar deferred, result = Rest._index[(service.servicePath || '') + id];\r\n\t\t\tif(result && !result._loadObject){// cache hit\r\n\t\t\t\tdeferred = new dojo.Deferred();\r\n\t\t\t\tdeferred.callback(result);\r\n\t\t\t\treturn deferred;\r\n\t\t\t}\r\n\t\t\treturn this.query(service, id);\r\n\t\t},\r\n\t\tquery: function(service, id, args){\r\n\t\t\tvar deferred = service(id, args);\r\n\t\t\t\r\n\t\t\tdeferred.addCallback(function(result){\r\n\t\t\t\tif(result.nodeType && result.cloneNode){\r\n\t\t\t\t\t// return immediately if it is an XML document\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\treturn resolveJson(service, deferred, result, typeof id != 'string' || (args && (args.start || args.count)) ? undefined: id);\r\n\t\t\t});\r\n\t\t\treturn deferred;\r\n\t\t},\r\n\t\t_loader: function(callback){\r\n\t\t\t// load a lazy object\r\n\t\t\tvar serviceAndId = jr.getServiceAndId(this.__id);\r\n\t\t\tvar self = this;\r\n\t\t\tjr.query(serviceAndId.service, serviceAndId.id).addBoth(function(result){\r\n\t\t\t\t// if they are the same this means an object was loaded, otherwise it\r\n\t\t\t\t// might be a primitive that was loaded or maybe an error\r\n\t\t\t\tif(result == self){\r\n\t\t\t\t\t// we can clear the flag, so it is a loaded object\r\n\t\t\t\t\tdelete result.$ref;\r\n\t\t\t\t\tdelete result._loadObject;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// it is probably a primitive value, we can't change the identity of an object to\r\n\t\t\t\t\t//\tthe loaded value, so we will keep it lazy, but define the lazy loader to always\r\n\t\t\t\t\t//\treturn the loaded value\r\n\t\t\t\t\tself._loadObject = function(callback){\r\n\t\t\t\t\t\tcallback(result);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t\tcallback(result);\r\n\t\t\t});\r\n\t\t},\r\n\t\tisDirty: function(item, store){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns true if the item is marked as dirty or true if there are any dirty items\r\n\t\t\tif(!item){\r\n\t\t\t\tif(store){\r\n\t\t\t\t\treturn dojo.some(dirtyObjects, function(dirty){\r\n\t\t\t\t\t\treturn dojox.data._getStoreForItem(dirty.object || dirty.old) == store;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\treturn !!dirtyObjects.length;\r\n\t\t\t}\r\n\t\t\treturn item.__isDirty;\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n\treturn dojox.rpc.JsonRest;\r\n});\r\n\r\n"]}