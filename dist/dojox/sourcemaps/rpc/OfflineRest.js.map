{"version":3,"sources":["rpc/OfflineRest.js"],"names":["define","dojo","dojox","loaded","dontSave","OfflineRest","Rest","rpc","namespace","index","_index","getStorageKey","key","replace","saveObject","object","id","__id","storage","put","json","ref","toJson","isNetworkError","error","Error","status","sendChanges","dirty","get","dirtyId","commitDirty","sync","downloadChanges","manager","addOnLoad","i","available","syncId","setInterval","connect","document","turnOffAutoSync","clearInterval","addStore","store","baseQuery","stores","push","fetch","queryOptions","cache","query","onComplete","results","args","_localBaseResults","_localBaseFetch","defaultGet","_get","changeOccurred","method","absoluteId","contentId","serializedContent","service","remove","_store","updateResultSet","_getRequest","url","window","navigator","onLine","dfd","e","Deferred","errback","_sync","addCallback","result","addErrback","loadedObjects","byId","backup","fromJson","val","$ref","substring","Array","length","undefined","splice","arguments","callee","callback","data","message","channel","event","toLowerCase","JsonRest","getServiceAndId","defaultChange","_change","dirtyItem","serviceAndId","deferred","content","addBoth","apply","this","_contentId","isNaN","parseInt"],"mappings":"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","file":"../../rpc/OfflineRest.js","sourcesContent":["define(\"dojox/rpc/OfflineRest\", [\"dojo\", \"dojox\", \"dojox/data/ClientFilter\", \"dojox/rpc/Rest\", \"dojox/storage\"], function(dojo, dojox) {\r\n\r\n\tvar Rest = dojox.rpc.Rest;\r\n\tvar namespace = \"dojox_rpc_OfflineRest\";\r\n\tvar loaded;\r\n\tvar index = Rest._index;\r\n\tdojox.storage.manager.addOnLoad(function(){\r\n\t\t// now that we are loaded we need to save everything in the index\r\n\t\tloaded = dojox.storage.manager.available;\r\n\t\tfor(var i in index){\r\n\t\t\tsaveObject(index[i], i);\r\n\t\t}\r\n\t});\r\n\tvar dontSave;\r\n\tfunction getStorageKey(key){\r\n\t\t// returns a key that is safe to use in storage\r\n\t\treturn key.replace(/[^0-9A-Za-z_]/g,'_');\r\n\t}\r\n\tfunction saveObject(object,id){\r\n\t\t// save the object into local storage\r\n\t\t\r\n\t\tif(loaded && !dontSave && (id || (object && object.__id))){\r\n\t\t\tdojox.storage.put(\r\n\t\t\t\t\tgetStorageKey(id||object.__id),\r\n\t\t\t\t\ttypeof object=='object'?dojox.json.ref.toJson(object):object, // makeshift technique to determine if the object is json object or not\r\n\t\t\t\t\tfunction(){},\r\n\t\t\t\t\tnamespace);\r\n\t\t}\r\n\t}\r\n\tfunction isNetworkError(error){\r\n\t\t//\tdetermine if the error was a network error and should be saved offline\r\n\t\t// \tor if it was a server error and not a result of offline-ness\r\n\t\treturn error instanceof Error && (error.status == 503 || error.status > 12000 ||  !error.status); // TODO: Make the right error determination\r\n\t}\r\n\tfunction sendChanges(){\r\n\t\t// periodical try to save our dirty data\r\n\t\tif(loaded){\r\n\t\t\tvar dirty = dojox.storage.get(\"dirty\",namespace);\r\n\t\t\tif(dirty){\r\n\t\t\t\tfor (var dirtyId in dirty){\r\n\t\t\t\t\tcommitDirty(dirtyId,dirty);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tvar OfflineRest;\r\n\tfunction sync(){\r\n\t\tOfflineRest.sendChanges();\r\n\t\tOfflineRest.downloadChanges();\r\n\t}\r\n\tvar syncId = setInterval(sync,15000);\r\n\tdojo.connect(document, \"ononline\", sync);\r\n\tOfflineRest = dojox.rpc.OfflineRest = {\r\n\t\t// summary:\r\n\t\t//\t\tMakes the REST service be able to store changes in local\r\n\t\t//\t\tstorage so it can be used offline automatically.\r\n\r\n\t\tturnOffAutoSync: function(){\r\n\t\t\tclearInterval(syncId);\r\n\t\t},\r\n\t\tsync: sync,\r\n\t\tsendChanges: sendChanges,\r\n\t\tdownloadChanges: function(){\r\n\t\t\t\r\n\t\t},\r\n\t\taddStore: function(/*data-store*/store,/*query?*/baseQuery){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdds a store to the monitored store for local storage\r\n\t\t\t// store:\r\n\t\t\t//\t\tStore to add\r\n\t\t\t// baseQuery:\r\n\t\t\t//\t\tThis is the base query to should be used to load the items for\r\n\t\t\t//\t\tthe store. Generally you want to load all the items that should be\r\n\t\t\t//\t\tavailable when offline.\r\n\t\t\tOfflineRest.stores.push(store);\r\n\t\t\tstore.fetch({queryOptions:{cache:true},query:baseQuery,onComplete:function(results,args){\r\n\t\t\t\tstore._localBaseResults = results;\r\n\t\t\t\tstore._localBaseFetch = args;\r\n\t\t\t}});\r\n\t\t\t\t\t\t\r\n\t\t}\r\n\t};\r\n\tOfflineRest.stores = [];\r\n\tvar defaultGet = Rest._get;\r\n\tRest._get = function(service, id){\r\n\t\t// We specifically do NOT want the paging information to be used by the default handler,\r\n\t\t// this is because online apps want to minimize the data transfer,\r\n\t\t// but an offline app wants the opposite, as much data as possible transferred to\r\n\t\t// the client side\r\n\t\ttry{\r\n\t\t\t// if we are reloading the application with local dirty data in an online environment\r\n\t\t\t//\twe want to make sure we save the changes first, so that we get up-to-date\r\n\t\t\t//\tinformation from the server\r\n\t\t\tsendChanges();\r\n\t\t\tif(window.navigator && navigator.onLine===false){\r\n\t\t\t\t// we force an error if we are offline in firefox, otherwise it will silently load it from the cache\r\n\t\t\t\tthrow new Error();\r\n\t\t\t}\r\n\t\t\tvar dfd = defaultGet(service, id);\r\n\t\t}catch(e){\r\n\t\t\tdfd = new dojo.Deferred();\r\n\t\t\tdfd.errback(e);\r\n\t\t}\r\n\t\tvar sync = dojox.rpc._sync;\r\n\t\tdfd.addCallback(function(result){\r\n\t\t\tsaveObject(result, service._getRequest(id).url);\r\n\t\t\treturn result;\r\n\t\t});\r\n\t\tdfd.addErrback(function(error){\r\n\t\t\tif(loaded){\r\n\t\t\t\t// if the storage is loaded, we can go ahead and get the object out of storage\r\n\t\t\t\tif(isNetworkError(error)){\r\n\t\t\t\t\tvar loadedObjects = {};\r\n\t\t\t\t\t// network error, load from local storage\r\n\t\t\t\t\tvar byId = function(id,backup){\r\n\t\t\t\t\t\tif(loadedObjects[id]){\r\n\t\t\t\t\t\t\treturn backup;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar result = dojo.fromJson(dojox.storage.get(getStorageKey(id),namespace)) || backup;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tloadedObjects[id] = result;\r\n\t\t\t\t\t\tfor(var i in result){\r\n\t\t\t\t\t\t\tvar val = result[i]; // resolve references if we can\r\n\t\t\t\t\t\t\tid = val && val.$ref;\r\n\t\t\t\t\t\t\tif (id){\r\n\t\t\t\t\t\t\t\tif(id.substring && id.substring(0,4) == \"cid:\"){\r\n\t\t\t\t\t\t\t\t\t// strip the cid scheme, we should be able to resolve it locally\r\n\t\t\t\t\t\t\t\t\tid = id.substring(4);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tresult[i] = byId(id,val);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (result instanceof Array){\r\n\t\t\t\t\t\t\t//remove any deleted items\r\n\t\t\t\t\t\t\tfor (i = 0;i<result.length;i++){\r\n\t\t\t\t\t\t\t\tif (result[i]===undefined){\r\n\t\t\t\t\t\t\t\t\tresult.splice(i--,1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t};\r\n\t\t\t\t\tdontSave = true; // we don't want to be resaving objects when loading from local storage\r\n\t\t\t\t\t//TODO: Should this reuse something from dojox.rpc.Rest\r\n\t\t\t\t\tvar result = byId(service._getRequest(id).url);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(!result){// if it is not found we have to just return the error\r\n\t\t\t\t\t\treturn error;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdontSave = false;\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\treturn error; // server error, let the error propagate\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif(sync){\r\n\t\t\t\t\treturn new Error(\"Storage manager not loaded, can not continue\");\r\n\t\t\t\t}\r\n\t\t\t\t// we are not loaded, so we need to defer until we are loaded\r\n\t\t\t\tdfd = new dojo.Deferred();\r\n\t\t\t\tdfd.addCallback(arguments.callee);\r\n\t\t\t\tdojox.storage.manager.addOnLoad(function(){\r\n\t\t\t\t\tdfd.callback();\r\n\t\t\t\t});\r\n\t\t\t\treturn dfd;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn dfd;\r\n\t};\r\n\tfunction changeOccurred(method, absoluteId, contentId, serializedContent, service){\r\n\t\tif(method=='delete'){\r\n\t\t\tdojox.storage.remove(getStorageKey(absoluteId),namespace);\r\n\t\t}\r\n\t\telse{\r\n\t\t\t// both put and post should store the actual object\r\n\t\t\tdojox.storage.put(getStorageKey(contentId), serializedContent, function(){\r\n\t\t\t},namespace);\r\n\t\t}\r\n\t\tvar store = service && service._store;\r\n\t\t// record all the updated queries\r\n\t\tif(store){\r\n\t\t\tstore.updateResultSet(store._localBaseResults, store._localBaseFetch);\r\n\t\t\tdojox.storage.put(getStorageKey(service._getRequest(store._localBaseFetch.query).url),dojox.json.ref.toJson(store._localBaseResults),function(){\r\n\t\t\t\t},namespace);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tdojo.addOnLoad(function(){\r\n\t\tdojo.connect(dojox.data, \"restListener\", function(message){\r\n\t\t\tvar channel = message.channel;\r\n\t\t\tvar method = message.event.toLowerCase();\r\n\t\t\tvar service = dojox.rpc.JsonRest && dojox.rpc.JsonRest.getServiceAndId(channel).service;\r\n\t\t\tchangeOccurred(\r\n\t\t\t\tmethod,\r\n\t\t\t\tchannel,\r\n\t\t\t\tmethod == \"post\" ? channel + message.result.id : channel,\r\n\t\t\t\tdojo.toJson(message.result),\r\n\t\t\t\tservice\r\n\t\t\t);\r\n\t\t\t\r\n\t\t});\r\n\t});\r\n\t//FIXME: Should we make changes after a commit to see if the server rejected the change\r\n\t// or should we come up with a revert mechanism?\r\n\tvar defaultChange = Rest._change;\r\n\tRest._change = function(method,service,id,serializedContent){\r\n\t\tif(!loaded){\r\n\t\t\treturn defaultChange.apply(this,arguments);\r\n\t\t}\r\n\t\tvar absoluteId = service._getRequest(id).url;\r\n\t\tchangeOccurred(method, absoluteId, dojox.rpc.JsonRest._contentId, serializedContent, service);\r\n\t\tvar dirty = dojox.storage.get(\"dirty\",namespace) || {};\r\n\t\tif (method=='put' || method=='delete'){\r\n\t\t\t// these supersede so we can overwrite anything using this id\r\n\t\t\tvar dirtyId = absoluteId;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tdirtyId = 0;\r\n\t\t\tfor (var i in dirty){\r\n\t\t\t\tif(!isNaN(parseInt(i))){\r\n\t\t\t\t\tdirtyId = i;\r\n\t\t\t\t}\r\n\t\t\t} // get the last dirtyId to make a unique id for non-idempotent methods\r\n\t\t\tdirtyId++;\r\n\t\t}\r\n\t\tdirty[dirtyId] = {method:method,id:absoluteId,content:serializedContent};\r\n\t\treturn commitDirty(dirtyId,dirty);\r\n\t};\r\n\tfunction commitDirty(dirtyId, dirty){\r\n\t\tvar dirtyItem = dirty[dirtyId];\r\n\t\tvar serviceAndId = dojox.rpc.JsonRest.getServiceAndId(dirtyItem.id);\r\n\t\tvar deferred = defaultChange(dirtyItem.method,serviceAndId.service,serviceAndId.id,dirtyItem.content);\r\n\t\t// add it to our list of dirty objects\r\n\t\tdirty[dirtyId] = dirtyItem;\r\n\t\tdojox.storage.put(\"dirty\",dirty,function(){},namespace);\r\n\t\tdeferred.addBoth(function(result){\r\n\t\t\tif (isNetworkError(result)){\r\n\t\t\t\t// if a network error (offlineness) was the problem, we leave it\r\n\t\t\t\t// dirty, and return to indicate successfulness\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t\t// it was successful or the server rejected it, we remove it from the dirty list\r\n\t\t\tvar dirty = dojox.storage.get(\"dirty\",namespace) || {};\r\n\t\t\tdelete dirty[dirtyId];\r\n\t\t\tdojox.storage.put(\"dirty\",dirty,function(){},namespace);\r\n\t\t\treturn result;\r\n\t\t});\r\n\t\treturn deferred;\r\n\t}\r\n\t\t\r\n\tdojo.connect(index,\"onLoad\",saveObject);\r\n\tdojo.connect(index,\"onUpdate\",saveObject);\r\n\r\n\treturn OfflineRest;\r\n});\r\n"]}