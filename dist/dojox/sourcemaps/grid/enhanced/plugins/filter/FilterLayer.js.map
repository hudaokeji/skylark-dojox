{"version":3,"sources":["grid/enhanced/plugins/filter/FilterLayer.js"],"names":["define","declare","lang","kernel","json","layers","hitchIfCan","scope","func","hitch","global","_FilterLayerMixin","tags","name","onFilterDefined","filter","onFiltered","filteredSize","totalSize","ServerSideFilterLayer","_ServerSideLayer","constructor","args","this","_onUserCommandLoad","setupFilterQuery","filterDef","_filter","obj","toObject","command","_isStateful","toJson","useCommands","onCommandLoad","responce","userRequest","inherited","arguments","oldOnBegin","onBegin","sizes","split","length","_filteredSize","parseInt","enabled","size","req","_this","_storeSize","ClientSideFilterLayer","_StoreLayer","_fetchAll","isObject","fetchAllOnFirstFilter","fetchAll","_getter","isFunction","getter","_defaultGetter","datarow","colName","rowIndex","store","getValue","undefined","invalidate","setGetter","toFetchAll","_items","_nextUnfetchedIdx","_result","_indexMap","_resultStartIdx","_fetch","filterRequest","old_onbegin","r","originFetch","sortStr","start","_nextResultItemIdx","isArray","sort","_lastSortInfo","end","count","concat","slice","_hasReachedStoreEnd","_completeQuery","res","shallowClone","_onFetchBegin","onComplete","items","_doFilter","e","onError","_applyFilter","g","s","_store","applyRow","item","arg","console","warn","startIdx","i","onItem","_addCachedItems","push","filterStartIdx","k","onRowMappingChange","mapping","m","clone","alreadyUpdated","mixin"],"mappings":"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","file":"../../../../../grid/enhanced/plugins/filter/FilterLayer.js","sourcesContent":["define([\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/kernel\",\r\n\t\"dojo/_base/json\",\r\n\t\"../_StoreLayer\"\r\n], function(declare, lang, kernel, json, layers){\r\n\r\n\tvar cmdSetFilter = \"filter\",\r\n\t\tcmdClearFilter = \"clear\",\r\n\t\thitchIfCan = function(scope, func){\r\n\t\t\treturn func ? lang.hitch(scope || kernel.global, func) : function(){};\r\n\t\t},\r\n\t\tshallowClone = function(obj){\r\n\t\t\tvar res = {};\r\n\t\t\tif(obj && lang.isObject(obj)){\r\n\t\t\t\tfor(var name in obj){\r\n\t\t\t\t\tres[name] = obj[name];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t};\r\n\tvar _FilterLayerMixin = declare(\"dojox.grid.enhanced.plugins.filter._FilterLayerMixin\", null, {\r\n/*=====\r\n\t\t// _filter: _ConditionExpr\r\n\t\t//\t\tThe filter definition\r\n\t\t_filter: null,\r\n\t\t\r\n\t\tfilterDef: function(filter){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet/set/clear the filter definition\r\n\t\t\t// tags:\r\n\t\t\t//\t\tpublic\r\n\t\t\t// filter: (_ConditionExpr|null)?\r\n\t\t\t//\t\t- null: clear filter definition\r\n\t\t\t//\t\t- undefined: it's getter\r\n\t\t\t// returns:\r\n\t\t\t//\t\tA filter definition if it's getter.\r\n\t\t},\r\n=====*/\r\n\t\ttags: [\"sizeChange\"],\r\n\t\tname: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\toverride from _StoreLayer.name\r\n\t\t\treturn \"filter\";\t//string\r\n\t\t},\r\n\t\tonFilterDefined: function(filter){},\r\n\t\t\r\n\t\tonFiltered: function(filteredSize, totalSize){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled when store data is filtered. This event is before *onComplete*, after *onBegin*.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback extension\r\n\t\t\t// filteredSize: Integer\r\n\t\t\t//\t\tThe number of remaining fetched items after filtering.\r\n\t\t\t// totalSize: Integer\r\n\t\t\t//\t\tThe number of original fetched items.\r\n\t\t}\r\n\t});\r\n\tvar ServerSideFilterLayer = declare(\"dojox.grid.enhanced.plugins.filter.ServerSideFilterLayer\", [layers._ServerSideLayer, _FilterLayerMixin], {\r\n\t\tconstructor: function(args){\r\n\t\t\tthis._onUserCommandLoad = args.setupFilterQuery || this._onUserCommandLoad;\r\n\t\t\tthis.filterDef(null);\r\n\t\t},\r\n\t\tfilterDef: function(/* (_ConditionExpr|null)? */filter){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee _FilterLayerMixin.filterDef\r\n\t\t\tif(filter){\r\n\t\t\t\tthis._filter = filter;\r\n\t\t\t\tvar obj = filter.toObject();\r\n\t\t\t\t//Stateless implementation will need to parse the filter object.\r\n\t\t\t\tthis.command(cmdSetFilter, this._isStateful ? json.toJson(obj) : obj);\r\n\t\t\t\tthis.command(cmdClearFilter, null);\r\n\t\t\t\tthis.useCommands(true);\r\n\t\t\t\tthis.onFilterDefined(filter);\r\n\t\t\t}else if(filter === null){\r\n\t\t\t\tthis._filter = null;\r\n\t\t\t\tthis.command(cmdSetFilter, null);\r\n\t\t\t\tthis.command(cmdClearFilter, true);\r\n\t\t\t\tthis.useCommands(true);\r\n\t\t\t\tthis.onFilterDefined(null);\r\n\t\t\t}\r\n\t\t\treturn this._filter;\t//_ConditionExpr\r\n\t\t},\r\n\t\tonCommandLoad: function(/* (in)string */responce, /* (in|out)keywordArgs */ userRequest){\r\n\t\t\t// summary:\r\n\t\t\t//\t\toverride from _ServerSideLayer.onCommandLoad\r\n\t\t\tthis.inherited(arguments);\r\n\t\t\tvar oldOnBegin = userRequest.onBegin;\r\n\t\t\tif(this._isStateful){\r\n\t\t\t\tvar filteredSize;\r\n\t\t\t\tif(responce){\r\n\t\t\t\t\tthis.command(cmdSetFilter, null);\r\n\t\t\t\t\tthis.command(cmdClearFilter, null);\r\n\t\t\t\t\tthis.useCommands(false);\r\n\t\t\t\t\tvar sizes = responce.split(',');\r\n\t\t\t\t\tif(sizes.length >= 2){\r\n\t\t\t\t\t\tfilteredSize = this._filteredSize = parseInt(sizes[0], 10);\r\n\t\t\t\t\t\tthis.onFiltered(filteredSize, parseInt(sizes[1], 10));\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t//Error here.\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfilteredSize = this._filteredSize;\r\n\t\t\t\t}\r\n\t\t\t\tif(this.enabled()){\r\n\t\t\t\t\tuserRequest.onBegin = function(size, req){\r\n\t\t\t\t\t\thitchIfCan(userRequest.scope, oldOnBegin)(filteredSize, req);\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tvar _this = this;\r\n\t\t\t\tuserRequest.onBegin = function(size, req){\r\n\t\t\t\t\tif(!_this._filter){\r\n\t\t\t\t\t\t_this._storeSize = size;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t_this.onFiltered(size, _this._storeSize || size);\r\n\t\t\t\t\treq.onBegin = oldOnBegin;\r\n\t\t\t\t\thitchIfCan(userRequest.scope, oldOnBegin)(size, req);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\tvar ClientSideFilterLayer = declare(\"dojox.grid.enhanced.plugins.filter.ClientSideFilterLayer\", [layers._StoreLayer, _FilterLayerMixin], {\r\n\t\t// summary:\r\n\t\t//\t\tAdd a client side filter layer on top of the data store,\r\n\t\t//\t\tso any filter expression can be applied to the store.\r\n/*=====\r\n\t\t// _items: Array,\r\n\t\t//\t\tCached items (may contain holes)\r\n\t\t_items: [],\r\n\t\t\r\n\t\t// _result: Array,\r\n\t\t//\t\tCurrent fetch result\r\n\t\t_result: [],\r\n\r\n\t\t// _resultStartIdx: Integer,\r\n\t\t//\t\tThe index in cache of the first result item\r\n\t\t_resultStartIdx: 0,\r\n\t\t\r\n\t\t// _indexMap: Array,\r\n\t\t//\t\tA map from the row index of this._items to the row index of the original store.\r\n\t\t_indexMap: null,\r\n\t\t\r\n\t\t// _getter: function(datarow, colArg, rowIndex, store);\r\n\t\t//\t\tA user defined way to get data from store\r\n\t\t_getter: null,\r\n\t\t\r\n\t\t// _nextUnfetchedIdx: Integer\r\n\t\t//\t\tThe index of the next item in the store that is never fetched.\r\n\t\t_nextUnfetchedIdx: 0,\r\n=====*/\r\n\t\t// _storeSize: Integer\r\n\t\t//\t\tThe actual size of the original store\r\n\t\t_storeSize: -1,\r\n\t\t\r\n\t\t// _fetchAll\r\n\t\t//\t\tIf the store is small or store size must be correct when onBegin is called,\r\n\t\t//\t\twe should fetch and filter all the items on the first query.\r\n\t\t_fetchAll: true,\r\n\t\t\r\n\t\tconstructor: function(args){\r\n\t\t\tthis.filterDef(null);\r\n\t\t\targs = lang.isObject(args) ? args : {};\r\n\t\t\tthis.fetchAllOnFirstFilter(args.fetchAll);\r\n\t\t\tthis._getter = lang.isFunction(args.getter) ? args.getter : this._defaultGetter;\r\n\t\t},\r\n\t\t_defaultGetter: function(datarow, colName, rowIndex, store){\r\n\t\t\treturn store.getValue(datarow, colName);\r\n\t\t},\r\n\t\tfilterDef: function(/* (_ConditionExpr|null)? */filter){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSee _FilterLayerMixin.filterDef\r\n\t\t\tif(filter !== undefined){\r\n\t\t\t\tthis._filter = filter;\r\n\t\t\t\tthis.invalidate();\r\n\t\t\t\tthis.onFilterDefined(filter);\r\n\t\t\t}\r\n\t\t\treturn this._filter;\t//_ConditionExpr\r\n\t\t},\r\n\t\tsetGetter: function(/* function */getter){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet the user defined way to retrieve data from store.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tpublic\r\n\t\t\t// getter: function(datarow, colArg, rowIndex, store);\r\n\t\t\tif(lang.isFunction(getter)){\r\n\t\t\t\tthis._getter = getter;\r\n\t\t\t}\r\n\t\t},\r\n\t\tfetchAllOnFirstFilter: function(/* bool? */toFetchAll){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe get/set function for fetchAll.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tpublic\r\n\t\t\t// toFetchAll: boolean?\r\n\t\t\t//\t\tIf provided, it's a set function, otherwise it's a get function.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tWhether fetch all on first filter if this is a getter\r\n\t\t\tif(toFetchAll !== undefined){\r\n\t\t\t\tthis._fetchAll = !!toFetchAll;\r\n\t\t\t}\r\n\t\t\treturn this._fetchAll;\t//Boolean\r\n\t\t},\r\n\t\tinvalidate: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tClear all the status information of this layer\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis._items = [];\r\n\t\t\tthis._nextUnfetchedIdx = 0;\r\n\t\t\tthis._result = [];\r\n\t\t\tthis._indexMap = [];\r\n\t\t\tthis._resultStartIdx = 0;\r\n\t\t},\r\n\t\t//----------------Private Functions-----------------------------\r\n\t\t_fetch: function(userRequest,filterRequest){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tImplement _StoreLayer._fetch\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate callback\r\n\t\t\t// filterRequest: dojo/data/api/Request\r\n\t\t\t//\t\tThe actual request used in store.fetch.\r\n\t\t\t//\t\tThis function is called recursively to fill the result store items\r\n\t\t\t//\t\tuntil the user specified item count is reached. Only in recursive calls,\r\n\t\t\t//\t\tthis parameter is valid.\r\n\t\t\tif(!this._filter){\r\n\t\t\t\t//If we don't have any filter, use the original request and fetch.\r\n\t\t\t\tvar old_onbegin = userRequest.onBegin, _this = this;\r\n\t\t\t\tuserRequest.onBegin = function(size, r){\r\n\t\t\t\t\thitchIfCan(userRequest.scope, old_onbegin)(size, r);\r\n\t\t\t\t\t_this.onFiltered(size, size);\r\n\t\t\t\t};\r\n\t\t\t\tthis.originFetch(userRequest);\r\n\t\t\t\treturn userRequest;\r\n\t\t\t}\r\n\t\t\ttry{\r\n\t\t\t\t//If the fetch is at the beginning, user's start position is used;\r\n\t\t\t\t//If we are in a recursion, our own request is used.\r\n\t\t\t\tvar start = filterRequest ? filterRequest._nextResultItemIdx : userRequest.start;\r\n\t\t\t\tstart = start || 0;\r\n\t\t\t\tif(!filterRequest){\r\n\t\t\t\t\t//Initially, we have no results.\r\n\t\t\t\t\tthis._result = [];\r\n\t\t\t\t\tthis._resultStartIdx = start;\r\n\t\t\t\t\tvar sortStr;\r\n\t\t\t\t\tif(lang.isArray(userRequest.sort) && userRequest.sort.length > 0 &&\r\n\t\t\t\t\t\t//Sort info will stay here in every re-fetch, so remember it!\r\n\t\t\t\t\t\t(sortStr = json.toJson(userRequest.sort)) != this._lastSortInfo){\r\n\t\t\t\t\t\t//If we should sort data, all the old caches are no longer valid.\r\n\t\t\t\t\t\tthis.invalidate();\r\n\t\t\t\t\t\tthis._lastSortInfo = sortStr;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t//this._result contains the current fetch result (of every recursion).\r\n\t\t\t\tvar end = typeof userRequest.count == \"number\" ?\r\n\t\t\t\t\tstart + userRequest.count - this._result.length : this._items.length;\r\n\t\t\t\t//Try to retrieve all the items from our cache.\r\n\t\t\t\t//Only need items after userRequest.start, test it in case start is smaller.\r\n\t\t\t\tif(this._result.length){\r\n\t\t\t\t\tthis._result = this._result.concat(this._items.slice(start, end));\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis._result = this._items.slice(userRequest.start, typeof userRequest.count == \"number\" ?\r\n\t\t\t\t\t\tuserRequest.start + userRequest.count : this._items.length);\r\n\t\t\t\t}\r\n\t\t\t\tif(this._result.length >= userRequest.count || this._hasReachedStoreEnd()){\r\n\t\t\t\t\t//We already have had enough items, or we have to stop fetching because there's nothing more to fetch.\r\n\t\t\t\t\tthis._completeQuery(userRequest);\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//User's request hasn't been finished yet. Fetch more.\r\n\t\t\t\t\tif(!filterRequest){\r\n\t\t\t\t\t\t//Initially, we've got to create a new request object.\r\n\t\t\t\t\t\tfilterRequest = shallowClone(userRequest);\r\n\t\t\t\t\t\t//Use our own onBegin function to remember the total size of the original store.\r\n\t\t\t\t\t\tfilterRequest.onBegin = lang.hitch(this, this._onFetchBegin);\r\n\t\t\t\t\t\tfilterRequest.onComplete = lang.hitch(this, function(items, req){\r\n\t\t\t\t\t\t\t//We've fetched some more, so march ahead!\r\n\t\t\t\t\t\t\tthis._nextUnfetchedIdx += items.length;\r\n\t\t\t\t\t\t\t//Actual filtering work goes here. Survived items are added to our cache.\r\n\t\t\t\t\t\t\t//req is our own request object.\r\n\t\t\t\t\t\t\tthis._doFilter(items, req.start, userRequest);\r\n\t\t\t\t\t\t\t//Recursively call this function. Let's do this again!\r\n\t\t\t\t\t\t\tthis._fetch(userRequest, req);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//Fetch starts from the next unfetched item.\r\n\t\t\t\t\tfilterRequest.start = this._nextUnfetchedIdx;\r\n\t\t\t\t\t//If store is small, we should only fetch once.\r\n\t\t\t\t\tif(this._fetchAll){\r\n\t\t\t\t\t\tdelete filterRequest.count;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//Remember we've (maybe) already added something to our result array, so next time we should not start over again.\r\n\t\t\t\t\tfilterRequest._nextResultItemIdx = end < this._items.length ? end : this._items.length;\r\n\t\t\t\t\t//Actual fetch work goes here.\r\n\t\t\t\t\tthis.originFetch(filterRequest);\r\n\t\t\t\t}\r\n\t\t\t}catch(e){\r\n\t\t\t\tif(userRequest.onError){\r\n\t\t\t\t\thitchIfCan(userRequest.scope, userRequest.onError)(e, userRequest);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn userRequest;\r\n\t\t},\r\n\t\t_hasReachedStoreEnd: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCheck whether all the items in the original store have been fetched.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\treturn this._storeSize >= 0 && this._nextUnfetchedIdx >= this._storeSize;\t//Boolean\r\n\t\t},\r\n\t\t_applyFilter: function(/* data item */datarow,/* Integer */rowIndex){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tApply the filter to a row of data\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\t// returns:\r\n\t\t\t//\t\twhether this row survived the filter.\r\n\t\t\tvar g = this._getter, s = this._store;\r\n\t\t\ttry{\r\n\t\t\t\treturn !!(this._filter.applyRow(datarow, function(item, arg){\r\n\t\t\t\t\treturn g(item, arg, rowIndex, s);\r\n\t\t\t\t}).getValue());\r\n\t\t\t}catch(e){\r\n\t\t\t\tconsole.warn(\"FilterLayer._applyFilter() error: \", e);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t},\r\n\t\t_doFilter: function(/* Array */items,/* Integer */startIdx,/* object */userRequest){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tUse the filter expression to filter items. Survived items are stored in this._items.\r\n\t\t\t//\t\tThe given items start from \"startIdx\" in the original store.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tfor(var i = 0, cnt = 0; i < items.length; ++i){\r\n\t\t\t\tif(this._applyFilter(items[i], startIdx + i)){\r\n\t\t\t\t\thitchIfCan(userRequest.scope, userRequest.onItem)(items[i], userRequest);\r\n\t\t\t\t\tcnt += this._addCachedItems(items[i], this._items.length);\r\n\t\t\t\t\tthis._indexMap.push(startIdx + i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t_onFetchBegin: function(/* Integer */size,/* request object */req){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis function is used to replace the user's onFetchBegin in store.fetch\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tthis._storeSize = size;\r\n\t\t},\r\n\t\t_completeQuery: function(/* request object */userRequest){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tLogically, the user's query is completed here, i.e., all the filtered results are ready.\r\n\t\t\t//\t\t(or their index mappings are ready)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar size = this._items.length;\r\n\t\t\tif(this._nextUnfetchedIdx < this._storeSize){\r\n\t\t\t\t//FIXME: There's still some items in the original store that are not fetched & filtered.\r\n\t\t\t\t//So we have to estimate a little bigger size to allow scrolling to these unfetched items.\r\n\t\t\t\t//However, this behavior is ONLY correct in Grid! Any better way to do this?\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t\thitchIfCan(userRequest.scope, userRequest.onBegin)(size,userRequest);\r\n\t\t\tthis.onFiltered(this._items.length, this._storeSize);\r\n\t\t\thitchIfCan(userRequest.scope, userRequest.onComplete)(this._result, userRequest);\r\n\t\t},\r\n\t\t_addCachedItems: function(/* Array */items,/* Integer */filterStartIdx){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdd data items to the cache. The insert point is at *filterStartIdx*\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\t// items: Array\r\n\t\t\t//\t\tData items to add.\r\n\t\t\t// filterStartIdx: Integer\r\n\t\t\t//\t\tThe start point to insert in the cache.\r\n\t\t\tif(!lang.isArray(items)){\r\n\t\t\t\titems = [items];\r\n\t\t\t}\r\n\t\t\tfor(var k = 0; k < items.length; ++k){\r\n\t\t\t\tthis._items[filterStartIdx + k] = items[k];\r\n\t\t\t}\r\n\t\t\treturn items.length;\r\n\t\t},\r\n\t\tonRowMappingChange: function(mapping){\r\n\t\t\t//This function runs in FilterLayer scope!\r\n\t\t\tif(this._filter){\r\n\t\t\t\tvar m = lang.clone(mapping),\r\n\t\t\t\t\talreadyUpdated = {};\r\n\t\t\t\tfor(var r in m){\r\n\t\t\t\t\tr = parseInt(r, 10);\r\n\t\t\t\t\tmapping[this._indexMap[r]] = this._indexMap[m[r]];\r\n\t\t\t\t\tif(!alreadyUpdated[this._indexMap[r]]){\r\n\t\t\t\t\t\talreadyUpdated[this._indexMap[r]] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(!alreadyUpdated[r]){\r\n\t\t\t\t\t\talreadyUpdated[r] = true;\r\n\t\t\t\t\t\tdelete mapping[r];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\treturn lang.mixin({\r\n\t\tServerSideFilterLayer: ServerSideFilterLayer,\r\n\t\tClientSideFilterLayer: ClientSideFilterLayer\r\n\t}, layers);\r\n});\r\n"]}