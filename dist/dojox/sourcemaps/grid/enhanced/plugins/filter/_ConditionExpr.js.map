{"version":3,"sources":["grid/enhanced/plugins/filter/_ConditionExpr.js"],"names":["define","declare","lang","array","_ConditionExpr","_name","applyRow","datarow","getter","Error","toObject","getName","this","_DataExpr","constructor","dataValue","isColumn","convertArgs","_convertArgs","isFunction","convert","_convertData","hitch","scope","_colArg","_value","getValue","getObject","declaredClass","op","data","undefined","isCol","_OperatorExpr","isArray","arguments","_operands","i","length","push","map","operand","_UniOpExpr","_calculate","_BiOpExpr","left_operand","right_operand"],"mappings":";;;;;;;AAAAA,QACC,qBACA,kBACA,oBACE,SAASC,EAASC,EAAMC,GAE3B,IAAIC,EAAiBH,EAAQ,oDAAqD,MAQjFI,MAAO,OAEPC,SAAU,SAAwBC,EAAkCC,GAcnE,MAAM,IAAIC,MAAM,qDAGjBC,SAAU,WAOT,UAGDC,QAAS,WAOR,OAAOC,KAAKP,SAIVQ,EAAYZ,EAAQ,+CAAgDG,GAUvEC,MAAO,OAEPS,YAAa,SAAuBC,EAAoBC,EAAsBC,GAY7EL,KAAKM,aAAeD,MACjBf,EAAKiB,WAAWP,KAAKM,aAAaE,WACpCR,KAAKS,aAAenB,EAAKoB,MAAMV,KAAKM,aAAaK,MAAOX,KAAKM,aAAaE,UAExEJ,EACFJ,KAAKY,QAAUT,EAEfH,KAAKa,OAASb,KAAKS,aAAaN,EAAWH,KAAKM,eAIlDQ,SAAU,WAQT,OAAOd,KAAKa,QAGbnB,SAAU,SAAwBC,EAAkCC,GAMnE,YAA8B,IAAhBI,KAAKY,QAAyBZ,KAC3C,IAAKV,EAAKyB,UAAUf,KAAKgB,eAAzB,CACChB,KAAKS,aAAab,EAAOD,EAASK,KAAKY,SAAUZ,KAAKM,gBAIzDG,aAAc,SAAuBN,GAKpC,OAAOA,GAGRL,SAAU,WAGT,OACCmB,GAAIjB,KAAKD,UACTmB,UAAuBC,IAAjBnB,KAAKY,QAAwBZ,KAAKa,OAASb,KAAKY,QACtDQ,WAAwBD,IAAjBnB,KAAKY,YAKXS,EAAgBhC,EAAQ,mDAAoDG,GAI/EC,MAAO,WAEPS,YAAa,WAKZ,GAAGZ,EAAKgC,QAAQC,UAAU,IACzBvB,KAAKwB,UAAYD,UAAU,OACvB,CACJvB,KAAKwB,aACL,IAAI,IAAIC,EAAI,EAAGA,EAAIF,UAAUG,SAAUD,EACtCzB,KAAKwB,UAAUG,KAAKJ,UAAUE,MAIjC3B,SAAU,WAGT,OACCmB,GAAIjB,KAAKD,UACTmB,KAAM3B,EAAMqC,IAAI5B,KAAKwB,UAAU,SAASK,GACvC,OAAOA,EAAQ/B,iBAMfgC,EAAazC,EAAQ,gDAAiDgC,GAIzE5B,MAAO,cAEPC,SAAU,SAAwBC,EAAkCC,GAKnE,KAAKI,KAAKwB,UAAU,aAAchC,GACjC,MAAM,IAAIK,MAAM,0CAEjB,OAAOG,KAAK+B,WAAW/B,KAAKwB,UAAU,GAAG7B,EAAQC,IAGlDmC,WAAY,SAA6BF,EAAsBlC,EAAkCC,GAWhG,MAAM,IAAIC,MAAM,qDAIdmC,EAAY3C,EAAQ,+CAAgDgC,GAIvE5B,MAAO,aAEPC,SAAU,SAAwBC,EAAkCC,GAInE,KAAKI,KAAKwB,UAAU,aAAchC,GACjC,MAAM,IAAIK,MAAM,8CACX,KAAKG,KAAKwB,UAAU,aAAchC,GACvC,MAAM,IAAIK,MAAM,+CAEjB,OAAOG,KAAK+B,WAAW/B,KAAKwB,UAAU,GAAGxB,KAAKwB,UAAU,GAAG7B,EAAQC,IAGpEmC,WAAY,SAA6BE,EAAiCC,EAA4BvC,EAAkCC,GAYvI,MAAM,IAAIC,MAAM,oDAIlB,OACCL,eAAgBA,EAChBS,UAAWA,EACXoB,cAAeA,EACfS,WAAYA,EACZE,UAAWA","file":"../../../../../grid/enhanced/plugins/filter/_ConditionExpr.js","sourcesContent":["define([\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/array\"\r\n], function(declare, lang, array){\r\n\t\r\nvar _ConditionExpr = declare(\"dojox.grid.enhanced.plugins.filter._ConditionExpr\", null, {\r\n\t// summary:\r\n\t//\t\tThe most abstract class for all condition expressions.\r\n\t//\t\tA condition expression can be applied on a data row (e.g. an item in a store)\r\n\t//\t\tand generate a result condition expression.\r\n\t// tags:\r\n\t//\t\tabstract\r\n\t\r\n\t_name: \"expr\",\r\n\r\n\tapplyRow: function(/* data item */datarow,/* function(row,colArg) */getter){\r\n\t\t// summary:\r\n\t\t//\t\t*Unimplemented Interface*\r\n\t\t//\t\tApply this condition expression on the given datarow, return a result expression.\r\n\t\t// taqs:\r\n\t\t//\t\tpublic extension\r\n\t\t// datarow: object\r\n\t\t//\t\tA data item of a store.\r\n\t\t// getter: function(datarow, colArg)\r\n\t\t//\t\tA user defined function that extract cell data from *datarow*.\r\n\t\t//\t\t*colArg* is an argument that provides a kind of column information.\r\n\t\t//\t\tIt is defined by user in the constructor of a _DataExpr object.\r\n\t\t// returns:\r\n\t\t//\t\tMUST return a _ConditionExpr object\r\n\t\tthrow new Error(\"_ConditionExpr.applyRow: unimplemented interface\");\r\n\t},\r\n\r\n\ttoObject: function(){\r\n\t\t// summary:\r\n\t\t//\t\tConvert this data expression to a simple object. Mainly used for serialization.\r\n\t\t// tags:\r\n\t\t//\t\tpublic extension\r\n\t\t// returns:\r\n\t\t//\t\tAn object for serialization.\r\n\t\treturn {};\t//Object\r\n\t},\r\n\r\n\tgetName: function(){\r\n\t\t// summary:\r\n\t\t//\t\tGet the name of this kind of expression.\r\n\t\t// tags:\r\n\t\t//\t\tpublic extension\r\n\t\t// returns:\r\n\t\t//\t\tthe name of this kind of expression\r\n\t\treturn this._name;\t//String\r\n\t}\r\n});\r\n\r\nvar _DataExpr = declare(\"dojox.grid.enhanced.plugins.filter._DataExpr\", _ConditionExpr, {\r\n\t// summary:\r\n\t//\t\tThe most abstract class for all data expressions.\r\n\t//\t\tA _DataExpr is a condition expression for a single data value.\r\n\t//\t\tIf the data value to be represent is a pure value (literal value, like string/number/Date/...)\r\n\t//\t\tthis _DataExpr is nothing more than a simple wrapper.\r\n\t//\t\tIf the data value to be represent is in a store, then _DataExpr is responsible to extract it\r\n\t//\t\tfrom the store when this condition is applied to a data row.\r\n\t// _value: [private] anything\r\n\t// _colArg: [private] anything\r\n\t_name: \"data\",\r\n\r\n\tconstructor: function(/* anything */dataValue,/* bool */isColumn, /* object */convertArgs){\r\n\t\t// summary:\r\n\t\t//\t\tIf a _DataExpr is constructed with only one argument, this argument is regarded as a pure value.\r\n\t\t//\t\tIf the second argument is exactly a boolean true (no implict type transformation,\r\n\t\t//\t\tso as to allow derived classes accept more arguments while retain *isColumn* to be optional),\r\n\t\t//\t\tthen this _DataExpr represents a column, and it's applyRow method is not a no-op.\r\n\t\t// dataValue: anything\r\n\t\t//\t\tIf *isColumn* is a boolean true, then it should be a kind of column information, like field name\r\n\t\t//\t\tor column index. Otherwise, it is regarded as a pure value, and the getValue method will simply\r\n\t\t//\t\treturn it.\r\n\t\t// isColumn: boolean?\r\n\t\t//\t\tOptional. To specify whether this _DataExpr represents a column or a pure value.\r\n\t\tthis._convertArgs = convertArgs || {};\r\n\t\tif(lang.isFunction(this._convertArgs.convert)){\r\n\t\t\tthis._convertData = lang.hitch(this._convertArgs.scope, this._convertArgs.convert);\r\n\t\t}\r\n\t\tif(isColumn){\r\n\t\t\tthis._colArg = dataValue;\r\n\t\t}else{\r\n\t\t\tthis._value = this._convertData(dataValue, this._convertArgs);\r\n\t\t}\r\n\t},\r\n\r\n\tgetValue: function(){\r\n\t\t// summary:\r\n\t\t//\t\tIf this is a pure value wrapper, simply return the value.\r\n\t\t//\t\tOtherwise (it's a column), return is undefined.\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\t\t// returns:\r\n\t\t//\t\tthe value of this data expression.\r\n\t\treturn this._value;\t//String\r\n\t},\r\n\r\n\tapplyRow: function(/* data item */datarow,/* function(row,colIdx) */getter){\r\n\t\t// summary:\r\n\t\t//\t\tImplement _ConditionExpr.applyRow.\r\n\t\t//\t\tIf this is a pure value, simply return self.\r\n\t\t//\t\tOtherwise, extract the cell data from datarow using the given getter function,\r\n\t\t//\t\tand then convert this cell data to a _DataExpr and return the expression.\r\n\t\treturn typeof this._colArg == \"undefined\" ? this :\t\t\t//_ConditionExpr\r\n\t\t\tnew (lang.getObject(this.declaredClass))(\r\n\t\t\t\tthis._convertData(getter(datarow, this._colArg), this._convertArgs)\r\n\t\t\t);\r\n\t},\r\n\r\n\t_convertData: function(/* anything */dataValue){\r\n\t\t// tags:\r\n\t\t//\t\tprotected extension\r\n\t\t// dataValue: anything\r\n\t\t//\t\tThis argument should come from a store.\r\n\t\treturn dataValue;\r\n\t},\r\n\r\n\ttoObject: function(){\r\n\t\t// summary:\r\n\t\t//\t\tOverrided from _ConditionExpr.toObject\r\n\t\treturn {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//String\r\n\t\t\top: this.getName(),\r\n\t\t\tdata: this._colArg === undefined ? this._value : this._colArg,\r\n\t\t\tisCol: this._colArg !== undefined\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar _OperatorExpr = declare(\"dojox.grid.enhanced.plugins.filter._OperatorExpr\", _ConditionExpr, {\r\n\t// summary:\r\n\t//\t\tThe most abstract class for all operator expressions.\r\n\t//\t\tAn operator expression is a _ConditionExpr that represents an operation.\r\n\t_name: \"operator\",\r\n\r\n\tconstructor: function(/* Array|operand1,operand2,... */){\r\n\t\t// summary:\r\n\t\t//\t\tThe arguments are operands (or an array of operands, if the first argument\r\n\t\t//\t\tis an Array) of this operator, ordering from left to right.\r\n\t\t//\t\tEvery operand should be a _ConditionExpr.\r\n\t\tif(lang.isArray(arguments[0])){\r\n\t\t\tthis._operands = arguments[0];\r\n\t\t}else{\r\n\t\t\tthis._operands = [];\r\n\t\t\tfor(var i = 0; i < arguments.length; ++i){\r\n\t\t\t\tthis._operands.push(arguments[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\ttoObject: function(){\r\n\t\t// summary:\r\n\t\t//\t\tOverrided from _ConditionExpr.toObject\r\n\t\treturn {\t\t\t\t\t\t\t\t\t\t\t//Object\r\n\t\t\top: this.getName(),\r\n\t\t\tdata: array.map(this._operands,function(operand){\r\n\t\t\t\treturn operand.toObject();\r\n\t\t\t})\r\n\t\t};\r\n\t}\r\n});\r\n\r\nvar _UniOpExpr = declare(\"dojox.grid.enhanced.plugins.filter._UniOpExpr\", _OperatorExpr, {\r\n\t// summary:\r\n\t//\t\tThe most abstract class for all uni-operator expressions.\r\n\t//\t\tA uni-operator expression is an _OperatorExpr that only allow one operand.\r\n\t_name: \"uniOperator\",\r\n\r\n\tapplyRow: function(/* data item */datarow,/* function(row,colArg) */getter){\r\n\t\t// summary:\r\n\t\t//\t\tImplement _ConditionExpr.applyRow.\r\n\t\t//\t\tApply the restriction of \"only one operand\" and confirm the operand is a valid _ConditionExpr.\r\n\t\t//\t\tThen do the calculation of this operator.\r\n\t\tif(!(this._operands[0] instanceof _ConditionExpr)){\r\n\t\t\tthrow new Error(\"_UniOpExpr: operand is not expression.\");\r\n\t\t}\r\n\t\treturn this._calculate(this._operands[0],datarow,getter);\t//_ConditionExpr\r\n\t},\r\n\r\n\t_calculate: function(/* _ConditionExpr */operand,/* data item*/datarow,/* function(row,colArg) */getter){\r\n\t\t// summary:\r\n\t\t//\t\t*Unimplemented Interface*\r\n\t\t//\t\tDo the actrual work of applyRow here.\r\n\t\t// tags:\r\n\t\t//\t\tprotected extension\r\n\t\t// operand: _ConditionExpr\r\n\t\t// datarow: object\r\n\t\t// getter: function(row,colArg)\r\n\t\t// returns:\r\n\t\t//\t\tMUST return a _ConditionExpr object.\r\n\t\tthrow new Error(\"_UniOpExpr._calculate: unimplemented interface\");\r\n\t}\r\n});\r\n\r\nvar _BiOpExpr = declare(\"dojox.grid.enhanced.plugins.filter._BiOpExpr\", _OperatorExpr, {\r\n\t// summary:\r\n\t//\t\tThe most abstract class for all bi-operator expressions.\r\n\t//\t\tA bi-operator expression is an _OperatorExpr that allow and only allow two operands.\r\n\t_name: \"biOperator\",\r\n\r\n\tapplyRow: function(/* data item */datarow,/* function(row,colArg) */getter){\r\n\t\t// summary:\r\n\t\t//\t\tImplement _ConditionExpr.applyRow.\r\n\t\t//\t\tApply the restriction of \"two operands\" and confirm operands are valid _ConditionExpr's.\r\n\t\tif(!(this._operands[0] instanceof _ConditionExpr)){\r\n\t\t\tthrow new Error(\"_BiOpExpr: left operand is not expression.\");\r\n\t\t}else if(!(this._operands[1] instanceof _ConditionExpr)){\r\n\t\t\tthrow new Error(\"_BiOpExpr: right operand is not expression.\");\r\n\t\t}\r\n\t\treturn this._calculate(this._operands[0],this._operands[1],datarow,getter);\r\n\t},\r\n\r\n\t_calculate: function(/* _ConditionExpr */left_operand,/* _ConditionExpr */right_operand,/* data item*/datarow,/* function(row,colArg) */getter){\r\n\t\t// summary:\r\n\t\t//\t\t*Unimplemented Interface*\r\n\t\t//\t\tDo the actrual work of applyRow here.\r\n\t\t// tags:\r\n\t\t//\t\tprotected extension\r\n\t\t// left_operand: _ConditionExpr\r\n\t\t// right_operand: _ConditionExpr\r\n\t\t// datarow: object\r\n\t\t// getter: function(row,colArg)\r\n\t\t// returns:\r\n\t\t//\t\tMUST return a _ConditionExpr object.\r\n\t\tthrow new Error(\"_BiOpExpr._calculate: unimplemented interface\");\r\n\t}\r\n});\r\n\r\nreturn {\r\n\t_ConditionExpr: _ConditionExpr,\r\n\t_DataExpr: _DataExpr,\r\n\t_OperatorExpr: _OperatorExpr,\r\n\t_UniOpExpr: _UniOpExpr,\r\n\t_BiOpExpr: _BiOpExpr\r\n};\r\n\r\n});\r\n"]}