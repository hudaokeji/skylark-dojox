{"version":3,"sources":["grid/enhanced/plugins/_SelectionPreserver.js"],"names":["define","declare","lang","connect","_SelectionPreserver","constructor","selection","grid","this","onSelectedById","_oldClearData","_clearData","self","_updateMapping","_noInternalMapping","_trustSelection","apply","arguments","_connects","push","hitch","destroy","inherited","reset","_idMap","_defaultSelected","_reSelectById","item","index","s","g","_hasIdentity","id","store","getIdentity","undefined","_selectedById","selected","_selectById","toSelect","inItemOrIndex","rowIndex","value","trustSelection","isSelect","isForAll","from","to","i","flag","unloaded","rowCount","_by_idx","idty","usingPagination","Math","abs","selectionMode","length"],"mappings":";;;;;;;AAAAA,QACC,qBACA,kBACA,qBACA,6BACE,SAASC,EAASC,EAAMC,EAASC,GAEpC,OAAOH,EAAQ,kDAAmDG,GAejEC,YAAa,SAASC,GACrB,IAAIC,EAAOC,KAAKD,KAChBA,EAAKE,eAAiBD,KAAKC,eAC3BD,KAAKE,cAAgBH,EAAKI,WAC1B,IAAIC,EAAOJ,KACXD,EAAKI,WAAa,WACjBC,EAAKC,gBAAgBN,EAAKO,oBAC1BF,EAAKG,mBACLH,EAAKF,cAAcM,MAAMT,EAAMU,YAEhCT,KAAKU,UAAUC,KACdhB,EAAQA,QAAQG,EAAW,cAAeJ,EAAKkB,MAAMZ,KAAM,kBAAkB,GAAM,GAAM,IACzFL,EAAQA,QAAQG,EAAW,gBAAiBJ,EAAKkB,MAAMZ,KAAM,kBAAkB,GAAM,GAAO,IAC5FL,EAAQA,QAAQG,EAAW,cAAeJ,EAAKkB,MAAMZ,KAAM,kBAAkB,GAAM,GAAO,MAG5Fa,QAAS,WACRb,KAAKc,UAAUL,WACfT,KAAKD,KAAKI,WAAaH,KAAKE,eAE7Ba,MAAO,WACNf,KAAKc,UAAUL,WACfT,KAAKgB,UACLhB,KAAKO,mBACLP,KAAKiB,kBAAmB,GAEzBC,cAAe,SAASC,EAAMC,GAG7B,IAAIC,EAAIrB,KAAKF,UAAWwB,EAAItB,KAAKD,KACjC,GAAGoB,GAAQG,EAAEC,aAAa,CACzB,IAAIC,EAAKF,EAAEG,MAAMC,YAAYP,QACCQ,IAA3B3B,KAAK4B,cAAcJ,GACjBxB,KAAKO,gBAAgBa,KACxBC,EAAEQ,SAAST,GAASpB,KAAKiB,kBAG1BI,EAAEQ,SAAST,GAASpB,KAAK4B,cAAcJ,GAExCxB,KAAKgB,OAAOL,KAAKa,GACjBF,EAAErB,eAAeuB,EAAIJ,EAAOC,EAAEQ,SAAST,MAGzCU,YAAa,SAASC,EAAUC,GAG3BhC,KAAKc,UAAUL,aAClBT,KAAKO,gBAAgByB,IAAiB,IAGxC/B,eAAgB,SAASuB,EAAIS,EAAUC,KAEvC7B,eAAgB,SAAS8B,EAAgBC,EAAUC,EAAUC,EAAMC,GAOlE,IAA+DC,EAAGhB,EAA9DH,EAAIrB,KAAKF,UAAWwB,EAAItB,KAAKD,KAAM0C,EAAO,EAAGC,EAAW,EAC5D,IAAIF,EAAIlB,EAAEqB,SAAW,EAAGH,GAAK,IAAKA,EAC7BlB,EAAEsB,QAAQJ,IAIbhB,EAAKF,EAAEsB,QAAQJ,GAAGK,QACRV,QAA6CR,IAA3B3B,KAAK4B,cAAcJ,MAC9CxB,KAAK4B,cAAcJ,KAAQH,EAAEQ,SAASW,OALrCE,EACFD,GAAQpB,EAAEQ,SAASW,GAAK,GAAK,GAgB/B,GARGE,IACF1C,KAAKiB,iBAAmBwB,EAAO,GAE5BJ,QAAqBV,IAATW,QAA6BX,IAAPY,IACrCF,GAAYf,EAAEwB,iBAAmBC,KAAKC,IAAIT,EAAKD,EAAO,KAAOhB,EAAEqB,UAI7DN,KAAcf,EAAEwB,iBAAuC,WAApBxB,EAAE2B,eACvC,IAAIT,EAAIxC,KAAKgB,OAAOkC,OAAS,EAAGV,GAAK,IAAKA,EACzCxC,KAAK4B,cAAc5B,KAAKgB,OAAOwB,IAAMJ","file":"../../../../grid/enhanced/plugins/_SelectionPreserver.js","sourcesContent":["define([\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/connect\",\r\n\t'../../_SelectionPreserver'\r\n], function(declare, lang, connect, _SelectionPreserver){\r\n\r\nreturn declare(\"dojox.grid.enhanced.plugins._SelectionPreserver\", _SelectionPreserver, {\r\n\t// summary:\r\n\t//\t\tPreserve selections across various user actions.\r\n\t//\r\n\t// description:\r\n\t//\t\tExtends dojox.grid._SelectionPreserver adding a bit more support to make selection persistence working well\r\n\t//\t\twith various EnhancedGrid features, e.g. filtering, nested sorting, pagination, select all etc.\r\n\t//\r\n\t//\t\tPrecondition - Identifier(id) is required for store, as id is used for differentiating row items.\r\n\t//\t\tKnown issue - The preserved selections might be inaccurate if some unloaded rows are previously selected by range(e.g.SHIFT + click)\r\n\t//\r\n\t// example:\r\n\t// |\t//To turn on this - set 'keepSelection' attribute to true\r\n\t// |\t<div dojoType=\"dojox.grid.EnhancedGrid\" keepSelection = true .../>\r\n\t\r\n\tconstructor: function(selection){\r\n\t\tvar grid = this.grid;\r\n\t\tgrid.onSelectedById = this.onSelectedById;\r\n\t\tthis._oldClearData = grid._clearData;\r\n\t\tvar self = this;\r\n\t\tgrid._clearData = function(){\r\n\t\t\tself._updateMapping(!grid._noInternalMapping);\r\n\t\t\tself._trustSelection = [];\r\n\t\t\tself._oldClearData.apply(grid, arguments);\r\n\t\t};\r\n\t\tthis._connects.push(\r\n\t\t\tconnect.connect(selection, 'selectRange', lang.hitch(this, '_updateMapping', true, true, false)),\r\n\t\t\tconnect.connect(selection, 'deselectRange', lang.hitch(this, '_updateMapping', true, false, false)),\r\n\t\t\tconnect.connect(selection, 'deselectAll', lang.hitch(this, '_updateMapping', true, false, true))\r\n\t\t);\r\n\t},\r\n\tdestroy: function(){\r\n\t\tthis.inherited(arguments);\r\n\t\tthis.grid._clearData = this._oldClearData;\r\n\t},\r\n\treset: function(){\r\n\t\tthis.inherited(arguments);\r\n\t\tthis._idMap = [];\r\n\t\tthis._trustSelection = [];\r\n\t\tthis._defaultSelected = false;\r\n\t},\r\n\t_reSelectById: function(item, index){\r\n\t\t// summary:\r\n\t\t//\t\tOverwritten\r\n\t\tvar s = this.selection, g = this.grid;\r\n\t\tif(item && g._hasIdentity){\r\n\t\t\tvar id = g.store.getIdentity(item);\r\n\t\t\tif(this._selectedById[id] === undefined){\r\n\t\t\t\tif(!this._trustSelection[index]){\r\n\t\t\t\t\ts.selected[index] = this._defaultSelected;\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\ts.selected[index] = this._selectedById[id];\r\n\t\t\t}\r\n\t\t\tthis._idMap.push(id);\r\n\t\t\tg.onSelectedById(id, index, s.selected[index]);\r\n\t\t}\r\n\t},\r\n\t_selectById: function(toSelect, inItemOrIndex){\r\n\t\t// summary:\r\n\t\t//\t\tOverwritten\r\n\t\tif(!this.inherited(arguments)){\r\n\t\t\tthis._trustSelection[inItemOrIndex] = true;\r\n\t\t}\r\n\t},\r\n\tonSelectedById: function(id, rowIndex, value){},\r\n\t\r\n\t_updateMapping: function(trustSelection, isSelect, isForAll, from, to){\r\n\t\t// summary:\r\n\t\t//\t\tThis function try to keep the selection info updated when range selection is performed.\r\n\t\t//\r\n\t\t//\t\t1. Calculate how many unloaded rows are there;\r\n\t\t//\t\t2. update _selectedById data if grid.selection._selected can be trusted, so loaded but unselected rows can\r\n\t\t//\t\t\tbe properly recorded.\r\n\t\tvar s = this.selection, g = this.grid, flag = 0, unloaded = 0, i, id;\r\n\t\tfor(i = g.rowCount - 1; i >= 0; --i){\r\n\t\t\tif(!g._by_idx[i]){\r\n\t\t\t\t++unloaded;\r\n\t\t\t\tflag += s.selected[i] ? 1 : -1;\r\n\t\t\t}else{\r\n\t\t\t\tid = g._by_idx[i].idty;\r\n\t\t\t\tif(id && (trustSelection || this._selectedById[id] === undefined)){\r\n\t\t\t\t\tthis._selectedById[id] = !!s.selected[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(unloaded){\r\n\t\t\tthis._defaultSelected = flag > 0;\r\n\t\t}\r\n\t\tif(!isForAll && from !== undefined && to !== undefined){\r\n\t\t\tisForAll = !g.usingPagination && Math.abs(to - from + 1) === g.rowCount;\r\n\t\t}\r\n\t\t// When deselectAll, make sure every thing is deselected, even if it was selected but not loaded now.\r\n\t\t// This occurs only when pagination's \"All\" is used.\r\n\t\tif(isForAll && (!g.usingPagination || g.selectionMode === 'single')){\r\n\t\t\tfor(i = this._idMap.length - 1; i >= 0; --i){\r\n\t\t\t\tthis._selectedById[this._idMap[i]] = isSelect;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n});\r\n});\r\n"]}