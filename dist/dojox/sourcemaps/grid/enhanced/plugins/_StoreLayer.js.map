{"version":3,"sources":["grid/enhanced/plugins/_StoreLayer.js"],"names":["define","declare","array","lang","xhr","ns","getObject","dojox","unwrap","layerName","i","layers","this","_layers","len","length","name","_unwrap","splice","layer","forEachLayer","getLayer","callback","isInnerToOuter","start","end","dir","wrap","store","funcName","layerFuncName","hitch","prevTags","tags","tagList","idx","p","indexOf","slice","getPrevTags","some","lyr","tag","_wrap","push","_StoreLayer","constructor","_store","_originFetch","__enabled","initialize","uninitialize","invalidate","nextLayer","_funcName","fetchFunc","enabled","originFetch","apply","arguments","toEnable","__name","m","declaredClass","match","toLowerCase","_ServerSideLayer","args","_url","url","_isStateful","isStateful","_onUserCommandLoad","onCommandLoad","__cmds","cmdlayer","enable","useCommands","res","inherited","toUse","_fetch","userRequest","post","content","load","responce","error","onCommandError","command","cmdName","cmdContent","cmds","response","console","log"],"mappings":"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","file":"../../../../grid/enhanced/plugins/_StoreLayer.js","sourcesContent":["define([\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/xhr\"\r\n], function(declare, array, lang, xhr){\r\n\t// summary:\r\n\t//\t\tThe dojo/data/api/Read API is powerful, but it's difficult to give the store some special commands before\r\n\t//\t\tfetch, so that the store content can be temporarily modified or transformed, and acts as another store. The\r\n\t//\t\tparameter *query* or *queryOptions* in keywordArgs for *fetch* is not enough because:\r\n\t//\r\n\t//\t\t1.\tusers do not have the opportunity to response to the store actions when these options or queries are applied,\r\n\t//\t\t\tespecially when the real store is at server side.\r\n\t//\t\t2.\tthe store implementation must be changed to support any new options in 'query' or 'queryOptions', so it'll be\r\n\t//\t\t\tdifficult if this implementation is not able to or very hard to be changed, or some new options are required to\r\n\t//\t\t\tbe valid for all stores.\r\n\t//\r\n\t//\t\tThis *StoreLayer* framework is dedicated to provide a uniform way for configuring an existing store, so that\r\n\t//\t\tit can be easily extended to have special behaviors or act like a totally different store.\r\n\t//\t\tThe major approach is to wrap the *fetch* function of store, layer by layer. Every layer treats the incoming\r\n\t//\t\tstore.fetch as a 'black box', thus maintaining the independence between layers.\r\n\t//\t\t*fetch* is the most important data retriever in the Read API, almost all other functions are used for a single\r\n\t//\t\titem, and require that this item is already retrieved (by and only by *fetch*). So once we've controlled this\r\n\t//\t\t*fetch* function, we've controlled almost the whole store. This fact simplifies our implementation of StoreLayer.\r\n\t// example:\r\n\t//\t| //ns is for namespace, i.e.:dojox.grid.enhanced.plugins\r\n\t//\t| ns.wrap(ns.wrap(ns.wrap(store, new ns.FilterLayer()), new ns.UniqueLayer()), new ns.TransformLayer());\r\n\t//\t| \r\n\t//\t| //every layer has a name, it should be given in the document of this layer.\r\n\t//\t| //if you don't know it's name, you can get it by: ns.SomeLayer.prototype.name();\r\n\t//\t| store.layer(\"filter\").filterDef(...);\r\n\t//\t| store.layer(\"unique\").setUniqueColumns(...);\r\n\t//\t| store.layer(\"transform\").setScheme(...);\r\n\t//\t| \r\n\t//\t| //now use the store as usual...\r\n\t//\t| \r\n\t//\t| store.unwrap(\"transform\"); //remove the transform layer but retain the other two.\r\n\t//\t| \r\n\t//\t| //now use the store as usual...\r\n\t//\t| \r\n\t//\t| store.unwrap(); //remove all the layers, get the original store back.\r\n\r\n\tvar ns = lang.getObject(\"grid.enhanced.plugins\", true, dojox);\r\n\t\r\n\tvar getPrevTags = function(tags){\r\n\t\tvar tagList = [\"reorder\", \"sizeChange\", \"normal\", \"presentation\"];\r\n\t\tvar idx = tagList.length;\r\n\t\tfor(var i = tags.length - 1; i >= 0; --i){\r\n\t\t\tvar p = array.indexOf(tagList, tags[i]);\r\n\t\t\tif(p >= 0 && p <= idx){\r\n\t\t\t\tidx = p;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(idx < tagList.length - 1){\r\n\t\t\treturn tagList.slice(0, idx + 1);\r\n\t\t}else{\r\n\t\t\treturn tagList;\r\n\t\t}\r\n\t},\r\n\t\r\n\tunwrap = function(/* string? */layerName){\r\n\t\t// summary:\r\n\t\t//\t\tUnwrap the layers of the store\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\t\t// returns:\r\n\t\t//\t\tThe unwrapped store, for nested use only.\r\n\t\tvar i, layers = this._layers, len = layers.length;\r\n\t\tif(layerName){\r\n\t\t\tfor(i = len-1; i >= 0; --i){\r\n\t\t\t\tif(layers[i].name() == layerName){\r\n\t\t\t\t\tlayers[i]._unwrap(layers[i + 1]);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlayers.splice(i, 1);\r\n\t\t}else{\r\n\t\t\tfor(i = len - 1; i >= 0; --i){\r\n\t\t\t\tlayers[i]._unwrap();\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!layers.length){\r\n\t\t\tdelete this._layers;\r\n\t\t\tdelete this.layer;\r\n\t\t\tdelete this.unwrap;\r\n\t\t\tdelete this.forEachLayer;\r\n\t\t}\r\n\t\t//console.log(\"layers:\",this._layers);\r\n\t\treturn this;\t//Read-store\r\n\t},\r\n\t\r\n\tgetLayer = function(layerName){\r\n\t\t// summary:\r\n\t\t//\t\tGet a layer of the store, so we can configure that layer.\r\n\t\t// tags:\r\n\t\t//\t\tpublic (scope is store)\r\n\t\t// layerName: string\r\n\t\t//\t\tthe name of the layer\r\n\t\t// returns:\r\n\t\t//\t\tthe store layer object\r\n\t\tvar i, layers = this._layers;\r\n\t\tif(typeof layerName == \"undefined\"){\r\n\t\t\treturn layers.length;\t//Integer\r\n\t\t}\r\n\t\tif(typeof layerName == \"number\"){\r\n\t\t\treturn layers[layerName];\t//_StoreLayer\r\n\t\t}\r\n\t\tfor(i = layers.length - 1; i >= 0; --i){\r\n\t\t\tif(layers[i].name() == layerName){\r\n\t\t\t\treturn layers[i];\t//_StoreLayer\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\t//_StoreLayer\r\n\t},\r\n\t\r\n\tforEachLayer = function(callback, isInnerToOuter){\r\n\t\t// summary:\r\n\t\t//\t\tVisit the layers one by one. From the outer most to inner most by default.\r\n\t\t// callback: Function\r\n\t\t//\t\tThe function to callback.\r\n\t\t//\t\tIf return false, break the loop.\r\n\t\t// isInnerToOuter: Boolean\r\n\t\t//\t\tWhether visit from the inner most layer to the outer most layer.\r\n\t\tvar len = this._layers.length, start, end, dir;\r\n\t\tif(isInnerToOuter){\r\n\t\t\tstart = 0;\r\n\t\t\tend = len;\r\n\t\t\tdir = 1;\r\n\t\t}else{\r\n\t\t\tstart = len - 1;\r\n\t\t\tend = -1;\r\n\t\t\tdir = -1;\r\n\t\t}\r\n\t\tfor(var i = start; i != end; i += dir){\r\n\t\t\tif(callback(this._layers[i], i) === false){\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn end;\r\n\t};\r\n\tns.wrap = function(store, funcName, layer, layerFuncName){\r\n\t\t// summary:\r\n\t\t//\t\tWrap the store with the given layer.\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\t\t// store: Read-store\r\n\t\t//\t\tThe store to be wrapped.\r\n\t\t// layer: _StoreLayer\r\n\t\t//\t\tThe layer to be used\r\n\t\t// returns:\r\n\t\t//\t\tThe wrapped store, for nested use only.\r\n\t\tif(!store._layers){\r\n\t\t\tstore._layers = [];\r\n\t\t\tstore.layer = lang.hitch(store, getLayer);\r\n\t\t\tstore.unwrap = lang.hitch(store, unwrap);\r\n\t\t\tstore.forEachLayer = lang.hitch(store, forEachLayer);\r\n\t\t}\r\n\t\tvar prevTags = getPrevTags(layer.tags);\r\n\t\tif(!array.some(store._layers, function(lyr, i){\r\n\t\t\tif(array.some(lyr.tags, function(tag){\r\n\t\t\t\treturn array.indexOf(prevTags, tag) >= 0;\r\n\t\t\t})){\r\n\t\t\t\treturn false;\r\n\t\t\t}else{\r\n\t\t\t\tstore._layers.splice(i, 0, layer);\r\n\t\t\t\tlayer._wrap(store, funcName, layerFuncName, lyr);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t})){\r\n\t\t\tstore._layers.push(layer);\r\n\t\t\tlayer._wrap(store, funcName, layerFuncName);\r\n\t\t}\r\n\t\t//console.log(\"wrapped layers:\", dojo.map(store._layers, function(lyr){return lyr.name();}));\r\n\t\treturn store;\t//Read-store\r\n\t};\r\n\r\n\tvar _StoreLayer = declare(\"dojox.grid.enhanced.plugins._StoreLayer\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tThe most abstract class of store layers, provides basic utilities and some interfaces.\r\n\t\t// tags:\r\n\t\t//\t\tabstract\r\n/*=====\r\n\t\t// _store: [protected] Read-store\r\n\t\t//\t\tThe wrapped store.\r\n\t\t_store: null,\r\n\t\t\r\n\t\t// _originFetch: [protected] function\r\n\t\t//\t\tThe original fetch function of the store.\r\n\t\t_originFetch: null,\r\n\t\t\r\n\t\t// __enabled: [private] Boolean\r\n\t\t//\t\tTo control whether this layer is valid.\r\n\t\t__enabled: true,\r\n=====*/\r\n\t\ttags: [\"normal\"],\r\n\t\t\r\n\t\tlayerFuncName: \"_fetch\",\r\n\t\t\r\n\t\tconstructor: function(){\r\n\t\t\tthis._store = null;\r\n\t\t\tthis._originFetch = null;\r\n\t\t\tthis.__enabled = true;\r\n\t\t},\r\n\t\tinitialize: function(store){\r\n\t\t},\r\n\t\tuninitialize: function(store){\r\n\t\t},\r\n\t\tinvalidate: function(){\r\n\t\t\t\r\n\t\t},\r\n\t\t_wrap: function(store, funcName, layerFuncName, nextLayer){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDo the actual wrapping (or 'hacking' if you like) to the store.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tinternal\r\n\t\t\t// store: Read-store\r\n\t\t\t//\t\tThe store to be wrapped.\r\n\t\t\tthis._store = store;\r\n\t\t\tthis._funcName = funcName;\r\n\t\t\tvar fetchFunc = lang.hitch(this, function(){\r\n\t\t\t\treturn (this.enabled() ? this[layerFuncName || this.layerFuncName] : this.originFetch).apply(this, arguments);\r\n\t\t\t});\r\n\t\t\tif(nextLayer){\r\n\t\t\t\tthis._originFetch = nextLayer._originFetch;\r\n\t\t\t\tnextLayer._originFetch = fetchFunc;\r\n\t\t\t}else{\r\n\t\t\t\tthis._originFetch = store[funcName] || function(){};\r\n\t\t\t\tstore[funcName] = fetchFunc;\r\n\t\t\t}\r\n\t\t\tthis.initialize(store);\r\n\t\t},\r\n\t\t_unwrap: function(nextLayer){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDo the actual unwrapping to the store.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tinternal\r\n\t\t\t// store: Read-store\r\n\t\t\t//\t\tThe store to be unwrapped.\r\n\t\t\tthis.uninitialize(this._store);\r\n\t\t\tif(nextLayer){\r\n\t\t\t\tnextLayer._originFetch = this._originFetch;\r\n\t\t\t}else{\r\n\t\t\t\tthis._store[this._funcName] = this._originFetch;\r\n\t\t\t}\r\n\t\t\tthis._originFetch = null;\r\n\t\t\tthis._store = null;\r\n\t\t},\r\n\t\tenabled: function(/* bool? */toEnable){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe get/set function of the enabled status of this layer\r\n\t\t\t// tags:\r\n\t\t\t//\t\tpublic\r\n\t\t\t// toEnable: Boolean?\r\n\t\t\t//\t\tIf given, is a setter, otherwise, it's getter.\r\n\t\t\tif(typeof toEnable != \"undefined\"){\r\n\t\t\t\tthis.__enabled = !!toEnable;\r\n\t\t\t}\r\n\t\t\treturn this.__enabled;\t//Boolean\r\n\t\t},\r\n\t\tname: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet the name of this store layer.\r\n\t\t\t//\t\tThe default name retrieved from class name, which should have a pattern of \"{name}Layer\".\r\n\t\t\t//\t\tIf this pattern does not exist, the whole class name will be this layer's name.\r\n\t\t\t//\t\tIt's better to override this method if your class name is too complicated.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tpublic extension\r\n\t\t\t// returns:\r\n\t\t\t//\t\tThe name of this layer.\r\n\t\t\tif(!this.__name){\r\n\t\t\t\tvar m = this.declaredClass.match(/(?:\\.(?:_*)([^\\.]+)Layer$)|(?:\\.([^\\.]+)$)/i);\r\n\t\t\t\tthis.__name = m ? (m[1] || m[2]).toLowerCase() : this.declaredClass;\r\n\t\t\t}\r\n\t\t\treturn this.__name;\r\n\t\t},\r\n\t\toriginFetch: function(){\r\n\t\t\treturn (lang.hitch(this._store, this._originFetch)).apply(this, arguments);\r\n\t\t}\r\n\t});\r\n\tvar _ServerSideLayer = declare(\"dojox.grid.enhanced.plugins._ServerSideLayer\", _StoreLayer, {\r\n\t\t// summary:\r\n\t\t//\t\tThe most abstract class for all server side store layers.\r\n\t\t// tags:\r\n\t\t//\t\tabstract\r\n/*=====\r\n\t\t// _url: [protected] string\r\n\t\t//\t\tThe url of the server\r\n\t\t_url: \"\",\r\n\t\t// __cmds [private] object\r\n\t\t//\t\tThe command object to be sent to server.\r\n\t\t__cmds: {},\r\n=====*/\r\n\t\tconstructor: function(args){\r\n\t\t\targs = args || {};\r\n\t\t\tthis._url = args.url || \"\";\r\n\t\t\tthis._isStateful = !!args.isStateful;\r\n\t\t\tthis._onUserCommandLoad = args.onCommandLoad || function(){};\r\n\t\t\tthis.__cmds = {cmdlayer:this.name(), enable:true};\r\n\t\t\t\r\n\t\t\t//Only for stateful server, sending commands before fetch makes sense.\r\n\t\t\tthis.useCommands(this._isStateful);\r\n\t\t},\r\n\t\tenabled: function(/* bool? */toEnable){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tOverrided from _StoreLayer.enabled\r\n\t\t\tvar res = this.inherited(arguments);\r\n\t\t\tthis.__cmds.enable = this.__enabled;\r\n\t\t\treturn res;\r\n\t\t},\r\n\t\tuseCommands: function(/* bool? */toUse){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tIf you only want to modify the user request, instead of sending a separate command\r\n\t\t\t//\t\tto server before fetch, just call:\r\n\t\t\t// |\t\tthis.useCommand(false);\r\n\t\t\t// tags:\r\n\t\t\t//\t\tpublic\r\n\t\t\t// toUse: Boolean?\r\n\t\t\t//\t\tIf provided, it's a setter, otherwise, it's a getter\r\n\t\t\tif(typeof toUse != \"undefined\"){\r\n\t\t\t\tthis.__cmds.cmdlayer = (toUse && this._isStateful) ? this.name() : null;\r\n\t\t\t}\r\n\t\t\treturn !!(this.__cmds.cmdlayer);\t//Boolean\r\n\t\t},\r\n\t\t_fetch: function(/* keywordArgs */userRequest){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tImplementation of _StoreLayer._fetch\r\n\t\t\tif(this.__cmds.cmdlayer){\r\n\t\t\t\t//We're gonna send command to server before fetch.\r\n\t\t\t\txhr.post({\r\n\t\t\t\t\turl: this._url || this._store.url,\r\n\t\t\t\t\tcontent: this.__cmds,\r\n\t\t\t\t\tload: lang.hitch(this, function(responce){\r\n\t\t\t\t\t\tthis.onCommandLoad(responce, userRequest);\r\n\t\t\t\t\t\tthis.originFetch(userRequest);\r\n\t\t\t\t\t}),\r\n\t\t\t\t\terror: lang.hitch(this, this.onCommandError)\r\n\t\t\t\t});\r\n\t\t\t}else{\r\n\t\t\t\t//The user only wants to modify the request object.\r\n\t\t\t\tthis.onCommandLoad(\"\", userRequest);\r\n\t\t\t\tthis.originFetch(userRequest);\r\n\t\t\t}\r\n\t\t\treturn userRequest;\t// dojo/data/api/Request\r\n\t\t},\r\n\t\tcommand: function(/* string */cmdName,/* (string|number|bool|...)? */cmdContent){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tget/set a command (a name-value pair)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tpublic\r\n\t\t\t// cmdName: string\r\n\t\t\t//\t\tThe name of the command\r\n\t\t\t// cmdContent: anything\r\n\t\t\t//\t\tThe content of the command\r\n\t\t\t// returns:\r\n\t\t\t//\t\tThe content of the command if cmdContent is undefined\r\n\t\t\tvar cmds = this.__cmds;\r\n\t\t\tif(cmdContent === null){\r\n\t\t\t\tdelete cmds[cmdName];\r\n\t\t\t}else if(typeof cmdContent !== \"undefined\"){\r\n\t\t\t\tcmds[cmdName] = cmdContent;\r\n\t\t\t}\r\n\t\t\treturn cmds[cmdName];\t//anything\r\n\t\t},\r\n\t\tonCommandLoad: function(/* string */response, /* keywordArgs */userRequest){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tWhen the server gives back *response* for the commands, you can do something here.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback extension\r\n\t\t\t// response: string\r\n\t\t\t//\t\tserver response\r\n\t\t\t// userRequest: [in|out] dojo/data/api/Request\r\n\t\t\t//\t\tThe request object for *fetch*. You can modify this object according to the *response*\r\n\t\t\t//\t\tso as to change the behavior of *fetch*\r\n\t\t\tthis._onUserCommandLoad(this.__cmds, userRequest, response);\r\n\t\t},\r\n\t\tonCommandError: function(error){\r\n\t\t\t// summary:\r\n\t\t\t//\t\thandle errors when sending commands.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback extension\r\n\t\t\t// error: Error\r\n\t\t\tconsole.log(error);\r\n\t\t\tthrow error;\r\n\t\t}\r\n\t});\r\n\r\n\treturn {\r\n\t\t_StoreLayer: _StoreLayer,\r\n\t\t_ServerSideLayer: _ServerSideLayer,\r\n\t\twrap: ns.wrap\r\n\t};\r\n});\r\n"]}