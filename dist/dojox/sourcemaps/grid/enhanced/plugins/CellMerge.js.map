{"version":3,"sources":["grid/enhanced/plugins/CellMerge.js"],"names":["define","declare","array","lang","html","_Plugin","EnhancedGrid","CellMerge","name","constructor","grid","args","this","_records","_merged","isObject","_setupConfig","mergedCells","_initEvents","_mixinGrid","mergeCells","rowTester","startColumnIndex","endColumnIndex","majorColumnIndex","item","_createRecord","row","start","end","major","_updateRows","unmergeCells","mergeHandler","idx","indexOf","splice","getMergedCells","res","i","concat","getMergedCellsByRow","rowIndex","config","forEach","views","view","connect","hitch","index","g","_getWidth","colIndex","node","layout","cells","getHeaderNode","position","w","_onAfterRow","viewIdx","subrows","j","result","len","length","storeItem","_by_idx","store","record","hiddenCells","totalWidth","majorNode","getNode","majorHeaderNode","push","r","style","pbm","marginBox","contentBox","tw","isWebKit","setAttribute","handle","e","console","warn","_isValid","isNaN","id","getFeatures","getIdentity","error","isFunction","colCount","subrow","min","count","rowCount","updateRow","scroller","rowHeightChanged","registerPlugin"],"mappings":"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","file":"../../../../grid/enhanced/plugins/CellMerge.js","sourcesContent":["define([\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/html\",\r\n\t\"../_Plugin\",\r\n\t\"../../EnhancedGrid\"\r\n], function(declare, array, lang, html, _Plugin, EnhancedGrid){\r\n\r\nvar CellMerge = declare(\"dojox.grid.enhanced.plugins.CellMerge\", _Plugin, {\r\n\t// summary:\r\n\t//\t\tThis plugin provides functions to merge(un-merge) adjacent cells within one row.\r\n\t//\t\tAcceptable plugin parameters:\r\n\t//\r\n\t//\t\t- mergedCells: Array: An array of objects with structure:\r\n\t//\r\n\t// |\t\t{\r\n\t// |\t\t\trow: function(Integer)|Integer\r\n\t// |\t\t\t\tIf it's a function, it's a predicate to decide which rows are to be merged.\r\n\t// |\t\t\t\tIt takes an integer (the row index), and should return true or false;\r\n\t// |\t\t\tstart: Integer\r\n\t// |\t\t\t\tThe column index of the left most cell that shall be merged.\r\n\t// |\t\t\tend: Integer\r\n\t// |\t\t\t\tThe column index of the right most cell that shall be merged.\r\n\t// |\t\t\tmajor: Integer\r\n\t// |\t\t\t\tThe column index of the cell whose content should be used as the content of the merged cell.\r\n\t// |\t\t\t\tIt must be larger than or equal to the startColumnIndex, and less than or equal to the endColumnIndex.\r\n\t// |\t\t\t\tIf it is omitted, the content of the leading edge (left-most for ltr, right most for rtl) cell will be used.\r\n\t// |\t\t}\r\n\t\r\n\t// name: String\r\n\t//\t\tPlugin name\r\n\tname: \"cellMerge\",\r\n\t\r\n\tconstructor: function(grid, args){\r\n\t\tthis.grid = grid;\r\n\t\tthis._records = [];\r\n\t\tthis._merged = {};\r\n\t\tif(args && lang.isObject(args)){\r\n\t\t\tthis._setupConfig(args.mergedCells);\r\n\t\t}\r\n\t\tthis._initEvents();\r\n\t\tthis._mixinGrid();\r\n\t},\r\n\t//----------------Public----------------------------\r\n\tmergeCells: function(rowTester, startColumnIndex, endColumnIndex, majorColumnIndex){\r\n\t\t// summary:\r\n\t\t//\t\tMerge cells from *startColumnIndex* to *endColumnIndex* at rows that make *rowTester* return true,\r\n\t\t//\t\tusing the content of the cell at *majorColumnIndex*\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\t\t// rowTester: function(Integer)|Integer\r\n\t\t//\t\tIf it's a function, it's a predicate to decide which rows are to be merged.\r\n\t\t//\t\tIt takes an integer (the row index), and should return true or false;\r\n\t\t// startColumnIndex: Integer\r\n\t\t//\t\tThe column index of the left most cell that shall be merged.\r\n\t\t// endColumnIndex: Integer\r\n\t\t//\t\tThe column index of the right most cell that shall be merged.\r\n\t\t// majorColumnIndex: Integer?\r\n\t\t//\t\tThe column index of the cell whose content should be used as the content of the merged cell.\r\n\t\t//\t\tIt must be larger than or equal to the startColumnIndex, and less than or equal to the endColumnIndex.\r\n\t\t//\t\tIf it is omitted, the content of the leading edge (left-most for ltr, right most for rtl) cell will be used.\r\n\t\t// returns: Object|null\r\n\t\t//\t\tA handler for the merged cells created by a call of this function.\r\n\t\t//\t\tThis handler can be used later to unmerge cells using the function unmergeCells\r\n\t\t//\t\tIf the merge is not valid, returns null;\r\n\t\tvar item = this._createRecord({\r\n\t\t\t\"row\": rowTester,\r\n\t\t\t\"start\": startColumnIndex,\r\n\t\t\t\"end\": endColumnIndex,\r\n\t\t\t\"major\": majorColumnIndex\r\n\t\t});\r\n\t\tif(item){\r\n\t\t\tthis._updateRows(item);\r\n\t\t}\r\n\t\treturn item; // Object|null\r\n\t},\r\n\tunmergeCells: function(mergeHandler){\r\n\t\t// summary:\r\n\t\t//\t\tUnmerge the cells that are merged by the *mergeHandler*, which represents a call to the function mergeCells.\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\t\t// mergeHandler: object\r\n\t\t//\t\tA handler for the merged cells created by a call of function mergeCells.\r\n\t\tvar idx;\r\n\t\tif(mergeHandler && (idx = array.indexOf(this._records, mergeHandler)) >= 0){\r\n\t\t\tthis._records.splice(idx, 1);\r\n\t\t\tthis._updateRows(mergeHandler);\r\n\t\t}\r\n\t},\r\n\tgetMergedCells: function(){\r\n\t\t// summary:\r\n\t\t//\t\tGet all records of currently merged cells.\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\t\t// returns: Array\r\n\t\t//\t\tAn array of records for merged-cells.\r\n\t\t//\t\tThe record has the following structure:\r\n\t\t// |\t{\r\n\t\t// |\t\t\"row\": 1, //the row index\r\n\t\t// |\t\t\"start\": 2, //the start column index\r\n\t\t// |\t\t\"end\": 4, //the end column index\r\n\t\t// |\t\t\"major\": 3, //the major column index\r\n\t\t// |\t\t\"handle\": someHandle, //The handler that covers this merge cell record.\r\n\t\t// |\t}\r\n\t\tvar res = [];\r\n\t\tfor(var i in this._merged){\r\n\t\t\tres = res.concat(this._merged[i]);\r\n\t\t}\r\n\t\treturn res;\r\n\t},\r\n\tgetMergedCellsByRow: function(rowIndex){\r\n\t\t// summary:\r\n\t\t//\t\tGet the records of currently merged cells at the given row.\r\n\t\t// tags:\r\n\t\t//\t\tpublic\r\n\t\t// returns: Array\r\n\t\t//\t\tAn array of records for merged-cells. See docs of getMergedCells.\r\n\t\treturn this._merged[rowIndex] || [];\r\n\t},\r\n\t\r\n\t//----------------Private--------------------------\r\n\t_setupConfig: function(config){\r\n\t\tarray.forEach(config, this._createRecord, this);\r\n\t},\r\n\t_initEvents: function(){\r\n\t\tarray.forEach(this.grid.views.views, function(view){\r\n\t\t\tthis.connect(view, \"onAfterRow\", lang.hitch(this, \"_onAfterRow\", view.index));\r\n\t\t}, this);\r\n\t},\r\n\t_mixinGrid: function(){\r\n\t\tvar g = this.grid;\r\n\t\tg.mergeCells = lang.hitch(this, \"mergeCells\");\r\n\t\tg.unmergeCells = lang.hitch(this, \"unmergeCells\");\r\n\t\tg.getMergedCells = lang.hitch(this, \"getMergedCells\");\r\n\t\tg.getMergedCellsByRow = lang.hitch(this, \"getMergedCellsByRow\");\r\n\t},\r\n\t_getWidth: function(colIndex){\r\n\t\tvar node = this.grid.layout.cells[colIndex].getHeaderNode();\r\n\t\treturn html.position(node).w;\r\n\t},\r\n\t_onAfterRow: function(viewIdx, rowIndex, subrows){\r\n\t\ttry{\r\n\t\t\tif(rowIndex < 0){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar result = [], i, j, len = this._records.length,\r\n\t\t\t\tcells = this.grid.layout.cells;\r\n\t\t\t//Apply merge-cell requests one by one.\r\n\t\t\tfor(i = 0; i < len; ++i){\r\n\t\t\t\tvar item = this._records[i];\r\n\t\t\t\tvar storeItem = this.grid._by_idx[rowIndex];\r\n\t\t\t\tif(item.view == viewIdx && item.row(rowIndex, storeItem && storeItem.item, this.grid.store)){\r\n\t\t\t\t\tvar res = {\r\n\t\t\t\t\t\trecord: item,\r\n\t\t\t\t\t\thiddenCells: [],\r\n\t\t\t\t\t\ttotalWidth: 0,\r\n\t\t\t\t\t\tmajorNode: cells[item.major].getNode(rowIndex),\r\n\t\t\t\t\t\tmajorHeaderNode: cells[item.major].getHeaderNode()\r\n\t\t\t\t\t};\r\n\t\t\t\t\t//Calculated the width of merged cell.\r\n\t\t\t\t\tfor(j = item.start; j <= item.end; ++j){\r\n\t\t\t\t\t\tvar w = this._getWidth(j, rowIndex);\r\n\t\t\t\t\t\tres.totalWidth += w;\r\n\t\t\t\t\t\tif(j != item.major){\r\n\t\t\t\t\t\t\tres.hiddenCells.push(cells[j].getNode(rowIndex));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//If width is valid, remember it. There may be multiple merges within one row.\r\n\t\t\t\t\tif(subrows.length != 1 || res.totalWidth > 0){\r\n\t\t\t\t\t\t//Remove conflicted merges.\r\n\t\t\t\t\t\tfor(j = result.length - 1; j >= 0; --j){\r\n\t\t\t\t\t\t\tvar r = result[j].record;\r\n\t\t\t\t\t\t\tif((r.start >= item.start && r.start <= item.end) ||\r\n\t\t\t\t\t\t\t\t(r.end >= item.start && r.end <= item.end)){\r\n\t\t\t\t\t\t\t\tresult.splice(j, 1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tresult.push(res);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._merged[rowIndex] = [];\r\n\t\t\tarray.forEach(result, function(res){\r\n\t\t\t\tarray.forEach(res.hiddenCells, function(node){\r\n\t\t\t\t\thtml.style(node, \"display\", \"none\");\r\n\t\t\t\t});\r\n\t\t\t\tvar pbm = html.marginBox(res.majorHeaderNode).w - html.contentBox(res.majorHeaderNode).w;\r\n\t\t\t\tvar tw = res.totalWidth;\r\n\t\t\t\t\r\n\t\t\t\t//Tricky for WebKit.\r\n\t\t\t\tif(!html.isWebKit){\r\n\t\t\t\t\ttw -= pbm;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\thtml.style(res.majorNode, \"width\", tw + \"px\");\r\n\t\t\t\t//In case we're dealing with multiple subrows.\r\n\t\t\t\tres.majorNode.setAttribute(\"colspan\", res.hiddenCells.length + 1);\r\n\t\r\n\t\t\t\tthis._merged[rowIndex].push({\r\n\t\t\t\t\t\"row\": rowIndex,\r\n\t\t\t\t\t\"start\": res.record.start,\r\n\t\t\t\t\t\"end\": res.record.end,\r\n\t\t\t\t\t\"major\": res.record.major,\r\n\t\t\t\t\t\"handle\": res.record\r\n\t\t\t\t});\r\n\t\t\t}, this);\r\n\t\t}catch(e){\r\n\t\t\tconsole.warn(\"CellMerge._onAfterRow() error: \", rowIndex, e);\r\n\t\t}\r\n\t},\r\n\t_createRecord: function(item){\r\n\t\tif(this._isValid(item)){\r\n\t\t\titem = {\r\n\t\t\t\t\"row\": item.row,\r\n\t\t\t\t\"start\": item.start,\r\n\t\t\t\t\"end\": item.end,\r\n\t\t\t\t\"major\": item.major\r\n\t\t\t};\r\n\t\t\tvar cells = this.grid.layout.cells;\r\n\t\t\titem.view = cells[item.start].view.index;\r\n\t\t\titem.major = typeof item.major == \"number\" && !isNaN(item.major) ? item.major : item.start;\r\n\t\t\tif(typeof item.row == \"number\"){\r\n\t\t\t\tvar r = item.row;\r\n\t\t\t\titem.row = function(rowIndex){\r\n\t\t\t\t\treturn rowIndex === r;\r\n\t\t\t\t};\r\n\t\t\t}else if(typeof item.row == \"string\"){\r\n\t\t\t\tvar id = item.row;\r\n\t\t\t\titem.row = function(rowIndex, storeItem, store){\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tif(store && storeItem && store.getFeatures()['dojo.data.api.Identity']){\r\n\t\t\t\t\t\t\treturn store.getIdentity(storeItem) == id;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\tconsole.error(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tif(lang.isFunction(item.row)){\r\n\t\t\t\tthis._records.push(item);\r\n\t\t\t\treturn item;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\t_isValid: function(item){\r\n\t\tvar cells = this.grid.layout.cells,\r\n\t\t\tcolCount = cells.length;\r\n\t\treturn (lang.isObject(item) && (\"row\" in item) && (\"start\" in item) && (\"end\" in item) &&\r\n\t\t\titem.start >= 0 && item.start < colCount &&\r\n\t\t\titem.end > item.start && item.end < colCount &&\r\n\t\t\tcells[item.start].view.index == cells[item.end].view.index &&\r\n\t\t\tcells[item.start].subrow == cells[item.end].subrow &&\r\n\t\t\t!(typeof item.major == \"number\" && (item.major < item.start || item.major > item.end)));\r\n\t},\r\n\t_updateRows: function(item){\r\n\t\tvar min = null;\r\n\t\tfor(var i = 0, count = this.grid.rowCount; i < count; ++i){\r\n\t\t\tvar storeItem = this.grid._by_idx[i];\r\n\t\t\tif(storeItem && item.row(i, storeItem && storeItem.item, this.grid.store)){\r\n\t\t\t\tthis.grid.views.updateRow(i);\r\n\t\t\t\tif(min === null){ min = i; }\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(min >= 0){\r\n\t\t\tthis.grid.scroller.rowHeightChanged(min);\r\n\t\t}\r\n\t}\r\n});\r\n\r\nEnhancedGrid.registerPlugin(CellMerge);\r\n\r\nreturn CellMerge;\r\n});\r\n"]}