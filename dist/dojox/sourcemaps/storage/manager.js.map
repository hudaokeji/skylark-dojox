{"version":3,"sources":["storage/manager.js"],"names":["dojo","provide","dojox","storage","manager","this","currentProvider","available","providers","_initialized","_onLoadListeners","initialize","autodetect","register","name","instance","push","setProvider","storageClass","providerToUse","forceProvider","config","i","length","declaredClass","isAvailable","console","warn","loaded","mixin","addOnLoad","func","isInitialized","_fireLoaded","removeOnLoad","splice","flash","ready","supportsProvider","provider","eval","results","e","getProvider","forEach","debug","getResourceList","concat"],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,yBAIbC,MAAMC,QAAQC,QAAU,IAAI,WAU3BC,KAAKC,gBAAkB,KAIvBD,KAAKE,WAAY,EAKjBF,KAAKG,aAELH,KAAKI,cAAe,EAEpBJ,KAAKK,oBAELL,KAAKM,WAAa,WAIjBN,KAAKO,cAGNP,KAAKQ,SAAW,SAAoBC,EAAiBC,GAkBpDV,KAAKG,UAAUQ,KAAKD,GACpBV,KAAKG,UAAUM,GAAQC,GAGxBV,KAAKY,YAAc,SAASC,KAU5Bb,KAAKO,WAAa,WAOjB,IAAGP,KAAKI,aAAR,CAYA,IALA,IAGIU,EAHAC,EAAgBpB,KAAKqB,OAA6B,uBAAK,EAKnDC,EAAI,EAAGA,EAAIjB,KAAKG,UAAUe,OAAQD,IAAI,CAE7C,GADAH,EAAgBd,KAAKG,UAAUc,GAC5BF,GAAiBA,GAAiBD,EAAcK,cAAc,CAKhEL,EAAcM,cACd,MACK,IAAIL,GAAiBD,EAAcM,cACxC,MAIF,IAAIN,EAMH,OALAd,KAAKI,cAAe,EACpBJ,KAAKE,WAAY,EACjBF,KAAKC,gBAAkB,KACvBoB,QAAQC,KAAK,oDACbtB,KAAKuB,SAONvB,KAAKC,gBAAkBa,EACvBnB,KAAK6B,MAAM3B,MAAMC,QAASE,KAAKC,iBAG/BJ,MAAMC,QAAQQ,aAEdN,KAAKI,cAAe,EACpBJ,KAAKE,WAAY,IAGlBF,KAAKoB,YAAc,WAGlB,OAAOpB,KAAKE,WAGbF,KAAKyB,UAAY,SAASC,GAWzB1B,KAAKK,iBAAiBM,KAAKe,GAExB1B,KAAK2B,iBACP3B,KAAK4B,eAIP5B,KAAK6B,aAAe,SAASH,GAG5B,IAAI,IAAIT,EAAI,EAAGA,EAAIjB,KAAKK,iBAAiBa,OAAQD,IAChD,GAAGS,GAAQ1B,KAAKK,iBAAiBY,GAAG,CACnCjB,KAAKK,iBAAiByB,OAAOb,EAAG,GAChC,QAKHjB,KAAK2B,cAAgB,WASpB,OAA2B,MAAxB3B,KAAKC,iBACkC,sCAAtCD,KAAKC,gBAAgBkB,eACA,GAArBtB,MAAMkC,MAAMC,QAGRhC,KAAKI,cAIdJ,KAAKiC,iBAAmB,SAAoBpB,cAQ3C,IAGC,IAAIqB,SAAWC,KAAK,OAAStB,aAAe,MACxCuB,QAAUF,SAASd,cACvB,OAAIgB,UAAiB,EAErB,MAAMC,GACN,OAAO,IAITrC,KAAKsC,YAAc,WAGlB,OAAOtC,KAAKC,iBAGbD,KAAKuB,OAAS,WAoBbvB,KAAK4B,eAGN5B,KAAK4B,YAAc,WAGlBjC,KAAK4C,QAAQvC,KAAKK,iBAAkB,SAASY,GAC5C,IACCA,IACA,MAAMoB,GAAIhB,QAAQmB,MAAMH,OAI3BrC,KAAKyC,gBAAkB,WAgBtB,IAAIL,KAKJ,OAJAzC,KAAK4C,QAAQ1C,MAAMC,QAAQC,QAAQI,UAAW,SAASF,GACtDmC,EAAUA,EAAQM,OAAOzC,EAAgBwC,qBAGnCL","file":"../../storage/manager.js","sourcesContent":["dojo.provide(\"dojox.storage.manager\");\r\n//dojo.require(\"dojo.AdapterRegistry\");\r\n// FIXME: refactor this to use an AdapterRegistry\r\n\r\ndojox.storage.manager = new function(){\r\n\t// summary:\r\n\t//\t\tA singleton class in charge of the dojox.storage system\r\n\t// description:\r\n\t//\t\tInitializes the storage systems and figures out the best available\r\n\t//\t\tstorage options on this platform.\r\n\r\n\t// currentProvider: Object\r\n\t//\t\tThe storage provider that was automagically chosen to do storage\r\n\t//\t\ton this platform, such as dojox.storage.FlashStorageProvider.\r\n\tthis.currentProvider = null;\r\n\r\n\t// available: Boolean\r\n\t//\t\tWhether storage of some kind is available.\r\n\tthis.available = false;\r\n\r\n\t// providers: Array\r\n\t//\t\tArray of all the static provider instances, useful if you want to\r\n\t//\t\tloop through and see what providers have been registered.\r\n\tthis.providers = [];\r\n\r\n\tthis._initialized = false;\r\n\r\n\tthis._onLoadListeners = [];\r\n\r\n\tthis.initialize = function(){\r\n\t\t// summary:\r\n\t\t//\t\tInitializes the storage system and autodetects the best storage\r\n\t\t//\t\tprovider we can provide on this platform\r\n\t\tthis.autodetect();\r\n\t};\r\n\r\n\tthis.register = function(/*string*/ name, /*Object*/ instance){\r\n\t\t// summary:\r\n\t\t//\t\tRegisters the existence of a new storage provider; used by\r\n\t\t//\t\tsubclasses to inform the manager of their existence. The\r\n\t\t//\t\tstorage manager will select storage providers based on\r\n\t\t//\t\ttheir ordering, so the order in which you call this method\r\n\t\t//\t\tmatters.\r\n\t\t// name:\r\n\t\t//\t\tThe full class name of this provider, such as\r\n\t\t//\t\t\"dojox.storage.FlashStorageProvider\".\r\n\t\t// instance:\r\n\t\t//\t\tAn instance of this provider, which we will use to call\r\n\t\t//\t\tisAvailable() on.\r\n\r\n\t\t// keep list of providers as a list so that we can know what order\r\n\t\t// storage providers are preferred; also, store the providers hashed\r\n\t\t// by name in case someone wants to get a provider that uses\r\n\t\t// a particular storage backend\r\n\t\tthis.providers.push(instance);\r\n\t\tthis.providers[name] = instance;\r\n\t};\r\n\r\n\tthis.setProvider = function(storageClass){\r\n\t\t// summary:\r\n\t\t//\t\tInstructs the storageManager to use the given storage class for\r\n\t\t//\t\tall storage requests.\r\n\t\t// example:\r\n\t\t//\t|\tdojox.storage.setProvider(\r\n\t\t//\t|\t\tdojox.storage.IEStorageProvider)\r\n\r\n\t};\r\n\r\n\tthis.autodetect = function(){\r\n\t\t// summary:\r\n\t\t//\t\tAutodetects the best possible persistent storage provider\r\n\t\t//\t\tavailable on this platform.\r\n\r\n\t\t//console.debug(\"dojox.storage.manager.autodetect\");\r\n\r\n\t\tif(this._initialized){ // already finished\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// a flag to force the storage manager to use a particular\r\n\t\t// storage provider type, such as\r\n\t\t// djConfig = {forceStorageProvider: \"dojox.storage.WhatWGStorageProvider\"};\r\n\t\tvar forceProvider = dojo.config[\"forceStorageProvider\"] || false;\r\n\r\n\t\t// go through each provider, seeing if it can be used\r\n\t\tvar providerToUse;\r\n\t\t//FIXME: use dojo.some\r\n\t\tfor(var i = 0; i < this.providers.length; i++){\r\n\t\t\tproviderToUse = this.providers[i];\r\n\t\t\tif(forceProvider && forceProvider == providerToUse.declaredClass){\r\n\t\t\t\t// still call isAvailable for this provider, since this helps some\r\n\t\t\t\t// providers internally figure out if they are available\r\n\t\t\t\t// FIXME: This should be refactored since it is non-intuitive\r\n\t\t\t\t// that isAvailable() would initialize some state\r\n\t\t\t\tproviderToUse.isAvailable();\r\n\t\t\t\tbreak;\r\n\t\t\t}else if(!forceProvider && providerToUse.isAvailable()){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(!providerToUse){ // no provider available\r\n\t\t\tthis._initialized = true;\r\n\t\t\tthis.available = false;\r\n\t\t\tthis.currentProvider = null;\r\n\t\t\tconsole.warn(\"No storage provider found for this platform\");\r\n\t\t\tthis.loaded();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// create this provider and mix in it's properties\r\n\t\t// so that developers can do dojox.storage.put rather\r\n\t\t// than dojox.storage.currentProvider.put, for example\r\n\t\tthis.currentProvider = providerToUse;\r\n\t\tdojo.mixin(dojox.storage, this.currentProvider);\r\n\r\n\t\t// have the provider initialize itself\r\n\t\tdojox.storage.initialize();\r\n\r\n\t\tthis._initialized = true;\r\n\t\tthis.available = true;\r\n\t};\r\n\r\n\tthis.isAvailable = function(){ /*Boolean*/\r\n\t\t// summary:\r\n\t\t//\t\tReturns whether any storage options are available.\r\n\t\treturn this.available;\r\n\t};\r\n\r\n\tthis.addOnLoad = function(func){ /* void */\r\n\t\t// summary:\r\n\t\t//\t\tAdds an onload listener to know when Dojo Offline can be used.\r\n\t\t// description:\r\n\t\t//\t\tAdds a listener to know when Dojo Offline can be used. This\r\n\t\t//\t\tensures that the Dojo Offline framework is loaded and that the\r\n\t\t//\t\tlocal dojox.storage system is ready to be used. This method is\r\n\t\t//\t\tuseful if you don't want to have a dependency on Dojo Events\r\n\t\t//\t\twhen using dojox.storage.\r\n\t\t// func: Function\r\n\t\t//\t\tA function to call when Dojo Offline is ready to go\r\n\t\tthis._onLoadListeners.push(func);\r\n\r\n\t\tif(this.isInitialized()){\r\n\t\t\tthis._fireLoaded();\r\n\t\t}\r\n\t};\r\n\r\n\tthis.removeOnLoad = function(func){ /* void */\r\n\t\t// summary:\r\n\t\t//\t\tRemoves the given onLoad listener\r\n\t\tfor(var i = 0; i < this._onLoadListeners.length; i++){\r\n\t\t\tif(func == this._onLoadListeners[i]){\r\n\t\t\t\tthis._onLoadListeners.splice(i, 1);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tthis.isInitialized = function(){ /*Boolean*/\r\n\t \t// summary:\r\n\t\t//\t\tReturns whether the storage system is initialized and ready to\r\n\t\t//\t\tbe used.\r\n\r\n\t\t// FIXME: This should REALLY not be in here, but it fixes a tricky\r\n\t\t// Flash timing bug.\r\n\t\t// Confirm that this is still needed with the newly refactored Dojo\r\n\t\t// Flash. Used to be for Internet Explorer. -- Brad Neuberg\r\n\t\tif(this.currentProvider != null\r\n\t\t\t&& this.currentProvider.declaredClass == \"dojox.storage.FlashStorageProvider\"\r\n\t\t\t&& dojox.flash.ready == false){\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn this._initialized;\r\n\t\t}\r\n\t};\r\n\r\n\tthis.supportsProvider = function(/*string*/ storageClass){ /* Boolean */\r\n\t\t// summary:\r\n\t\t//\t\tDetermines if this platform supports the given storage provider.\r\n\t\t// example:\r\n\t\t// |\tdojox.storage.manager.supportsProvider(\r\n\t\t// |\t\t\"dojox.storage.InternetExplorerStorageProvider\");\r\n\r\n\t\t// construct this class dynamically\r\n\t\ttry{\r\n\t\t\t// dynamically call the given providers class level isAvailable()\r\n\t\t\t// method\r\n\t\t\tvar provider = eval(\"new \" + storageClass + \"()\");\r\n\t\t\tvar results = provider.isAvailable();\r\n\t\t\tif(!results){ return false; }\r\n\t\t\treturn results;\r\n\t\t}catch(e){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\tthis.getProvider = function(){ /* Object */\r\n\t\t// summary:\r\n\t\t//\t\tGets the current provider\r\n\t\treturn this.currentProvider;\r\n\t};\r\n\r\n\tthis.loaded = function(){\r\n\t\t// summary:\r\n\t\t//\t\tThe storage provider should call this method when it is loaded\r\n\t\t//\t\tand ready to be used. Clients who will use the provider will\r\n\t\t//\t\tconnect to this method to know when they can use the storage\r\n\t\t//\t\tsystem. You can either use dojo.connect to connect to this\r\n\t\t//\t\tfunction, or can use dojox.storage.manager.addOnLoad() to add\r\n\t\t//\t\ta listener that does not depend on the dojo.event package.\r\n\t\t// example:\r\n\t\t// |\tif(dojox.storage.manager.isInitialized() == false){\r\n\t\t// |\t\tdojo.connect(dojox.storage.manager, \"loaded\", TestStorage, \"initialize\");\r\n\t\t// |\t}else{\r\n\t\t// |\t\tdojo.connect(dojo, \"loaded\", TestStorage, \"initialize\");\r\n\t\t// |\t}\r\n\t\t// example:\r\n\t\t// |\tdojox.storage.manager.addOnLoad(someFunction);\r\n\r\n\r\n\t\t// FIXME: we should just provide a Deferred for this. That way you\r\n\t\t// don't care when this happens or has happened. Deferreds are in Base\r\n\t\tthis._fireLoaded();\r\n\t};\r\n\r\n\tthis._fireLoaded = function(){\r\n\t\t//console.debug(\"dojox.storage.manager._fireLoaded\");\r\n\r\n\t\tdojo.forEach(this._onLoadListeners, function(i){\r\n\t\t\ttry{\r\n\t\t\t\ti();\r\n\t\t\t}catch(e){ console.debug(e); }\r\n\t\t});\r\n\t};\r\n\r\n\tthis.getResourceList = function(){\r\n\t\t// summary:\r\n\t\t//\t\tReturns a list of whatever resources are necessary for storage\r\n\t\t//\t\tproviders to work.\r\n\t\t// description:\r\n\t\t//\t\tThis will return all files needed by all storage providers for\r\n\t\t//\t\tthis particular environment type. For example, if we are in the\r\n\t\t//\t\tbrowser environment, then this will return the hidden SWF files\r\n\t\t//\t\tneeded by the FlashStorageProvider, even if we don't need them\r\n\t\t//\t\tfor the particular browser we are working within. This is meant\r\n\t\t//\t\tto faciliate Dojo Offline, which must retrieve all resources we\r\n\t\t//\t\tneed offline into the offline cache -- we retrieve everything\r\n\t\t//\t\tneeded, in case another browser that requires different storage\r\n\t\t//\t\tmechanisms hits the local offline cache. For example, if we\r\n\t\t//\t\twere to sync against Dojo Offline on Firefox 2, then we would\r\n\t\t//\t\tnot grab the FlashStorageProvider resources needed for Safari.\r\n\t\tvar results = [];\r\n\t\tdojo.forEach(dojox.storage.manager.providers, function(currentProvider){\r\n\t\t\tresults = results.concat(currentProvider.getResourceList());\r\n\t\t});\r\n\r\n\t\treturn results;\r\n\t}\r\n};\r\n"]}