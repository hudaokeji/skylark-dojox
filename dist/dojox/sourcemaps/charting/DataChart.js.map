{"version":3,"sources":["charting/DataChart.js"],"names":["define","kernel","lang","declare","html","hub","arr","Chart","blue","dom","experimental","_yaxis","vertical","min","max","majorTickStep","minorTickStep","natural","stroke","majorTick","length","minorTick","majorLabels","_xaxis","includeZero","fixUpper","htmlLabels","from","chartPlot","markers","tension","gap","scroll","comparative","query","queryOptions","fieldName","chartTheme","displayRange","stretchToFit","minWidth","minHeight","showing","label","constructor","node","kwArgs","this","domNode","byId","mixin","xaxis","labelFunc","hitch","yaxis","_events","convertLabels","onSetItems","onSetInterval","dataLength","seriesData","seriesDataBk","firstRun","dataOffset","plotarea","color","width","setTheme","to","cartesian","type","prototype","declaredClass","addAxis","addPlot","grid","hMinorLines","render","store","setStore","destroy","forEach","disconnect","inherited","arguments","getLabelAttributes","connect","fetch","show","style","hide","onSet","item","nm","getProperty","runs","clearTimeout","setTimeout","items","push","onData","onError","err","console","error","onDataReceived","prop","getLabel","getIdentity","value","getValues","getValue","m","id","m2","i","field","isArray","Number","ar","map","Array","displayData","addSeries","slice","updateSeries","start","count","sort","onComplete","data","axis","labels","isObject","ele","text","seriesLabels","val","series","name","resizeChart","dim","w","Math","h","resize"],"mappings":"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","file":"../../charting/DataChart.js","sourcesContent":["define([\"dojo/_base/kernel\", \"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/html\", \"dojo/_base/connect\",\r\n\t \"dojo/_base/array\", \"./Chart2D\", \"./themes/PlotKit/blue\", \"dojo/dom\"], \r\n\t function(kernel, lang, declare, html, hub, arr, Chart, blue, dom){\r\n\t// FIXME: This module drags in all Charting modules because of the Chart2D dependency...it is VERY heavy\r\n\tkernel.experimental(\"dojox.charting.DataChart\");\r\n\r\n\t// Defaults for axes\r\n\t//\tto be mixed in with xaxis/yaxis custom properties\r\n\t// see dojox.charting.axis2d.Default for details.\r\n\tvar _yaxis = {\r\n\t\tvertical: true,\r\n\t\tmin: 0,\r\n\t\tmax: 10,\r\n\t\tmajorTickStep: 5,\r\n\t\tminorTickStep: 1,\r\n\t\tnatural:false,\r\n\t\tstroke: \"black\",\r\n\t\tmajorTick: {stroke: \"black\", length: 8},\r\n\t\tminorTick: {stroke: \"gray\", length: 2},\r\n\t\tmajorLabels:true\r\n\t};\r\n\r\n\tvar _xaxis = {\r\n\t\tnatural: true, \t\t// true - no fractions\r\n\t\tmajorLabels: true, \t//show labels on major ticks\r\n\t\tincludeZero: false, // do not change on upating chart\r\n\t\tmajorTickStep: 1,\r\n\t\tmajorTick: {stroke: \"black\", length: 8},\r\n\t\tfixUpper:\"major\",\r\n\t\tstroke: \"black\",\r\n\t\thtmlLabels: true,\r\n\t\tfrom:1\r\n\t};\r\n\r\n\t// default for chart elements\r\n\tvar chartPlot = {\r\n\t\tmarkers: true,\r\n\t\ttension:2,\r\n\t\tgap:2\r\n\t};\r\n\r\n\treturn declare(\"dojox.charting.DataChart\", Chart, {\r\n\t\t// summary:\r\n\t\t//\t\tExtension to the 2D chart that connects to a data store in\r\n\t\t//\t\ta simple manner. Convenience methods have been added for\r\n\t\t//\t\tconnecting store item labels to the chart labels.\r\n\t\t// description:\r\n\t\t//\t\tThis code should be considered very experimental and the APIs subject\r\n\t\t//\t\tto change. This is currently an alpha version and will need some testing\r\n\t\t//\t\tand review.\r\n\t\t//\r\n\t\t//\t\tThe main reason for this extension is to create animated charts, generally\r\n\t\t//\t\tavailable with scroll=true, and a property field that gets continually updated.\r\n\t\t//\t\tThe previous property settings are kept in memory and displayed until scrolled\r\n\t\t//\t\toff the chart.\r\n\t\t//\r\n\t\t//\t\tAlthough great effort was made to maintain the integrity of the current\r\n\t\t//\t\tcharting APIs, some things have been added or modified in order to get\r\n\t\t//\t\tthe store to connect and also to get the data to scroll/animate.\r\n\t\t//\t\t\"displayRange\" in particular is used to force the xaxis to a specific\r\n\t\t//\t\tsize and keep the chart from stretching or squashing to fit the data.\r\n\t\t//\r\n\t\t//\t\tCurrently, plot lines can only be set at initialization. Setting\r\n\t\t//\t\ta new store query will have no effect (although using setStore\r\n\t\t//\t\tmay work but its untested).\r\n\t\t// example:\r\n\t\t//\t|\tvar chart = new dojox.charting.DataChart(\"myNode\", {\r\n\t\t//\t|\t\tdisplayRange:8,\r\n\t\t//\t|\t\tstore:dataStore,\r\n\t\t//\t|\t\tquery:{symbol:\"*\"},\r\n\t\t//\t|\t\tfieldName:\"price\"\r\n\t\t//\t|\t\ttype: dojox.charting.plot2d.Columns\r\n\t\t//\t|\t});\r\n\r\n\t\t// scroll: Boolean\r\n\t\t//\t\tWhether live data updates and changes display, like columns moving\r\n\t\t//\t\tup and down, or whether it scrolls to the left as data is added\r\n\t\tscroll:true,\r\n\r\n\t\t// comparative: Boolean\r\n\t\t//\t\tIf false, all items are each their own series.\r\n\t\t//\t\tIf true, the items are combined into one series\r\n\t\t//\t\tso that their charted properties can be compared.\r\n\t\tcomparative:false,\r\n\r\n\t\t// query: String\r\n\t\t//\t\tUsed for fetching items. Will vary depending upon store.\r\n\t\tquery: \"*\",\r\n\r\n\t\t// queryOptions: String\r\n\t\t//\t\tOption used for fetching items\r\n\t\tqueryOptions: \"\",\r\n\r\n\t\t/*=====\r\n\t\t\t// start:Number\r\n\t\t\t//\t\tfirst item to fetch from store\r\n\t\t\t// count:Number\r\n\t\t\t//\t\tTotal amount of items to fetch from store\r\n\t\t\t// sort:Object\r\n\t\t\t//\t\tParameters to sort the fetched items from store\r\n\t\t=====*/\r\n\r\n\t\t// fieldName: String\r\n\t\t//\t\tThe field in the store item that is getting charted\r\n\t\tfieldName: \"value\",\r\n\r\n\t\t// chartTheme: dojox.charting.themes.*\r\n\t\t//\t\tThe theme to style the chart. Defaults to PlotKit.blue.\r\n\t\tchartTheme: blue,\r\n\r\n\t\t// displayRange: Number\r\n\t\t//\t\tThe number of major ticks to show on the xaxis\r\n\t\tdisplayRange:0,\r\n\r\n\t\t// stretchToFit: Boolean\r\n\t\t//\t\tIf true, chart is sized to data. If false, chart is a\r\n\t\t//\t\tfixed size. Note, is overridden by displayRange.\r\n\t\t//\t\tTODO: Stretch for the y-axis?\r\n\t\tstretchToFit:true,\r\n\r\n\t\t// minWidth: Number\r\n\t\t//\t\tThe the smallest the chart width can be\r\n\t\tminWidth:200,\r\n\r\n\t\t// minHeight: Number\r\n\t\t//\t\tThe the smallest the chart height can be\r\n\t\tminHeight:100,\r\n\r\n\t\t// showing: Boolean\r\n\t\t//\t\tWhether the chart is showing (default) on\r\n\t\t//\t\tinitialization or hidden.\r\n\t\tshowing: true,\r\n\r\n\t\t// label: String\r\n\t\t//\t\tThe name field of the store item\r\n\t\t//\t\tDO NOT SET: Set from store.labelAttribute\r\n\t\tlabel: \"name\",\r\n\r\n\t\tconstructor: function(node, kwArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet up properties and initialize chart build.\r\n\t\t\t// node: DomNode\r\n\t\t\t//\t\tThe node to attach the chart to.\r\n\t\t\t// kwArgs: Object\r\n\t\t\t//\t\t- xaxis: Object: optional parameters for xaxis (see above)\r\n\t\t\t//\t\t- yaxis: Object: optional parameters for yaxis (see above)\r\n\t\t\t//\t\t- store: Object: dojo.data store (currently nly supports Persevere)\r\n\t\t\t//\t\t- xaxis: Object: First query for store\r\n\t\t\t//\t\t- grid: Object: Options for the grid plot\r\n\t\t\t//\t\t- chartPlot: Object: Options for chart elements (lines, bars, etc)\r\n\r\n\t\t\tthis.domNode = dom.byId(node);\r\n\r\n\t\t\tlang.mixin(this, kwArgs);\r\n\r\n\t\t\tthis.xaxis = lang.mixin(lang.mixin({}, _xaxis), kwArgs.xaxis);\r\n\t\t\tif(this.xaxis.labelFunc == \"seriesLabels\"){\r\n\t\t\t\tthis.xaxis.labelFunc = lang.hitch(this, \"seriesLabels\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.yaxis = lang.mixin(lang.mixin({}, _yaxis), kwArgs.yaxis);\r\n\t\t\tif(this.yaxis.labelFunc == \"seriesLabels\"){\r\n\t\t\t\tthis.yaxis.labelFunc = lang.hitch(this, \"seriesLabels\");\r\n\t\t\t}\r\n\r\n\t\t\t// potential event's collector\r\n\t\t\tthis._events = [];\r\n\r\n\t\t\tthis.convertLabels(this.yaxis);\r\n\t\t\tthis.convertLabels(this.xaxis);\r\n\r\n\t\t\tthis.onSetItems = {};\r\n\t\t\tthis.onSetInterval = 0;\r\n\t\t\tthis.dataLength = 0;\r\n\t\t\tthis.seriesData = {};\r\n\t\t\tthis.seriesDataBk = {};\r\n\t\t\tthis.firstRun =  true;\r\n\r\n\t\t\tthis.dataOffset = 0;\r\n\r\n\t\t\t// FIXME: looks better with this, but it's custom\r\n\t\t\tthis.chartTheme.plotarea.stroke = {color: \"gray\", width: 3};\r\n\r\n\t\t\tthis.setTheme(this.chartTheme);\r\n\r\n\t\t\t// displayRange overrides stretchToFit\r\n\t\t\tif(this.displayRange){\r\n\t\t\t\tthis.stretchToFit = false;\r\n\t\t\t}\r\n\t\t\tif(!this.stretchToFit){\r\n\t\t\t\tthis.xaxis.to = this.displayRange;\r\n\t\t\t}\r\n\t\t\t// we don't want axis on Pie\r\n\t\t\tvar cartesian = kwArgs.type && kwArgs.type != \"Pie\" && kwArgs.type.prototype.declaredClass != \"dojox.charting.plot2d.Pie\";\r\n\t\t\tif(cartesian){\r\n\t\t\t\tthis.addAxis(\"x\", this.xaxis);\r\n\t\t\t\tthis.addAxis(\"y\", this.yaxis);\r\n\t\t\t}\r\n\t\t\tchartPlot.type = kwArgs.type || \"Markers\";\r\n\t\t\tthis.addPlot(\"default\", lang.mixin(chartPlot, kwArgs.chartPlot));\r\n\t\t\tif(cartesian){\r\n\t\t\t\tthis.addPlot(\"grid\", lang.mixin(kwArgs.grid || {}, {type: \"Grid\", hMinorLines: true}));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(this.showing){\r\n\t\t\t\tthis.render();\r\n\t\t\t}\r\n\r\n\t\t\tif(kwArgs.store){\r\n\t\t\t\tthis.setStore(kwArgs.store, kwArgs.query, kwArgs.fieldName, kwArgs.queryOptions);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tdestroy: function(){\r\n\t\t\tarr.forEach(this._events, hub.disconnect);\r\n\t\t\tthis.inherited(arguments);\r\n\t\t},\r\n\r\n\t\tsetStore: function(/*Object*/store, /* ? String*/query, /* ? String*/fieldName, /* ? Object */queryOptions){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSets the chart store and query\r\n\t\t\t//\t\tthen does the first fetch and\r\n\t\t\t//\t\tconnects to subsequent changes.\r\n\r\n\t\t\t// TODO: Not handling resetting store\r\n\r\n\t\t\tthis.firstRun = true;\r\n\t\t\tthis.store = store || this.store;\r\n\t\t\tthis.query = query || this.query;\r\n\t\t\tthis.fieldName = fieldName || this.fieldName;\r\n\t\t\tthis.label = this.store.getLabelAttributes();\r\n\t\t\tthis.queryOptions = queryOptions || queryOptions;\r\n\r\n\t\t\tarr.forEach(this._events, hub.disconnect);\r\n\t\t\tthis._events = [\r\n\t\t\t\thub.connect(this.store, \"onSet\", this, \"onSet\"),\r\n\t\t\t\thub.connect(this.store, \"onError\", this, \"onError\")\r\n\t\t\t];\r\n\t\t\tthis.fetch();\r\n\t\t},\r\n\r\n\t\tshow: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tIf chart is hidden, show it\r\n\t\t\tif(!this.showing){\r\n\t\t\t\thtml.style(this.domNode, \"display\", \"\");\r\n\t\t\t\tthis.showing = true;\r\n\t\t\t\tthis.render();\r\n\t\t\t}\r\n\t\t},\r\n\t\thide: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tIf chart is showing, hide it\r\n\t\t\t//\t\tPrevents rendering while hidden\r\n\t\t\tif(this.showing){\r\n\t\t\t\thtml.style(this.domNode, \"display\", \"none\");\r\n\t\t\t\tthis.showing = false;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonSet: function(/*storeObject*/item){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFired when a store item changes.\r\n\t\t\t//\t\tCollects the item calls and when\r\n\t\t\t//\t\tdone (after 200ms), sends item\r\n\t\t\t//\t\tarray to onData().\r\n\r\n\t\t\t// FIXME: Using labels instead of IDs for item\r\n\t\t\t//\tidentifiers here and in the chart series. This\r\n\t\t\t//\tis obviously short sighted, but currently used\r\n\t\t\t//\tfor seriesLabels. Workaround for potential bugs\r\n\t\t\t//\tis to assign a label for which all items are unique.\r\n\r\n\t\t\tvar nm = this.getProperty(item, this.label);\r\n\r\n\t\t\t// FIXME: why the check for if-in-runs?\r\n\t\t\tif(nm in this.runs || this.comparative){\r\n\t\t\t\tclearTimeout(this.onSetInterval);\r\n\t\t\t\tif(!this.onSetItems[nm]){\r\n\t\t\t\t\tthis.onSetItems[nm] = item;\r\n\t\t\t\t}\r\n\t\t\t\tthis.onSetInterval = setTimeout(lang.hitch(this, function(){\r\n\t\t\t\t\tclearTimeout(this.onSetInterval);\r\n\t\t\t\t\tvar items = [];\r\n\t\t\t\t\tfor(var nm in this.onSetItems){\r\n\t\t\t\t\t\titems.push(this.onSetItems[nm]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.onData(items);\r\n\t\t\t\t\tthis.onSetItems = {};\r\n\t\t\t\t}),200);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonError: function(/*Error*/err){\r\n\t\t\t// stub\r\n\t\t\t//\tFires on fetch error\r\n\t\t\tconsole.error(\"DataChart Error:\", err);\r\n\t\t},\r\n\r\n\t\tonDataReceived: function(/*Array*/items){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tstub. Fires after data is received but\r\n\t\t\t//\t\tbefore data is parsed and rendered\r\n\t\t},\r\n\r\n\t\tgetProperty: function(/*storeObject*/item, prop){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe main use of this function is to determine\r\n\t\t\t//\t\tbetween a single value and an array of values.\r\n\t\t\t//\t\tOther property types included for convenience.\r\n\t\t\t//\r\n\t\t\tif(prop==this.label){\r\n\t\t\t\treturn this.store.getLabel(item);\r\n\t\t\t}\r\n\t\t\tif(prop==\"id\"){\r\n\t\t\t\treturn this.store.getIdentity(item);\r\n\t\t\t}\r\n\t\t\tvar value = this.store.getValues(item, prop);\r\n\t\t\tif(value.length < 2){\r\n\t\t\t\tvalue = this.store.getValue(item, prop);\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t},\r\n\t\tonData: function(/*Array*/items){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalled after a completed fetch\r\n\t\t\t//\t\tor when store items change.\r\n\t\t\t//\t\tOn first run, sets the chart data,\r\n\t\t\t//\t\tthen updates chart and legends.\r\n\r\n\t\t\t//console.log(\"Store:\", store);console.log(\"items: (\", items.length+\")\", items);console.log(\"Chart:\", this);\r\n\t\t\tif(!items || !items.length){ return; }\r\n\r\n\t\t\tif(this.items && this.items.length != items.length){\r\n\t\t\t\tarr.forEach(items, function(m){\r\n\t\t\t\t\tvar id = this.getProperty(m, \"id\");\r\n\t\t\t\t\tarr.forEach(this.items, function(m2, i){\r\n\t\t\t\t\t\tif(this.getProperty(m2, \"id\") == id){\r\n\t\t\t\t\t\t\tthis.items[i] = m2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},this);\r\n\t\t\t\t}, this);\r\n\t\t\t\titems = this.items;\r\n\t\t\t}\r\n\t\t\tif(this.stretchToFit){\r\n\t\t\t\tthis.displayRange = items.length;\r\n\t\t\t}\r\n\t\t\tthis.onDataReceived(items);\r\n\t\t\tthis.items = items;\r\n\r\n\r\n\t\t\tif(this.comparative){\r\n\t\t\t\t// all items are gathered together and used as one\r\n\t\t\t\t//\tseries so their properties can be compared.\r\n\t\t\t\tvar nm = \"default\";\r\n\r\n\t\t\t\tthis.seriesData[nm] = [];\r\n\t\t\t\tthis.seriesDataBk[nm] = [];\r\n\t\t\t\tarr.forEach(items, function(m){\r\n\t\t\t\t\tvar field = this.getProperty(m, this.fieldName);\r\n\t\t\t\t\tthis.seriesData[nm].push(field);\r\n\t\t\t\t}, this);\r\n\r\n\t\t\t}else{\r\n\r\n\t\t\t\t// each item is a separate series.\r\n\t\t\t\tarr.forEach(items, function(m, i){\r\n\t\t\t\t\tvar nm = this.store.getLabel(m);\r\n\t\t\t\t\tif(!this.seriesData[nm]){\r\n\t\t\t\t\t\tthis.seriesData[nm] = [];\r\n\t\t\t\t\t\tthis.seriesDataBk[nm] = [];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// the property in the item we are using\r\n\t\t\t\t\tvar field = this.getProperty(m, this.fieldName);\r\n\t\t\t\t\tif(lang.isArray(field)){\r\n\t\t\t\t\t\t// Data is an array, so it's a snapshot, and not\r\n\t\t\t\t\t\t//\tlive, updating data\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tthis.seriesData[nm] = field;\r\n\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(!this.scroll){\r\n\t\t\t\t\t\t\t// Data updates, and \"moves in place\". Columns and\r\n\t\t\t\t\t\t\t//\tline markers go up and down\r\n\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t// create empty chart elements by starting an array\r\n\t\t\t\t\t\t\t//\twith zeros until we reach our relevant data\r\n\t\t\t\t\t\t\tvar ar = arr.map(new Array(i+1), function(){ return 0; });\r\n\t\t\t\t\t\t\tar.push(Number(field));\r\n\t\t\t\t\t\t\tthis.seriesData[nm] = ar;\r\n\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// Data updates and scrolls to the left\r\n\t\t\t\t\t\t\tif(this.seriesDataBk[nm].length > this.seriesData[nm].length){\r\n\t\t\t\t\t\t\t\tthis.seriesData[nm] = this.seriesDataBk[nm];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// Collecting and storing series data. The items come in\r\n\t\t\t\t\t\t\t//\tonly one at a time, but we need to display historical\r\n\t\t\t\t\t\t\t//\tdata, so it is kept in memory.\r\n\t\t\t\t\t\t\tthis.seriesData[nm].push(Number(field));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.seriesDataBk[nm].push(Number(field));\r\n\t\t\t\t\t}\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\r\n\t\t\t// displayData is the segment of the data array that is within\r\n\t\t\t// the chart boundaries\r\n\t\t\tvar displayData;\r\n\t\t\tif(this.firstRun){\r\n\t\t\t\t// First time around we need to add the series (chart lines)\r\n\t\t\t\t//\tto the chart.\r\n\t\t\t\tthis.firstRun = false;\r\n\t\t\t\tfor(nm in this.seriesData){\r\n\t\t\t\t\tthis.addSeries(nm, this.seriesData[nm]);\r\n\t\t\t\t\tdisplayData = this.seriesData[nm];\r\n\t\t\t\t}\r\n\r\n\t\t\t}else{\r\n\r\n\t\t\t\t// update existing series\r\n\t\t\t\tfor(nm in this.seriesData){\r\n\t\t\t\t\tdisplayData = this.seriesData[nm];\r\n\r\n\t\t\t\t\tif(this.scroll && displayData.length > this.displayRange){\r\n\t\t\t\t\t\t// chart lines have gone beyond the right boundary.\r\n\t\t\t\t\t\tthis.dataOffset = displayData.length-this.displayRange - 1;\r\n\t\t\t\t\t\tdisplayData = displayData.slice(displayData.length-this.displayRange, displayData.length);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.updateSeries(nm, displayData);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.dataLength = displayData.length;\r\n\r\n\t\t\tif(this.showing){\r\n\t\t\t\tthis.render();\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tfetch: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFetches initial data. Subsequent changes\r\n\t\t\t//\t\tare received via onSet in data store.\r\n\t\t\t//\r\n\t\t\tif(!this.store){ return; }\r\n\t\t\tthis.store.fetch({query:this.query, queryOptions:this.queryOptions, start:this.start, count:this.count, sort:this.sort,\r\n\t\t\t\tonComplete:lang.hitch(this, function(data){\r\n\t\t\t\t\tsetTimeout(lang.hitch(this, function(){\r\n\t\t\t\t\t\tthis.onData(data)\r\n\t\t\t\t\t}),0);\r\n\t\t\t\t}),\r\n\t\t\t\tonError:lang.hitch(this, \"onError\")\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tconvertLabels: function(axis){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConvenience method to convert a label array of strings\r\n\t\t\t//\t\tinto an array of objects\r\n\t\t\t//\r\n\t\t\tif(!axis.labels || lang.isObject(axis.labels[0])){ return null; }\r\n\r\n\t\t\taxis.labels = arr.map(axis.labels, function(ele, i){\r\n\t\t\t\treturn {value:i, text:ele};\r\n\t\t\t});\r\n\t\t\treturn null; // null\r\n\t\t},\r\n\r\n\t\tseriesLabels: function(/*Number*/val){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConvenience method that sets series labels based on item labels.\r\n\t\t\tval--;\r\n\t\t\tif(this.series.length<1 || (!this.comparative && val>this.series.length)){ return \"-\"; }\r\n\t\t\tif(this.comparative){\r\n\t\t\t\treturn this.store.getLabel(this.items[val]);// String\r\n\r\n\t\t\t}else{\r\n\t\t\t\t// FIXME:\r\n\t\t\t\t// Here we are setting the label base on if there is data in the array slot.\r\n\t\t\t\t//\tA typical series may look like: [0,0,3.1,0,0,0] which mean the data is populated in the\r\n\t\t\t\t//\t3rd row or column. This works well and keeps the labels aligned but has a side effect\r\n\t\t\t\t//\tof not showing the label is the data is zero. Work around is to not go lower than\r\n\t\t\t\t//\t0.01 or something.\r\n\t\t\t\tfor(var i=0;i<this.series.length; i++){\r\n\t\t\t\t\tif(this.series[i].data[val]>0){\r\n\t\t\t\t\t\treturn this.series[i].name; // String\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn \"-\"; // String\r\n\r\n\t\t},\r\n\r\n\t\tresizeChart: function(/*Object*/dim){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCall this function to change the chart size.\r\n\t\t\t//\t\tCan be connected to a layout widget that calls\r\n\t\t\t//\t\tresize.\r\n\r\n\t\t\tvar w = Math.max(dim.w, this.minWidth);\r\n\t\t\tvar h = Math.max(dim.h, this.minHeight);\r\n\t\t\tthis.resize(w, h);\r\n\t\t}\r\n\t});\r\n});\r\n"]}