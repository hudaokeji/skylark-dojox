{"version":3,"sources":["charting/DataSeries.js"],"names":["define","Lang","declare","ArrayUtil","connect","df","constructor","store","kwArgs","value","this","isFunction","isObject","hitch","keys","data","_events","getFeatures","push","_initialRendering","fetch","destroy","forEach","disconnect","setSeriesObject","series","_dictValue","dict","item","o","key","getValue","_fieldValue","field","_defaultValue","_inFlight","delegate","onComplete","onError","_onFetchComplete","items","request","_buildItemMap","map","_pushDataChanges","onFetchError","errorData","itemMap","index","getIdentity","chart","updateSeries","name","delayedRender","_onStoreNew","_onStoreDelete","some","it","splice","_onStoreSet","id"],"mappings":"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","file":"../../charting/DataSeries.js","sourcesContent":["define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/array\", \"dojo/_base/connect\", \"dojox/lang/functional\"],\r\n\tfunction(Lang, declare, ArrayUtil, connect, df){\r\n\r\n\treturn declare(\"dojox.charting.DataSeries\", null, {\r\n\t\tconstructor: function(store, kwArgs, value){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSeries adapter for dojo.data stores.\r\n\t\t\t// store: Object\r\n\t\t\t//\t\tA dojo.data store object.\r\n\t\t\t// kwArgs: Object\r\n\t\t\t//\t\tA store-specific keyword parameters used for fetching items.\r\n\t\t\t//\t\tSee dojo/data/api/Read.fetch().\r\n\t\t\t// value: Function|Object|String\r\n\t\t\t//\t\tFunction, which takes a store, and an object handle, and\r\n\t\t\t//\t\tproduces an output possibly inspecting the store's item. Or\r\n\t\t\t//\t\ta dictionary object, which tells what names to extract from\r\n\t\t\t//\t\tan object and how to map them to an output. Or a string, which\r\n\t\t\t//\t\tis a numeric field name to use for plotting. If undefined, null\r\n\t\t\t//\t\tor empty string (the default), \"value\" field is extracted.\r\n\t\t\tthis.store = store;\r\n\t\t\tthis.kwArgs = kwArgs;\r\n\t\r\n\t\t\tif(value){\r\n\t\t\t\tif(Lang.isFunction(value)){\r\n\t\t\t\t\tthis.value = value;\r\n\t\t\t\t}else if(Lang.isObject(value)){\r\n\t\t\t\t\tthis.value = Lang.hitch(this, \"_dictValue\",\r\n\t\t\t\t\t\tdf.keys(value), value);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.value = Lang.hitch(this, \"_fieldValue\", value);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tthis.value = Lang.hitch(this, \"_defaultValue\");\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.data = [];\r\n\t\r\n\t\t\tthis._events = [];\r\n\t\r\n\t\t\tif(this.store.getFeatures()[\"dojo.data.api.Notification\"]){\r\n\t\t\t\tthis._events.push(\r\n\t\t\t\t\tconnect.connect(this.store, \"onNew\", this, \"_onStoreNew\"),\r\n\t\t\t\t\tconnect.connect(this.store, \"onDelete\", this, \"_onStoreDelete\"),\r\n\t\t\t\t\tconnect.connect(this.store, \"onSet\", this, \"_onStoreSet\")\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tthis._initialRendering = true;\r\n\t\t\tthis.fetch();\r\n\t\t},\r\n\t\r\n\t\tdestroy: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tClean up before GC.\r\n\t\t\tArrayUtil.forEach(this._events, connect.disconnect);\r\n\t\t},\r\n\t\r\n\t\tsetSeriesObject: function(series){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSets a dojox.charting.Series object we will be working with.\r\n\t\t\t// series: dojox.charting.Series\r\n\t\t\t//\t\tOur interface to the chart.\r\n\t\t\tthis.series = series;\r\n\t\t},\r\n\t\r\n\t\t// value transformers\r\n\t\r\n\t\t_dictValue: function(keys, dict, store, item){\r\n\t\t\tvar o = {};\r\n\t\t\tArrayUtil.forEach(keys, function(key){\r\n\t\t\t\to[key] = store.getValue(item, dict[key]);\r\n\t\t\t});\r\n\t\t\treturn o;\r\n\t\t},\r\n\t\r\n\t\t_fieldValue: function(field, store, item){\r\n\t\t\treturn store.getValue(item, field);\r\n\t\t},\r\n\t\r\n\t\t_defaultValue: function(store, item){\r\n\t\t\treturn store.getValue(item, \"value\");\r\n\t\t},\r\n\t\r\n\t\t// store fetch loop\r\n\t\r\n\t\tfetch: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFetches data from the store and updates a chart.\r\n\t\t\tif(!this._inFlight){\r\n\t\t\t\tthis._inFlight = true;\r\n\t\t\t\tvar kwArgs = Lang.delegate(this.kwArgs);\r\n\t\t\t\tkwArgs.onComplete = Lang.hitch(this, \"_onFetchComplete\");\r\n\t\t\t\tkwArgs.onError = Lang.hitch(this, \"onFetchError\");\r\n\t\t\t\tthis.store.fetch(kwArgs);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onFetchComplete: function(items, request){\r\n\t\t\tthis.items = items;\r\n\t\t\tthis._buildItemMap();\r\n\t\t\tthis.data = ArrayUtil.map(this.items, function(item){\r\n\t\t\t\treturn this.value(this.store, item);\r\n\t\t\t}, this);\r\n\t\t\tthis._pushDataChanges();\r\n\t\t\tthis._inFlight = false;\r\n\t\t},\r\n\t\r\n\t\tonFetchError: function(errorData, request){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAs stub to process fetch errors. Provide so user can attach to\r\n\t\t\t//\t\tit with dojo.connect(). See dojo/data/api/Read fetch() for\r\n\t\t\t//\t\tdetails: onError property.\r\n\t\t\tthis._inFlight = false;\r\n\t\t},\r\n\t\r\n\t\t_buildItemMap: function(){\r\n\t\t\tif(this.store.getFeatures()[\"dojo.data.api.Identity\"]){\r\n\t\t\t\tvar itemMap = {};\r\n\t\t\t\tArrayUtil.forEach(this.items, function(item, index){\r\n\t\t\t\t\titemMap[this.store.getIdentity(item)] = index;\r\n\t\t\t\t}, this);\r\n\t\t\t\tthis.itemMap = itemMap;\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_pushDataChanges: function(){\r\n\t\t\tif(this.series){\r\n\t\t\t\tthis.series.chart.updateSeries(this.series.name, this, this._initialRendering);\r\n\t\t\t\tthis._initialRendering = false;\r\n\t\t\t\tthis.series.chart.delayedRender();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t// store notification handlers\r\n\t\r\n\t\t_onStoreNew: function(){\r\n\t\t\t// the only thing we can do is to re-fetch items\r\n\t\t\tthis.fetch();\r\n\t\t},\r\n\t\r\n\t\t_onStoreDelete: function(item){\r\n\t\t\t// we cannot do anything with deleted item, the only way is to compare\r\n\t\t\t// items for equality\r\n\t\t\tif(this.items){\r\n\t\t\t\tvar flag = ArrayUtil.some(this.items, function(it, index){\r\n\t\t\t\t\tif(it === item){\r\n\t\t\t\t\t\tthis.items.splice(index, 1);\r\n\t\t\t\t\t\tthis._buildItemMap();\r\n\t\t\t\t\t\tthis.data.splice(index, 1);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}, this);\r\n\t\t\t\tif(flag){\r\n\t\t\t\t\tthis._pushDataChanges();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onStoreSet: function(item){\r\n\t\t\tif(this.itemMap){\r\n\t\t\t\t// we can use our handy item map, if the store supports Identity\r\n\t\t\t\tvar id = this.store.getIdentity(item), index = this.itemMap[id];\r\n\t\t\t\tif(typeof index == \"number\"){\r\n\t\t\t\t\tthis.data[index] = this.value(this.store, this.items[index]);\r\n\t\t\t\t\tthis._pushDataChanges();\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t// otherwise we have to rely on item's equality\r\n\t\t\t\tif(this.items){\r\n\t\t\t\t\tvar flag = ArrayUtil.some(this.items, function(it, index){\r\n\t\t\t\t\t\tif(it === item){\r\n\t\t\t\t\t\t\tthis.data[index] = this.value(this.store, it);\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}, this);\r\n\t\t\t\t\tif(flag){\r\n\t\t\t\t\t\tthis._pushDataChanges();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n});\r\n"]}