{"version":3,"sources":["charting/plot2d/Default.js"],"names":["define","lang","declare","arr","has","CartesianBase","_PlotEvents","dc","df","dfr","du","fx","purgeGroup","lambda","defaultParams","lines","areas","markers","tension","animate","enableCache","interpolate","optionalParams","stroke","outline","shadow","fill","filter","styleFunc","font","fontColor","marker","markerStroke","markerOutline","markerShadow","markerFill","markerFont","markerFontColor","constructor","chart","kwArgs","this","opt","clone","mixin","updateWithObject","updateWithPattern","createPath","run","creator","params","path","_pathFreePool","length","pop","setShape","add","_pathUsePool","push","buildSegments","i","indexed","series","min","Math","max","floor","_hScaler","bounds","from","data","ceil","to","rseg","segments","j","y","index","hasOwnProperty","render","dim","offsets","zoom","isDataDirty","performZoom","s","resetEvents","dirty","isDirty","forEach","_eventSeries","cleanGroup","getGroup","setTransform","forEachRev","item","t","theme","events","concat","lpoly","next","ht","scaler","getTransformerFromModel","vt","_vScaler","eventSeries","name","Array","group","hidden","dyn","symbol","some","rsegments","seg","rsegment","map","v","x","l","height","b","lpath","curve","_plotFill","apoly","apath","setFill","getFill","createPolyline","makeStroke","width","shape","frontMarkers","outlineMarkers","shadowMarkers","spoly","c","dx","dy","setStroke","getStroke","color","setFilter","markerBox","markerTheme","tMixin","addMixin","post","labels","getBoundingBox","o","element","cx","cy","_connectEvents","labelBoxW","labelBoxH","createLabel","skip","_reconnectEvents","_checkOrientation","plotGroup","animateTransform","delegate","duration","transform","start","end","play"],"mappings":"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","file":"../../../charting/plot2d/Default.js","sourcesContent":["define([\"dojo/_base/lang\", \"dojo/_base/declare\", \"dojo/_base/array\", \"dojo/has\", \r\n\t\t\"./CartesianBase\", \"./_PlotEvents\", \"./common\", \"dojox/lang/functional\", \"dojox/lang/functional/reversed\", \"dojox/lang/utils\", \"dojox/gfx/fx\"],\r\n\tfunction(lang, declare, arr, has, CartesianBase, _PlotEvents, dc, df, dfr, du, fx){\r\n\r\n\t/*=====\r\n\tdeclare(\"dojox.charting.plot2d.__DefaultCtorArgs\", dojox.charting.plot2d.__CartesianCtorArgs, {\r\n\t\t// summary:\r\n\t\t//\t\tThe arguments used for any/most plots.\r\n\t\r\n\t\t// lines: Boolean?\r\n\t\t//\t\tWhether or not to draw lines on this plot.  Defaults to true.\r\n\t\tlines:   true,\r\n\t\r\n\t\t// areas: Boolean?\r\n\t\t//\t\tWhether or not to draw areas on this plot. Defaults to false.\r\n\t\tareas:   false,\r\n\t\r\n\t\t// markers: Boolean?\r\n\t\t//\t\tWhether or not to draw markers at data points on this plot. Default is false.\r\n\t\tmarkers: false,\r\n\t\r\n\t\t// tension: Number|String?\r\n\t\t//\t\tWhether or not to apply 'tensioning' to the lines on this chart.\r\n\t\t//\t\tOptions include a number, \"X\", \"x\", or \"S\"; if a number is used, the\r\n\t\t//\t\tsimpler bezier curve calculations are used to draw the lines.  If X, x or S\r\n\t\t//\t\tis used, the more accurate smoothing algorithm is used.\r\n\t\ttension: \"\",\r\n\t\r\n\t\t// animate: Boolean?|Number?\r\n\t\t//\t\tWhether or not to animate the chart to place. When a Number it specifies the duration of the animation.\r\n\t\t//\t\tDefault is false.\r\n\t\tanimate: false,\r\n\t\r\n\t\t// stroke: dojox.gfx.Stroke?\r\n\t\t//\t\tAn optional stroke to use for any series on the plot.\r\n\t\tstroke:\t\t{},\r\n\t\r\n\t\t// outline: dojox.gfx.Stroke?\r\n\t\t//\t\tAn optional stroke used to outline any series on the plot.\r\n\t\toutline:\t{},\r\n\t\r\n\t\t// shadow: dojox.gfx.Stroke?\r\n\t\t//\t\tAn optional stroke to use to draw any shadows for a series on a plot.\r\n\t\tshadow:\t\t{},\r\n\t\r\n\t\t// fill: dojox.gfx.Fill?\r\n\t\t//\t\tAny fill to be used for elements on the plot (such as areas).\r\n\t\tfill:\t\t{},\r\n\r\n\t\t// filter: dojox.gfx.Filter?\r\n\t\t//\t\tAn SVG filter to be used for elements on the plot. gfx SVG renderer must be used and dojox/gfx/svgext must\r\n\t\t//\t\tbe required for this to work.\r\n\t\tfilter:\t\t{},\r\n\r\n\t\t// styleFunc: Function?\r\n\t\t//\t\tA function that returns a styling object for the a given data item.\r\n\t\tstyleFunc:\tnull,\r\n\t\r\n\t\t// font: String?\r\n\t\t//\t\tA font definition to be used for labels and other text-based elements on the plot.\r\n\t\tfont:\t\t\"\",\r\n\t\r\n\t\t// fontColor: String|dojo.Color?\r\n\t\t//\t\tThe color to be used for any text-based elements on the plot.\r\n\t\tfontColor:\t\"\",\r\n\t\r\n\t\t// markerStroke: dojo.gfx.Stroke?\r\n\t\t//\t\tAn optional stroke to use for any markers on the plot.\r\n\t\tmarkerStroke:\t\t{},\r\n\t\r\n\t\t// markerOutline: dojo.gfx.Stroke?\r\n\t\t//\t\tAn optional outline to use for any markers on the plot.\r\n\t\tmarkerOutline:\t\t{},\r\n\t\r\n\t\t// markerShadow: dojo.gfx.Stroke?\r\n\t\t//\t\tAn optional shadow to use for any markers on the plot.\r\n\t\tmarkerShadow:\t\t{},\r\n\t\r\n\t\t// markerFill: dojo.gfx.Fill?\r\n\t\t//\t\tAn optional fill to use for any markers on the plot.\r\n\t\tmarkerFill:\t\t\t{},\r\n\t\r\n\t\t// markerFont: String?\r\n\t\t//\t\tAn optional font definition to use for any markers on the plot.\r\n\t\tmarkerFont:\t\t\t\"\",\r\n\t\r\n\t\t// markerFontColor: String|dojo.Color?\r\n\t\t//\t\tAn optional color to use for any marker text on the plot.\r\n\t\tmarkerFontColor:\t\"\",\r\n\t\t\r\n\t\t// enableCache: Boolean?\r\n\t\t//\t\tWhether the markers are cached from one rendering to another. This improves the rendering performance of\r\n\t\t//\t\tsuccessive rendering but penalize the first rendering.  Default false.\r\n\t\tenableCache: false,\r\n\r\n\t\t// interpolate: Boolean?\r\n\t\t//\t\tWhether when there is a null data point in the data the plot interpolates it or if the lines is split at that\r\n\t\t//\t\tpoint.\tDefault false.\r\n\t\tinterpolate: false\r\n\t});\r\n=====*/\r\n\r\n\tvar purgeGroup = dfr.lambda(\"item.purgeGroup()\");\r\n\r\n\tvar DEFAULT_ANIMATION_LENGTH = 1200;\t// in ms\r\n\r\n\treturn declare(\"dojox.charting.plot2d.Default\", [CartesianBase, _PlotEvents], {\r\n\t\t\r\n\t\t// defaultParams:\r\n\t\t//\t\tThe default parameters of this plot.\r\n\t\tdefaultParams: {\r\n\t\t\tlines:   true,\t// draw lines\r\n\t\t\tareas:   false,\t// draw areas\r\n\t\t\tmarkers: false,\t// draw markers\r\n\t\t\ttension: \"\",\t// draw curved lines (tension is \"X\", \"x\", or \"S\")\r\n\t\t\tanimate: false, // animate chart to place\r\n\t\t\tenableCache: false,\r\n\t\t\tinterpolate: false\r\n\t\t},\r\n\t\t\r\n\t\t// optionalParams:\r\n\t\t//\t\tThe optional parameters of this plot.\r\n\t\toptionalParams: {\r\n\t\t\t// theme component\r\n\t\t\tstroke:\t\t{},\r\n\t\t\toutline:\t{},\r\n\t\t\tshadow:\t\t{},\r\n\t\t\tfill:\t\t{},\r\n\t\t\tfilter:     {},\r\n\t\t\tstyleFunc: null,\r\n\t\t\tfont:\t\t\"\",\r\n\t\t\tfontColor:\t\"\",\r\n\t\t\tmarker:             \"\",\r\n\t\t\tmarkerStroke:\t\t{},\r\n\t\t\tmarkerOutline:\t\t{},\r\n\t\t\tmarkerShadow:\t\t{},\r\n\t\t\tmarkerFill:\t\t\t{},\r\n\t\t\tmarkerFont:\t\t\t\"\",\r\n\t\t\tmarkerFontColor:\t\"\"\r\n\t\t},\r\n\r\n\t\tconstructor: function(chart, kwArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn a new plot.\r\n\t\t\t// chart: dojox/charting/Chart\r\n\t\t\t//\t\tThe chart this plot belongs to.\r\n\t\t\t// kwArgs: dojox.charting.plot2d.__DefaultCtorArgs?\r\n\t\t\t//\t\tAn optional arguments object to help define this plot.\r\n\t\t\tthis.opt = lang.clone(lang.mixin(this.opt, this.defaultParams));\r\n\t\t\tdu.updateWithObject(this.opt, kwArgs);\r\n\t\t\tdu.updateWithPattern(this.opt, kwArgs, this.optionalParams);\r\n\t\t\t// animation properties\r\n\t\t\tthis.animate = this.opt.animate;\r\n\t\t},\r\n\r\n\t\tcreatePath: function(run, creator, params){\r\n\t\t\tvar path;\r\n\t\t\tif(this.opt.enableCache && run._pathFreePool.length > 0){\r\n\t\t\t\tpath = run._pathFreePool.pop();\r\n\t\t\t\tpath.setShape(params);\r\n\t\t\t\t// was cleared, add it back\r\n\t\t\t\tcreator.add(path);\r\n\t\t\t}else{\r\n\t\t\t\tpath = creator.createPath(params);\r\n\t\t\t}\r\n\t\t\tif(this.opt.enableCache){\r\n\t\t\t\trun._pathUsePool.push(path);\r\n\t\t\t}\r\n\t\t\treturn path;\r\n\t\t},\r\n\r\n\t\tbuildSegments: function(i, indexed){\r\n\t\t\tvar run = this.series[i],\r\n\t\t\t\tmin = indexed?Math.max(0, Math.floor(this._hScaler.bounds.from - 1)):0,\r\n\t\t\t\tmax = indexed?Math.min(run.data.length, Math.ceil(this._hScaler.bounds.to)):run.data.length,\r\n\t\t\t\trseg = null, segments = [];\r\n\r\n\t\t\t// split the run data into dense segments (each containing no nulls)\r\n\t\t\t// except if interpolates is false in which case ignore null between valid data\r\n\t\t\tfor(var j = min; j < max; j++){\r\n\t\t\t\tif(run.data[j] != null && (indexed || run.data[j].y != null)){\r\n\t\t\t\t\tif(!rseg){\r\n\t\t\t\t\t\trseg = [];\r\n\t\t\t\t\t\tsegments.push({index: j, rseg: rseg});\r\n\t\t\t\t\t}\r\n\t\t\t\t\trseg.push((indexed && run.data[j].hasOwnProperty(\"y\"))?run.data[j].y:run.data[j]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(!this.opt.interpolate || indexed){\r\n\t\t\t\t\t\t// we break the line only if not interpolating or if we have indexed data\r\n\t\t\t\t\t\trseg = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn segments;\r\n\t\t},\r\n\r\n\t\trender: function(dim, offsets){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRender/draw everything on this plot.\r\n\t\t\t// dim: Object\r\n\t\t\t//\t\tAn object of the form { width, height }\r\n\t\t\t// offsets: Object\r\n\t\t\t//\t\tAn object of the form { l, r, t, b }\r\n\t\t\t// returns: dojox/charting/plot2d/Default\r\n\t\t\t//\t\tA reference to this plot for functional chaining.\r\n\r\n\t\t\t// make sure all the series is not modified\r\n\t\t\tif(this.zoom && !this.isDataDirty()){\r\n\t\t\t\treturn this.performZoom(dim, offsets);\r\n\t\t\t}\r\n\r\n\t\t\tthis.resetEvents();\r\n\t\t\tthis.dirty = this.isDirty();\r\n\t\t\tvar s;\r\n\t\t\tif(this.dirty){\r\n\t\t\t\tarr.forEach(this.series, purgeGroup);\r\n\t\t\t\tthis._eventSeries = {};\r\n\t\t\t\tthis.cleanGroup();\r\n\t\t\t\tthis.getGroup().setTransform(null);\r\n\t\t\t\ts = this.getGroup();\r\n\t\t\t\tdf.forEachRev(this.series, function(item){ item.cleanGroup(s); });\r\n\t\t\t}\r\n\t\t\tvar t = this.chart.theme, stroke, outline, events = this.events();\r\n\r\n\t\t\tfor(var i = this.series.length - 1; i >= 0; --i){\r\n\t\t\t\tvar run = this.series[i];\r\n\t\t\t\tif(!this.dirty && !run.dirty){\r\n\t\t\t\t\tt.skip();\r\n\t\t\t\t\tthis._reconnectEvents(run.name);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\trun.cleanGroup();\r\n\t\t\t\tif(this.opt.enableCache){\r\n\t\t\t\t\trun._pathFreePool = (run._pathFreePool?run._pathFreePool:[]).concat(run._pathUsePool?run._pathUsePool:[]);\r\n\t\t\t\t\trun._pathUsePool = [];\r\n\t\t\t\t}\r\n\t\t\t\tif(!run.data.length){\r\n\t\t\t\t\trun.dirty = false;\r\n\t\t\t\t\tt.skip();\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar theme = t.next(this.opt.areas ? \"area\" : \"line\", [this.opt, run], true),\r\n\t\t\t\t\tlpoly,\r\n\t\t\t\t\tht = this._hScaler.scaler.getTransformerFromModel(this._hScaler),\r\n\t\t\t\t\tvt = this._vScaler.scaler.getTransformerFromModel(this._vScaler),\r\n\t\t\t\t\teventSeries = this._eventSeries[run.name] = new Array(run.data.length);\r\n\r\n\t\t\t\ts = run.group;\r\n\t\t\t\tif(run.hidden){\r\n\t\t\t\t\tif(this.opt.lines){\r\n\t\t\t\t\t\trun.dyn.stroke = theme.series.stroke;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(this.opt.markers){\r\n\t\t\t\t\t\trun.dyn.markerFill = theme.marker.fill;\r\n\t\t\t\t\t\trun.dyn.markerStroke = theme.marker.stroke;\r\n\t\t\t\t\t\trun.dyn.marker = theme.symbol;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(this.opt.areas){ \r\n\t\t\t\t\t\trun.dyn.fill = theme.series.fill;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t// optim works only for index based case\r\n\t\t\t\tvar indexed = arr.some(run.data, function(item){\r\n\t\t\t\t\treturn typeof item == \"number\" || (item && !item.hasOwnProperty(\"x\"));\r\n\t\t\t\t});\r\n\r\n\t\t\t\tvar rsegments = this.buildSegments(i, indexed);\r\n\t\t\t\tfor(var seg = 0; seg < rsegments.length; seg++){\r\n\t\t\t\t\tvar rsegment = rsegments[seg];\r\n\t\t\t\t\tif(indexed){\r\n\t\t\t\t\t\tlpoly = arr.map(rsegment.rseg, function(v, i){\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\tx: ht(i + rsegment.index + 1) + offsets.l,\r\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v),\r\n\t\t\t\t\t\t\t\tdata: v\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tlpoly = arr.map(rsegment.rseg, function(v){\r\n\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\tx: ht(v.x) + offsets.l,\r\n\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v.y),\r\n\t\t\t\t\t\t\t\tdata: v\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if we are indexed & we interpolate we need to put all the segments as a single one now\r\n\t\t\t\t\tif(indexed && this.opt.interpolate){\r\n\t\t\t\t\t\twhile(seg < rsegments.length) {\r\n\t\t\t\t\t\t\tseg++;\r\n\t\t\t\t\t\t\trsegment = rsegments[seg];\r\n\t\t\t\t\t\t\tif(rsegment){\r\n\t\t\t\t\t\t\t\tlpoly = lpoly.concat(arr.map(rsegment.rseg, function(v, i){\r\n\t\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\t\tx: ht(i + rsegment.index + 1) + offsets.l,\r\n\t\t\t\t\t\t\t\t\t\ty: dim.height - offsets.b - vt(v),\r\n\t\t\t\t\t\t\t\t\t\tdata: v\r\n\t\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\t}, this));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} \r\n\r\n\t\t\t\t\tvar lpath = this.opt.tension ? dc.curve(lpoly, this.opt.tension) : \"\";\r\n\r\n\t\t\t\t\tif(this.opt.areas && lpoly.length > 1){\r\n\t\t\t\t\t\tvar fill = this._plotFill(theme.series.fill, dim, offsets), apoly = lang.clone(lpoly);\r\n\t\t\t\t\t\tif(this.opt.tension){\r\n\t\t\t\t\t\t\tvar apath = \"L\" + apoly[apoly.length-1].x + \",\" + (dim.height - offsets.b) +\r\n\t\t\t\t\t\t\t\t\" L\" + apoly[0].x + \",\" + (dim.height - offsets.b) +\r\n\t\t\t\t\t\t\t\t\" L\" + apoly[0].x + \",\" + apoly[0].y;\r\n\t\t\t\t\t\t\trun.dyn.fill = s.createPath(lpath + \" \" + apath).setFill(fill).getFill();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tapoly.push({x: lpoly[lpoly.length - 1].x, y: dim.height - offsets.b});\r\n\t\t\t\t\t\t\tapoly.push({x: lpoly[0].x, y: dim.height - offsets.b});\r\n\t\t\t\t\t\t\tapoly.push(lpoly[0]);\r\n\t\t\t\t\t\t\trun.dyn.fill = s.createPolyline(apoly).setFill(fill).getFill();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(this.opt.lines || this.opt.markers){\r\n\t\t\t\t\t\t// need a stroke\r\n\t\t\t\t\t\tstroke = theme.series.stroke;\r\n\t\t\t\t\t\tif(theme.series.outline){\r\n\t\t\t\t\t\t\toutline = run.dyn.outline = dc.makeStroke(theme.series.outline);\r\n\t\t\t\t\t\t\toutline.width = 2 * outline.width + stroke.width;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(this.opt.markers){\r\n\t\t\t\t\t\trun.dyn.marker = theme.symbol;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar frontMarkers = null, outlineMarkers = null, shadowMarkers = null;\r\n\t\t\t\t\tif(stroke && theme.series.shadow && lpoly.length > 1){\r\n\t\t\t\t\t\tvar shadow = theme.series.shadow,\r\n\t\t\t\t\t\t\tspoly = arr.map(lpoly, function(c){\r\n\t\t\t\t\t\t\t\treturn {x: c.x + shadow.dx, y: c.y + shadow.dy};\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif(this.opt.lines){\r\n\t\t\t\t\t\t\tif(this.opt.tension){\r\n\t\t\t\t\t\t\t\trun.dyn.shadow = s.createPath(dc.curve(spoly, this.opt.tension)).setStroke(shadow).getStroke();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\trun.dyn.shadow = s.createPolyline(spoly).setStroke(shadow).getStroke();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(this.opt.markers && theme.marker.shadow){\r\n\t\t\t\t\t\t\tshadow = theme.marker.shadow;\r\n\t\t\t\t\t\t\tshadowMarkers = arr.map(spoly, function(c){\r\n\t\t\t\t\t\t\t\treturn this.createPath(run, s, \"M\" + c.x + \" \" + c.y + \" \" + theme.symbol).\r\n\t\t\t\t\t\t\t\t\tsetStroke(shadow).setFill(shadow.color);\r\n\t\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(this.opt.lines && lpoly.length > 1){\r\n\t\t\t\t\t\tvar shape;\r\n\t\t\t\t\t\tif(outline){\r\n\t\t\t\t\t\t\tif(this.opt.tension){\r\n\t\t\t\t\t\t\t\trun.dyn.outline = s.createPath(lpath).setStroke(outline).getStroke();\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\trun.dyn.outline = s.createPolyline(lpoly).setStroke(outline).getStroke();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(this.opt.tension){\r\n\t\t\t\t\t\t\trun.dyn.stroke = (shape = s.createPath(lpath)).setStroke(stroke).getStroke();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\trun.dyn.stroke = (shape = s.createPolyline(lpoly)).setStroke(stroke).getStroke();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(shape.setFilter && theme.series.filter){\r\n\t\t\t\t\t\t\tshape.setFilter(theme.series.filter);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar markerBox = null;\r\n\t\t\t\t\tif(this.opt.markers){\r\n\t\t\t\t\t\tvar markerTheme = theme; \r\n\t\t\t\t\t\tfrontMarkers = new Array(lpoly.length);\r\n\t\t\t\t\t\toutlineMarkers = new Array(lpoly.length);\r\n\t\t\t\t\t\toutline = null;\r\n\t\t\t\t\t\tif(markerTheme.marker.outline){\r\n\t\t\t\t\t\t\toutline = dc.makeStroke(markerTheme.marker.outline);\r\n\t\t\t\t\t\t\toutline.width = 2 * outline.width + (markerTheme.marker.stroke ? markerTheme.marker.stroke.width : 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tarr.forEach(lpoly, function(c, i){\r\n\t\t\t\t\t\t\tif(this.opt.styleFunc || typeof c.data != \"number\"){\r\n\t\t\t\t\t\t\t\tvar tMixin = typeof c.data != \"number\" ? [c.data] : [];\r\n\t\t\t\t\t\t\t\tif(this.opt.styleFunc){\r\n\t\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(c.data));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmarkerTheme = t.addMixin(theme, \"marker\", tMixin, true);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tmarkerTheme = t.post(theme, \"marker\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar path = \"M\" + c.x + \" \" + c.y + \" \" + markerTheme.symbol;\r\n\t\t\t\t\t\t\tif(outline){\r\n\t\t\t\t\t\t\t\toutlineMarkers[i] = this.createPath(run, s, path).setStroke(outline);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfrontMarkers[i] = this.createPath(run, s, path).setStroke(markerTheme.marker.stroke).setFill(markerTheme.marker.fill);\r\n\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t\trun.dyn.markerFill = markerTheme.marker.fill;\r\n\t\t\t\t\t\trun.dyn.markerStroke = markerTheme.marker.stroke;\r\n\t\t\t\t\t\tif(!markerBox && this.opt.labels){\r\n\t\t\t\t\t\t\tmarkerBox = frontMarkers[0].getBoundingBox();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(events){\r\n\t\t\t\t\t\t\tarr.forEach(frontMarkers, function(s, i){\r\n\t\t\t\t\t\t\t\tvar o = {\r\n\t\t\t\t\t\t\t\t\telement: \"marker\",\r\n\t\t\t\t\t\t\t\t\tindex:   i + rsegment.index,\r\n\t\t\t\t\t\t\t\t\trun:     run,\r\n\t\t\t\t\t\t\t\t\tshape:   s,\r\n\t\t\t\t\t\t\t\t\toutline: outlineMarkers[i] || null,\r\n\t\t\t\t\t\t\t\t\tshadow:  shadowMarkers && shadowMarkers[i] || null,\r\n\t\t\t\t\t\t\t\t\tcx:      lpoly[i].x,\r\n\t\t\t\t\t\t\t\t\tcy:      lpoly[i].y\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\tif(indexed){\r\n\t\t\t\t\t\t\t\t\to.x = i + rsegment.index + 1;\r\n\t\t\t\t\t\t\t\t\to.y = run.data[i + rsegment.index];\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\to.x = rsegment.rseg[i].x;\r\n\t\t\t\t\t\t\t\t\to.y = run.data[i + rsegment.index].y;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tthis._connectEvents(o);\r\n\t\t\t\t\t\t\t\teventSeries[i + rsegment.index] = o;\r\n\t\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tdelete this._eventSeries[run.name];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(this.opt.labels){\r\n\t\t\t\t\t\tvar labelBoxW = markerBox?markerBox.width:2;\r\n\t\t\t\t\t\tvar labelBoxH = markerBox?markerBox.height:2;\r\n\t\t\t\t\t\tarr.forEach(lpoly, function(c, i){\r\n\t\t\t\t\t\t\tif(this.opt.styleFunc || typeof c.data != \"number\"){\r\n\t\t\t\t\t\t\t\tvar tMixin = typeof c.data != \"number\" ? [c.data] : [];\r\n\t\t\t\t\t\t\t\tif(this.opt.styleFunc){\r\n\t\t\t\t\t\t\t\t\ttMixin.push(this.opt.styleFunc(c.data));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmarkerTheme = t.addMixin(theme, \"marker\", tMixin, true);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tmarkerTheme = t.post(theme, \"marker\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis.createLabel(s, rsegment.rseg[i], { x: c.x - labelBoxW / 2, y: c.y - labelBoxH / 2,\r\n\t\t\t\t\t\t\t\twidth: labelBoxW , height: labelBoxH }, markerTheme);\r\n\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\trun.dirty = false;\r\n\t\t\t}\r\n\t\t\t// chart mirroring starts\r\n\t\t\tif(has(\"dojo-bidi\")){\r\n\t\t\t\tthis._checkOrientation(this.group, dim, offsets);\r\n\t\t\t}\r\n\t\t\t// chart mirroring ends\r\n\t\t\tif(this.animate){\r\n\t\t\t\t// grow from the bottom\r\n\t\t\t\tvar plotGroup = this.getGroup();\r\n\t\t\t\tfx.animateTransform(lang.delegate({\r\n\t\t\t\t\tshape: plotGroup,\r\n\t\t\t\t\tduration: DEFAULT_ANIMATION_LENGTH,\r\n\t\t\t\t\ttransform:[\r\n\t\t\t\t\t\t{name:\"translate\", start: [0, dim.height - offsets.b], end: [0, 0]},\r\n\t\t\t\t\t\t{name:\"scale\", start: [1, 0], end:[1, 1]},\r\n\t\t\t\t\t\t{name:\"original\"}\r\n\t\t\t\t\t]\r\n\t\t\t\t}, this.animate)).play();\r\n\t\t\t}\r\n\t\t\tthis.dirty = false;\r\n\t\t\treturn this;\t//\tdojox/charting/plot2d/Default\r\n\t\t}\r\n\t});\r\n});\r\n"]}