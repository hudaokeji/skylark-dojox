{"version":3,"sources":["charting/plot2d/Stacked.js"],"names":["define","declare","Default","commonStacked","getSeriesStats","collectStats","this","series","buildSegments","i","indexed","run","min","Math","max","floor","_hScaler","bounds","from","data","length","ceil","to","rseg","segments","j","value","getIndexValue","getValue","x","y","opt","interpolate","push","index"],"mappings":";;;;;;;AAAAA,QAAQ,qBAAsB,YAAa,mBAC1C,SAASC,EAASC,EAASC,GAE3B,OAAOF,EAAQ,gCAAiCC,GAK/CE,eAAgB,WAMf,OADYD,EAAcE,aAAaC,KAAKC,SAI7CC,cAAe,SAASC,EAAGC,GAO1B,IANA,IAAIC,EAAML,KAAKC,OAAOE,GACrBG,EAAMF,EAAQG,KAAKC,IAAI,EAAGD,KAAKE,MAAMT,KAAKU,SAASC,OAAOC,KAAO,IAAI,EACrEJ,EAAMJ,EAAQG,KAAKD,IAAID,EAAIQ,KAAKC,OAAO,EAAGP,KAAKQ,KAAKf,KAAKU,SAASC,OAAOK,KAAKX,EAAIQ,KAAKC,OAAO,EAC9FG,EAAO,KAAMC,KAGNC,EAAIb,EAAKa,GAAKX,EAAKW,IAAI,CAC9B,IAAIC,EAAQhB,EAAUP,EAAcwB,cAAcrB,KAAKC,OAAQE,EAAGgB,GAAKtB,EAAcyB,SAAStB,KAAKC,OAAQE,EAAGE,EAAIQ,KAAKM,GAAId,EAAIQ,KAAKM,GAAGI,EAAG,MAC3H,MAAZH,EAAM,KAAehB,GAAyB,MAAdgB,EAAM,GAAGI,EAOvCxB,KAAKyB,IAAIC,cAAetB,IAE3Ba,EAAO,OARJA,IACHA,KACAC,EAASS,MAAMC,MAAOT,EAAGF,KAAMA,KAEhCA,EAAKU,KAAKP,EAAM,KAQlB,OAAOF","file":"../../../charting/plot2d/Stacked.js","sourcesContent":["define([\"dojo/_base/declare\", \"./Default\", \"./commonStacked\"], \r\n\tfunction(declare, Default, commonStacked){\r\n\r\n\treturn declare(\"dojox.charting.plot2d.Stacked\", Default, {\r\n\t\t// summary:\r\n\t\t//\t\tLike the default plot, Stacked sets up lines, areas and markers\r\n\t\t//\t\tin a stacked fashion (values on the y axis added to each other)\r\n\t\t//\t\tas opposed to a direct one.\r\n\t\tgetSeriesStats: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalculate the min/max on all attached series in both directions.\r\n\t\t\t// returns: Object\r\n\t\t\t//\t\t{hmin, hmax, vmin, vmax} min/max in both directions.\r\n\t\t\tvar stats = commonStacked.collectStats(this.series);\r\n\t\t\treturn stats; // Object\r\n\t\t},\r\n\t\t\r\n\t\tbuildSegments: function(i, indexed){\r\n\t\t\tvar run = this.series[i],\r\n\t\t\t\tmin = indexed?Math.max(0, Math.floor(this._hScaler.bounds.from - 1)):0,\r\n\t\t\t\tmax = indexed?Math.min(run.data.length-1, Math.ceil(this._hScaler.bounds.to)):run.data.length-1,\r\n\t\t\t\trseg = null, segments = [];\r\n\t\t\t// split the run data into dense segments (each containing no nulls)\r\n\t\t\t// except if interpolates is false in which case ignore null between valid data\r\n\t\t\tfor(var j = min; j <= max; j++){\r\n\t\t\t\tvar value = indexed ? commonStacked.getIndexValue(this.series, i, j) : commonStacked.getValue(this.series, i, run.data[j] ?run.data[j].x: null);\r\n\t\t\t\tif(value[0] != null && (indexed || value[0].y != null)){\r\n\t\t\t\t\tif(!rseg){\r\n\t\t\t\t\t\trseg = [];\r\n\t\t\t\t\t\tsegments.push({index: j, rseg: rseg});\r\n\t\t\t\t\t}\r\n\t\t\t\t\trseg.push(value[0]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(!this.opt.interpolate || indexed){\r\n\t\t\t\t\t\t// we break the line only if not interpolating or if we have indexed data\r\n\t\t\t\t\t\trseg = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn segments;\r\n\t\t}\r\n\t\t\r\n\t});\r\n});\r\n"]}