{"version":3,"sources":["editor/plugins/NormalizeIndentOutdent.js"],"names":["define","dojo","dijit","dojox","_Plugin","NormalizeIndentOutdent","declare","indentBy","indentUnits","setEditor","editor","this","_indentImpl","hitch","_outdentImpl","_indentoutdent_queryCommandEnabled","queryCommandEnabled","_queryCommandEnabled","customUndo","command","ed","sel","range","node","tag","prevNode","c","toLowerCase","style","_isLtr","getSelection","window","rangeCount","getRangeAt","startContainer","document","editNode","_getTagName","previousSibling","nodeType","_isIndentableElement","parentNode","_isRootInline","cIndent","_convertIndent","html","start","end","div","endContainer","_isTextElement","_isInlineFormat","nextSibling","createElement","place","appendChild","_indentElement","_sCall","_indentList","curNode","body","next","isIE","_isEmpty","removeChild","parseInt","_outdentElement","_outdentList","execCommand","listItem","newList","li","listContainer","prevTag","type","tg","tagName","embList","i","childNodes","length","n","trim","nodeValue","paddingTop","paddingBottom","listStyleImage","listStyleType","list","listParent","lpTg","prevListLi","firstItem","prevLi","nextLi","empty","innerHTML","nv","indent","curUnit","indexOf","replace","Math","ceil","editDoc","cs","getComputedStyle","direction","subscribe","_scopeName","o","plugin","args","name"],"mappings":"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","file":"../../../editor/plugins/NormalizeIndentOutdent.js","sourcesContent":["define([\r\n\t\"dojo\",\r\n\t\"dijit\",\r\n\t\"dojox\",\r\n\t\"dijit/_editor/_Plugin\",\r\n\t\"dojo/_base/declare\"\r\n], function(dojo, dijit, dojox, _Plugin) {\r\n\r\nvar NormalizeIndentOutdent = dojo.declare(\"dojox.editor.plugins.NormalizeIndentOutdent\", _Plugin, {\r\n\t// summary:\r\n\t//\t\tThis plugin provides improved indent and outdent handling to\r\n\t//\t\tthe editor.  It tries to generate valid HTML, as well as be\r\n\t//\t\tconsistent about how it indents and outdents lists and blocks/elements.\r\n\r\n\t// indentBy: [public] number\r\n\t//\t\tThe amount to indent by.  Valid values are 1+.  This is combined with\r\n\t//\t\tthe indentUnits parameter to determine how much to indent or outdent\r\n\t//\t\tby for regular text.  It does not affect lists.\r\n\tindentBy: 40,\r\n\t\r\n\t// indentUnits: [public] String\r\n\t//\t\tThe units to apply to the indent amount.  Usually 'px', but can also\r\n\t//\t\tbe em.\r\n\tindentUnits: \"px\",\r\n\r\n\tsetEditor: function(editor){\r\n\t\t// summary:\r\n\t\t//\t\tOver-ride for the setting of the editor.\r\n\t\t// editor: Object\r\n\t\t//\t\tThe editor to configure for this plugin to use.\r\n\t\tthis.editor = editor;\r\n\r\n\t\t// Register out indent handler via the builtin over-ride mechanism.\r\n\t\teditor._indentImpl = dojo.hitch(this, this._indentImpl);\r\n\t\teditor._outdentImpl = dojo.hitch(this, this._outdentImpl);\r\n\r\n\t\t// Take over the query command enabled function, we want to prevent\r\n\t\t// indent of first items in a list, etc.\r\n\t\tif(!editor._indentoutdent_queryCommandEnabled){\r\n\t\t\teditor._indentoutdent_queryCommandEnabled = editor.queryCommandEnabled;\r\n\t\t}\r\n\t\teditor.queryCommandEnabled = dojo.hitch(this, this._queryCommandEnabled);\r\n\r\n\t\t// We need the custom undo code since we manipulate the dom\r\n\t\t// outside of the browser natives and only customUndo really handles\r\n\t\t// that.  It will incur a performance hit, but should hopefully be\r\n\t\t// relatively small.\r\n\t\teditor.customUndo = true;\r\n\t},\r\n\r\n\t_queryCommandEnabled: function(command){\r\n\t\t// summary:\r\n\t\t//\t\tAn over-ride for the editor's query command enabled,\r\n\t\t//\t\tso that we can prevent indents, etc, on bad elements\r\n\t\t//\t\tor positions (like first element in a list).\r\n\t\t// command:\r\n\t\t//\t\tThe command passed in to check enablement.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar c = command.toLowerCase();\r\n\t\tvar ed, sel, range, node, tag, prevNode;\r\n\t\tvar style = \"marginLeft\";\r\n\t\tif(!this._isLtr()){\r\n\t\t\tstyle = \"marginRight\";\r\n\t\t}\r\n\t\tif(c === \"indent\"){\r\n\t\t\ted = this.editor;\r\n\t\t\tsel = dijit.range.getSelection(ed.window);\r\n\t\t\tif(sel && sel.rangeCount > 0){\r\n\t\t\t\trange = sel.getRangeAt(0);\r\n\t\t\t\tnode = range.startContainer;\r\n\r\n\t\t\t\t// Check for li nodes first, we handle them a certain way.\r\n\t\t\t\twhile(node && node !== ed.document && node !== ed.editNode){\r\n\t\t\t\t\ttag = this._getTagName(node);\r\n\t\t\t\t\tif(tag === \"li\"){\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tprevNode = node.previousSibling;\r\n\t\t\t\t\t\twhile(prevNode && prevNode.nodeType !== 1){\r\n\t\t\t\t\t\t\tprevNode = prevNode.previousSibling;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(prevNode && this._getTagName(prevNode) === \"li\"){\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// First item, disallow\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(this._isIndentableElement(tag)){\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t}\r\n\t\t\t\tif(this._isRootInline(range.startContainer)){\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else if(c === \"outdent\"){\r\n\t\t\ted = this.editor;\r\n\t\t\tsel = dijit.range.getSelection(ed.window);\r\n\t\t\tif(sel && sel.rangeCount > 0){\r\n\t\t\t\trange = sel.getRangeAt(0);\r\n\t\t\t\tnode = range.startContainer;\r\n\t\t\t\t// Check for li nodes first, we handle them a certain way.\r\n\t\t\t\twhile(node && node !== ed.document && node !== ed.editNode){\r\n\t\t\t\t\ttag = this._getTagName(node);\r\n\t\t\t\t\tif(tag === \"li\"){\r\n\t\t\t\t\t\t// Standard list, we can ask the browser.\r\n\t\t\t\t\t\treturn this.editor._indentoutdent_queryCommandEnabled(command);\r\n\t\t\t\t\t}else if(this._isIndentableElement(tag)){\r\n\t\t\t\t\t\t// Block, we need to handle the indent check.\r\n\t\t\t\t\t\tvar cIndent = node.style?node.style[style]:\"\";\r\n\t\t\t\t\t\tif(cIndent){\r\n\t\t\t\t\t\t\tcIndent = this._convertIndent(cIndent);\r\n\t\t\t\t\t\t\tif(cIndent/this.indentBy >= 1){\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t}\r\n\t\t\t\tif(this._isRootInline(range.startContainer)){\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\treturn this.editor._indentoutdent_queryCommandEnabled(command);\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_indentImpl: function(/*String*/ html) {\r\n\t\t// summary:\r\n\t\t//\t\tImproved implementation of indent, generates correct indent for\r\n\t\t//\t\tul/ol\r\n\t\tvar ed = this.editor;\r\n\r\n\t\tvar sel = dijit.range.getSelection(ed.window);\r\n\t\tif(sel && sel.rangeCount > 0){\r\n\t\t\tvar range = sel.getRangeAt(0);\r\n\t\t\tvar node = range.startContainer;\r\n\t\t\tvar tag, start, end, div;\r\n\t\t\t\r\n\r\n\t\t\tif(range.startContainer === range.endContainer){\r\n\t\t\t\t// No selection, just cursor point, we need to see if we're\r\n\t\t\t\t// in an indentable block, or similar.\r\n\t\t\t\tif(this._isRootInline(range.startContainer)){\r\n\t\t\t\t\t// Text at the 'root' of the document,\r\n\t\t\t\t\t// we'll try to indent it and all inline selements around it\r\n\t\t\t\t\t// as they are visually a single line.\r\n\r\n\t\t\t\t\t// First, we need to find the toplevel inline element that is rooted\r\n\t\t\t\t\t// to the document 'editNode'\r\n\t\t\t\t\tstart = range.startContainer;\r\n\t\t\t\t\twhile(start && start.parentNode !== ed.editNode){\r\n\t\t\t\t\t\tstart = start.parentNode;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Now we need to walk up its siblings and look for the first one in the rooting\r\n\t\t\t\t\t// that isn't inline or text, as we want to grab all of that for indent.\r\n\t\t\t\t\twhile(start && start.previousSibling && (\r\n\t\t\t\t\t\t\tthis._isTextElement(start) ||\r\n\t\t\t\t\t\t\t(start.nodeType === 1 && this._isInlineFormat(this._getTagName(start))\r\n\t\t\t\t\t\t))){\r\n\t\t\t\t\t\tstart = start.previousSibling;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(start && start.nodeType === 1 && !this._isInlineFormat(this._getTagName(start))){\r\n\t\t\t\t\t\t// Adjust slightly, we're one node too far back in this case.\r\n\t\t\t\t\t\tstart = start.nextSibling;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Okay, we have a configured start, lets grab everything following it that's\r\n\t\t\t\t\t// inline and make it an indentable block!\r\n\t\t\t\t\tif(start){\r\n\t\t\t\t\t\tdiv = ed.document.createElement(\"div\");\r\n\t\t\t\t\t\tdojo.place(div, start, \"after\");\r\n\t\t\t\t\t\tdiv.appendChild(start);\r\n\t\t\t\t\t\tend = div.nextSibling;\r\n\t\t\t\t\t\twhile(end && (\r\n\t\t\t\t\t\t\tthis._isTextElement(end) ||\r\n\t\t\t\t\t\t\t(end.nodeType === 1 &&\r\n\t\t\t\t\t\t\t\tthis._isInlineFormat(this._getTagName(end)))\r\n\t\t\t\t\t\t\t)){\r\n\t\t\t\t\t\t\t// Add it.\r\n\t\t\t\t\t\t\tdiv.appendChild(end);\r\n\t\t\t\t\t\t\tend = div.nextSibling;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis._indentElement(div);\r\n\t\t\t\t\t\ted._sCall(\"selectElementChildren\", [div]);\r\n\t\t\t\t\t\ted._sCall(\"collapse\", [true]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\twhile(node && node !== ed.document && node !== ed.editNode){\r\n\t\t\t\t\t\ttag = this._getTagName(node);\r\n\t\t\t\t\t\tif(tag === \"li\"){\r\n\t\t\t\t\t\t\tthis._indentList(node);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}else if(this._isIndentableElement(tag)){\r\n\t\t\t\t\t\t\tthis._indentElement(node);\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tvar curNode;\r\n\t\t\t\t// multi-node select.  We need to scan over them.\r\n\t\t\t\t// Find the two containing nodes at start and end.\r\n\t\t\t\t// then move the end one node past.  Then ... lets see\r\n\t\t\t\t// what we can indent!\r\n\t\t\t\tstart = range.startContainer;\r\n\t\t\t\tend = range.endContainer;\r\n\t\t\t\t// Find the non-text nodes.\r\n\r\n\t\t\t\twhile(start && this._isTextElement(start) && start.parentNode !== ed.editNode){\r\n\t\t\t\t\tstart = start.parentNode;\r\n\t\t\t\t}\r\n\t\t\t\twhile(end && this._isTextElement(end) && end.parentNode !== ed.editNode){\r\n\t\t\t\t\tend = end.parentNode;\r\n\t\t\t\t}\r\n\t\t\t\tif(end === ed.editNode || end === ed.document.body){\r\n\t\t\t\t\t// Okay, selection end is somewhere after start, we need to find the last node\r\n\t\t\t\t\t// that is safely in the range.\r\n\t\t\t\t\tcurNode = start;\r\n\t\t\t\t\twhile(curNode.nextSibling &&\r\n\t\t\t\t\t\ted._sCall(\"inSelection\", [curNode])){\r\n\t\t\t\t\t\tcurNode = curNode.nextSibling;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tend = curNode;\r\n\t\t\t\t\tif(end === ed.editNode || end === ed.document.body){\r\n\t\t\t\t\t\t// Unable to determine real selection end, so just make it\r\n\t\t\t\t\t\t// a single node indent of start + all following inline styles, if\r\n\t\t\t\t\t\t// present, then just exit.\r\n\t\t\t\t\t\ttag = this._getTagName(start);\r\n\t\t\t\t\t\tif(tag === \"li\"){\r\n\t\t\t\t\t\t\tthis._indentList(start);\r\n\t\t\t\t\t\t}else if(this._isIndentableElement(tag)){\r\n\t\t\t\t\t\t\tthis._indentElement(start);\r\n\t\t\t\t\t\t}else if(this._isTextElement(start) ||\r\n\t\t\t\t\t\t\t\t this._isInlineFormat(tag)){\r\n\t\t\t\t\t\t\t// inline element or textnode, So we want to indent it somehow\r\n\t\t\t\t\t\t\tdiv = ed.document.createElement(\"div\");\r\n\t\t\t\t\t\t\tdojo.place(div, start, \"after\");\r\n\r\n\t\t\t\t\t\t\t// Find and move all inline tags following the one we inserted also into the\r\n\t\t\t\t\t\t\t// div so we don't split up content funny.\r\n\t\t\t\t\t\t\tvar next = start;\r\n\t\t\t\t\t\t\twhile(next && (\r\n\t\t\t\t\t\t\t\tthis._isTextElement(next) ||\r\n\t\t\t\t\t\t\t\t(next.nodeType === 1 &&\r\n\t\t\t\t\t\t\t\tthis._isInlineFormat(this._getTagName(next))))){\r\n\t\t\t\t\t\t\t\tdiv.appendChild(next);\r\n\t\t\t\t\t\t\t\tnext = div.nextSibling;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis._indentElement(div);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Has a definite end somewhere, so lets try to indent up to it.\r\n\t\t\t\t// requires looking at the selections and in some cases, moving nodes\r\n\t\t\t\t// into indentable blocks.\r\n\t\t\t\tend = end.nextSibling;\r\n\t\t\t\tcurNode = start;\r\n\t\t\t\twhile(curNode && curNode !== end){\r\n\t\t\t\t\tif(curNode.nodeType === 1){\r\n\t\t\t\t\t\ttag = this._getTagName(curNode);\r\n\t\t\t\t\t\tif(dojo.isIE){\r\n\t\t\t\t\t\t\t// IE sometimes inserts blank P tags, which we want to skip\r\n\t\t\t\t\t\t\t// as they end up indented, which messes up layout.\r\n\t\t\t\t\t\t\tif(tag === \"p\" && this._isEmpty(curNode)){\r\n\t\t\t\t\t\t\t\tcurNode = curNode.nextSibling;\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(tag === \"li\"){\r\n\t\t\t\t\t\t\tif(div){\r\n\t\t\t\t\t\t\t\tif(this._isEmpty(div)){\r\n\t\t\t\t\t\t\t\t\tdiv.parentNode.removeChild(div);\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\tthis._indentElement(div);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdiv = null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis._indentList(curNode);\r\n\t\t\t\t\t\t}else if(!this._isInlineFormat(tag) && this._isIndentableElement(tag)){\r\n\t\t\t\t\t\t\tif(div){\r\n\t\t\t\t\t\t\t\tif(this._isEmpty(div)){\r\n\t\t\t\t\t\t\t\t\tdiv.parentNode.removeChild(div);\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\tthis._indentElement(div);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdiv = null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcurNode = this._indentElement(curNode);\r\n\t\t\t\t\t\t}else if(this._isInlineFormat(tag)){\r\n\t\t\t\t\t\t\t// inline tag.\r\n\t\t\t\t\t\t\tif(!div){\r\n\t\t\t\t\t\t\t\tdiv = ed.document.createElement(\"div\");\r\n\t\t\t\t\t\t\t\tdojo.place(div, curNode, \"after\");\r\n\t\t\t\t\t\t\t\tdiv.appendChild(curNode);\r\n\t\t\t\t\t\t\t\tcurNode = div;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tdiv.appendChild(curNode);\r\n\t\t\t\t\t\t\t\tcurNode = div;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(this._isTextElement(curNode)){\r\n\t\t\t\t\t\tif(!div){\r\n\t\t\t\t\t\t\tdiv = ed.document.createElement(\"div\");\r\n\t\t\t\t\t\t\tdojo.place(div, curNode, \"after\");\r\n\t\t\t\t\t\t\tdiv.appendChild(curNode);\r\n\t\t\t\t\t\t\tcurNode = div;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tdiv.appendChild(curNode);\r\n\t\t\t\t\t\t\tcurNode = div;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurNode = curNode.nextSibling;\r\n\t\t\t\t}\r\n\t\t\t\t// Okay, indent everything we merged if we haven't yet..\r\n\t\t\t\tif(div){\r\n\t\t\t\t\tif(this._isEmpty(div)){\r\n\t\t\t\t\t\tdiv.parentNode.removeChild(div);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tthis._indentElement(div);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdiv = null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_indentElement: function(node){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to indent a block type tag.\r\n\t\t// node:\r\n\t\t//\t\tThe node who's content to indent.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar style = \"marginLeft\";\r\n\t\tif(!this._isLtr()){\r\n\t\t\tstyle = \"marginRight\";\r\n\t\t}\r\n\t\tvar tag = this._getTagName(node);\r\n\t\tif(tag === \"ul\" || tag === \"ol\"){\r\n\t\t\t// Lists indent funny, so lets wrap them in a div\r\n\t\t\t// and indent the div instead.\r\n\t\t\tvar div = this.editor.document.createElement(\"div\");\r\n\t\t\tdojo.place(div, node, \"after\");\r\n\t\t\tdiv.appendChild(node);\r\n\t\t\tnode = div;\r\n\t\t}\r\n\t\tvar cIndent = node.style?node.style[style]:\"\";\r\n\t\tif(cIndent){\r\n\t\t\tcIndent = this._convertIndent(cIndent);\r\n\t\t\tcIndent = (parseInt(cIndent, 10) + this.indentBy) + this.indentUnits;\r\n\t\t}else{\r\n\t\t\tcIndent = this.indentBy + this.indentUnits;\r\n\t\t}\r\n\t\tdojo.style(node, style, cIndent);\r\n\t\treturn node; //Return the node that was indented.\r\n\t},\r\n\r\n\t_outdentElement: function(node){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to outdent a block type tag.\r\n\t\t// node:\r\n\t\t//\t\tThe node who's content to outdent.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar style = \"marginLeft\";\r\n\t\tif(!this._isLtr()){\r\n\t\t\tstyle = \"marginRight\";\r\n\t\t}\r\n\t\tvar cIndent = node.style?node.style[style]:\"\";\r\n\t\tif(cIndent){\r\n\t\t\tcIndent = this._convertIndent(cIndent);\r\n\t\t\tif(cIndent - this.indentBy > 0){\r\n\t\t\t\tcIndent = (parseInt(cIndent, 10) - this.indentBy) + this.indentUnits;\r\n\t\t\t}else{\r\n\t\t\t\tcIndent = \"\";\r\n\t\t\t}\r\n\t\t\tdojo.style(node, style, cIndent);\r\n\t\t}\r\n\t},\r\n\r\n\t_outdentImpl: function(/*String*/ html) {\r\n\t\t// summary:\r\n\t\t//\t\tImproved implementation of outdent, generates correct indent for\r\n\t\t//\t\tul/ol and other elements.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar ed = this.editor;\r\n\t\tvar sel = dijit.range.getSelection(ed.window);\r\n\t\tif(sel && sel.rangeCount > 0){\r\n\t\t\tvar range = sel.getRangeAt(0);\r\n\t\t\tvar node = range.startContainer;\r\n\t\t\tvar tag;\r\n\r\n\t\t\tif(range.startContainer === range.endContainer){\r\n\t\t\t\t// Check for li nodes first, we handle them a certain way.\r\n\t\t\t\twhile(node && node !== ed.document && node !== ed.editNode){\r\n\t\t\t\t\ttag = this._getTagName(node);\r\n\t\t\t\t\tif(tag === \"li\"){\r\n\t\t\t\t\t\treturn this._outdentList(node);\r\n\t\t\t\t\t}else if(this._isIndentableElement(tag)){\r\n\t\t\t\t\t\treturn this._outdentElement(node);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnode = node.parentNode;\r\n\t\t\t\t}\r\n\t\t\t\ted.document.execCommand(\"outdent\", false, html);\r\n\t\t\t}else{\r\n\t\t\t\t// multi-node select.  We need to scan over them.\r\n\t\t\t\t// Find the two containing nodes at start and end.\r\n\t\t\t\t// then move the end one node past.  Then ... lets see\r\n\t\t\t\t// what we can outdent!\r\n\t\t\t\tvar start = range.startContainer;\r\n\t\t\t\tvar end =  range.endContainer;\r\n\t\t\t\t// Find the non-text nodes.\r\n\t\t\t\twhile(start && start.nodeType === 3){\r\n\t\t\t\t\tstart = start.parentNode;\r\n\t\t\t\t}\r\n\t\t\t\twhile(end && end.nodeType === 3){\r\n\t\t\t\t\tend = end.parentNode;\r\n\t\t\t\t}\r\n\t\t\t\tend = end.nextSibling;\r\n\t\t\t\tvar curNode = start;\r\n\t\t\t\twhile(curNode && curNode !== end){\r\n\t\t\t\t\tif(curNode.nodeType === 1){\r\n\t\t\t\t\t\ttag = this._getTagName(curNode);\r\n\t\t\t\t\t\tif(tag === \"li\"){\r\n\t\t\t\t\t\t\tthis._outdentList(curNode);\r\n\t\t\t\t\t\t}else if(this._isIndentableElement(tag)){\r\n\t\t\t\t\t\t\tthis._outdentElement(curNode);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurNode = curNode.nextSibling;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\r\n\r\n\t_indentList: function(listItem){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to handle indenting a list element.\r\n\t\t// listItem:\r\n\t\t//\t\tThe list item to indent.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar ed = this.editor;\r\n\t\tvar newList, li;\r\n\t\tvar listContainer = listItem.parentNode;\r\n\t\tvar prevTag = listItem.previousSibling;\r\n\t\t\r\n\t\t// Ignore text, we want elements.\r\n\t\twhile(prevTag && prevTag.nodeType !== 1){\r\n\t\t\tprevTag = prevTag.previousSibling;\r\n\t\t}\r\n\t\tvar type = null;\r\n\t\tvar tg = this._getTagName(listContainer);\r\n\t\t\r\n\t\t// Try to determine what kind of list item is here to indent.\r\n\t\tif(tg === \"ol\"){\r\n\t\t\ttype = \"ol\";\r\n\t\t}else if(tg === \"ul\"){\r\n\t\t\ttype = \"ul\";\r\n\t\t}\r\n\t\t\r\n\t\t// Only indent list items actually in a list.\r\n\t\t// Bail out if the list is malformed somehow.\r\n\t\tif(type){\r\n\t\t\t// There is a previous node in the list, so we want to append a new list\r\n\t\t\t// element after it that contains a new list of the content to indent it.\r\n\t\t\tif(prevTag && prevTag.tagName.toLowerCase() == \"li\"){\r\n\t\t\t\t// Lets see if we can merge this into another  (Eg,\r\n\t\t\t\t// does the sibling li contain an embedded list already of\r\n\t\t\t\t// the same type?  if so, we move into that one.\r\n\t\t\t\tvar embList;\r\n\t\t\t\tif(prevTag.childNodes){\r\n\t\t\t\t\tvar i;\r\n\t\t\t\t\tfor(i = 0; i < prevTag.childNodes.length; i++){\r\n\t\t\t\t\t\tvar n = prevTag.childNodes[i];\r\n\t\t\t\t\t\tif(n.nodeType === 3){\r\n\t\t\t\t\t\t\tif(dojo.trim(n.nodeValue)){\r\n\t\t\t\t\t\t\t\tif(embList){\r\n\t\t\t\t\t\t\t\t\t// Non-empty text after list, exit, can't embed.\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else if(n.nodeType === 1 && !embList){\r\n\t\t\t\t\t\t\t// See if this is a list container.\r\n\t\t\t\t\t\t\tif(type === n.tagName.toLowerCase()){\r\n\t\t\t\t\t\t\t\tembList = n;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// Other node present, break, can't embed.\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(embList){\r\n\t\t\t\t\t// We found a list to merge to, so merge.\r\n\t\t\t\t\tembList.appendChild(listItem);\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// Nope, wasn't an embedded list container,\r\n\t\t\t\t\t// So lets just create a new one.\r\n\t\t\t\t\tnewList = ed.document.createElement(type);\r\n\t\t\t\t\tdojo.style(newList, {\r\n\t\t\t\t\t\tpaddingTop: \"0px\",\r\n\t\t\t\t\t\tpaddingBottom: \"0px\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tli = ed.document.createElement(\"li\");\r\n\t\t\t\t\tdojo.style(li, {\r\n\t\t\t\t\t\tlistStyleImage: \"none\",\r\n\t\t\t\t\t\tlistStyleType: \"none\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tprevTag.appendChild(newList);\r\n\t\t\t\t\tnewList.appendChild(listItem);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move cursor.\r\n\t\t\t\ted._sCall(\"selectElementChildren\", [listItem]);\r\n\t\t\t\ted._sCall(\"collapse\", [true]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_outdentList: function(listItem){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to handle outdenting a list element.\r\n\t\t// listItem:\r\n\t\t//\t\tThe list item to outdent.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar ed = this.editor;\r\n\t\tvar list = listItem.parentNode;\r\n\t\tvar type = null;\r\n\t\tvar tg = list.tagName ? list.tagName.toLowerCase() : \"\";\r\n\t\tvar li;\r\n\r\n\t\t// Try to determine what kind of list contains the item.\r\n\t\tif(tg === \"ol\"){\r\n\t\t\ttype = \"ol\";\r\n\t\t}else if(tg === \"ul\"){\r\n\t\t\ttype = \"ul\";\r\n\t\t}\r\n\r\n\t\t// Check to see if it is a nested list, as outdenting is handled differently.\r\n\t\tvar listParent = list.parentNode;\r\n\t\tvar lpTg = this._getTagName(listParent);\r\n\t\t\r\n\t\t// We're in a list, so we need to outdent this specially.\r\n\t\t// Check for welformed and malformed lists (<ul><ul></ul>U/ul> type stuff).\r\n\t\tif(lpTg === \"li\" || lpTg === \"ol\" || lpTg === \"ul\"){\r\n\t\t\tif(lpTg === \"ol\" || lpTg === \"ul\"){\r\n\t\t\t\t// Okay, we need to fix this up, this is invalid html,\r\n\t\t\t\t// So try to combine this into a previous element before\r\n\t\t\t\t// de do a shuffle of the nodes, to build an HTML compliant\r\n\t\t\t\t// list.\r\n\t\t\t\tvar prevListLi = list.previousSibling;\r\n\t\t\t\twhile(prevListLi && (prevListLi.nodeType !== 1 ||\r\n\t\t\t\t\t\t(prevListLi.nodeType === 1 &&\r\n\t\t\t\t\t\tthis._getTagName(prevListLi) !== \"li\"))\r\n\t\t\t\t\t){\r\n\t\t\t\t\tprevListLi = prevListLi.previousSibling;\r\n\t\t\t\t}\r\n\t\t\t\tif(prevListLi){\r\n\t\t\t\t\t// Move this list up into the previous li\r\n\t\t\t\t\t// to fix malformation.\r\n\t\t\t\t\tprevListLi.appendChild(list);\r\n\t\t\t\t\tlistParent = prevListLi;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tli = listItem;\r\n\t\t\t\t\tvar firstItem = listItem;\r\n\t\t\t\t\twhile(li.previousSibling){\r\n\t\t\t\t\t\tli = li.previousSibling;\r\n\t\t\t\t\t\tif(li.nodeType === 1 && this._getTagName(li) === \"li\"){\r\n\t\t\t\t\t\t\tfirstItem = li;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(firstItem !== listItem){\r\n\t\t\t\t\t\tdojo.place(firstItem, list, \"before\");\r\n\t\t\t\t\t\tfirstItem.appendChild(list);\r\n\t\t\t\t\t\tlistParent = firstItem;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\t// No previous list item in a malformed list\r\n\t\t\t\t\t\t// ... so create one  and move into that.\r\n\t\t\t\t\t\tli = ed.document.createElement(\"li\");\r\n\t\t\t\t\t\tdojo.place(li, list, \"before\");\r\n\t\t\t\t\t\tli.appendChild(list);\r\n\t\t\t\t\t\tlistParent = li;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdojo.style(list, {\r\n\t\t\t\t\t\tpaddingTop: \"0px\",\r\n\t\t\t\t\t\tpaddingBottom: \"0px\"\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// find the previous node, if any,\r\n\t\t\t// non-text.\r\n\t\t\tvar prevLi = listItem.previousSibling;\r\n\t\t\twhile(prevLi && prevLi.nodeType !== 1){\r\n\t\t\t\tprevLi = prevLi.previousSibling;\r\n\t\t\t}\r\n\t\t\tvar nextLi = listItem.nextSibling;\r\n\t\t\twhile(nextLi && nextLi.nodeType !== 1){\r\n\t\t\t\tnextLi = nextLi.nextSibling;\r\n\t\t\t}\r\n\r\n\t\t\tif(!prevLi){\r\n\t\t\t\t// Top item in a nested list, so just move it out\r\n\t\t\t\t// and then shuffle the remaining indented list into it.\r\n\t\t\t\tdojo.place(listItem, listParent, \"after\");\r\n\t\t\t\tlistItem.appendChild(list);\r\n\t\t\t}else if(!nextLi){\r\n\t\t\t\t// Last item in a nested list, shuffle it out after\r\n\t\t\t\t// the nsted list only.\r\n\t\t\t\tdojo.place(listItem, listParent, \"after\");\r\n\t\t\t}else{\r\n\t\t\t\t// Item is in the middle of an embedded  list, so we\r\n\t\t\t\t// have to split it.\r\n\r\n\t\t\t\t// Move all the items following current list item into\r\n\t\t\t\t// a list after it.\r\n\t\t\t\tvar newList = ed.document.createElement(type);\r\n\t\t\t\tdojo.style(newList, {\r\n\t\t\t\t\tpaddingTop: \"0px\",\r\n\t\t\t\t\tpaddingBottom: \"0px\"\r\n\t\t\t\t});\r\n\t\t\t\tlistItem.appendChild(newList);\r\n\t\t\t\twhile(listItem.nextSibling){\r\n\t\t\t\t\tnewList.appendChild(listItem.nextSibling);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Okay, now place the list item after the\r\n\t\t\t\t// current list parent (li).\r\n\t\t\t\tdojo.place(listItem, listParent, \"after\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Clean up any empty lists left behind.\r\n\t\t\tif(list && this._isEmpty(list)){\r\n\t\t\t\tlist.parentNode.removeChild(list);\r\n\t\t\t}\r\n\t\t\tif(listParent && this._isEmpty(listParent)){\r\n\t\t\t\tlistParent.parentNode.removeChild(listParent);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Move our cursor to the list item we moved.\r\n\t\t\ted._sCall(\"selectElementChildren\", [listItem]);\r\n\t\t\ted._sCall(\"collapse\", [true]);\r\n\t\t}else{\r\n\t\t\t// Not in a nested list, so we can just defer to the\r\n\t\t\t// browser and hope it outdents right.\r\n\t\t\ted.document.execCommand(\"outdent\", false, null);\r\n\t\t}\r\n\t},\r\n\r\n\t_isEmpty: function(node){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to determine if a node is 'empty'\r\n\t\t//\t\tEg, contains only blank text.  Used to determine if\r\n\t\t//\t\tan empty list element should be removed or not.\r\n\t\t// node:\r\n\t\t//\t\tThe node to check.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tif(node.childNodes){\r\n\t\t\tvar empty = true;\r\n\t\t\tvar i;\r\n\t\t\tfor(i = 0; i < node.childNodes.length; i++){\r\n\t\t\t\tvar n = node.childNodes[i];\r\n\t\t\t\tif(n.nodeType === 1){\r\n\t\t\t\t\tif(this._getTagName(n) === \"p\"){\r\n\t\t\t\t\t\tif(!dojo.trim(n.innerHTML)){\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tempty = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}else if(this._isTextElement(n)){\r\n\t\t\t\t\t// Check for empty text.\r\n\t\t\t\t\tvar nv = dojo.trim(n.nodeValue);\r\n\t\t\t\t\tif(nv && nv !==\"&nbsp;\" && nv !== \"\\u00A0\"){\r\n\t\t\t\t\t\tempty = false;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tempty = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn empty;\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t},\r\n\r\n\t_isIndentableElement: function(tag){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to detect what element types\r\n\t\t//\t\tare indent-controllable by us.\r\n\t\t// tag:\r\n\t\t//\t\tThe tag to check\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tswitch(tag){\r\n\t\t\tcase \"p\":\r\n\t\t\tcase \"div\":\r\n\t\t\tcase \"h1\":\r\n\t\t\tcase \"h2\":\r\n\t\t\tcase \"h3\":\r\n\t\t\tcase \"center\":\r\n\t\t\tcase \"table\":\r\n\t\t\tcase \"ul\":\r\n\t\t\tcase \"ol\":\r\n\t\t\t\treturn true;\r\n\t\t\tdefault:\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t},\r\n\r\n\t_convertIndent: function(indent){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to convert the current indent style to\r\n\t\t//\t\tthe units we're using by some heuristic.\r\n\t\t// indent:\r\n\t\t//\t\tThe indent amount to convert.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar pxPerEm = 12;\r\n\t\tindent = indent + \"\";\r\n\t\tindent = indent.toLowerCase();\r\n\t\tvar curUnit = (indent.indexOf(\"px\") > 0) ? \"px\" : (indent.indexOf(\"em\") > 0) ? \"em\" : \"px\";\r\n\t\tindent = indent.replace(/(px;?|em;?)/gi, \"\");\r\n\t\tif(curUnit === \"px\"){\r\n\t\t\tif(this.indentUnits === \"em\"){\r\n\t\t\t\tindent = Math.ceil(indent/pxPerEm);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif(this.indentUnits === \"px\"){\r\n\t\t\t\tindent = indent * pxPerEm;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn indent;\r\n\t},\r\n\r\n\t_isLtr: function(){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to detect if the editor body is in RTL or LTR.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar editDoc = this.editor.document.body;\r\n\t\tvar cs = dojo.getComputedStyle(editDoc);\r\n\t\treturn cs ? cs.direction == \"ltr\" : true;\r\n\t},\r\n\r\n\t_isInlineFormat: function(tag){\r\n\t\t// summary:\r\n\t\t//\t\tFunction to determine if the current tag is an inline\r\n\t\t//\t\telement that does formatting, as we don't want to\r\n\t\t//\t\tbreak/indent around it, as it can screw up text.\r\n\t\t// tag:\r\n\t\t//\t\tThe tag to examine\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tswitch(tag){\r\n\t\t\tcase \"a\":\r\n\t\t\tcase \"b\":\r\n\t\t\tcase \"strong\":\r\n\t\t\tcase \"s\":\r\n\t\t\tcase \"strike\":\r\n\t\t\tcase \"i\":\r\n\t\t\tcase \"u\":\r\n\t\t\tcase \"em\":\r\n\t\t\tcase \"sup\":\r\n\t\t\tcase \"sub\":\r\n\t\t\tcase \"span\":\r\n\t\t\tcase \"font\":\r\n\t\t\tcase \"big\":\r\n\t\t\tcase \"cite\":\r\n\t\t\tcase \"q\":\r\n\t\t\tcase \"img\":\r\n\t\t\tcase \"small\":\r\n\t\t\t\treturn true;\r\n\t\t\tdefault:\r\n\t\t\t\treturn false;\r\n\t\t}\r\n\t},\r\n\r\n\t_getTagName: function(node){\r\n\t\t// summary:\r\n\t\t//\t\tInternal function to get the tag name of an element\r\n\t\t//\t\tif any.\r\n\t\t// node:\r\n\t\t//\t\tThe node to look at.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar tag = \"\";\r\n\t\tif(node && node.nodeType === 1){\r\n\t\t\ttag = node.tagName?node.tagName.toLowerCase():\"\";\r\n\t\t}\r\n\t\treturn tag;\r\n\t},\r\n\r\n\t_isRootInline: function(node){\r\n\t\t// summary:\r\n\t\t//\t\tThis functions tests whether an indicated node is in root as inline\r\n\t\t//\t\tor rooted inline elements in the page.\r\n\t\t// node:\r\n\t\t//\t\tThe node to start at.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tvar ed = this.editor;\r\n\t\tif(this._isTextElement(node) && node.parentNode === ed.editNode){\r\n\t\t\treturn true;\r\n\t\t}else if(node.nodeType === 1 && this._isInlineFormat(node) && node.parentNode === ed.editNode){\r\n\t\t\treturn true;\r\n\t\t}else if(this._isTextElement(node) && this._isInlineFormat(this._getTagName(node.parentNode))){\r\n\t\t\tnode = node.parentNode;\r\n\t\t\twhile(node && node !== ed.editNode && this._isInlineFormat(this._getTagName(node))){\r\n\t\t\t\tnode = node.parentNode;\r\n\t\t\t}\r\n\t\t\tif(node === ed.editNode){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t_isTextElement: function(node){\r\n\t\t// summary:\r\n\t\t//\t\tHelper function to check for text nodes.\r\n\t\t// node:\r\n\t\t//\t\tThe node to check.\r\n\t\t// tags:\r\n\t\t//\t\tprivate\r\n\t\tif(node && node.nodeType === 3 || node.nodeType === 4){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n});\r\n\r\n// Register this plugin.\r\ndojo.subscribe(dijit._scopeName + \".Editor.getPlugin\",null,function(o){\r\n\tif(o.plugin){ return; }\r\n\tvar name = o.args.name.toLowerCase();\r\n\tif(name === \"normalizeindentoutdent\"){\r\n\t\to.plugin = new NormalizeIndentOutdent({\r\n\t\t\tindentBy: (\"indentBy\" in o.args) ?\r\n\t\t\t\t(o.args.indentBy > 0 ? o.args.indentBy : 40) :\r\n\t\t\t\t40,\r\n\t\t\tindentUnits: (\"indentUnits\" in o.args) ?\r\n\t\t\t\t(o.args.indentUnits.toLowerCase() == \"em\"? \"em\" : \"px\") :\r\n\t\t\t\t\"px\"\r\n\t\t});\r\n\t}\r\n});\r\n\r\nreturn NormalizeIndentOutdent;\r\n\r\n});\r\n"]}