{"version":3,"sources":["mvc/sync.js"],"names":["define","lang","config","array","has","sync","mvc","getObject","add","debugBindings","getLogContent","source","sourceProp","target","targetProp","canConvertToLoggable","declaredClass","join","copy","convertFunc","constraints","equals","old","current","excludes","indexOf","get","prop","logContent","e","console","log","reverse","isFunction","set","directions","from","to","both","options","converterInstance","formatFunc","parseFunc","converter","format","hitch","parse","list","_watchHandles","mixin","bindDirection","Error","s","hasOwnProperty","push","watch","apply","concat","name","forEach","value","undef","handle","unwatch","remove","h","pop","setObject","dst","src","isNaN","getTime"],"mappings":"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","file":"../../mvc/sync.js","sourcesContent":["define([\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/config\",\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/has\"\r\n], function(lang, config, array, has){\r\n\tvar mvc = lang.getObject(\"dojox.mvc\", true);\r\n\t/*=====\r\n\tmvc = {};\r\n\t=====*/\r\n\t\r\n\t/*=====\r\n\tdojox.mvc.sync.converter = {\r\n\t\t// summary:\r\n\t\t//\t\tClass/object containing the converter functions used when the data goes between data binding source (e.g. data model or controller) to data binding origin (e.g. widget).\r\n\r\n\t\tformat: function(value, constraints){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe converter function used when the data comes from data binding source (e.g. data model or controller) to data binding origin (e.g. widget).\r\n\t\t\t// value: Anything\r\n\t\t\t//\t\tThe data.\r\n\t\t\t// constraints: Object\r\n\t\t\t//\t\tThe options for data conversion, which is: mixin({}, dataBindingTarget.constraints, dataBindingOrigin.constraints).\r\n\t\t},\r\n\r\n\t\tparse: function(value, constraints){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThe converter function used when the data comes from data binding origin (e.g. widget) to data binding source (e.g. data model or controller).\r\n\t\t\t// value: Anything\r\n\t\t\t//\t\tThe data.\r\n\t\t\t// constraints: Object\r\n\t\t\t//\t\tThe options for data conversion, which is: mixin({}, dataBindingTarget.constraints, dataBindingOrigin.constraints).\r\n\t\t}\r\n\t};\r\n\r\n\tdojox.mvc.sync.options = {\r\n\t\t// summary:\r\n\t\t//\t\tData binding options.\r\n\r\n\t\t// bindDirection: Number\r\n\t\t//\t\tThe data binding bindDirection, choose from: dojox.mvc.Bind.from, dojox.mvc.Bind.to or dojox.mvc.Bind.both.\r\n\t\tbindDirection: dojox/mvc.both,\r\n\r\n\t\t// converter: dojox/mvc/sync.converter\r\n\t\t//\t\tClass/object containing the converter functions used when the data goes between data binding source (e.g. data model or controller) to data binding origin (e.g. widget).\r\n\t\tconverter: null,\r\n\r\n\t\t// equals: Function\r\n\t\t//\t\tThe function to check if there really was a change when source/target dojo/Stateful indicates so.\r\n\t\t//\t\tShould take two arguments, and should return true when those two are considered equal.\r\n\t\tequals: null\r\n\t};\r\n\t=====*/\r\n\r\n\thas.add(\"mvc-bindings-log-api\", (config[\"mvc\"] || {}).debugBindings);\r\n\r\n\tvar sync;\r\n\r\n\tif(has(\"mvc-bindings-log-api\")){\r\n\t\tfunction getLogContent(/*dojo/Stateful*/ source, /*String*/ sourceProp, /*dojo/Stateful*/ target, /*String*/ targetProp){\r\n\t\t\treturn [\r\n\t\t\t\t[target.canConvertToLoggable || !target.declaredClass ? target : target.declaredClass, targetProp].join(\":\"),\r\n\t\t\t\t[source.canConvertToLoggable || !source.declaredClass ? source : source.declaredClass, sourceProp].join(\":\")\r\n\t\t\t];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction equals(/*Anything*/ dst, /*Anything*/ src){\r\n\t\t// summary:\r\n\t\t//\t\tReturns if the given two values are equal.\r\n\r\n\t\treturn dst === src\r\n\t\t || typeof dst == \"number\" && isNaN(dst) && typeof src == \"number\" && isNaN(src)\r\n\t\t || lang.isFunction((dst || {}).getTime) && lang.isFunction((src || {}).getTime) && dst.getTime() == src.getTime()\r\n\t\t || (lang.isFunction((dst || {}).equals) ? dst.equals(src) : lang.isFunction((src || {}).equals) ? src.equals(dst) : false);\r\n\t}\r\n\r\n\tfunction copy(/*Function*/ convertFunc, /*Object?*/ constraints, /*Function*/ equals, /*dojo/Stateful*/ source, /*String*/ sourceProp, /*dojo/Stateful*/ target, /*String*/ targetProp, /*Anything*/ old, /*Anything*/ current, /*Object?*/ excludes){\r\n\t\t// summary:\r\n\t\t//\t\tWatch for change in property in dojo/Stateful object.\r\n\t\t// description:\r\n\t\t//\t\tCalled when targetProp property in target is changed. (This is mainly used as a callback function of dojo/Stateful.watch())\r\n\t\t//\t\tWhen older value and newer value are different, copies the newer value to sourceProp property in source.\r\n\t\t// convertFunc: Function\r\n\t\t//\t\tThe data converter function.\r\n\t\t// constraints: Object?\r\n\t\t//\t\tThe data converter options.\r\n\t\t// equals: Function\r\n\t\t//\t\tThe function to check if there really was a change when source/target dojo/Stateful indicates so.\r\n\t\t//\t\tShould take two arguments, and should return true when those two are considered equal.\r\n\t\t// source: dojo/Stateful\r\n\t\t//\t\tThe dojo/Stateful of copy source.\r\n\t\t// sourceProp: String\r\n\t\t//\t\tThe property of copy source, specified in data binding. May be wildcarded.\r\n\t\t// target: dojo/Stateful\r\n\t\t//\t\tThe dojo/Stateful of copy target.\r\n\t\t// targetProp: String\r\n\t\t//\t\tThe property of copy target, being changed. For wildcard-based data binding, this is used as the property to be copied.\r\n\t\t// old: Anything\r\n\t\t//\t\tThe older property value.\r\n\t\t// current: Anything\r\n\t\t//\t\tThe newer property value.\r\n\t\t// excludes: Object?\r\n\t\t//\t\tThe list of properties that should be excluded from wildcarded data binding.\r\n\r\n\t\t// Bail if there is no change in value,\r\n\t\t// or property name is wildcarded and the property to be copied is not in source property list (and source property list is defined),\r\n\t\t// or property name is wildcarded and the property to be copied is in explicit \"excludes\" list\r\n\t\tif(equals(current, old)\r\n\t\t || sourceProp == \"*\" && array.indexOf(source.get(\"properties\") || [targetProp], targetProp) < 0\r\n\t\t || sourceProp == \"*\" && targetProp in (excludes || {})){ return; }\r\n\r\n\t\tvar prop = sourceProp == \"*\" ? targetProp : sourceProp;\r\n\t\tif(has(\"mvc-bindings-log-api\")){\r\n\t\t\tvar logContent = getLogContent(source, prop, target, targetProp);\r\n\t\t}\r\n\r\n\t\ttry{\r\n\t\t\tcurrent = convertFunc ? convertFunc(current, constraints) : current;\r\n\t\t}catch(e){\r\n\t\t\tif(has(\"mvc-bindings-log-api\")){\r\n\t\t\t\tconsole.log(\"Copy from\" + logContent.join(\" to \") + \" was not done as an error is thrown in the converter.\");\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(has(\"mvc-bindings-log-api\")){\r\n\t\t\tconsole.log(logContent.reverse().join(\" is being copied from: \") + \" (Value: \" + current + \" from \" + old + \")\");\r\n\t\t}\r\n\r\n\t\t// Copy the new value to source\r\n\t\tlang.isFunction(source.set) ? source.set(prop, current) : (source[prop] = current);\r\n\t}\r\n\r\n\tvar directions = {\r\n\t\t// from: Number\r\n\t\t//\t\tData binding goes from the source to the target\r\n\t\tfrom: 1,\r\n\r\n\t\t// to: Number\r\n\t\t//\t\tData binding goes from the target to the source\r\n\t\tto: 2,\r\n\r\n\t\t// both: Number\r\n\t\t//\t\tData binding goes in both directions (dojox/mvc/Bind.from | dojox/mvc/Bind.to)\r\n\t\tboth: 3\r\n\t}, undef;\r\n\r\n\tsync = function(/*dojo/Stateful*/ source, /*String*/ sourceProp, /*dojo/Stateful*/ target, /*String*/ targetProp, /*dojox/mvc/sync.options*/ options){\r\n\t\t// summary:\r\n\t\t//\t\tSynchronize two dojo/Stateful properties.\r\n\t\t// description:\r\n\t\t//\t\tSynchronize two dojo/Stateful properties.\r\n\t\t// source: dojo/Stateful\r\n\t\t//\t\tSource dojo/Stateful to be synchronized.\r\n\t\t// sourceProp: String\r\n\t\t//\t\tThe property name in source to be synchronized.\r\n\t\t// target: dojo/Stateful\r\n\t\t//\t\tTarget dojo/Stateful to be synchronized.\r\n\t\t// targetProp: String\r\n\t\t//\t\tThe property name in target to be synchronized.\r\n\t\t// options: dojox/mvc/sync.options\r\n\t\t//\t\tData binding options.\r\n\t\t// returns:\r\n\t\t//\t\tThe handle of data binding synchronization.\r\n\r\n\t\tvar converter = (options || {}).converter, converterInstance, formatFunc, parseFunc;\r\n\t\tif(converter){\r\n\t\t\tconverterInstance = {source: source, target: target};\r\n\t\t\tformatFunc = converter.format && lang.hitch(converterInstance, converter.format);\r\n\t\t\tparseFunc = converter.parse && lang.hitch(converterInstance, converter.parse);\r\n\t\t}\r\n\r\n\t\tvar _watchHandles = [],\r\n\t\t excludes = [],\r\n\t\t list,\r\n\t\t constraints = lang.mixin({}, source.constraints, target.constraints),\r\n\t\t bindDirection = (options || {}).bindDirection || mvc.both,\r\n\t\t equals = (options || {}).equals || sync.equals;\r\n\r\n\t\tif(has(\"mvc-bindings-log-api\")){\r\n\t\t\tvar logContent = getLogContent(source, sourceProp, target, targetProp);\r\n\t\t}\r\n\r\n\t\tif(targetProp == \"*\"){\r\n\t\t\tif(sourceProp != \"*\"){ throw new Error(\"Unmatched wildcard is specified between source and target.\"); }\r\n\t\t\tlist = target.get(\"properties\");\r\n\t\t\tif(!list){\r\n\t\t\t\tlist = [];\r\n\t\t\t\tfor(var s in target){ if(target.hasOwnProperty(s) && s != \"_watchCallbacks\"){ list.push(s); } }\r\n\t\t\t}\r\n\t\t\texcludes = target.get(\"excludes\");\r\n\t\t}else{\r\n\t\t\tlist = [sourceProp];\r\n\t\t}\r\n\r\n\t\tif(bindDirection & mvc.from){\r\n\t\t\t// Start synchronization from source to target (e.g. from model to widget). For wildcard mode (sourceProp == targetProp == \"*\"), the 1st argument of watch() is omitted\r\n\t\t\tif(lang.isFunction(source.set) && lang.isFunction(source.watch)){\r\n\t\t\t\t_watchHandles.push(source.watch.apply(source, ((sourceProp != \"*\") ? [sourceProp] : []).concat([function(name, old, current){\r\n\t\t\t\t\tcopy(formatFunc, constraints, equals, target, targetProp, source, name, old, current, excludes);\r\n\t\t\t\t}])));\r\n\t\t\t}else if(has(\"mvc-bindings-log-api\")){\r\n\t\t\t\tconsole.log(logContent.reverse().join(\" is not a stateful property. Its change is not reflected to \") + \".\");\r\n\t\t\t}\r\n\r\n\t\t\t// Initial copy from source to target (e.g. from model to widget)\r\n\t\t\tarray.forEach(list, function(prop){\r\n\t\t\t\t// In \"all properties synchronization\" case, copy is not done for properties in \"exclude\" list\r\n\t\t\t\tif(targetProp != \"*\" || !(prop in (excludes || {}))){\r\n\t\t\t\t\tvar value = lang.isFunction(source.get) ? source.get(prop) : source[prop];\r\n\t\t\t\t\tcopy(formatFunc, constraints, equals, target, targetProp == \"*\" ? prop : targetProp, source, prop, undef, value);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif(bindDirection & mvc.to){\r\n\t\t\tif(!(bindDirection & mvc.from)){\r\n\t\t\t\t// Initial copy from source to target (e.g. from model to widget)\r\n\t\t\t\tarray.forEach(list, function(prop){\r\n\t\t\t\t\t// In \"all properties synchronization\" case, copy is not done for properties in \"exclude\" list\r\n\t\t\t\t\tif(targetProp != \"*\" || !(prop in (excludes || {}))){\r\n\t\t\t\t\t\t// Initial copy from target to source (e.g. from widget to model), only done for one-way binding from widget to model\r\n\t\t\t\t\t\tvar value = lang.isFunction(target.get) ? target.get(targetProp) : target[targetProp];\r\n\t\t\t\t\t\tcopy(parseFunc, constraints, equals, source, prop, target, targetProp == \"*\" ? prop : targetProp, undef, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Start synchronization from target to source (e.g. from widget to model). For wildcard mode (sourceProp == targetProp == \"*\"), the 1st argument of watch() is omitted\r\n\t\t\tif(lang.isFunction(target.set) && lang.isFunction(target.watch)){\r\n\t\t\t\t_watchHandles.push(target.watch.apply(target, ((targetProp != \"*\") ? [targetProp] : []).concat([function(name, old, current){\r\n\t\t\t\t\tcopy(parseFunc, constraints, equals, source, sourceProp, target, name, old, current, excludes);\r\n\t\t\t\t}])));\r\n\t\t\t}else if(has(\"mvc-bindings-log-api\")){\r\n\t\t\t\tconsole.log(logContent.join(\" is not a stateful property. Its change is not reflected to \") + \".\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(has(\"mvc-bindings-log-api\")){\r\n\t\t\tconsole.log(logContent.join(\" is bound to: \"));\r\n\t\t}\r\n\r\n\t\tvar handle = {};\r\n\t\thandle.unwatch = handle.remove = function(){\r\n\t\t\tfor(var h = null; h = _watchHandles.pop();){\r\n\t\t\t\th.unwatch();\r\n\t\t\t}\r\n\t\t\tif(has(\"mvc-bindings-log-api\")){\r\n\t\t\t\tconsole.log(logContent.join(\" is unbound from: \"));\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn handle; // dojo/handle\r\n\t};\r\n\r\n\tlang.mixin(mvc, directions);\r\n\r\n\t// lang.setObject() thing is for back-compat, remove it in 2.0\r\n\treturn lang.setObject(\"dojox.mvc.sync\", lang.mixin(sync, {equals: equals}, directions));\r\n});\r\n"]}