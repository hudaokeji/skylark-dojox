{"version":3,"sources":["mvc/Bind.js"],"names":["define","lang","array","mvc","getObject","mixin","bind","source","sourceProp","target","targetProp","func","bindOnlyIfUnequal","convertedValue","watch","prop","oldValue","newValue","isFunction","get","set","bindInputs","sourceBindArray","watchHandles","forEach","h","push"],"mappings":";;;;;;;AAAAA,QACC,kBACA,oBACE,SAASC,EAAMC,GACjB,IAAIC,EAAMF,EAAKG,UAAU,aAAa,GAEtC,OAAOH,EAAKI,MAAMF,GACjBG,KAAM,SAA2BC,EAAmBC,EAC/BC,EAAmBC,EACvBC,EAAmBC,GAoBnC,IAAIC,EACJ,OAAON,EAAOO,MAAMN,EAAY,SAASO,EAAMC,EAAUC,GACxDJ,EAAiBZ,EAAKiB,WAAWP,GAAQA,EAAKM,GAAYA,EACtDL,GAAqBC,GAAkBJ,EAAOU,IAAIT,IACrDD,EAAOW,IAAIV,EAAYG,MAK1BQ,WAAY,SAA6BC,EAA8BX,GAYtE,IAAIY,KAIJ,OAHArB,EAAMsB,QAAQF,EAAiB,SAASG,GACvCF,EAAaG,KAAKD,EAAEX,MAAM,QAASH,MAE7BY","file":"../../mvc/Bind.js","sourcesContent":["define([\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/array\"\r\n], function(lang, array){\r\n\tvar mvc = lang.getObject(\"dojox.mvc\", true);\r\n\r\n\treturn lang.mixin(mvc, {\r\n\t\tbind: function(/*dojo/Stateful*/ source, /*String*/ sourceProp,\r\n\t\t\t\t\t/*dojo/Stateful*/ target, /*String*/ targetProp,\r\n\t\t\t\t\t/*Function?*/ func, /*Boolean?*/ bindOnlyIfUnequal){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tBind the specified property of the target to the specified\r\n\t\t\t//\t\tproperty of the source with the supplied transformation.\r\n\t\t\t// source:\r\n\t\t\t//\t\tThe source dojo/Stateful object for the bind.\r\n\t\t\t// sourceProp:\r\n\t\t\t//\t\tThe name of the source's property whose change triggers the bind.\r\n\t\t\t// target:\r\n\t\t\t//\t\tThe target dojo/Stateful object for the bind whose\r\n\t\t\t//\t\tproperty will be updated with the result of the function.\r\n\t\t\t// targetProp:\r\n\t\t\t//\t\tThe name of the target's property to be updated with the\r\n\t\t\t//\t\tresult of the function.\r\n\t\t\t// func:\r\n\t\t\t//\t\tThe optional calculation to be performed to obtain the target\r\n\t\t\t//\t\tproperty value.\r\n\t\t\t// bindOnlyIfUnequal:\r\n\t\t\t//\t\tWhether the bind notification should happen only if the old and\r\n\t\t\t//\t\tnew values are unequal (optional, defaults to false).\r\n\t\t\tvar convertedValue;\r\n\t\t\treturn source.watch(sourceProp, function(prop, oldValue, newValue){\r\n\t\t\t\tconvertedValue = lang.isFunction(func) ? func(newValue) : newValue;\r\n\t\t\t\tif(!bindOnlyIfUnequal || convertedValue != target.get(targetProp)){\r\n\t\t\t\t\ttarget.set(targetProp, convertedValue);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tbindInputs: function(/*dojo/Stateful[]*/ sourceBindArray, /*Function*/ func){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tBind the values at the sources specified in the first argument\r\n\t\t\t//\t\tarray such that a composing function in the second argument is\r\n\t\t\t//\t\tcalled when any of the values changes.\r\n\t\t\t// sourceBindArray:\r\n\t\t\t//\t\tThe array of dojo/Stateful objects to watch values changes on.\r\n\t\t\t// func:\r\n\t\t\t//\t\tThe composing function that is called when any of the source\r\n\t\t\t//\t\tvalues changes.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\tvar watchHandles = [];\r\n\t\t\tarray.forEach(sourceBindArray, function(h){\r\n\t\t\t\twatchHandles.push(h.watch(\"value\", func));\r\n\t\t\t});\r\n\t\t\treturn watchHandles;\r\n\t\t}\r\n\t});\r\n});\r\n"]}