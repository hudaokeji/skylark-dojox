{"version":3,"sources":["mvc/StatefulArray.js"],"names":["define","lang","Stateful","update","a","_watchElementCallbacks","StatefulArray","array","_toArray","ctor","constructor","mixin","pop","this","splice","get","push","apply","concat","arguments","reverse","shift","sort","idx","n","l","p","Math","min","removals","slice","adds","Array","length","i","_watchCallbacks","unshift","join","sep","list","start","end","watchElements","callback","callbacks","_self","call","h","unwatch","remove","prototype","set","name","value","old","oldLength","isInstanceOf","cls","_meta","bases","setObject"],"mappings":"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","file":"../../mvc/StatefulArray.js","sourcesContent":["define([\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/Stateful\"\r\n], function(lang, Stateful){\r\n\tfunction update(/*dojox/mvc/StatefulArray*/ a){\r\n\t\t// summary:\r\n\t\t//\t\tSet all array elements as stateful so that watch function runs.\r\n\t\t// a: dojox/mvc/StatefulArray\r\n\t\t//\t\tThe array.\r\n\r\n\t\t// Notify change of elements.\r\n\t\tif(a._watchElementCallbacks){\r\n\t\t\ta._watchElementCallbacks();\r\n\t\t}\r\n\r\n\t\treturn a; // dojox/mvc/StatefulArray\r\n\t}\r\n\r\n\tvar StatefulArray = function(/*Anything[]*/ a){\r\n\t\t// summary:\r\n\t\t//\t\tAn inheritance of native JavaScript array, that adds dojo/Stateful capability.\r\n\t\t// description:\r\n\t\t//\t\tSupported methods are:\r\n\t\t//\r\n\t\t//\t\t- pop() - watchElements() notification is done for the removed elements. watch() notification is done for the length.\r\n\t\t//\t\t- push() - watchElements() notification is done for the added elements. watch() notification is done for the length.\r\n\t\t//\t\t- reverse() - watchElements() notification is done, indicating that the change affects all elements.\r\n\t\t//\t\t- shift() - watchElements() notification is done for the removed elements. watch() notification is done for the length.\r\n\t\t//\t\t- sort() - watchElements() notification is done, indicating that the change affects all elements.\r\n\t\t//\t\t- splice() - watchElements() notification is done for the removed/added elements. watch() notification is done for the length. Returns an instance of StatefulArray instead of the native array.\r\n\t\t//\t\t- unshift() - watchElements() notification is done for the added elements. watch() notification is done for the length.\r\n\t\t//\t\t- concat() - Returns an instance of StatefulArray instead of the native Array.\r\n\t\t//\t\t- join() - The length as well as the elements are obtained via stateful getters, instead of direct access.\r\n\t\t//\t\t- slice() - The length as well as the elements are obtained via stateful getters, instead of direct access.\r\n\t\t//\t\t- Setting an element to this array via set() - watch() notification is done for the new element as well as the new length.\r\n\t\t//\t\t- Setting a length to this array via set() - watchElements() notification is done for the removed/added elements. watch() notification is done for the new length.\r\n\r\n\t\tvar array = lang._toArray(a || []);\r\n\t\tvar ctor = StatefulArray;\r\n\t\tarray.constructor = ctor;\r\n\t\treturn lang.mixin(array, {\r\n\t\t\tpop: function(){\r\n\t\t\t\treturn this.splice(this.get(\"length\") - 1, 1)[0];\r\n\t\t\t},\r\n\t\t\tpush: function(){\r\n\t\t\t\tthis.splice.apply(this, [this.get(\"length\"), 0].concat(lang._toArray(arguments)));\r\n\t\t\t\treturn this.get(\"length\");\r\n\t\t\t},\r\n\t\t\treverse: function(){\r\n\t\t\t\treturn update([].reverse.apply(this, lang._toArray(arguments)));\r\n\t\t\t},\r\n\t\t\tshift: function(){\r\n\t\t\t\treturn this.splice(0, 1)[0];\r\n\t\t\t},\r\n\t\t\tsort: function(){\r\n\t\t\t\treturn update([].sort.apply(this, lang._toArray(arguments)));\r\n\t\t\t},\r\n\t\t\tsplice: function(/*Number*/ idx, /*Number*/ n){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tRemoves and then adds some elements to an array.\r\n\t\t\t\t//\t\twatchElements() notification is done for the removed/added elements.\r\n\t\t\t\t//\t\twatch() notification is done for the length.\r\n\t\t\t\t//\t\tReturns an instance of StatefulArray instead of the native array.\r\n\t\t\t\t// idx: Number\r\n\t\t\t\t//\t\tThe index where removal/addition should be done.\r\n\t\t\t\t// n: Number\r\n\t\t\t\t//\t\tHow many elements to be removed at idx.\r\n\t\t\t\t// varargs: Anything[]\r\n\t\t\t\t//\t\tThe elements to be added to idx.\r\n\t\t\t\t// returns: dojox/mvc/StatefulArray\r\n\t\t\t\t//\t\tThe removed elements.\r\n\r\n\t\t\t\tvar l = this.get(\"length\");\r\n\r\n\t\t\t\tidx += idx < 0 ? l : 0;\r\n\r\n\t\t\t\tvar p = Math.min(idx, l),\r\n\t\t\t\t removals = this.slice(idx, idx + n),\r\n\t\t\t\t adds = lang._toArray(arguments).slice(2);\r\n\r\n\t\t\t\t// Do the modification in a native manner except for setting additions\r\n\t\t\t\t[].splice.apply(this, [idx, n].concat(new Array(adds.length)));\r\n\r\n\t\t\t\t// Set additions in a stateful manner\r\n\t\t\t\tfor(var i = 0; i < adds.length; i++){\r\n\t\t\t\t\tthis[p + i] = adds[i];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Notify change of elements.\r\n\t\t\t\tif(this._watchElementCallbacks){\r\n\t\t\t\t\tthis._watchElementCallbacks(idx, removals, adds);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Notify change of length.\r\n\t\t\t\t// Not calling the setter for \"length\" though, given removal/addition of array automatically changes the length.\r\n\t\t\t\tif(this._watchCallbacks){\r\n\t\t\t\t\tthis._watchCallbacks(\"length\", l, l - removals.length + adds.length);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn removals; // dojox/mvc/StatefulArray\r\n\t\t\t},\r\n\t\t\tunshift: function(){\r\n\t\t\t\tthis.splice.apply(this, [0, 0].concat(lang._toArray(arguments)));\r\n\t\t\t\treturn this.get(\"length\");\r\n\t\t\t},\r\n\t\t\tconcat: function(/*Array*/ a){\r\n\t\t\t\treturn new StatefulArray([].concat.apply(this, arguments));\r\n\t\t\t},\r\n\t\t\tjoin: function(/*String*/ sep){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tReturns a string joining string elements in a, with a separator.\r\n\t\t\t\t// sep: String\r\n\t\t\t\t//\t\tThe separator.\r\n\r\n\t\t\t\tvar list = [];\r\n\t\t\t\tfor(var l = this.get(\"length\"), i = 0; i < l; i++){\r\n\t\t\t\t\tlist.push(this.get(i));\r\n\t\t\t\t}\r\n\t\t\t\treturn list.join(sep); // String\r\n\t\t\t},\r\n\t\t\tslice: function(/*Number*/ start, /*Number*/ end){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tReturns partial elements of an array.\r\n\t\t\t\t// start: Number\r\n\t\t\t\t//\t\tThe index to begin with.\r\n\t\t\t\t// end: Number\r\n\t\t\t\t//\t\tThe index to end at. (a[end] won't be picked up)\r\n\r\n\t\t\t\tvar l = this.get(\"length\");\r\n\r\n\t\t\t\tstart += start < 0 ? l : 0;\r\n\t\t\t\tend = (end === void 0 ? l : end) + (end < 0 ? l : 0);\r\n\r\n\t\t\t\tvar slice = [];\r\n\t\t\t\tfor(var i = start || 0; i < Math.min(end, this.get(\"length\")); i++){\r\n\t\t\t\t\tslice.push(this.get(i));\r\n\t\t\t\t}\r\n\t\t\t\treturn new StatefulArray(slice); // dojox/mvc/StatefulArray\r\n\t\t\t},\r\n\t\t\twatchElements: function(/*Function*/ callback){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tWatch for change in array elements.\r\n\t\t\t\t// callback: Function\r\n\t\t\t\t//\t\tThe callback function, which should take: The array index, the removed elements, and the added elements.\r\n\r\n\t\t\t\tvar callbacks = this._watchElementCallbacks, _self = this;\r\n\t\t\t\tif(!callbacks){\r\n\t\t\t\t\tcallbacks = this._watchElementCallbacks = function(idx, removals, adds){\r\n\t\t\t\t\t\tfor(var list = [].concat(callbacks.list), i = 0; i < list.length; i++){\r\n\t\t\t\t\t\t\tlist[i].call(_self, idx, removals, adds);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\tcallbacks.list = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallbacks.list.push(callback);\r\n\r\n\t\t\t\tvar h = {};\r\n\t\t\t\th.unwatch = h.remove = function(){\r\n\t\t\t\t\tfor(var list = callbacks.list, i = 0; i < list.length; i++){\r\n\t\t\t\t\t\tif(list[i] == callback){\r\n\t\t\t\t\t\t\tlist.splice(i, 1);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\treturn h; // dojo/handle\r\n\t\t\t}\r\n\t\t}, Stateful.prototype, {\r\n\t\t\tset: function(/*Number|String*/ name, /*Anything*/ value){\r\n\t\t\t\t// summary:\r\n\t\t\t\t//\t\tSets a new value to an array.\r\n\t\t\t\t// name: Number|String\r\n\t\t\t\t//\t\tThe property name.\r\n\t\t\t\t// value: Anything\r\n\t\t\t\t//\t\tThe new value.\r\n\r\n\t\t\t\tif(name == \"length\"){\r\n\t\t\t\t\tvar old = this.get(\"length\");\r\n\t\t\t\t\tif(old < value){\r\n\t\t\t\t\t\tthis.splice.apply(this, [old, 0].concat(new Array(value - old)));\r\n\t\t\t\t\t}else if(value < old){\r\n\t\t\t\t\t\tthis.splice.apply(this, [value, old - value]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar oldLength = this.length;\r\n\t\t\t\t\tStateful.prototype.set.call(this, name, value);\r\n\t\t\t\t\tif(oldLength != this.length){\r\n\t\t\t\t\t\tStateful.prototype.set.call(this, \"length\", this.length);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tisInstanceOf: function(cls){\r\n\t\t\t\treturn Stateful.prototype.isInstanceOf.apply(this, arguments) || cls == StatefulArray;\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\r\n\tStatefulArray._meta = {bases: [Stateful]}; // For isInstanceOf()\r\n\treturn lang.setObject(\"dojox.mvc.StatefulArray\", StatefulArray);\r\n});\r\n"]}