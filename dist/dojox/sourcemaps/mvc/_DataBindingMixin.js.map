{"version":3,"sources":["mvc/_DataBindingMixin.js"],"names":["define","kernel","lang","array","declare","Stateful","registry","deprecated","ref","isValid","valid","this","get","_dbstartup","_databound","_unwatchArray","_viewWatchHandles","watch","name","old","current","_setupBinding","binding","valueOf","set","_beingBound","parentBinding","pb","isFunction","toPlainObject","test","replace","getObject","_getParentBindingFromDOM","tokens","split","length","byId","shift","join","b","err","indexOf","console","warn","domNode","_relTargetProp","_updateBinding","_isEqual","one","other","isNaN","_modelWatchHandles","pThis","_updateProperty","validate","val","_updateChildBindings","defaultValue","setPropName","setPropValue","undefined","parentBind","forEach","findWidgets","widget","pw","pn","parentNode","getEnclosingWidget","watchHandles","h","unwatch"],"mappings":"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","file":"../../mvc/_DataBindingMixin.js","sourcesContent":["define([\r\n\t\"dojo/_base/kernel\",\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/Stateful\",\r\n\t\"dijit/registry\"\r\n], function(kernel, lang, array, declare, Stateful, registry){\r\n\r\n\tkernel.deprecated(\"dojox.mvc._DataBindingMixin\", \"Use dojox/mvc/at for data binding.\");\r\n\r\n\t// Note: This should be a plain Object, not a Class.\r\n\t// But no need to change it since it's deprecated.\r\n\treturn declare(\"dojox.mvc._DataBindingMixin\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tDeprecated.  Use dojox/mvc/at for data binding.\r\n\t\t//\t\tProvides the ability for dijits or custom view components to become\r\n\t\t//\t\tdata binding aware.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tData binding awareness enables dijits or other view layer\r\n\t\t//\t\tcomponents to bind to locations within a client-side data model,\r\n\t\t//\t\twhich is commonly an instance of the dojox/mvc/StatefulModel class. A\r\n\t\t//\t\tbind is a bi-directional update mechanism which is capable of\r\n\t\t//\t\tsynchronizing value changes between the bound dijit or other view\r\n\t\t//\t\tcomponent and the specified location within the data model, as well\r\n\t\t//\t\tas changes to other properties such as \"valid\", \"required\",\r\n\t\t//\t\t\"readOnly\" etc.\r\n\t\t//\r\n\t\t//\t\tThe data binding is commonly specified declaratively via the \"ref\"\r\n\t\t//\t\tproperty in the \"data-dojo-props\" attribute value.\r\n\t\t//\r\n\t\t//\t\tConsider the following simple example:\r\n\t\t//\r\n\t\t//\t\t|\t<script>\r\n\t\t//\t\t|\t\tvar model;\r\n\t\t//\t\t|\t\trequire([\"dijit/StatefulModel\", \"dojo/parser\"], function(StatefulModel, parser){\r\n\t\t//\t\t|\t\t\tmodel = new StatefulModel({ data : {\r\n\t\t//\t\t|\t\t\t\thello : \"Hello World\"\r\n\t\t//\t\t|\t\t\t}});\r\n\t\t//\t\t|\t\t\tparser.parse();\r\n\t\t//\t\t|\t\t});\r\n\t\t//\t\t|\t</script>\r\n\t\t//\t\t|\r\n\t\t//\t\t|\t<input id=\"hello1\" data-dojo-type=\"dijit/form/TextBox\"\r\n\t\t//\t\t|\t\tdata-dojo-props=\"ref: model.hello\"></input>\r\n\t\t//\t\t|\r\n\t\t//\t\t|\t<input id=\"hello2\" data-dojo-type=\"dijit/form/TextBox\"\r\n\t\t//\t\t|\t\tdata-dojo-props=\"ref: model.hello\"></input>\r\n\t\t//\r\n\t\t//\t\tIn the above example, both dijit/form/TextBox instances (with IDs\r\n\t\t//\t\t\"hello1\" and \"hello2\" respectively) are bound to the same reference\r\n\t\t//\t\tlocation in the data model i.e. \"hello\" via the \"ref\" expression\r\n\t\t//\t\t\"model.hello\". Both will have an initial value of \"Hello World\".\r\n\t\t//\t\tThereafter, a change in the value of either of the two textboxes\r\n\t\t//\t\twill cause an update of the value in the data model at location\r\n\t\t//\t\t\"hello\" which will in turn cause a matching update of the value in\r\n\t\t//\t\tthe other textbox.\r\n\t\t// tags:\r\n\t\t//\t\tdeprecated\r\n\t\r\n\t\t// ref: [deprecated] String||dojox/mvc/StatefulModel\r\n\t\t//\t\tThe value of the data binding expression passed declaratively by\r\n\t\t//\t\tthe developer. This usually references a location within an\r\n\t\t//\t\texisting datamodel and may be a relative reference based on the\r\n\t\t//\t\tparent / container data binding (dot-separated string).\r\n\t\tref: null,\r\n\r\n/*=====\r\n\t\t// binding: [readOnly] dojox/mvc/StatefulModel\r\n\t\t//\t\tThe read only value of the resolved data binding for this widget.\r\n\t\t//\t\tThis may be a result of resolving various relative refs along\r\n\t\t//\t\tthe parent axis.\r\n\t\tbinding: null,\r\n=====*/\r\n\r\n\t\t//////////////////////// PUBLIC METHODS ////////////////////////\r\n\t\r\n\t\tisValid: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the validity of the data binding.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tBoolean\r\n\t\t\t//\t\tThe validity associated with the data binding.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis function is meant to provide an API bridge to the dijit API.\r\n\t\t\t//\t\tValidity of data-bound dijits is a function of multiple concerns:\r\n\t\t\t//\r\n\t\t\t//\t\t- The validity of the value as ascertained by the data binding\r\n\t\t\t//\t\t  and constraints specified in the data model (usually semantic).\r\n\t\t\t//\t\t- The validity of the value as ascertained by the widget itself\r\n\t\t\t//\t\t  based on widget constraints (usually syntactic).\r\n\t\t\t//\r\n\t\t\t//\t\tIn order for dijits to function correctly in data-bound\r\n\t\t\t//\t\tenvironments, it is imperative that their isValid() functions\r\n\t\t\t//\t\tassess the model validity of the data binding via the\r\n\t\t\t//\t\tthis.inherited(arguments) hierarchy and declare any values\r\n\t\t\t//\t\tfailing the test as invalid.\r\n\t\t\tvar valid = this.get(\"valid\");\r\n\t\t\treturn typeof valid != \"undefined\" ? valid : this.get(\"binding\") ? this.get(\"binding\").get(\"valid\") : true;\r\n\t\t},\r\n\r\n\t\t//////////////////////// LIFECYCLE METHODS ////////////////////////\r\n\r\n\t\t_dbstartup: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTie data binding initialization into the widget lifecycle, at\r\n\t\t\t//\t\twidget startup.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(this._databound){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis._unwatchArray(this._viewWatchHandles);\r\n\t\t\t// add 2 new view watches, active only after widget has started up\r\n\t\t\tthis._viewWatchHandles = [\r\n\t\t\t\t// 1. data binding refs\r\n\t\t\t\tthis.watch(\"ref\", function(name, old, current){\r\n\t\t\t\t\tif(this._databound && old !== current){\r\n\t\t\t\t\t\tthis._setupBinding();\r\n\t\t\t\t\t}\r\n\t\t\t\t}),\r\n\t\t\t\t// 2. widget values\r\n\t\t\t\tthis.watch(\"value\", function(name, old, current){\r\n\t\t\t\t\tif(this._databound){\r\n\t\t\t\t\t\tvar binding = this.get(\"binding\");\r\n\t\t\t\t\t\tif(binding){\r\n\t\t\t\t\t\t\t// dont set value if the valueOf current and old match.\r\n\t\t\t\t\t\t\tif(!((current && old) && (old.valueOf() === current.valueOf()))){\r\n\t\t\t\t\t\t\t\tbinding.set(\"value\", current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t];\r\n\t\t\tthis._beingBound = true;\r\n\t\t\tthis._setupBinding();\r\n\t\t\tdelete this._beingBound;\r\n\t\t\tthis._databound = true;\r\n\t\t},\r\n\r\n\t\t//////////////////////// PRIVATE METHODS ////////////////////////\r\n\r\n\t\t_setupBinding: function(parentBinding){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCalculate and set the dojo/Stateful data binding for the\r\n\t\t\t//\t\tassociated dijit or custom view component.\r\n\t\t\t// parentBinding:\r\n\t\t\t//\t\tThe binding of this widget/view component's data-bound parent,\r\n\t\t\t//\t\tif available.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe declarative data binding reference may be specified in two\r\n\t\t\t//\t\tways via markup:\r\n\t\t\t//\r\n\t\t\t//\t\t- For older style documents (non validating), controls may use\r\n\t\t\t//\t\t  the \"ref\" attribute to specify the data binding reference\r\n\t\t\t//\t\t  (String).\r\n\t\t\t//\t\t- For validating documents using the new Dojo parser, controls\r\n\t\t\t//\t\t  may specify the data binding reference (String) as the \"ref\"\r\n\t\t\t//\t\t  property specified in the data-dojo-props attribute.\r\n\t\t\t//\r\n\t\t\t//\t\tOnce the ref value is obtained using either of the above means,\r\n\t\t\t//\t\tthe binding is set up for this control and its required, readOnly\r\n\t\t\t//\t\tetc. properties are refreshed.\r\n\t\t\t//\t\tThe data binding may be specified as a direct reference to the\r\n\t\t\t//\t\tdojo/Stateful model node or as a string relative to its DOM\r\n\t\t\t//\t\tparent or another widget.\r\n\t\t\t//\t\tThere are three ways in which the data binding node reference is\r\n\t\t\t//\t\tcalculated when specified as a string:\r\n\t\t\t//\r\n\t\t\t//\t\t- If an explicit parent widget is specified, the binding is\r\n\t\t\t//\t\t  calculated relative to the parent widget's data binding.\r\n\t\t\t//\t\t- For any dijits that specify a data binding reference,\r\n\t\t\t//\t\t  we walk up their DOM hierarchy to obtain the first container\r\n\t\t\t//\t\t  dijit that has a data binding set up and use the reference String\r\n\t\t\t//\t\t  as a property name relative to the parent's data binding context.\r\n\t\t\t//\t\t- If no such parent is found i.e. for the outermost container\r\n\t\t\t//\t\t  dijits that specify a data binding reference, the binding is\r\n\t\t\t//\t\t  calculated by treating the reference String as an expression and\r\n\t\t\t//\t\t  evaluating it to obtain the dojo/Stateful node in the datamodel.\r\n\t\t\t//\r\n\t\t\t//\t\tThis method calls console.warn in these two conditions:\r\n\t\t\t//\r\n\t\t\t//\t\t- The ref is an expression i.e. outermost bound dijit, but the\r\n\t\t\t//\t\t  expression evaluation fails.\r\n\t\t\t//\t\t- The calculated binding turns out to not be an instance of a\r\n\t\t\t//\t\t  dojo/Stateful node.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\r\n\t\t\tif(!this.ref){\r\n\t\t\t\treturn; // nothing to do here\r\n\t\t\t}\r\n\t\t\tvar ref = this.ref, pw, pb, binding;\r\n\t\t\t// Now compute the model node to bind to\r\n\t\t\tif(ref && lang.isFunction(ref.toPlainObject)){ // programmatic instantiation or direct ref\r\n\t\t\t\tbinding = ref;\r\n\t\t\t}else if(/^\\s*expr\\s*:\\s*/.test(ref)){ // declarative: refs as dot-separated expressions\r\n\t\t\t\tref = ref.replace(/^\\s*expr\\s*:\\s*/, \"\");\r\n\t\t\t\tbinding = lang.getObject(ref);\r\n\t\t\t}else if(/^\\s*rel\\s*:\\s*/.test(ref)){ // declarative: refs relative to parent binding, dot-separated \r\n\t\t\t\tref = ref.replace(/^\\s*rel\\s*:\\s*/, \"\");\r\n\t\t\t\tparentBinding = parentBinding || this._getParentBindingFromDOM();\r\n\t\t\t\tif(parentBinding){\r\n\t\t\t\t\tbinding = lang.getObject(\"\" + ref, false, parentBinding);\r\n\t\t\t\t}\r\n\t\t\t}else if(/^\\s*widget\\s*:\\s*/.test(ref)){ // declarative: refs relative to another dijits binding, dot-separated\r\n\t\t\t\tref = ref.replace(/^\\s*widget\\s*:\\s*/, \"\");\r\n\t\t\t\tvar tokens = ref.split(\".\");\r\n\t\t\t\tif(tokens.length == 1){\r\n\t\t\t\t\tbinding = registry.byId(ref).get(\"binding\");\r\n\t\t\t\t}else{\r\n\t\t\t\t\tpb = registry.byId(tokens.shift()).get(\"binding\");\r\n\t\t\t\t\tbinding = lang.getObject(tokens.join(\".\"), false, pb);\r\n\t\t\t\t}\r\n\t\t\t}else{ // defaults: outermost refs are expressions, nested are relative to parents\r\n\t\t\t\tparentBinding = parentBinding || this._getParentBindingFromDOM();\r\n\t\t\t\tif(parentBinding){\r\n\t\t\t\t\tbinding = lang.getObject(\"\" + ref, false, parentBinding);\r\n\t\t\t\t}else{\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\tvar b = lang.getObject(\"\" + ref) || {};\r\n\t\t\t\t\t\tif(lang.isFunction(b.set) && lang.isFunction(b.watch)){\r\n\t\t\t\t\t\t\tbinding = b;\r\n\t\t\t\t\t\t}\t\t\t\t\t\t\r\n\t\t\t\t\t}catch(err){\r\n\t\t\t\t\t\tif(ref.indexOf(\"${\") == -1){ // Ignore templated refs such as in repeat body\r\n\t\t\t\t\t\t\tconsole.warn(\"dojox/mvc/_DataBindingMixin: '\" + this.domNode +\r\n\t\t\t\t\t\t\t\t\"' widget with illegal ref not evaluating to a dojo/Stateful node: '\" + ref + \"'\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(binding){\r\n\t\t\t\tif(lang.isFunction(binding.toPlainObject)){\r\n\t\t\t\t\tthis.binding = binding;\r\n\t\t\t\t\tif(this[this._relTargetProp || \"target\"] !== binding){\r\n\t\t\t\t\t\tthis.set(this._relTargetProp || \"target\", binding);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._updateBinding(\"binding\", null, binding);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tconsole.warn(\"dojox/mvc/_DataBindingMixin: '\" + this.domNode +\r\n\t\t\t\t\t\t\"' widget with illegal ref not evaluating to a dojo/Stateful node: '\" + ref + \"'\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_isEqual: function(one, other){\r\n\t\t\t// test for equality\r\n\t\t\treturn one === other ||\r\n\t\t\t\t// test for NaN === NaN\r\n\t\t\t\tisNaN(one) && typeof one === 'number' &&\r\n\t\t\t\tisNaN(other) && typeof other === 'number';\r\n\t\t},\r\n\r\n\t\t_updateBinding: function(name, old, current){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet the data binding to the supplied value, which must be a\r\n\t\t\t//\t\tdojo/Stateful node of a data model.\r\n\t\t\t// name:\r\n\t\t\t//\t\tThe name of the binding property (always \"binding\").\r\n\t\t\t// old:\r\n\t\t\t//\t\tThe old dojo/Stateful binding node of the data model.\r\n\t\t\t// current:\r\n\t\t\t//\t\tThe new dojo/Stateful binding node of the data model.\r\n\t\t\t// description:\r\n\t\t\t//\t\tApplies the specified data binding to the attached widget.\r\n\t\t\t//\t\tLoses any prior watch registrations on the previously active\r\n\t\t\t//\t\tbind, registers the new one, updates data binds of any contained\r\n\t\t\t//\t\twidgets and also refreshes all associated properties (valid,\r\n\t\t\t//\t\trequired etc.)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\r\n\t\t\t// remove all existing watches (if there are any, there will be 5)\r\n\t\t\tthis._unwatchArray(this._modelWatchHandles);\r\n\t\t\t// add 5 new model watches\r\n\t\t\tvar binding = this.get(\"binding\");\r\n\t\t\tif(binding && lang.isFunction(binding.watch)){\r\n\t\t\t\tvar pThis = this;\r\n\t\t\t\tthis._modelWatchHandles = [\r\n\t\t\t\t\t// 1. value - no default\r\n\t\t\t\t\tbinding.watch(\"value\", function (name, old, current){\r\n\t\t\t\t\t\tif(pThis._isEqual(old, current)){return;}\r\n\t\t\t\t\t\tif(pThis._isEqual(pThis.get('value'), current)){return;}\r\n\t\t\t\t\t\tpThis.set(\"value\", current);\r\n\t\t\t\t\t}),\r\n\t\t\t\t\t// 2. valid - default \"true\"\r\n\t\t\t\t\tbinding.watch(\"valid\", function (name, old, current){\r\n\t\t\t\t\t\tpThis._updateProperty(name, old, current, true);\r\n\t\t\t\t\t\tif(current !== pThis.get(name)){\r\n\t\t\t\t\t\t\tif(pThis.validate && lang.isFunction(pThis.validate)){\r\n\t\t\t\t\t\t\t\tpThis.validate();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}),\r\n\t\t\t\t\t// 3. required - default \"false\"\r\n\t\t\t\t\tbinding.watch(\"required\", function (name, old, current){\r\n\t\t\t\t\t\tpThis._updateProperty(name, old, current, false, name, current);\r\n\t\t\t\t\t}),\r\n\t\t\t\t\t// 4. readOnly - default \"false\"\r\n\t\t\t\t\tbinding.watch(\"readOnly\", function (name, old, current){\r\n\t\t\t\t\t\tpThis._updateProperty(name, old, current, false, name, current);\r\n\t\t\t\t\t}),\r\n\t\t\t\t\t// 5. relevant - default \"true\"\r\n\t\t\t\t\tbinding.watch(\"relevant\", function (name, old, current){\r\n\t\t\t\t\t\tpThis._updateProperty(name, old, current, false, \"disabled\", !current);\r\n\t\t\t\t\t})\r\n\t\t\t\t];\r\n\t\t\t\tvar val = binding.get(\"value\");\r\n\t\t\t\tif(val != null){\r\n\t\t\t\t\tthis.set(\"value\", val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._updateChildBindings();\r\n\t\t},\r\n\t\r\n\t\t_updateProperty: function(name, old, current, defaultValue, setPropName, setPropValue){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tUpdate a binding property of the bound widget.\r\n\t\t\t// name:\r\n\t\t\t//\t\tThe binding property name.\r\n\t\t\t// old:\r\n\t\t\t//\t\tThe old value of the binding property.\r\n\t\t\t// current:\r\n\t\t\t//\t\tThe new or current value of the binding property.\r\n\t\t\t// defaultValue:\r\n\t\t\t//\t\tThe optional value to be applied as the current value of the\r\n\t\t\t//\t\tbinding property if the current value is null.\r\n\t\t\t// setPropName:\r\n\t\t\t//\t\tThe optional name of a stateful property to set on the bound\r\n\t\t\t//\t\twidget.\r\n\t\t\t// setPropValue:\r\n\t\t\t//\t\tThe value, if an optional name is provided, for the stateful\r\n\t\t\t//\t\tproperty of the bound widget.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tif(old === current){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif(current === null && defaultValue !== undefined){\r\n\t\t\t\tcurrent = defaultValue;\r\n\t\t\t}\r\n\t\t\tif(current !== this.get(\"binding\").get(name)){\r\n\t\t\t\tthis.get(\"binding\").set(name, current);\r\n\t\t\t}\r\n\t\t\tif(setPropName){\r\n\t\t\t\tthis.set(setPropName, setPropValue);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_updateChildBindings: function(parentBind){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tUpdate this widget's value based on the current binding and\r\n\t\t\t//\t\tset up the bindings of all contained widgets so as to refresh\r\n\t\t\t//\t\tany relative binding references. \r\n\t\t\t//\t\tfindWidgets does not return children of widgets so need to also\r\n\t\t\t//\t\tupdate children of widgets which are not bound but may hold widgets which are.\r\n\t\t\t// parentBind:\r\n\t\t\t//\t\tThe binding on the parent of a widget whose children may have bindings \r\n\t\t\t//\t\twhich need to be updated.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar binding = this.get(\"binding\") || parentBind;\r\n\t\t\tif(binding && !this._beingBound){\r\n\t\t\t\tarray.forEach(registry.findWidgets(this.domNode), function(widget){\r\n\t\t\t\t\tif(widget.ref && widget._setupBinding){\r\n\t\t\t\t\t\twidget._setupBinding(binding);\r\n\t\t\t\t\t}else{\t\r\n\t\t\t\t\t\twidget._updateChildBindings(binding);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_getParentBindingFromDOM: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGet the parent binding by traversing the DOM ancestors to find\r\n\t\t\t//\t\tthe first enclosing data-bound widget.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tThe parent binding, if one exists along the DOM parent axis.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar pn = this.domNode.parentNode, pw, pb;\r\n\t\t\twhile(pn){\r\n\t\t\t\tpw = registry.getEnclosingWidget(pn);\r\n\t\t\t\tif(pw){\r\n\t\t\t\t\tpb = pw.get(\"binding\");\r\n\t\t\t\t\tif(pb && lang.isFunction(pb.toPlainObject)){\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tpn = pw ? pw.domNode.parentNode : null;\r\n\t\t\t}\r\n\t\t\treturn pb;\r\n\t\t},\r\n\r\n\t\t_unwatchArray: function(watchHandles){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tGiven an array of watch handles, unwatch all.\r\n\t\t\t// watchHandles:\r\n\t\t\t//\t\tThe array of watch handles.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tarray.forEach(watchHandles, function(h){ h.unwatch(); });\r\n\t\t}\r\n\t});\r\n});\r\n"]}