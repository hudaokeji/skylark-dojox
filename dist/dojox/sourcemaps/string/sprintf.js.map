{"version":3,"sources":["string/sprintf.js"],"names":["define","dojo","lang","has","tokenize","strLib","getObject","dojox","sprintf","format","filler","args","i","arguments","length","push","formatter","Formatter","apply","this","_mapped","_format","_tokens","_re","_parseDelim","extend","mapping","intmapping","flags","minWidth","period","precision","specifier","_minWidth","_precision","_specifiers","b","base","isInt","o","x","X","toUpper","d","u","isUnsigned","c","setArg","token","isNaN","arg","num","parseInt","Error","String","fromCharCode","s","setMaxWidth","maxWidth","e","isDouble","doubleNotation","E","f","F","g","G","str","position","compiled","sign","zeroPad","rightJustify","alternative","fi","flag","charAt","mixins","mixin","formatInt","formatDouble","fitField","_zeros10","_spaces10","isFinite","toString","toUpperCase","toLowerCase","parseFloat","toExponential","toFixed","Math","abs","toPrecision","replace","tenless","pad","substring","spacePad"],"mappings":"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","file":"../../string/sprintf.js","sourcesContent":["define([\r\n\t\"dojo/_base/kernel\",\t// dojo.getObject, dojo.mixin\r\n\t\"dojo/_base/lang\",\t// dojo.extend\r\n\t\"dojo/_base/sniff\",\t// dojo.isOpera\r\n\t \"./tokenize\"\r\n], function(dojo, lang, has, tokenize){\r\n\tvar strLib = lang.getObject(\"string\", true, dojox);\r\n\r\n\tstrLib.sprintf = function(/*String*/ format, /*mixed...*/ filler){\r\n\t\tfor(var args = [], i = 1; i < arguments.length; i++){\r\n\t\t\targs.push(arguments[i]);\r\n\t\t}\r\n\t\tvar formatter = new strLib.sprintf.Formatter(format);\r\n\t\treturn formatter.format.apply(formatter, args);\r\n\t};\r\n\r\n\tstrLib.sprintf.Formatter = function(/*String*/ format){\r\n\t\tvar tokens = [];\r\n\t\tthis._mapped = false;\r\n\t\tthis._format = format;\r\n\t\tthis._tokens = tokenize(format, this._re, this._parseDelim, this);\r\n\t};\r\n\r\n\tlang.extend(strLib.sprintf.Formatter, {\r\n\t\t_re: /\\%(?:\\(([\\w_]+)\\)|([1-9]\\d*)\\$)?([0 +\\-\\#]*)(\\*|\\d+)?(\\.)?(\\*|\\d+)?[hlL]?([\\%scdeEfFgGiouxX])/g,\r\n\t\t_parseDelim: function(mapping, intmapping, flags, minWidth, period, precision, specifier){\r\n\t\t\tif(mapping){\r\n\t\t\t\tthis._mapped = true;\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\tmapping: mapping,\r\n\t\t\t\tintmapping: intmapping,\r\n\t\t\t\tflags: flags,\r\n\t\t\t\t_minWidth: minWidth, // May be dependent on parameters\r\n\t\t\t\tperiod: period,\r\n\t\t\t\t_precision: precision, // May be dependent on parameters\r\n\t\t\t\tspecifier: specifier\r\n\t\t\t};\r\n\t\t},\r\n\t\t_specifiers: {\r\n\t\t\tb: {\r\n\t\t\t\tbase: 2,\r\n\t\t\t\tisInt: true\r\n\t\t\t},\r\n\t\t\to: {\r\n\t\t\t\tbase: 8,\r\n\t\t\t\tisInt: true\r\n\t\t\t},\r\n\t\t\tx: {\r\n\t\t\t\tbase: 16,\r\n\t\t\t\tisInt: true\r\n\t\t\t},\r\n\t\t\tX: {\r\n\t\t\t\textend: [\"x\"],\r\n\t\t\t\ttoUpper: true\r\n\t\t\t},\r\n\t\t\td: {\r\n\t\t\t\tbase: 10,\r\n\t\t\t\tisInt: true\r\n\t\t\t},\r\n\t\t\ti: {\r\n\t\t\t\textend: [\"d\"]\r\n\t\t\t},\r\n\t\t\tu: {\r\n\t\t\t\textend: [\"d\"],\r\n\t\t\t\tisUnsigned: true\r\n\t\t\t},\r\n\t\t\tc: {\r\n\t\t\t\tsetArg: function(token){\r\n\t\t\t\t\tif(!isNaN(token.arg)){\r\n\t\t\t\t\t\tvar num = parseInt(token.arg);\r\n\t\t\t\t\t\tif(num < 0 || num > 127){\r\n\t\t\t\t\t\t\tthrow new Error(\"invalid character code passed to %c in sprintf\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoken.arg = isNaN(num) ? \"\" + num : String.fromCharCode(num);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\ts: {\r\n\t\t\t\tsetMaxWidth: function(token){\r\n\t\t\t\t\ttoken.maxWidth = (token.period == \".\") ? token.precision : -1;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\te: {\r\n\t\t\t\tisDouble: true,\r\n\t\t\t\tdoubleNotation: \"e\"\r\n\t\t\t},\r\n\t\t\tE: {\r\n\t\t\t\textend: [\"e\"],\r\n\t\t\t\ttoUpper: true\r\n\t\t\t},\r\n\t\t\tf: {\r\n\t\t\t\tisDouble: true,\r\n\t\t\t\tdoubleNotation: \"f\"\r\n\t\t\t},\r\n\t\t\tF: {\r\n\t\t\t\textend: [\"f\"]\r\n\t\t\t},\r\n\t\t\tg: {\r\n\t\t\t\tisDouble: true,\r\n\t\t\t\tdoubleNotation: \"g\"\r\n\t\t\t},\r\n\t\t\tG: {\r\n\t\t\t\textend: [\"g\"],\r\n\t\t\t\ttoUpper: true\r\n\t\t\t}\r\n\t\t},\r\n\t\tformat: function(/*mixed...*/ filler){\r\n\t\t\tif(this._mapped && typeof filler != \"object\"){\r\n\t\t\t\tthrow new Error(\"format requires a mapping\");\r\n\t\t\t}\r\n\r\n\t\t\tvar str = \"\";\r\n\t\t\tvar position = 0;\r\n\t\t\tfor(var i = 0, token; i < this._tokens.length; i++){\r\n\t\t\t\ttoken = this._tokens[i];\r\n\t\t\t\tif(typeof token == \"string\"){\r\n\t\t\t\t\tstr += token;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(this._mapped){\r\n\t\t\t\t\t\tif(typeof filler[token.mapping] == \"undefined\"){\r\n\t\t\t\t\t\t\tthrow new Error(\"missing key \" + token.mapping);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoken.arg = filler[token.mapping];\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(token.intmapping){\r\n\t\t\t\t\t\t\tvar position = parseInt(token.intmapping) - 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(position >= arguments.length){\r\n\t\t\t\t\t\t\tthrow new Error(\"got \" + arguments.length + \" printf arguments, insufficient for '\" + this._format + \"'\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoken.arg = arguments[position++];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(!token.compiled){\r\n\t\t\t\t\t\ttoken.compiled = true;\r\n\t\t\t\t\t\ttoken.sign = \"\";\r\n\t\t\t\t\t\ttoken.zeroPad = false;\r\n\t\t\t\t\t\ttoken.rightJustify = false;\r\n\t\t\t\t\t\ttoken.alternative = false;\r\n\r\n\t\t\t\t\t\tvar flags = {};\r\n\t\t\t\t\t\tfor(var fi = token.flags.length; fi--;){\r\n\t\t\t\t\t\t\tvar flag = token.flags.charAt(fi);\r\n\t\t\t\t\t\t\tflags[flag] = true;\r\n\t\t\t\t\t\t\tswitch(flag){\r\n\t\t\t\t\t\t\t\tcase \" \":\r\n\t\t\t\t\t\t\t\t\ttoken.sign = \" \";\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase \"+\":\r\n\t\t\t\t\t\t\t\t\ttoken.sign = \"+\";\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase \"0\":\r\n\t\t\t\t\t\t\t\t\ttoken.zeroPad = (flags[\"-\"]) ? false : true;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase \"-\":\r\n\t\t\t\t\t\t\t\t\ttoken.rightJustify = true;\r\n\t\t\t\t\t\t\t\t\ttoken.zeroPad = false;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase \"\\#\":\r\n\t\t\t\t\t\t\t\t\ttoken.alternative = true;\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\tthrow Error(\"bad formatting flag '\" + token.flags.charAt(fi) + \"'\");\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttoken.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;\r\n\t\t\t\t\t\ttoken.maxWidth = -1;\r\n\t\t\t\t\t\ttoken.toUpper = false;\r\n\t\t\t\t\t\ttoken.isUnsigned = false;\r\n\t\t\t\t\t\ttoken.isInt = false;\r\n\t\t\t\t\t\ttoken.isDouble = false;\r\n\t\t\t\t\t\ttoken.precision = 1;\r\n\t\t\t\t\t\tif(token.period == '.'){\r\n\t\t\t\t\t\t\tif(token._precision){\r\n\t\t\t\t\t\t\t\ttoken.precision = parseInt(token._precision);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\ttoken.precision = 0;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar mixins = this._specifiers[token.specifier];\r\n\t\t\t\t\t\tif(typeof mixins == \"undefined\"){\r\n\t\t\t\t\t\t\tthrow new Error(\"unexpected specifier '\" + token.specifier + \"'\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(mixins.extend){\r\n\t\t\t\t\t\t\tlang.mixin(mixins, this._specifiers[mixins.extend]);\r\n\t\t\t\t\t\t\tdelete mixins.extend;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tlang.mixin(token, mixins);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(typeof token.setArg == \"function\"){\r\n\t\t\t\t\t\ttoken.setArg(token);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(typeof token.setMaxWidth == \"function\"){\r\n\t\t\t\t\t\ttoken.setMaxWidth(token);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(token._minWidth == \"*\"){\r\n\t\t\t\t\t\tif(this._mapped){\r\n\t\t\t\t\t\t\tthrow new Error(\"* width not supported in mapped formats\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoken.minWidth = parseInt(arguments[position++]);\r\n\t\t\t\t\t\tif(isNaN(token.minWidth)){\r\n\t\t\t\t\t\t\tthrow new Error(\"the argument for * width at position \" + position + \" is not a number in \" + this._format);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// negative width means rightJustify\r\n\t\t\t\t\t\tif (token.minWidth < 0) {\r\n\t\t\t\t\t\t\ttoken.rightJustify = true;\r\n\t\t\t\t\t\t\ttoken.minWidth = -token.minWidth;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(token._precision == \"*\" && token.period == \".\"){\r\n\t\t\t\t\t\tif(this._mapped){\r\n\t\t\t\t\t\t\tthrow new Error(\"* precision not supported in mapped formats\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttoken.precision = parseInt(arguments[position++]);\r\n\t\t\t\t\t\tif(isNaN(token.precision)){\r\n\t\t\t\t\t\t\tthrow Error(\"the argument for * precision at position \" + position + \" is not a number in \" + this._format);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// negative precision means unspecified\r\n\t\t\t\t\t\tif (token.precision < 0) {\r\n\t\t\t\t\t\t\ttoken.precision = 1;\r\n\t\t\t\t\t\t\ttoken.period = '';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(token.isInt){\r\n\t\t\t\t\t\t// a specified precision means no zero padding\r\n\t\t\t\t\t\tif(token.period == '.'){\r\n\t\t\t\t\t\t\ttoken.zeroPad = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.formatInt(token);\r\n\t\t\t\t\t}else if(token.isDouble){\r\n\t\t\t\t\t\tif(token.period != '.'){\r\n\t\t\t\t\t\t\ttoken.precision = 6;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.formatDouble(token);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.fitField(token);\r\n\r\n\t\t\t\t\tstr += \"\" + token.arg;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn str;\r\n\t\t},\r\n\t\t_zeros10: '0000000000',\r\n\t\t_spaces10: '          ',\r\n\t\tformatInt: function(token) {\r\n\t\t\tvar i = parseInt(token.arg);\r\n\t\t\tif(!isFinite(i)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)\r\n\t\t\t\t// allow this only if arg is number\r\n\t\t\t\tif(typeof token.arg != \"number\"){\r\n\t\t\t\t\tthrow new Error(\"format argument '\" + token.arg + \"' not an integer; parseInt returned \" + i);\r\n\t\t\t\t}\r\n\t\t\t\t//return '' + i;\r\n\t\t\t\ti = 0;\r\n\t\t\t}\r\n\r\n\t\t\t// if not base 10, make negatives be positive\r\n\t\t\t// otherwise, (-10).toString(16) is '-a' instead of 'fffffff6'\r\n\t\t\tif(i < 0 && (token.isUnsigned || token.base != 10)){\r\n\t\t\t\ti = 0xffffffff + i + 1;\r\n\t\t\t}\r\n\r\n\t\t\tif(i < 0){\r\n\t\t\t\ttoken.arg = (- i).toString(token.base);\r\n\t\t\t\tthis.zeroPad(token);\r\n\t\t\t\ttoken.arg = \"-\" + token.arg;\r\n\t\t\t}else{\r\n\t\t\t\ttoken.arg = i.toString(token.base);\r\n\t\t\t\t// need to make sure that argument 0 with precision==0 is formatted as ''\r\n\t\t\t\tif(!i && !token.precision){\r\n\t\t\t\t\ttoken.arg = \"\";\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.zeroPad(token);\r\n\t\t\t\t}\r\n\t\t\t\tif(token.sign){\r\n\t\t\t\t\ttoken.arg = token.sign + token.arg;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(token.base == 16){\r\n\t\t\t\tif(token.alternative){\r\n\t\t\t\t\ttoken.arg = '0x' + token.arg;\r\n\t\t\t\t}\r\n\t\t\t\ttoken.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();\r\n\t\t\t}\r\n\t\t\tif(token.base == 8){\r\n\t\t\t\tif(token.alternative && token.arg.charAt(0) != '0'){\r\n\t\t\t\t\ttoken.arg = '0' + token.arg;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tformatDouble: function(token) {\r\n\t\t\tvar f = parseFloat(token.arg);\r\n\t\t\tif(!isFinite(f)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)\r\n\t\t\t\t// allow this only if arg is number\r\n\t\t\t\tif(typeof token.arg != \"number\"){\r\n\t\t\t\t\tthrow new Error(\"format argument '\" + token.arg + \"' not a float; parseFloat returned \" + f);\r\n\t\t\t\t}\r\n\t\t\t\t// C99 says that for 'f':\r\n\t\t\t\t//\t infinity -> '[-]inf' or '[-]infinity' ('[-]INF' or '[-]INFINITY' for 'F')\r\n\t\t\t\t//\t NaN -> a string  starting with 'nan' ('NAN' for 'F')\r\n\t\t\t\t// this is not commonly implemented though.\r\n\t\t\t\t//return '' + f;\r\n\t\t\t\tf = 0;\r\n\t\t\t}\r\n\r\n\t\t\tswitch(token.doubleNotation) {\r\n\t\t\t\tcase 'e': {\r\n\t\t\t\t\ttoken.arg = f.toExponential(token.precision);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 'f': {\r\n\t\t\t\t\ttoken.arg = f.toFixed(token.precision);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 'g': {\r\n\t\t\t\t\t// C says use 'e' notation if exponent is < -4 or is >= prec\r\n\t\t\t\t\t// ECMAScript for toPrecision says use exponential notation if exponent is >= prec,\r\n\t\t\t\t\t// though step 17 of toPrecision indicates a test for < -6 to force exponential.\r\n\t\t\t\t\tif(Math.abs(f) < 0.0001){\r\n\t\t\t\t\t\t//print(\"forcing exponential notation for f=\" + f);\r\n\t\t\t\t\t\ttoken.arg = f.toExponential(token.precision > 0 ? token.precision - 1 : token.precision);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\ttoken.arg = f.toPrecision(token.precision);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// In C, unlike 'f', 'gG' removes trailing 0s from fractional part, unless alternative format flag (\"#\").\r\n\t\t\t\t\t// But ECMAScript formats toPrecision as 0.00100000. So remove trailing 0s.\r\n\t\t\t\t\tif(!token.alternative){\r\n\t\t\t\t\t\t//print(\"replacing trailing 0 in '\" + s + \"'\");\r\n\t\t\t\t\t\ttoken.arg = token.arg.replace(/(\\..*[^0])0*/, \"$1\");\r\n\t\t\t\t\t\t// if fractional part is entirely 0, remove it and decimal point\r\n\t\t\t\t\t\ttoken.arg = token.arg.replace(/\\.0*e/, 'e').replace(/\\.0$/,'');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tdefault: throw new Error(\"unexpected double notation '\" + token.doubleNotation + \"'\");\r\n\t\t\t}\r\n\r\n\t\t\t// C says that exponent must have at least two digits.\r\n\t\t\t// But ECMAScript does not; toExponential results in things like \"1.000000e-8\" and \"1.000000e+8\".\r\n\t\t\t// Note that s.replace(/e([\\+\\-])(\\d)/, \"e$10$2\") won't work because of the \"$10\" instead of \"$1\".\r\n\t\t\t// And replace(re, func) isn't supported on IE50 or Safari1.\r\n\t\t\ttoken.arg = token.arg.replace(/e\\+(\\d)$/, \"e+0$1\").replace(/e\\-(\\d)$/, \"e-0$1\");\r\n\r\n\t\t\t// Ensure a '0' before the period.\r\n\t\t\t// Opera implements (0.001).toString() as '0.001', but (0.001).toFixed(1) is '.001'\r\n\t\t\tif(has(\"opera\")){\r\n\t\t\t\ttoken.arg = token.arg.replace(/^\\./, '0.');\r\n\t\t\t}\r\n\r\n\t\t\t// if alt, ensure a decimal point\r\n\t\t\tif(token.alternative){\r\n\t\t\t\ttoken.arg = token.arg.replace(/^(\\d+)$/,\"$1.\");\r\n\t\t\t\ttoken.arg = token.arg.replace(/^(\\d+)e/,\"$1.e\");\r\n\t\t\t}\r\n\r\n\t\t\tif(f >= 0 && token.sign){\r\n\t\t\t\ttoken.arg = token.sign + token.arg;\r\n\t\t\t}\r\n\r\n\t\t\ttoken.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();\r\n\t\t},\r\n\t\tzeroPad: function(token, /*Int*/ length) {\r\n\t\t\tlength = (arguments.length == 2) ? length : token.precision;\r\n\t\t\tif(typeof token.arg != \"string\"){\r\n\t\t\t\ttoken.arg = \"\" + token.arg;\r\n\t\t\t}\r\n\r\n\t\t\tvar tenless = length - 10;\r\n\t\t\twhile(token.arg.length < tenless){\r\n\t\t\t\ttoken.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;\r\n\t\t\t}\r\n\t\t\tvar pad = length - token.arg.length;\r\n\t\t\ttoken.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;\r\n\t\t},\r\n\t\tfitField: function(token) {\r\n\t\t\tif(token.maxWidth >= 0 && token.arg.length > token.maxWidth){\r\n\t\t\t\treturn token.arg.substring(0, token.maxWidth);\r\n\t\t\t}\r\n\t\t\tif(token.zeroPad){\r\n\t\t\t\tthis.zeroPad(token, token.minWidth);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis.spacePad(token);\r\n\t\t},\r\n\t\tspacePad: function(token, /*Int*/ length) {\r\n\t\t\tlength = (arguments.length == 2) ? length : token.minWidth;\r\n\t\t\tif(typeof token.arg != 'string'){\r\n\t\t\t\ttoken.arg = '' + token.arg;\r\n\t\t\t}\r\n\r\n\t\t\tvar tenless = length - 10;\r\n\t\t\twhile(token.arg.length < tenless){\r\n\t\t\t\ttoken.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;\r\n\t\t\t}\r\n\t\t\tvar pad = length - token.arg.length;\r\n\t\t\ttoken.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg;\r\n\t\t}\r\n\t});\r\n\treturn strLib.sprintf;\r\n});\r\n"]}