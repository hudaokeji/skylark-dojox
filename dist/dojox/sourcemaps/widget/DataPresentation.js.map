{"version":3,"sources":["widget/DataPresentation.js"],"names":["dojo","provide","experimental","require","getDependentAxisArgs","charttype","axistype","minval","maxval","args","vertical","fixLower","fixUpper","natural","leftBottom","min","max","getPlotArgs","animate","type","hAxis","vAxis","gap","lines","areas","markers","shadows","dx","dy","dw","getSubfield","object","field","result","fragments","split","frag","l","length","declare","chartType","reverse","labelMod","legendHorizontal","constructor","node","mixin","this","domNode","byId","theme","getObject","chartNode","legendNode","gridNode","titleNode","footerNode","legendVertical","url","setURL","refreshInterval","data","setData","setStore","urlContent","cancelRefresh","me","xhrGet","content","handleAs","load","response","ioArgs","error","xhr","urlError","refreshIntervalPending","setInterval","point","datapoint","datavalue","fdatavalue","_series","series","datasets","series_data","series_name","series_chart","series_charttype","series_linestyle","series_axis","series_grid","series_gridformatter","maxlen","ser","datapoints","name","namefield","chart","linestyle","axis","grid","gridformatter","index","parseFloat","isNaN","push","store","ItemFileWriteStore","identifier","items","title","footer","setPreparedStore","refresh","clearInterval","undefined","query","queryOptions","legend","horizontal","_legend","preparedstore","chartWidget","tooltip","_chart","innerHTML","dojox","charting","Chart2D","_clone","Theme","plotarea","marker","antiAlias","assignColors","assignMarkers","assigneMarkers","colors","delegate","_buildMarkerArray","setTheme","range","slice","labels","value","text","nlabels","cwid","offsetWidth","tmp","z","i","getLabels","plots","seriestoremove","sname","runs","nseries","axisname","addPlot","tooltipArgs","o","substitutions","element","run","x","y","replace","action2d","Tooltip","Highlight","xvals","valen","j","val","seriesargs","plot","stroke","style","addSeries","removeSeries","addAxis","majorTickStep","minorTickStep","getIndependentAxisArgs","setupChart","renderChartWidget","legendWidget","widget","Legend","gridWidget","_grid","DataGrid","startup","structure","width","formatter","setStructure","setupGrid","renderGridWidget","setupTitle","setupFooter","render","getChartWidget","getGridWidget","destroy"],"mappings":"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","file":"../../widget/DataPresentation.js","sourcesContent":["dojo.provide(\"dojox.widget.DataPresentation\");\r\ndojo.experimental(\"dojox.widget.DataPresentation\");\r\n\r\ndojo.require(\"dojox.grid.DataGrid\");\r\ndojo.require(\"dojox.charting.Chart2D\");\r\ndojo.require(\"dojox.charting.widget.Legend\");\r\ndojo.require(\"dojox.charting.action2d.Tooltip\");\r\ndojo.require(\"dojox.charting.action2d.Highlight\");\r\ndojo.require(\"dojo.colors\");\r\ndojo.require(\"dojo.data.ItemFileWriteStore\");\r\n\r\n(function(){\r\n\t\r\n\t// sort out the labels for the independent axis of the chart\r\n\tvar getLabels = function(range, labelMod, charttype, domNode){\r\n\t\t\r\n\t\t// prepare labels for the independent axis\r\n\t\tvar labels = [];\r\n\t\t// add empty label, hack\r\n\t\tlabels[0] = {value: 0, text: ''};\r\n\r\n\t\tvar nlabels = range.length;\r\n\r\n\t\t// auto-set labelMod for horizontal charts if the labels will otherwise collide\r\n\t\tif((charttype !== \"ClusteredBars\") && (charttype !== \"StackedBars\")){\r\n    \t\tvar cwid = domNode.offsetWidth;\r\n    \t\tvar tmp = (\"\" + range[0]).length * range.length * 7; // *assume* 7 pixels width per character ( was 9 )\r\n    \t  \r\n    \t\tif(labelMod == 1){\r\n    \t\t\tfor(var z = 1; z < 500; ++z){\r\n    \t\t\t\tif((tmp / z) < cwid){\r\n    \t\t\t\t\tbreak;\r\n    \t\t\t\t}\r\n    \t\t\t\t++labelMod;\r\n    \t\t\t}\r\n    \t\t}\r\n\t    }\r\n\r\n\t\t// now set the labels\r\n\t\tfor(var i = 0; i < nlabels; i++){\r\n\t\t\t//sparse labels\r\n\t\t\tlabels.push({\r\n\t\t\t\tvalue: i + 1,\r\n\t\t\t\ttext: (!labelMod || i % labelMod) ? \"\" : range[i]\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\t// add empty label again, hack\r\n\t\tlabels.push({value: nlabels + 1, text:''});\r\n\t\t\r\n\t\treturn labels;\r\n\t};\r\n\t\r\n\t// get the configuration of an independent axis for the chart\r\n\tvar getIndependentAxisArgs = function(charttype, labels){\r\n\r\n\t\tvar args = { vertical: false, labels: labels, min: 0, max: labels.length-1, majorTickStep: 1, minorTickStep: 1 };\r\n\t\t\r\n\t\t// clustered or stacked bars have a vertical independent axis\r\n\t\tif((charttype === \"ClusteredBars\") || (charttype === \"StackedBars\")){\r\n\t\t\targs.vertical = true;\r\n\t\t}\r\n\t\t\r\n\t\t// lines, areas and stacked areas don't need the extra slots at each end\r\n\t\tif((charttype === \"Lines\") || (charttype === \"Areas\") || (charttype === \"StackedAreas\")){\r\n\t\t\targs.min++;\r\n\t\t\targs.max--;\r\n\t\t}\r\n\r\n\t\treturn args;\r\n\t};\r\n\r\n\t// get the configuration of a dependent axis for the chart\r\n\tvar getDependentAxisArgs = function(charttype, axistype, minval, maxval){\r\n\t\t\r\n\t\tvar args = { vertical: true, fixLower: \"major\", fixUpper: \"major\", natural: true };\r\n\t\t\r\n\t\t// secondary dependent axis is not left-bottom\r\n\t\tif(axistype === \"secondary\"){\r\n\t\t\targs.leftBottom = false;\r\n\t\t}\r\n\r\n\t\t// clustered or stacked bars have horizontal dependent axes\r\n\t\tif((charttype === \"ClusteredBars\") || (charttype === \"StackedBars\")){\r\n\t\t\targs.vertical = false;\r\n\t\t}\r\n\t\t\r\n\t\t// ensure axis does not \"collapse\" for flat series\r\n\t\tif(minval == maxval){\r\n\t\t\targs.min = minval - 1;\r\n\t\t\targs.max = maxval + 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn args;\r\n\t};\r\n\t\r\n\t// get the configuration of a plot for the chart\r\n\tvar getPlotArgs = function(charttype, axistype, animate){\r\n\t\t\r\n\t\tvar args = { type: charttype, hAxis: \"independent\", vAxis: \"dependent-\" + axistype, gap: 4, lines: false, areas: false, markers: false };\r\n\t\t\r\n\t\t// clustered or stacked bars have horizontal dependent axes\r\n\t\tif((charttype === \"ClusteredBars\") || (charttype === \"StackedBars\")){\r\n\t\t\targs.hAxis = args.vAxis;\r\n\t\t\targs.vAxis = \"independent\";\r\n\t\t}\r\n\r\n\t\t// turn on lines for Lines, Areas and StackedAreas\r\n\t\tif((charttype === \"Lines\") || (charttype === \"Hybrid-Lines\") || (charttype === \"Areas\") || (charttype === \"StackedAreas\")){\r\n\t\t\targs.lines = true;\r\n\t\t}\r\n\t\t\r\n\t\t// turn on areas for Areas and StackedAreas\r\n\t\tif((charttype === \"Areas\") || (charttype === \"StackedAreas\")){\r\n\t\t\targs.areas = true;\r\n\t\t}\r\n\t\t\r\n\t\t// turn on markers and shadow for Lines\r\n\t\tif(charttype === \"Lines\"){\r\n\t\t\targs.markers = true;\r\n\t\t}\r\n\t\t\r\n\t\t// turn on shadow for Hybrid-Lines\r\n\t\t// also, Hybrid-Lines is not a true chart type: use Lines for the actual plot\r\n\t\tif(charttype === \"Hybrid-Lines\"){\r\n\t\t\targs.shadows = {dx: 2, dy: 2, dw: 2};\r\n\t\t\targs.type = \"Lines\";\r\n\t\t}\r\n\t\t\r\n\t\t// also, Hybrid-ClusteredColumns is not a true chart type: use ClusteredColumns for the actual plot\r\n\t\tif(charttype === \"Hybrid-ClusteredColumns\"){\r\n\t\t\targs.type = \"ClusteredColumns\";\r\n\t\t}\r\n\t\t\r\n\t\t// enable animation on the plot if animation is requested\r\n\t\tif(animate){\r\n\t\t\targs.animate = animate;\r\n\t\t}\r\n\t\t\r\n\t\treturn args;\r\n\t};\r\n\r\n\t// set up a chart presentation\r\n\tvar setupChart = function(/*DomNode*/domNode, /*Object?*/chart, /*String*/type, /*Boolean*/reverse, /*Object*/animate, /*Integer*/labelMod, /*String*/theme, /*String*/tooltip, /*Object?*/store, /*String?*/query, /*String?*/queryOptions){\r\n\t\tvar _chart = chart;\r\n\t\t\r\n\t\tif(!_chart){\r\n\t\t\tdomNode.innerHTML = \"\";  // any other content in the node disrupts the chart rendering\r\n\t\t\t_chart = new dojox.charting.Chart2D(domNode);\r\n\t\t}\r\n\t\t\r\n\t\t// set the theme\r\n\t\tif(theme){\r\n\r\n\t\t\t// workaround for a theme bug: its _clone method\r\n\t\t\t// does not transfer the markers, so we repair\r\n\t\t\t// that omission here\r\n\t\t\t// FIXME this should be removed once the theme bug is fixed\r\n\t        theme._clone = function(){\r\n\t\t\t      var result = new dojox.charting.Theme({\r\n\t\t\t        chart: this.chart,\r\n\t\t\t        plotarea: this.plotarea,\r\n\t\t\t        axis: this.axis,\r\n\t\t\t        series: this.series,\r\n\t\t\t        marker: this.marker,\r\n\t\t\t        antiAlias: this.antiAlias,\r\n\t\t\t        assignColors: this.assignColors,\r\n\t\t\t        assignMarkers: this.assigneMarkers,\r\n\t\t\t        colors: dojo.delegate(this.colors)\r\n\t\t\t      });\r\n\t\t\t      \r\n\t\t\t      result.markers = this.markers;\r\n\t\t\t      result._buildMarkerArray();\r\n\t\t\t      \r\n\t\t\t      return result;\r\n\t        };\r\n\t\t\t\r\n\t\t\t_chart.setTheme(theme);\r\n\t\t}\r\n\r\n\t\tvar range = store.series_data[0].slice(0);\r\n\t\t\r\n\t\t// reverse the labels if requested\r\n\t\tif(reverse){\r\n\t\t\trange.reverse();\r\n\t\t}\r\n\t\t\t\r\n\t\tvar labels = getLabels(range, labelMod, type, domNode);\r\n\r\n\t\t// collect details of whether primary and/or secondary axes are required\r\n\t\t// and what plots we have instantiated using each type of axis\r\n\t\tvar plots = {};\r\n\t\t\r\n\t\t// collect maximum and minimum data values\r\n\t\tvar maxval = null;\r\n\t\tvar minval = null;\r\n\t\t\r\n\t\tvar seriestoremove = {};\r\n\t\tfor(var sname in _chart.runs){\r\n\t\t\tseriestoremove[sname] = true;\r\n\t\t}\r\n\r\n\t\t// set x values & max data value\r\n\t\tvar nseries = store.series_name.length;\r\n\t\tfor(var i = 0; i < nseries; i++){\r\n\t\t\t// only include series with chart=true and with some data values in\r\n\t\t\tif(store.series_chart[i] && (store.series_data[i].length > 0)){\r\n\r\n\t\t\t\tvar charttype = type;\r\n\t\t\t\tvar axistype = store.series_axis[i];\r\n\r\n\t\t\t\tif(charttype == \"Hybrid\"){\r\n\t\t\t\t\tif(store.series_charttype[i] == 'line'){\r\n\t\t\t\t\t\tcharttype = \"Hybrid-Lines\";\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tcharttype = \"Hybrid-ClusteredColumns\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// ensure we have recorded that we are using this axis type\r\n\t\t\t\tif(!plots[axistype]){\r\n\t\t\t\t\tplots[axistype] = {};\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// ensure we have the correct type of plot for this series\r\n\t\t\t\tif(!plots[axistype][charttype]){\r\n\t\t\t\t\tvar axisname = axistype + \"-\" + charttype;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// create the plot and enable tooltips\r\n\t\t\t\t\t_chart.addPlot(axisname, getPlotArgs(charttype, axistype, animate));\r\n\r\n\t\t\t\t\tvar tooltipArgs = {};\r\n\t\t\t\t\tif(typeof tooltip == 'string'){\r\n\t\t\t\t\t\ttooltipArgs.text = function(o){\r\n\t\t\t\t\t\t\tvar substitutions = [o.element, o.run.name, range[o.index], ((charttype === \"ClusteredBars\") || (charttype === \"StackedBars\")) ? o.x : o.y];\r\n\t\t\t\t\t\t\treturn dojo.replace(tooltip, substitutions);  // from Dojo 1.4 onward\r\n\t\t\t\t\t\t\t//return tooltip.replace(/\\{([^\\}]+)\\}/g, function(_, token){ return dojo.getObject(token, false, substitutions); });  // prior to Dojo 1.4\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else if(typeof tooltip == 'function'){\r\n\t\t\t\t\t\ttooltipArgs.text = tooltip;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnew dojox.charting.action2d.Tooltip(_chart, axisname, tooltipArgs);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// add highlighting, except for lines\r\n\t\t\t\t\tif(charttype !== \"Lines\" && charttype !== \"Hybrid-Lines\"){\r\n\t\t\t\t\t\tnew dojox.charting.action2d.Highlight(_chart, axisname);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// record that this plot type is now created\r\n\t\t\t\t\tplots[axistype][charttype] = true;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// extract the series values\r\n\t\t\t\tvar xvals = [];\r\n\t\t\t\tvar valen = store.series_data[i].length;\r\n\t\t\t\tfor(var j = 0; j < valen; j++){\r\n\t\t\t\t\tvar val = store.series_data[i][j];\r\n\t\t\t\t\txvals.push(val);\r\n\t\t\t\t\tif(maxval === null || val > maxval){\r\n\t\t\t\t\t\tmaxval = val;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(minval === null || val < minval){\r\n\t\t\t\t\t\tminval = val;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t// reverse the values if requested\r\n\t\t\t\tif(reverse){\r\n\t\t\t\t\txvals.reverse();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar seriesargs = { plot: axistype + \"-\" + charttype };\r\n\t\t\t\tif(store.series_linestyle[i]){\r\n\t\t\t\t\tseriesargs.stroke = { style: store.series_linestyle[i] };\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_chart.addSeries(store.series_name[i], xvals, seriesargs);\r\n\t\t\t\tdelete seriestoremove[store.series_name[i]];\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// remove any series that are no longer needed\r\n\t\tfor(sname in seriestoremove){\r\n\t\t\t_chart.removeSeries(sname);\r\n\t\t}\r\n\r\n\t\t// create axes\r\n\t\t_chart.addAxis(\"independent\", getIndependentAxisArgs(type, labels));\r\n\t\t_chart.addAxis(\"dependent-primary\", getDependentAxisArgs(type, \"primary\", minval, maxval));\r\n\t\t_chart.addAxis(\"dependent-secondary\", getDependentAxisArgs(type, \"secondary\", minval, maxval));\r\n\t\t\r\n\t\treturn _chart;\r\n\t};\r\n\r\n\t// set up a legend presentation\r\n\tvar setupLegend = function(/*DomNode*/domNode, /*Legend*/legend, /*Chart2D*/chart, /*Boolean*/horizontal){\r\n\t\t// destroy any existing legend and recreate\r\n\t\tvar _legend = legend;\r\n\t\t\r\n\t\tif(!_legend){\r\n\t\t\t_legend = new dojox.charting.widget.Legend({ chart: chart, horizontal: horizontal }, domNode);\r\n\t\t}else{\r\n\t\t\t_legend.refresh();\r\n\t\t}\r\n\t\t\r\n\t\treturn _legend;\r\n\t};\r\n\t\r\n\t// set up a grid presentation\r\n\tvar setupGrid = function(/*DomNode*/domNode, /*Object?*/grid, /*Object?*/store, /*String?*/query, /*String?*/queryOptions){\r\n\t\tvar _grid = grid || new dojox.grid.DataGrid({}, domNode);\r\n\t\t_grid.startup();\r\n\t\t_grid.setStore(store, query, queryOptions);\r\n\t\t\r\n\t\tvar structure = [];\r\n\t\tfor(var ser = 0; ser < store.series_name.length; ser++){\r\n\t\t\t// only include series with grid=true and with some data values in\r\n\t\t\tif(store.series_grid[ser] && (store.series_data[ser].length > 0)){\r\n\t\t\t\tstructure.push({ field: \"data.\" + ser, name: store.series_name[ser], width: \"auto\", formatter: store.series_gridformatter[ser] });\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_grid.setStructure(structure);\r\n\t\t\r\n\t\treturn _grid;\r\n\t};\r\n\t\r\n\t// set up a title presentation\r\n\tvar setupTitle = function(/*DomNode*/domNode, /*object*/store){\r\n\t\tif(store.title){\r\n\t\t\tdomNode.innerHTML = store.title;\r\n\t\t}\r\n\t};\r\n\t\r\n\t// set up a footer presentation\r\n\tvar setupFooter = function(/*DomNode*/domNode, /*object*/store){\r\n\t\tif(store.footer){\r\n\t\t\tdomNode.innerHTML = store.footer;\r\n\t\t}\r\n\t};\r\n\t\r\n\t// obtain a subfield from a field specifier which may contain\r\n\t// multiple levels (eg, \"child.foo[36].manacle\")\r\n\tvar getSubfield = function(/*Object*/object, /*String*/field){\r\n\t\tvar result = object;\r\n\t\t\r\n\t\tif(field){\r\n\t\t\tvar fragments = field.split(/[.\\[\\]]+/);\r\n\t\t\tfor(var frag = 0, l = fragments.length; frag < l; frag++){\r\n\t\t\t\tif(result){\r\n\t\t\t\t\tresult = result[fragments[frag]];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\t};\r\n\t\r\n\tdojo.declare(\"dojox.widget.DataPresentation\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tA widget that connects to a data store in a simple manner,\r\n\t\t//\t\tand also provides some additional convenience mechanisms\r\n\t\t//\t\tfor connecting to common data sources without needing to\r\n\t\t//\t\texplicitly construct a Dojo data store. The widget can then\r\n\t\t//\t\tpresent the data in several forms: as a graphical chart,\r\n\t\t//\t\tas a tabular grid, or as display panels presenting meta-data\r\n\t\t//\t\t(title, creation information, etc) from the data. The\r\n\t\t//\t\twidget can also create and manage several of these forms\r\n\t\t//\t\tin one simple construction.\r\n\t\t//\r\n\t\t//\t\tNote: this is a first experimental draft and any/all details\r\n\t\t//\t\tare subject to substantial change in later drafts.\r\n\t\t// example:\r\n\t\t// |\tvar pres = new dojox.data.DataPresentation(\"myChartNode\", {\r\n\t\t// |\t\ttype: \"chart\",\r\n\t\t// |\t\turl: \"/data/mydata\",\r\n\t\t// |\t\tgridNode: \"myGridNode\"\r\n\t\t// |\t});\r\n\r\n\t\t// store: Object\r\n\t\t//\t\tDojo data store used to supply data to be presented. This may\r\n\t\t//\t\tbe supplied on construction or created implicitly based on\r\n\t\t//\t\tother construction parameters ('data', 'url').\r\n\r\n\t\t// query: String\r\n\t\t//\t\tQuery to apply to the Dojo data store used to supply data to\r\n\t\t//\t\tbe presented.\r\n\r\n\t\t// queryOptions: String\r\n\t\t//\t\tQuery options to apply to the Dojo data store used to supply\r\n\t\t//\t\tdata to be presented.\r\n\r\n\t\t// data: Object\r\n\t\t//\t\tData to be presented. If supplied on construction this property\r\n\t\t//\t\twill override any value supplied for the 'store' property.\r\n\r\n\t\t// url: String\r\n\t\t//\t\tURL to fetch data from in JSON format. If supplied on\r\n\t\t//\t\tconstruction this property will override any values supplied\r\n\t\t//\t\tfor the 'store' and/or 'data' properties. Note that the data\r\n\t\t//\t\tcan also be comment-filtered JSON, although this will trigger\r\n\t\t//\t\ta warning message in the console unless djConfig.useCommentedJson\r\n\t\t//\t\thas been set to true.\r\n\r\n\t\t// urlContent: Object\r\n\t\t//\t\tContent to be passed to the URL when fetching data. If a URL has\r\n\t\t//\t\tnot been supplied, this value is ignored.\r\n\r\n\t\t// urlError: function\r\n\t\t//\t\tA function to be called if an error is encountered when fetching\r\n\t\t//\t\tdata from the supplied URL. This function will be supplied with\r\n\t\t//\t\ttwo parameters exactly as the error function supplied to the\r\n\t\t//\t\tdojo.xhrGet function. This function may be called multiple times\r\n\t\t//\t\tif a refresh interval has been supplied.\r\n\r\n\t\t// refreshInterval: Number\r\n\t\t//\t\tthe time interval in milliseconds after which the data supplied\r\n\t\t//\t\tvia the 'data' property or fetched from a URL via the 'url'\r\n\t\t//\t\tproperty should be regularly refreshed. This property is\r\n\t\t//\t\tignored if neither the 'data' nor 'url' property has been\r\n\t\t//\t\tsupplied. If the refresh interval is zero, no regular refresh is done.\r\n\r\n\t\t// refreshIntervalPending:\r\n\t\t//\t\tthe JavaScript set interval currently in progress, if any\r\n\r\n\t\t// series: Array\r\n\t\t//\t\tan array of objects describing the data series to be included\r\n\t\t//\t\tin the data presentation. Each object may contain the\r\n\t\t//\t\tfollowing fields:\r\n\t\t//\r\n\t\t//\t\t- datapoints: the name of the field from the source data which\r\n\t\t//\t\t\tcontains an array of the data points for this data series.\r\n\t\t//\t\t\tIf not supplied, the source data is assumed to be an array\r\n\t\t//\t\t\tof data points to be used.\r\n\t\t//\t\t- field: the name of the field within each data point which\r\n\t\t//\t\t\tcontains the data for this data series. If not supplied,\r\n\t\t//\t\t\teach data point is assumed to be the value for the series.\r\n\t\t//\t\t- name: a name for the series, used in the legend and grid headings\r\n\t\t//\t\t- namefield:\r\n\t\t//\t\t\tthe name of the field from the source data which\r\n\t\t//\t\t\tcontains the name the series, used in the legend and grid\r\n\t\t//\t\t\theadings. If both name and namefield are supplied, name takes\r\n\t\t//\t\t    precedence. If neither are supplied, a default name is used.\r\n\t\t//\t\t- chart: true if the series should be included in a chart presentation (default: true)\r\n\t\t//\t\t- charttype: the type of presentation of the series in the chart, which can be\r\n\t\t//\t\t\t\"range\", \"line\", \"bar\" (default: \"bar\")\r\n\t\t//\t\t- linestyle: the stroke style for lines (if applicable) (default: \"Solid\")\r\n\t\t//\t\t- axis: the dependant axis to which the series will be attached in the chart,\r\n\t\t//\t\t    which can be \"primary\" or \"secondary\"\r\n\t\t//\t\t- grid: true if the series should be included in a data grid presentation (default: true)\r\n\t\t//\t\t- gridformatter: an optional formatter to use for this series in the data grid\r\n\t\t//\r\n\t\t//\t\ta call-back function may alternatively be supplied. The function takes\r\n\t\t//\t\ta single parameter, which will be the data (from the 'data' field or\r\n\t\t//\t\tloaded from the value in the 'url' field), and should return the array\r\n\t\t//\t\tof objects describing the data series to be included in the data\r\n\t\t//\t\tpresentation. This enables the series structures to be built dynamically\r\n\t\t//\t\tafter data load, and rebuilt if necessary on data refresh. The call-back\r\n\t\t//\t\tfunction will be called each time new data is set, loaded or refreshed.\r\n\t\t//\t\tA call-back function cannot be used if the data is supplied directly\r\n\t\t//\t\tfrom a Dojo data store.\r\n\r\n\t\t// type: String\r\n\t\t//\t\tthe type of presentation to be applied at the DOM attach point.\r\n\t\t//\t\tThis can be 'chart', 'legend', 'grid', 'title', 'footer'. The\r\n\t\t//\t\tdefault type is 'chart'.\r\n\t\ttype: \"chart\",\r\n\r\n\t\t// chartType: String\r\n\t\t//\t\tthe type of chart to display. This can be 'clusteredbars',\r\n\t\t//\t\t'areas', 'stackedcolumns', 'stackedbars', 'stackedareas',\r\n\t\t//\t\t'lines', 'hybrid'. The default type is 'bar'.\r\n\t\tchartType: \"clusteredBars\",\r\n\r\n\t\t// reverse: Boolean\r\n\t\t//\t\ttrue if the chart independent axis should be reversed.\r\n\t\treverse: false,\r\n\r\n\t\t// animate: Object\r\n\t\t//\t\tif an object is supplied, then the chart bars or columns will animate\r\n\t\t//\t\tinto place. If the object contains a field 'duration' then the value\r\n\t\t//\t\tsupplied is the duration of the animation in milliseconds, otherwise\r\n\t\t//\t\ta default duration is used. A boolean value true can alternatively be\r\n\t\t//\t\tsupplied to enable animation with the default duration.\r\n\t\t//\t\tThe default is null (no animation).\r\n\t\tanimate: null,\r\n\r\n\t\t// labelMod: Integer\r\n\t\t//\t\tthe frequency of label annotations to be included on the\r\n\t\t//\t\tindependent axis. 1=every label. 0=no labels. The default is 1.\r\n\t\tlabelMod: 1,\r\n\r\n\t\t// tooltip: String|Function\r\n\t\t//\t\ta string pattern defining the tooltip text to be applied to chart\r\n\t\t//\t\tdata points, or a function which takes a single parameter and returns\r\n\t\t//\t\tthe tooltip text to be applied to chart data points. The string pattern\r\n\t\t//\t\twill have the following substitutions applied:\r\n\t\t//\r\n\t\t//\t\t- {0} - the type of chart element ('bar', 'surface', etc)\r\n\t\t//\t\t- {1} - the name of the data series\r\n\t\t//\t\t- {2} - the independent axis value at the tooltip data point\r\n\t\t//\t\t- {3} - the series value at the tooltip data point point\r\n\t\t//\r\n\t\t//\t\tThe function, if supplied, will receive a single parameter exactly\r\n\t\t//\t\tas per the dojox.charting.action2D.Tooltip class. The default value\r\n\t\t//\t\tis to apply the default tooltip as defined by the\r\n\t\t//\t\tdojox.charting.action2D.Tooltip class.\r\n\r\n\t\t// legendHorizontal: Boolean|Number\r\n\t\t//\t\ttrue if the legend should be rendered horizontally, or a number if\r\n\t\t//\t\tthe legend should be rendered as horizontal rows with that number of\r\n\t\t//\t\titems in each row, or false if the legend should be rendered\r\n\t\t//\t\tvertically (same as specifying 1). The default is true (legend\r\n\t\t//\t\trendered horizontally).\r\n\t\tlegendHorizontal: true,\r\n\r\n\t\t// theme: String|Theme\r\n\t\t//\t\ta theme to use for the chart, or the name of a theme.\r\n\r\n\t\t// chartNode: String|DomNode\r\n\t\t//\t\tan optional DOM node or the id of a DOM node to receive a\r\n\t\t//\t\tchart presentation of the data. Supply only when a chart is\r\n\t\t//\t\trequired and the type is not 'chart'; when the type is\r\n\t\t//\t\t'chart' this property will be set to the widget attach point.\r\n\r\n\t\t// legendNode: String|DomNode\r\n\t\t//\t\tan optional DOM node or the id of a DOM node to receive a\r\n\t\t//\t\tchart legend for the data. Supply only when a legend is\r\n\t\t//\t\trequired and the type is not 'legend'; when the type is\r\n\t\t//\t\t'legend' this property will be set to the widget attach point.\r\n\r\n\t\t// gridNode: String|DomNode\r\n\t\t//\t\tan optional DOM node or the id of a DOM node to receive a\r\n\t\t//\t\tgrid presentation of the data. Supply only when a grid is\r\n\t\t//\t\trequired and the type is not 'grid'; when the type is\r\n\t\t//\t\t'grid' this property will be set to the widget attach point.\r\n\r\n\t\t// titleNode: String|DomNode\r\n\t\t//\t\tan optional DOM node or the id of a DOM node to receive a\r\n\t\t//\t\ttitle for the data. Supply only when a title is\r\n\t\t//\t\trequired and the type is not 'title'; when the type is\r\n\t\t//\t\t'title' this property will be set to the widget attach point.\r\n\r\n\t\t// footerNode: String|DomNode\r\n\t\t//\t\tan optional DOM node or the id of a DOM node to receive a\r\n\t\t//\t\tfooter presentation of the data. Supply only when a footer is\r\n\t\t//\t\trequired and the type is not 'footer'; when the type is\r\n\t\t//\t\t'footer' this property will be set to the widget attach point.\r\n\r\n\t\t// chartWidget: Object\r\n\t\t//\t\tthe chart widget, if any\r\n\r\n\t\t// legendWidget: Object\r\n\t\t//\t\tthe legend widget, if any\r\n\r\n\t\t// gridWidget: Object\r\n\t\t//\t\tthe grid widget, if any\r\n\t\t\r\n\t\tconstructor: function(node, args){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSet up properties and initialize.\r\n\t\t\t// node: DomNode\r\n\t\t\t//\t\tThe node to attach the data presentation to.\r\n\t\t\t// args: Object\r\n\t\t\t//\t\t(see above)\r\n\t\t\t\r\n\t\t\t// apply arguments directly\r\n\t\t\tdojo.mixin(this, args);\r\n\r\n\t\t\t// store our DOM attach point\r\n\t\t\tthis.domNode = dojo.byId(node);\r\n\t\t\t\r\n\t\t\t// also apply the DOM attach point as the node for the presentation type\r\n\t\t\tthis[this.type + \"Node\"] = this.domNode;\r\n\t\t\t\r\n\t\t\t// load the theme if provided by name\r\n\t\t\tif(typeof this.theme == 'string'){\r\n\t\t\t\tthis.theme = dojo.getObject(this.theme);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// resolve any the nodes that were supplied as ids\r\n\t\t\tthis.chartNode = dojo.byId(this.chartNode);\r\n\t\t\tthis.legendNode = dojo.byId(this.legendNode);\r\n\t\t\tthis.gridNode = dojo.byId(this.gridNode);\r\n\t\t\tthis.titleNode = dojo.byId(this.titleNode);\r\n\t\t\tthis.footerNode = dojo.byId(this.footerNode);\r\n\t\t\t\r\n\t\t\t// we used to support a 'legendVertical' so for now\r\n\t\t\t// at least maintain backward compatibility\r\n\t\t\tif(this.legendVertical){\r\n\t\t\t\tthis.legendHorizontal = !this.legendVertical;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(this.url){\r\n\t\t\t\tthis.setURL(null, null, this.refreshInterval);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif(this.data){\r\n\t\t\t\t\tthis.setData(null, this.refreshInterval);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tthis.setStore();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tsetURL: function(/*String?*/url, /*Object?*/ urlContent, /*Number?*/refreshInterval){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSets the URL to fetch data from, with optional content\r\n\t\t\t//\t\tsupplied with the request, and an optional\r\n\t\t\t//\t\trefresh interval in milliseconds (0=no refresh)\r\n\r\n\t\t\t// if a refresh interval is supplied we will start a fresh\r\n\t\t\t// refresh after storing the supplied url\r\n\t\t\tif(refreshInterval){\r\n\t\t\t\tthis.cancelRefresh();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.url = url || this.url;\r\n\t\t\tthis.urlContent = urlContent || this.urlContent;\r\n\t\t\tthis.refreshInterval = refreshInterval || this.refreshInterval;\r\n\t\t\t\r\n\t\t\tvar me = this;\r\n\t\t\t\r\n\t\t\tdojo.xhrGet({\r\n\t\t\t\turl: this.url,\r\n\t\t\t\tcontent: this.urlContent,\r\n\t\t\t\thandleAs: 'json-comment-optional',\r\n\t\t\t\tload: function(response, ioArgs){\r\n\t\t\t\t\tme.setData(response);\r\n\t\t\t\t},\r\n\t\t\t\terror: function(xhr, ioArgs){\r\n\t\t\t\t\tif(me.urlError && (typeof me.urlError == \"function\")){\r\n\t\t\t\t\t\tme.urlError(xhr, ioArgs);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\tif(refreshInterval && (this.refreshInterval > 0)){\r\n\t\t\t\tthis.refreshIntervalPending = setInterval(function(){\r\n\t\t\t\t\tme.setURL();\r\n\t\t\t\t}, this.refreshInterval);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tsetData: function(/*Object?*/data, /*Number?*/refreshInterval){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSets the data to be presented, and an optional\r\n\t\t\t//\t\trefresh interval in milliseconds (0=no refresh)\r\n\t\t\t\r\n\t\t\t// if a refresh interval is supplied we will start a fresh\r\n\t\t\t// refresh after storing the supplied data reference\r\n\t\t\tif(refreshInterval){\r\n\t\t\t\tthis.cancelRefresh();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.data = data || this.data;\r\n\t\t\tthis.refreshInterval = refreshInterval || this.refreshInterval;\r\n\t\t\t\r\n\t\t\t// TODO if no 'series' property was provided, build one intelligently here\r\n\t\t\t// (until that is done, a 'series' property must be supplied)\r\n\t\t\t\r\n\t\t\tvar _series = (typeof this.series == 'function') ? this.series(this.data) : this.series;\r\n\r\n\t\t\tvar datasets = [],\r\n\t\t\t\tseries_data = [],\r\n\t\t\t\tseries_name = [],\r\n\t\t\t\tseries_chart = [],\r\n\t\t\t\tseries_charttype = [],\r\n\t\t\t\tseries_linestyle = [],\r\n\t\t\t\tseries_axis = [],\r\n\t\t\t\tseries_grid = [],\r\n\t\t\t\tseries_gridformatter = [],\r\n\t\t\t\tmaxlen = 0;\r\n\t\t\t\r\n\t\t\t// identify the dataset arrays in which series values can be found\r\n\t\t\tfor(var ser = 0; ser < _series.length; ser++){\r\n\t\t\t\tdatasets[ser] = getSubfield(this.data, _series[ser].datapoints);\r\n\t\t\t\tif(datasets[ser] && (datasets[ser].length > maxlen)){\r\n\t\t\t\t\tmaxlen = datasets[ser].length;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tseries_data[ser] = [];\r\n\t\t\t\t// name can be specified in series structure, or by field in series structure, otherwise use a default\r\n\t\t\t\tseries_name[ser] = _series[ser].name || (_series[ser].namefield ? getSubfield(this.data, _series[ser].namefield) : null) || (\"series \" + ser);\r\n\t\t\t\tseries_chart[ser] = (_series[ser].chart !== false);\r\n\t\t\t\tseries_charttype[ser] = _series[ser].charttype || \"bar\";\r\n\t\t\t\tseries_linestyle[ser] = _series[ser].linestyle;\r\n\t\t\t\tseries_axis[ser] = _series[ser].axis || \"primary\";\r\n\t\t\t\tseries_grid[ser] = (_series[ser].grid !== false);\r\n\t\t\t\tseries_gridformatter[ser] = _series[ser].gridformatter;\r\n\t\t\t}\r\n\t\t\r\n\t\t\t// create an array of data points by sampling the series\r\n\t\t\t// and an array of series arrays by collecting the series\r\n\t\t\t// each data point has an 'index' item containing a sequence number\r\n\t\t\t// and items named \"data.0\", \"data.1\", ... containing the series samples\r\n\t\t\t// and the first data point also has items named \"name.0\", \"name.1\", ... containing the series names\r\n\t\t\t// and items named \"series.0\", \"series.1\", ... containing arrays with the complete series in\r\n\t\t\tvar point, datapoint, datavalue, fdatavalue;\r\n\t\t\tvar datapoints = [];\r\n\t\t\t\r\n\t\t\tfor(point = 0; point < maxlen; point++){\r\n\t\t\t\tdatapoint = { index: point };\r\n\t\t\t\tfor(ser = 0; ser < _series.length; ser++){\r\n\t\t\t\t\tif(datasets[ser] && (datasets[ser].length > point)){\r\n\t\t\t\t\t\tdatavalue = getSubfield(datasets[ser][point], _series[ser].field);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(series_chart[ser]){\r\n\t\t\t\t\t\t\t// convert the data value to a float if possible\r\n\t\t\t\t\t\t\tfdatavalue = parseFloat(datavalue);\r\n\t\t\t\t\t\t\tif(!isNaN(fdatavalue)){\r\n\t\t\t\t\t\t\t\tdatavalue = fdatavalue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdatapoint[\"data.\" + ser] = datavalue;\r\n\t\t\t\t\t\tseries_data[ser].push(datavalue);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tdatapoints.push(datapoint);\r\n\t\t\t}\r\n\r\n\t\t\tif(maxlen <= 0){\r\n\t\t\t\tdatapoints.push({index: 0});\r\n\t\t\t}\r\n\t\t\r\n\t\t\t// now build a prepared store from the data points we've constructed\r\n\t\t\tvar store = new dojo.data.ItemFileWriteStore({ data: { identifier: 'index', items: datapoints }});\r\n\t\t\tif(this.data.title){\r\n\t\t\t\tstore.title = this.data.title;\r\n\t\t\t}\r\n\t\t\tif(this.data.footer){\r\n\t\t\t\tstore.footer = this.data.footer;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tstore.series_data = series_data;\r\n\t\t\tstore.series_name = series_name;\r\n\t\t\tstore.series_chart = series_chart;\r\n\t\t\tstore.series_charttype = series_charttype;\r\n\t\t\tstore.series_linestyle = series_linestyle;\r\n\t\t\tstore.series_axis = series_axis;\r\n\t\t\tstore.series_grid = series_grid;\r\n\t\t\tstore.series_gridformatter = series_gridformatter;\r\n\t\t\t\r\n\t\t\tthis.setPreparedStore(store);\r\n\t\t\t\r\n\t\t\tif(refreshInterval && (this.refreshInterval > 0)){\r\n\t\t\t\tvar me = this;\r\n\t\t\t\tthis.refreshIntervalPending = setInterval(function(){\r\n\t\t\t\t\tme.setData();\r\n\t\t\t\t}, this.refreshInterval);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\trefresh: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tIf a URL or data has been supplied, refreshes the\r\n\t\t\t//\t\tpresented data from the URL or data. If a refresh\r\n\t\t\t//\t\tinterval is also set, the periodic refresh is\r\n\t\t\t//\t\trestarted. If a URL or data was not supplied, this\r\n\t\t\t//\t\tmethod has no effect.\r\n\t\t\tif(this.url){\r\n\t\t\t\tthis.setURL(this.url, this.urlContent, this.refreshInterval);\r\n\t\t\t}else if(this.data){\r\n\t\t\t\tthis.setData(this.data, this.refreshInterval);\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tcancelRefresh: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCancels any and all outstanding data refreshes\r\n\t\t\tif(this.refreshIntervalPending){\r\n\t\t\t\t// cancel existing refresh\r\n\t\t\t\tclearInterval(this.refreshIntervalPending);\r\n\t\t\t\tthis.refreshIntervalPending = undefined;\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tsetStore: function(/*Object?*/store, /*String?*/query, /*Object?*/queryOptions){\r\n\t\t\t// FIXME build a prepared store properly -- this requires too tight a convention to be followed to be useful\r\n\t\t\tthis.setPreparedStore(store, query, queryOptions);\r\n\t\t},\r\n\t\t\r\n\t\tsetPreparedStore: function(/*Object?*/store, /*String?*/query, /*Object?*/queryOptions){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSets the store and query.\r\n\r\n\t\t\tthis.preparedstore = store || this.store;\r\n\t\t\tthis.query = query || this.query;\r\n\t\t\tthis.queryOptions = queryOptions || this.queryOptions;\r\n\t\t\t\r\n\t\t\tif(this.preparedstore){\r\n\t\t\t\tif(this.chartNode){\r\n\t\t\t\t\tthis.chartWidget = setupChart(this.chartNode, this.chartWidget, this.chartType, this.reverse, this.animate, this.labelMod, this.theme, this.tooltip, this.preparedstore, this.query, this.queryOptions);\r\n\t\t\t\t\tthis.renderChartWidget();\r\n\t\t\t\t}\r\n\t\t\t\tif(this.legendNode){\r\n\t\t\t\t\tthis.legendWidget = setupLegend(this.legendNode, this.legendWidget, this.chartWidget, this.legendHorizontal);\r\n\t\t\t\t}\r\n\t\t\t\tif(this.gridNode){\r\n\t\t\t\t\tthis.gridWidget = setupGrid(this.gridNode, this.gridWidget, this.preparedstore, this.query, this.queryOptions);\r\n\t\t\t\t\tthis.renderGridWidget();\r\n\t\t\t\t}\r\n\t\t\t\tif(this.titleNode){\r\n\t\t\t\t\tsetupTitle(this.titleNode, this.preparedstore);\r\n\t\t\t\t}\r\n\t\t\t\tif(this.footerNode){\r\n\t\t\t\t\tsetupFooter(this.footerNode, this.preparedstore);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\trenderChartWidget: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRenders the chart widget (if any). This method is\r\n\t\t\t//\t\tcalled whenever a chart widget is created or\r\n\t\t\t//\t\tconfigured, and may be connected to.\r\n\t\t\tif(this.chartWidget){\r\n\t\t\t\tthis.chartWidget.render();\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\trenderGridWidget: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRenders the grid widget (if any). This method is\r\n\t\t\t//\t\tcalled whenever a grid widget is created or\r\n\t\t\t//\t\tconfigured, and may be connected to.\r\n\t\t\tif(this.gridWidget){\r\n\t\t\t\tthis.gridWidget.render();\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\tgetChartWidget: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the chart widget (if any) created if the type\r\n\t\t\t//\t\tis \"chart\" or the \"chartNode\" property was supplied.\r\n\t\t\treturn this.chartWidget;\r\n\t\t},\r\n\t\t\r\n\t\tgetGridWidget: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns the grid widget (if any) created if the type\r\n\t\t\t//\t\tis \"grid\" or the \"gridNode\" property was supplied.\r\n\t\t\treturn this.gridWidget;\r\n\t\t},\r\n\t\t\r\n\t\tdestroy: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDestroys the widget and all components and resources.\r\n\r\n\t\t\t// cancel any outstanding refresh requests\r\n\t\t\tthis.cancelRefresh();\r\n\t\t\t\r\n\t\t\tif(this.chartWidget){\r\n\t\t\t\tthis.chartWidget.destroy();\r\n\t\t\t\tdelete this.chartWidget;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(this.legendWidget){\r\n\t\t\t\t// no legend.destroy()\r\n\t\t\t\tdelete this.legendWidget;\r\n\t\t\t}\r\n\r\n\t\t\tif(this.gridWidget){\r\n\t\t\t\t// no grid.destroy()\r\n\t\t\t\tdelete this.gridWidget;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(this.chartNode){\r\n\t\t\t\tthis.chartNode.innerHTML = \"\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(this.legendNode){\r\n\t\t\t\tthis.legendNode.innerHTML = \"\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(this.gridNode){\r\n\t\t\t\tthis.gridNode.innerHTML = \"\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(this.titleNode){\r\n\t\t\t\tthis.titleNode.innerHTML = \"\";\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(this.footerNode){\r\n\t\t\t\tthis.footerNode.innerHTML = \"\";\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t});\r\n\t\t\r\n})();\r\n"]}