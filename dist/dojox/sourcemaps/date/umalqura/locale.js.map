{"version":3,"sources":["date/umalqura/locale.js"],"names":["define","dojox","lang","arr","dd","i18n","regexp","string","IDate","bundle","ilocale","getObject","formatPattern","dateObject","locale","fullYear","pattern","replace","match","s","pad","c","charAt","l","length","widthList","String","getFullYear","m","getMonth","propM","join","getDate","d","getDay","propD","timePeriod","getHours","h","getMinutes","getSeconds","Math","round","getMilliseconds","pow","getTimezoneName","toGregorian","offset","getTimezoneOffset","tz","floor","abs","splice","Error","_processPattern","applyPattern","applyLiteral","applyAll","identity","x","chunks","literal","forEach","chunk","i","_buildDateTimeRE","tokens","options","escapeString","normalizeLocale","p2","strict","am","pm","toLowerCase","push","format","formatLength","_getIslamicBundle","str","sauce","hitch","this","selector","datePattern","timePattern","_parseInfo","parse","value","info","RegExp","exec","result","amPm","hours","every","v","token","Number","months","concat","map","indexOf","period","_customFormats","addCustomFormats","packageName","bundleName","pkg","name","islamic","desc","getLocalization","mixin","getNames","item","type","context","date","label","lookup","props","undefined","weekDays"],"mappings":";;;;;;;AAAAA,QAAQ,QAAS,kBAAmB,mBAAoB,YAAa,YAAa,cAAe,cAAe,SAAU,mCACnH,SAAUC,EAAOC,EAAMC,EAAKC,EAAIC,EAAMC,EAAQC,EAAQC,EAAOC,GAEzD,IAAIC,EAAUR,EAAKS,UAAU,wBAAwB,EAAMV,GAG3D,SAASW,EAAcC,EAAYJ,EAAQK,EAAQC,EAAUC,GAEzD,OAAOA,EAAQC,QAAQ,eAAgB,SAAUC,GAC7C,IAAIC,EAAGC,EACHC,EAAIH,EAAMI,OAAO,GACjBC,EAAIL,EAAMM,OACVC,GAAa,OAAQ,OAAQ,UAEjC,OAAQJ,GACJ,IAAK,IACDF,EAAIV,EAAgB,QAAE,GACtB,MACJ,IAAK,IACDU,EAAIO,OAAOb,EAAWc,eACtB,MACJ,IAAK,IACD,IAAIC,EAAIf,EAAWgB,WACnB,GAAIN,EAAI,EACJJ,EAAIS,EAAI,EAAGR,GAAM,MACd,CACH,IAAIU,GAAS,SAAU,SAAUL,EAAUF,EAAI,IAAIQ,KAAK,KACxDZ,EAAIV,EAAOqB,GAAOF,GAEtB,MACJ,IAAK,IACDT,EAAIN,EAAWmB,SAAQ,GAAOZ,GAAM,EACpC,MACJ,IAAK,IACD,IAAIa,EAAIpB,EAAWqB,SACnB,GAAIX,EAAI,EACJJ,EAAIc,EAAI,EAAGb,GAAM,MACd,CACH,IAAIe,GAAS,OAAQ,SAAUV,EAAUF,EAAI,IAAIQ,KAAK,KACtDZ,EAAIV,EAAO0B,GAAOF,GAEtB,MACJ,IAAK,IACD,IAAIG,EAAcvB,EAAWwB,WAAa,GAAM,KAAO,KACvDlB,EAAIV,EAAO,0BAA4B2B,GACvC,MACJ,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACD,IAAIE,EAAIzB,EAAWwB,WACnB,OAAQhB,GACJ,IAAK,IACDF,EAAKmB,EAAI,IAAO,GAChB,MACJ,IAAK,IACDnB,EAAImB,EACJ,MACJ,IAAK,IACDnB,EAAKmB,EAAI,GACT,MACJ,IAAK,IACDnB,EAAImB,GAAK,GAGjBlB,GAAM,EACN,MACJ,IAAK,IACDD,EAAIN,EAAW0B,aAAcnB,GAAM,EACnC,MACJ,IAAK,IACDD,EAAIN,EAAW2B,aAAcpB,GAAM,EACnC,MACJ,IAAK,IACDD,EAAIsB,KAAKC,MAAM7B,EAAW8B,kBAAoBF,KAAKG,IAAI,GAAIrB,EAAI,IAAKH,GAAM,EAC1E,MACJ,IAAK,IAGD,GADAD,EAAIf,EAAGyC,gBAAgBhC,EAAWiC,eACzB,MACTvB,EAAI,EAER,IAAK,IACD,IAAIwB,EAASlC,EAAWiC,cAAcE,oBAClCC,GACCF,GAAU,EAAI,IAAM,IACrBxC,EAAOa,IAAIqB,KAAKS,MAAMT,KAAKU,IAAIJ,GAAU,IAAK,GAC9CxC,EAAOa,IAAIqB,KAAKU,IAAIJ,GAAU,GAAI,IAE7B,GAALxB,IACA0B,EAAGG,OAAO,EAAG,EAAG,OAChBH,EAAGG,OAAO,EAAG,EAAG,MAEpBjC,EAAI8B,EAAGlB,KAAK,IACZ,MACJ,QACI,MAAM,IAAIsB,MAAM,mEAAqErC,GAG7F,OADII,IAAOD,EAAIZ,EAAOa,IAAID,EAAGI,IACtBJ,IA+Kf,SAASmC,EAAgBtC,EAASuC,EAAcC,EAAcC,GAK1D,IAAIC,EAAW,SAAUC,GAAK,OAAOA,GACrCJ,EAAeA,GAAgBG,EAC/BF,EAAeA,GAAgBE,EAC/BD,EAAWA,GAAYC,EAIvB,IAAIE,EAAS5C,EAAQE,MAAM,eACvB2C,EAA+B,KAArB7C,EAAQM,OAAO,GAU7B,OARAnB,EAAI2D,QAAQF,EAAQ,SAAUG,EAAOC,GAC5BD,GAGDH,EAAOI,IAAMH,EAAUL,EAAeD,GAAcQ,GACpDF,GAAWA,GAHXD,EAAOI,GAAK,KAMbP,EAASG,EAAO7B,KAAK,KAGhC,SAASkC,EAAiBC,EAAQzD,EAAQ0D,EAASnD,GAG/CA,EAAUV,EAAO8D,aAAapD,GACjBX,EAAKgE,gBAAgBF,EAAQrD,QAE1C,OAAOE,EAAQC,QAAQ,eAAgB,SAAUC,GAG7C,IAAIC,EACAE,EAAIH,EAAMI,OAAO,GACjBC,EAAIL,EAAMM,OACV8C,EAAK,GAOT,OANIH,EAAQI,QACJhD,EAAI,IAAK+C,EAAK,MAAa/C,EAAI,GAAK,KACpCA,EAAI,GAAU,MAAaA,EAAI,GAAK,MAExC+C,EAAK,KAAW,UAEZjD,GACJ,IAAK,IACDF,EAAI,OACJ,MACJ,IAAK,IACDA,EAAKI,EAAI,EAAK,aAAe+C,EAAK,eAClC,MACJ,IAAK,IACDnD,EAAI,WAAamD,EAAK,cACtB,MACJ,IAAK,IACDnD,EAAI,OACJ,MACJ,IAAK,IACDA,EAAImD,EAAK,eACT,MACJ,IAAK,IACDnD,EAAImD,EAAK,YACT,MACJ,IAAK,IACDnD,EAAImD,EAAK,kBACT,MACJ,IAAK,IACDnD,EAAImD,EAAK,oBACT,MACJ,IAAK,IACL,IAAK,IACDnD,EAAImD,EAAK,eACT,MACJ,IAAK,IACDnD,EAAI,OAASI,EAAI,IACjB,MACJ,IAAK,IACD,IAAIiD,EAAKL,EAAQK,IAAM/D,EAAO,6BAC1BgE,EAAKN,EAAQM,IAAMhE,EAAO,6BAC1B0D,EAAQI,OACRpD,EAAIqD,EAAK,IAAMC,GAEftD,EAAIqD,EAAK,IAAMC,EACXD,GAAMA,EAAGE,gBAAiBvD,GAAK,IAAMqD,EAAGE,eACxCD,GAAMA,EAAGC,gBAAiBvD,GAAK,IAAMsD,EAAGC,gBAEhD,MACJ,QACIvD,EAAI,KAGZ,OADI+C,GAAUA,EAAOS,KAAKzD,GACnB,IAAMC,EAAI,MAClBF,QAAQ,WAAY,cAvQ3BP,EAAQkE,OAAS,SAAsC/D,EAAuBsD,GAG1EA,EAAUA,MAEV,IAAIrD,EAAST,EAAKgE,gBAAgBF,EAAQrD,QACtC+D,EAAeV,EAAQU,cAAgB,QACvCpE,EAASC,EAAQoE,kBAAkBhE,GACnCiE,KAEAC,EAAQ9E,EAAK+E,MAAMC,KAAMtE,EAAeC,EAAYJ,EAAQK,EAAQqD,EAAQpD,UAChF,GAAwB,QAApBoD,EAAQgB,SAER,OADWtE,EAAWc,cAG1B,GAAwB,QAApBwC,EAAQgB,SAAoB,CAC5B,IAAIC,EAAcjB,EAAQiB,aAAe3E,EAAO,cAAgBoE,GAC5DO,GAAeL,EAAIJ,KAAKrB,EAAgB8B,EAAaJ,IAE7D,GAAwB,QAApBb,EAAQgB,SAAoB,CAC5B,IAAIE,EAAclB,EAAQkB,aAAe5E,EAAO,cAAgBoE,GAC5DQ,GAAeN,EAAIJ,KAAKrB,EAAgB+B,EAAaL,IAI7D,OAFaD,EAAIhD,KAAK,MAK1BrB,EAAQJ,OAAS,SAAqB6D,GAMlC,OAAOzD,EAAQ4E,WAAWnB,GAAS7D,QAGvCI,EAAQ4E,WAAa,SAAqBnB,GAGtCA,EAAUA,MACV,IAAIrD,EAAST,EAAKgE,gBAAgBF,EAAQrD,QACtCL,EAASC,EAAQoE,kBAAkBhE,GACnC+D,EAAeV,EAAQU,cAAgB,QACvCO,EAAcjB,EAAQiB,aAAe3E,EAAO,cAAgBoE,GAC5DQ,EAAclB,EAAQkB,aAAe5E,EAAO,cAAgBoE,GAW5DX,KAGJ,OAAS5D,OADAgD,EAVe,QAApBa,EAAQgB,SACEC,EACiB,QAApBjB,EAAQgB,SACLE,OAEyB,IAAjB,EAAgCD,EAAcA,EAAc,IAAMC,EAKtDnF,EAAK+E,MAAMC,KAAMjB,EAAkBC,EAAQzD,EAAQ0D,IAChED,OAAQA,EAAQzD,OAAQA,IAGjDC,EAAQ6E,MAAQ,SAAoBC,EAAkBrB,GAMlDqB,EAAQA,EAAMvE,QAAQ,8BAA+B,IAEhDkD,IAAWA,MAChB,IAAIsB,EAAO/E,EAAQ4E,WAAWnB,GAE1BD,EAASuB,EAAKvB,OAAQzD,EAASgF,EAAKhF,OACpCH,EAASmF,EAAKnF,OAAOW,QAAQ,8BAA+B,IAG5DC,EAFK,IAAIwE,OAAO,IAAMpF,EAAS,KAEpBqF,KAAKH,GAEPnF,EAAKgE,gBAAgBF,EAAQrD,QAE1C,IAAKI,EAAS,OAAO,KAIrB,IAAI0E,GAAU,KAAM,EAAG,EAAG,EAAG,EAAG,EAAG,GAC/BC,EAAO,GAEPpE,GAAa,OAAQ,OAAQ,UAwE7BqE,GAvEQ3F,EAAI4F,MAAM7E,EAAO,SAAU8E,EAAGhC,GACtC,IAAKA,EAAK,OAAO,EACjB,IAAIiC,EAAQ/B,EAAOF,EAAI,GACnBzC,EAAI0E,EAAMzE,OACd,OAAQyE,EAAM3E,OAAO,IACjB,IAAK,IACDsE,EAAO,GAAKM,OAAOF,GACnB,MACJ,IAAK,IACD,GAAIzE,EAAI,EAAG,CACP,IAAI4E,EAAS1F,EAAO,iBAAmBgB,EAAUF,EAAI,IAAI6E,SAQzD,GAPKjC,EAAQI,SAGTyB,EAAIA,EAAE/E,QAAQ,IAAK,IAAIyD,cACvByB,EAAShG,EAAIkG,IAAIF,EAAQ,SAAUhF,GAAK,OAAOA,EAAIA,EAAEF,QAAQ,IAAK,IAAIyD,cAAgBvD,MAGhF,IADV6E,EAAI7F,EAAImG,QAAQH,EAAQH,IAEpB,OAAO,EAEDzE,OAEVyE,IAEJJ,EAAO,GAAKM,OAAOF,GACnB,MACJ,IAAK,IACDJ,EAAO,GAAK,EAEhB,IAAK,IACDA,EAAO,GAAKM,OAAOF,GACnB,MACJ,IAAK,IACD,IAAIxB,EAAKL,EAAQK,IAAM/D,EAAO,6BAC1BgE,EAAKN,EAAQM,IAAMhE,EAAO,6BAC9B,IAAK0D,EAAQI,OAAQ,CACjB,IAAIgC,EAAS,MACbP,EAAIA,EAAE/E,QAAQsF,EAAQ,IAAI7B,cAC1BF,EAAKA,EAAGvD,QAAQsF,EAAQ,IAAI7B,cAC5BD,EAAKA,EAAGxD,QAAQsF,EAAQ,IAAI7B,cAEhC,GAAIP,EAAQI,QAAUyB,GAAKxB,GAAMwB,GAAKvB,EAClC,OAAO,EAIXoB,EAAQG,GAAKvB,EAAM,IAAOuB,GAAKxB,EAAM,IAAM,GAC3C,MACJ,IAAK,IACQ,IAALwB,IAAWA,EAAI,GAEvB,IAAK,IACL,IAAK,IACL,IAAK,IAGDJ,EAAO,GAAKM,OAAOF,GACnB,MACJ,IAAK,IACDJ,EAAO,GAAKM,OAAOF,GACnB,MACJ,IAAK,IACDJ,EAAO,GAAKM,OAAOF,GACnB,MACJ,IAAK,IACDJ,EAAO,GAAKM,OAAOF,GAE3B,OAAO,KAGEJ,EAAO,IAOpB,MANa,MAATC,GAAgBC,EAAQ,GACxBF,EAAO,GAAKE,EAAQ,GACJ,MAATD,GAAyB,IAATC,IACvBF,EAAO,GAAK,GAEC,IAAIpF,EAAMoF,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,KAoGxG,IAAIY,KA0CJ,OAzCA9F,EAAQ+F,iBAAmB,SAAoBC,EAAuBC,GAIlEH,EAAe7B,MAAOiC,IAAKF,EAAaG,KAAMF,KAGlDjG,EAAQoE,kBAAoB,SAAoBhE,GAC5C,IAAIgG,KAKJ,OAJA3G,EAAI2D,QAAQ0C,EAAgB,SAAUO,GAClC,IAAItG,EAASJ,EAAK2G,gBAAgBD,EAAKH,IAAKG,EAAKF,KAAM/F,GACvDgG,EAAU5G,EAAK+G,MAAMH,EAASrG,IAC/ByE,MACI4B,GAGXpG,EAAQ+F,iBAAiB,YAAa,WAEtC/F,EAAQwG,SAAW,SAAoBC,EAAgBC,EAAiBC,EAAoBvG,EAAqCwG,GAG7H,IAAIC,EACAC,EAAS9G,EAAQoE,kBAAkBhE,GACnC2G,GAASN,EAAME,EAASD,GACb,cAAXC,IAIgB,IAFhBE,EAAQC,EADEC,EAAM1F,KAAK,OAGX,KAAWwF,OAAQG,IAKjC,OAHAD,EAAM,GAAK,UAGHF,GAASC,EAAOC,EAAM1F,KAAK,OAAOqE,UAI9C1F,EAAQiH,SAAWjH,EAAQwG,SAAS,OAAQ,OAAQ,UAEpDxG,EAAQyF,OAASzF,EAAQwG,SAAS,SAAU,OAAQ,UAE7CxG","file":"../../../date/umalqura/locale.js","sourcesContent":["define([\"../..\", \"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/date\", \"dojo/i18n\", \"dojo/regexp\", \"dojo/string\", \"./Date\", \"dojo/i18n!dojo/cldr/nls/islamic\"],\r\n       function (dojox, lang, arr, dd, i18n, regexp, string, IDate, bundle) {\r\n\r\n           var ilocale = lang.getObject(\"date.umalqura.locale\", true, dojox);\r\n\r\n           // Format a pattern without literals\r\n           function formatPattern(dateObject, bundle, locale, fullYear, pattern) {\r\n\r\n               return pattern.replace(/([a-z])\\1*/ig, function (match) {\r\n                   var s, pad;\r\n                   var c = match.charAt(0);\r\n                   var l = match.length;\r\n                   var widthList = [\"abbr\", \"wide\", \"narrow\"];\r\n\r\n                   switch (c) {\r\n                       case 'G':\r\n                           s = bundle[\"eraAbbr\"][0];\r\n                           break;\r\n                       case 'y':\r\n                           s = String(dateObject.getFullYear());\r\n                           break;\r\n                       case 'M':\r\n                           var m = dateObject.getMonth();\r\n                           if (l < 3) {\r\n                               s = m + 1; pad = true;\r\n                           } else {\r\n                               var propM = [\"months\", \"format\", widthList[l - 3]].join(\"-\");\r\n                               s = bundle[propM][m];\r\n                           }\r\n                           break;\r\n                       case 'd':\r\n                           s = dateObject.getDate(true); pad = true;\r\n                           break;\r\n                       case 'E':\r\n                           var d = dateObject.getDay();\r\n                           if (l < 3) {\r\n                               s = d + 1; pad = true;\r\n                           } else {\r\n                               var propD = [\"days\", \"format\", widthList[l - 3]].join(\"-\");\r\n                               s = bundle[propD][d];\r\n                           }\r\n                           break;\r\n                       case 'a':\r\n                           var timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';\r\n                           s = bundle['dayPeriods-format-wide-' + timePeriod];\r\n                           break;\r\n                       case 'h':\r\n                       case 'H':\r\n                       case 'K':\r\n                       case 'k':\r\n                           var h = dateObject.getHours();\r\n                           switch (c) {\r\n                               case 'h': // 1-12\r\n                                   s = (h % 12) || 12;\r\n                                   break;\r\n                               case 'H': // 0-23\r\n                                   s = h;\r\n                                   break;\r\n                               case 'K': // 0-11\r\n                                   s = (h % 12);\r\n                                   break;\r\n                               case 'k': // 1-24\r\n                                   s = h || 24;\r\n                                   break;\r\n                           }\r\n                           pad = true;\r\n                           break;\r\n                       case 'm':\r\n                           s = dateObject.getMinutes(); pad = true;\r\n                           break;\r\n                       case 's':\r\n                           s = dateObject.getSeconds(); pad = true;\r\n                           break;\r\n                       case 'S':\r\n                           s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l - 3)); pad = true;\r\n                           break;\r\n                       case 'z':\r\n                           // We only have one timezone to offer; the one from the browser\r\n                           s = dd.getTimezoneName(dateObject.toGregorian());\r\n                           if (s) { break; }\r\n                           l = 4;\r\n                           // fallthrough... use GMT if tz not available\r\n                       case 'Z':\r\n                           var offset = dateObject.toGregorian().getTimezoneOffset();\r\n                           var tz = [\r\n                               (offset <= 0 ? \"+\" : \"-\"),\r\n                               string.pad(Math.floor(Math.abs(offset) / 60), 2),\r\n                               string.pad(Math.abs(offset) % 60, 2)\r\n                           ];\r\n                           if (l == 4) {\r\n                               tz.splice(0, 0, \"GMT\");\r\n                               tz.splice(3, 0, \":\");\r\n                           }\r\n                           s = tz.join(\"\");\r\n                           break;\r\n                       default:\r\n                           throw new Error(\"dojox.date.umalqura.locale.formatPattern: invalid pattern char: \" + pattern);\r\n                   }\r\n                   if (pad) { s = string.pad(s, l); }\r\n                   return s;\r\n               });\r\n           }\r\n\r\n           // based on and similar to dojo.date.locale.format\r\n           ilocale.format = function (/*dojox/date/umalqura/Date*/dateObject, /*Object?*/options) {\r\n               // summary:\r\n               //\t\tFormat a Date object as a String, using  settings.\r\n               options = options || {};\r\n\r\n               var locale = i18n.normalizeLocale(options.locale);\r\n               var formatLength = options.formatLength || 'short';\r\n               var bundle = ilocale._getIslamicBundle(locale);\r\n               var str = [];\r\n\r\n               var sauce = lang.hitch(this, formatPattern, dateObject, bundle, locale, options.fullYear);\r\n               if (options.selector == \"year\") {\r\n                   var year = dateObject.getFullYear();\r\n                   return year;\r\n               }\r\n               if (options.selector != \"time\") {\r\n                   var datePattern = options.datePattern || bundle[\"dateFormat-\" + formatLength];\r\n                   if (datePattern) { str.push(_processPattern(datePattern, sauce)); }\r\n               }\r\n               if (options.selector != \"date\") {\r\n                   var timePattern = options.timePattern || bundle[\"timeFormat-\" + formatLength];\r\n                   if (timePattern) { str.push(_processPattern(timePattern, sauce)); }\r\n               }\r\n               var result = str.join(\" \"); //TODO: use locale-specific pattern to assemble date + time\r\n\r\n               return result; // String\r\n           };\r\n\r\n           ilocale.regexp = function (/*object?*/options) {\r\n               // summary:\r\n               //\t\tBuilds the regular needed to parse a umalqura.Date\r\n\r\n               //\tbased on and similar to dojo.date.locale.regexp\r\n\r\n               return ilocale._parseInfo(options).regexp; // String\r\n           };\r\n\r\n           ilocale._parseInfo = function (/*oblect?*/options) {\r\n               /* based on and similar to dojo.date.locale._parseInfo */\r\n\r\n               options = options || {};\r\n               var locale = i18n.normalizeLocale(options.locale);\r\n               var bundle = ilocale._getIslamicBundle(locale);\r\n               var formatLength = options.formatLength || 'short';\r\n               var datePattern = options.datePattern || bundle[\"dateFormat-\" + formatLength];\r\n               var timePattern = options.timePattern || bundle[\"timeFormat-\" + formatLength];\r\n\r\n               var pattern;\r\n               if (options.selector == 'date') {\r\n                   pattern = datePattern;\r\n               } else if (options.selector == 'time') {\r\n                   pattern = timePattern;\r\n               } else {\r\n                   pattern = (typeof (timePattern) == \"undefined\") ? datePattern : datePattern + ' ' + timePattern;\r\n               }\r\n\r\n               var tokens = [];\r\n\r\n               var re = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));\r\n               return { regexp: re, tokens: tokens, bundle: bundle };\r\n           };\r\n\r\n           ilocale.parse = function (/*String*/value, /*Object?*/options) {\r\n               // summary:\r\n               //\t\tThis function parse string date value according to options\r\n\r\n               // based on and similar to dojo.date.locale.parse\r\n\r\n               value = value.replace(/[\\u200E\\u200F\\u202A\\u202E]/g, \"\"); //remove bidi non-printing chars\r\n\r\n               if (!options) { options = {}; }\r\n               var info = ilocale._parseInfo(options);\r\n\r\n               var tokens = info.tokens, bundle = info.bundle;\r\n               var regexp = info.regexp.replace(/[\\u200E\\u200F\\u202A\\u202E]/g, \"\"); //remove bidi non-printing chars from the pattern\r\n               var re = new RegExp(\"^\" + regexp + \"$\");\r\n\r\n               var match = re.exec(value);\r\n\r\n               var locale = i18n.normalizeLocale(options.locale);\r\n\r\n               if (!match) { return null; } // null\r\n\r\n               var date, date1;\r\n\r\n               var result = [1389, 0, 1, 0, 0, 0, 0];  //FIXME: umalqura date for [1970,0,1,0,0,0,0] used in gregorian locale\r\n               var amPm = \"\";\r\n               var mLength = 0;\r\n               var widthList = [\"abbr\", \"wide\", \"narrow\"];\r\n               var valid = arr.every(match, function (v, i) {\r\n                   if (!i) { return true; }\r\n                   var token = tokens[i - 1];\r\n                   var l = token.length;\r\n                   switch (token.charAt(0)) {\r\n                       case 'y':\r\n                           result[0] = Number(v);\r\n                           break;\r\n                       case 'M':\r\n                           if (l > 2) {\r\n                               var months = bundle['months-format-' + widthList[l - 3]].concat();\r\n                               if (!options.strict) {\r\n                                   //Tolerate abbreviating period in month part\r\n                                   //Case-insensitive comparison\r\n                                   v = v.replace(\".\", \"\").toLowerCase();\r\n                                   months = arr.map(months, function (s) { return s ? s.replace(\".\", \"\").toLowerCase() : s; });\r\n                               }\r\n                               v = arr.indexOf(months, v);\r\n                               if (v == -1) {\r\n                                   return false;\r\n                               }\r\n                               mLength = l;\r\n                           } else {\r\n                               v--;\r\n                           }\r\n                           result[1] = Number(v);\r\n                           break;\r\n                       case 'D':\r\n                           result[1] = 0;\r\n                           // fallthrough...\r\n                       case 'd':\r\n                           result[2] = Number(v);\r\n                           break;\r\n                       case 'a': //am/pm\r\n                           var am = options.am || bundle['dayPeriods-format-wide-am'],\r\n                               pm = options.pm || bundle['dayPeriods-format-wide-pm'];\r\n                           if (!options.strict) {\r\n                               var period = /\\./g;\r\n                               v = v.replace(period, '').toLowerCase();\r\n                               am = am.replace(period, '').toLowerCase();\r\n                               pm = pm.replace(period, '').toLowerCase();\r\n                           }\r\n                           if (options.strict && v != am && v != pm) {\r\n                               return false;\r\n                           }\r\n\r\n                           // we might not have seen the hours field yet, so store the state and apply hour change later\r\n                           amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';\r\n                           break;\r\n                       case 'K': //hour (1-24)\r\n                           if (v == 24) { v = 0; }\r\n                           // fallthrough...\r\n                       case 'h': //hour (1-12)\r\n                       case 'H': //hour (0-23)\r\n                       case 'k': //hour (0-11)\r\n                           //in the 12-hour case, adjusting for am/pm requires the 'a' part\r\n                           //which could come before or after the hour, so we will adjust later\r\n                           result[3] = Number(v);\r\n                           break;\r\n                       case 'm': //minutes\r\n                           result[4] = Number(v);\r\n                           break;\r\n                       case 's': //seconds\r\n                           result[5] = Number(v);\r\n                           break;\r\n                       case 'S': //milliseconds\r\n                           result[6] = Number(v);\r\n                   }\r\n                   return true;\r\n               });\r\n\r\n               var hours = +result[3];\r\n               if (amPm === 'p' && hours < 12) {\r\n                   result[3] = hours + 12; //e.g., 3pm -> 15\r\n               } else if (amPm === 'a' && hours == 12) {\r\n                   result[3] = 0; //12am -> 0\r\n               }\r\n               var dateObject = new IDate(result[0], result[1], result[2], result[3], result[4], result[5], result[6]);\r\n               return dateObject;\r\n           };\r\n\r\n           function _processPattern(pattern, applyPattern, applyLiteral, applyAll) {\r\n               // summary:\r\n               //\t\tProcess a pattern with literals in it\r\n\r\n               // Break up on single quotes, treat every other one as a literal, except '' which becomes '\r\n               var identity = function (x) { return x; };\r\n               applyPattern = applyPattern || identity;\r\n               applyLiteral = applyLiteral || identity;\r\n               applyAll = applyAll || identity;\r\n\r\n               //split on single quotes (which escape literals in date format strings)\r\n               //but preserve escaped single quotes (e.g., o''clock)\r\n               var chunks = pattern.match(/(''|[^'])+/g);\r\n               var literal = pattern.charAt(0) == \"'\";\r\n\r\n               arr.forEach(chunks, function (chunk, i) {\r\n                   if (!chunk) {\r\n                       chunks[i] = '';\r\n                   } else {\r\n                       chunks[i] = (literal ? applyLiteral : applyPattern)(chunk);\r\n                       literal = !literal;\r\n                   }\r\n               });\r\n               return applyAll(chunks.join(''));\r\n           }\r\n\r\n           function _buildDateTimeRE(tokens, bundle, options, pattern) {\r\n               // based on and similar to dojo.date.locale._buildDateTimeRE\r\n\r\n               pattern = regexp.escapeString(pattern);\r\n               var locale = i18n.normalizeLocale(options.locale);\r\n\r\n               return pattern.replace(/([a-z])\\1*/ig, function (match) {\r\n\r\n                   // Build a simple regexp.  Avoid captures, which would ruin the tokens list\r\n                   var s;\r\n                   var c = match.charAt(0);\r\n                   var l = match.length;\r\n                   var p2 = '', p3 = '';\r\n                   if (options.strict) {\r\n                       if (l > 1) { p2 = '0' + '{' + (l - 1) + '}'; }\r\n                       if (l > 2) { p3 = '0' + '{' + (l - 2) + '}'; }\r\n                   } else {\r\n                       p2 = '0?'; p3 = '0{0,2}';\r\n                   }\r\n                   switch (c) {\r\n                       case 'y':\r\n                           s = '\\\\d+';\r\n                           break;\r\n                       case 'M':\r\n                           s = (l > 2) ? '\\\\S+ ?\\\\S+' : p2 + '[1-9]|1[0-2]';\r\n                           break;\r\n                       case 'd':\r\n                           s = '[12]\\\\d|' + p2 + '[1-9]|3[01]';\r\n                           break;\r\n                       case 'E':\r\n                           s = '\\\\S+';\r\n                           break;\r\n                       case 'h': //hour (1-12)\r\n                           s = p2 + '[1-9]|1[0-2]';\r\n                           break;\r\n                       case 'k': //hour (0-11)\r\n                           s = p2 + '\\\\d|1[01]';\r\n                           break;\r\n                       case 'H': //hour (0-23)\r\n                           s = p2 + '\\\\d|1\\\\d|2[0-3]';\r\n                           break;\r\n                       case 'K': //hour (1-24)\r\n                           s = p2 + '[1-9]|1\\\\d|2[0-4]';\r\n                           break;\r\n                       case 'm':\r\n                       case 's':\r\n                           s = p2 + '\\\\d|[0-5]\\\\d';\r\n                           break;\r\n                       case 'S':\r\n                           s = '\\\\d{' + l + '}';\r\n                           break;\r\n                       case 'a':\r\n                           var am = options.am || bundle['dayPeriods-format-wide-am'],\r\n                               pm = options.pm || bundle['dayPeriods-format-wide-pm'];\r\n                           if (options.strict) {\r\n                               s = am + '|' + pm;\r\n                           } else {\r\n                               s = am + '|' + pm;\r\n                               if (am != am.toLowerCase()) { s += '|' + am.toLowerCase(); }\r\n                               if (pm != pm.toLowerCase()) { s += '|' + pm.toLowerCase(); }\r\n                           }\r\n                           break;\r\n                       default:\r\n                           s = \".*\";\r\n                   }\r\n                   if (tokens) { tokens.push(match); }\r\n                   return \"(\" + s + \")\"; // add capture\r\n               }).replace(/[\\xa0 ]/g, \"[\\\\s\\\\xa0]\"); // normalize whitespace.  Need explicit handling of \\xa0 for IE. */\r\n           }\r\n\r\n           var _customFormats = [];\r\n           ilocale.addCustomFormats = function (/*String*/packageName, /*String*/bundleName) {\r\n               // summary:\r\n               //\t\tAdd a reference to a bundle containing localized custom formats to be\r\n               //\t\tused by date/time formatting and parsing routines.\r\n               _customFormats.push({ pkg: packageName, name: bundleName });\r\n           };\r\n\r\n           ilocale._getIslamicBundle = function (/*String*/locale) {\r\n               var islamic = {};\r\n               arr.forEach(_customFormats, function (desc) {\r\n                   var bundle = i18n.getLocalization(desc.pkg, desc.name, locale);\r\n                   islamic = lang.mixin(islamic, bundle);\r\n               }, this);\r\n               return islamic; /*Object*/\r\n           };\r\n\r\n           ilocale.addCustomFormats(\"dojo.cldr\", \"islamic\");\r\n\r\n           ilocale.getNames = function (/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale, /*dojox/date/umalqura/Date?*/date) {\r\n               // summary:\r\n               //\t\tUsed to get localized strings from dojo.cldr for day or month names.\r\n               var label;\r\n               var lookup = ilocale._getIslamicBundle(locale);\r\n               var props = [item, context, type];\r\n               if (context == 'standAlone') {\r\n                   var key = props.join('-');\r\n                   label = lookup[key];\r\n                   // Fall back to 'format' flavor of name\r\n                   if (label[0] == 1) { label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr\r\n               }\r\n               props[1] = 'format';\r\n\r\n               // return by copy so changes won't be made accidentally to the in-memory model\r\n               return (label || lookup[props.join('-')]).concat(); /*Array*/\r\n           };\r\n\r\n\r\n           ilocale.weekDays = ilocale.getNames('days', 'wide', 'format');\r\n\r\n           ilocale.months = ilocale.getNames('months', 'wide', 'format');\r\n\r\n           return ilocale;\r\n       });\r\n\r\n"]}