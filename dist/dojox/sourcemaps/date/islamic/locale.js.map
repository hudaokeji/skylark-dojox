{"version":3,"sources":["date/islamic/locale.js"],"names":["define","dojox","lang","arr","dd","i18n","regexp","string","IDate","bundle","ilocale","getObject","formatPattern","dateObject","locale","fullYear","pattern","replace","match","s","pad","c","charAt","l","length","widthList","String","getFullYear","m","getMonth","propM","join","getDate","d","getDay","propD","timePeriod","getHours","h","getMinutes","getSeconds","Math","round","getMilliseconds","pow","getTimezoneName","toGregorian","offset","getTimezoneOffset","tz","floor","abs","splice","Error","_processPattern","applyPattern","applyLiteral","applyAll","identity","x","chunks","literal","forEach","chunk","i","_buildDateTimeRE","tokens","options","escapeString","normalizeLocale","p2","strict","am","pm","toLowerCase","push","format","formatLength","_getIslamicBundle","str","sauce","hitch","this","selector","datePattern","timePattern","_parseInfo","parse","value","info","RegExp","exec","result","amPm","hours","every","v","token","Number","months","concat","map","indexOf","period","_customFormats","addCustomFormats","packageName","bundleName","pkg","name","islamic","desc","getLocalization","mixin","getNames","item","type","context","date","label","lookup","props","undefined","weekDays"],"mappings":"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","file":"../../../date/islamic/locale.js","sourcesContent":["define([\"../..\", \"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/date\", \"dojo/i18n\", \"dojo/regexp\", \"dojo/string\", \"./Date\", \"dojo/i18n!dojo/cldr/nls/islamic\"],\r\n       function(dojox, lang, arr, dd, i18n, regexp, string, IDate, bundle){\r\n\r\n\tvar ilocale = lang.getObject(\"date.islamic.locale\", true, dojox);\r\n\r\n\t// Format a pattern without literals\r\n\tfunction formatPattern(dateObject, bundle, locale, fullYear,  pattern){\r\n\r\n\t\treturn pattern.replace(/([a-z])\\1*/ig, function(match){\r\n\t\t\tvar s, pad;\r\n\t\t\tvar c = match.charAt(0);\r\n\t\t\tvar l = match.length;\r\n\t\t\tvar widthList = [\"abbr\", \"wide\", \"narrow\"];\r\n\t\t\t\r\n\t\t\tswitch(c){\r\n\t\t\t\tcase 'G':\r\n\t\t\t\t\ts = bundle[\"eraAbbr\"][0];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'y':\r\n\t\t\t\t\ts = String(dateObject.getFullYear());\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'M':\r\n\t\t\t\t\tvar m = dateObject.getMonth();\r\n\t\t\t\t\tif(l<3){\r\n\t\t\t\t\t\ts = m+1; pad = true;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tvar propM = [\"months\", \"format\", widthList[l-3]].join(\"-\");\r\n\t\t\t\t\t\ts = bundle[propM][m];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'd':\r\n\t\t\t\t\ts = dateObject.getDate(true); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'E':\r\n\t\t\t\t\tvar d = dateObject.getDay();\r\n\t\t\t\t\tif(l<3){\r\n\t\t\t\t\t\ts = d+1; pad = true;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tvar propD = [\"days\", \"format\", widthList[l-3]].join(\"-\");\r\n\t\t\t\t\t\ts = bundle[propD][d];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'a':\r\n\t\t\t\t\tvar timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';\r\n\t\t\t\t\ts = bundle['dayPeriods-format-wide-' + timePeriod];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'h':\r\n\t\t\t\tcase 'H':\r\n\t\t\t\tcase 'K':\r\n\t\t\t\tcase 'k':\r\n\t\t\t\t\tvar h = dateObject.getHours();\r\n\t\t\t\t\tswitch (c){\r\n\t\t\t\t\t\tcase 'h': // 1-12\r\n\t\t\t\t\t\t\ts = (h % 12) || 12;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'H': // 0-23\r\n\t\t\t\t\t\t\ts = h;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'K': // 0-11\r\n\t\t\t\t\t\t\ts = (h % 12);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'k': // 1-24\r\n\t\t\t\t\t\t\ts = h || 24;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'm':\r\n\t\t\t\t\ts = dateObject.getMinutes(); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 's':\r\n\t\t\t\t\ts = dateObject.getSeconds(); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'S':\r\n\t\t\t\t\ts = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'z':\r\n\t\t\t\t\t// We only have one timezone to offer; the one from the browser\r\n\t\t\t\t\ts = dd.getTimezoneName(dateObject.toGregorian());\r\n\t\t\t\t\tif(s){ break; }\r\n\t\t\t\t\tl = 4;\r\n\t\t\t\t\t// fallthrough... use GMT if tz not available\r\n\t\t\t\tcase 'Z':\r\n\t\t\t\t\tvar offset = dateObject.toGregorian().getTimezoneOffset();\r\n\t\t\t\t\tvar tz = [\r\n\t\t\t\t\t\t(offset <= 0 ? \"+\" : \"-\"),\r\n\t\t\t\t\t\tstring.pad(Math.floor(Math.abs(offset) / 60), 2),\r\n\t\t\t\t\t\tstring.pad(Math.abs(offset) % 60, 2)\r\n\t\t\t\t\t];\r\n\t\t\t\t\tif(l == 4){\r\n\t\t\t\t\t\ttz.splice(0, 0, \"GMT\");\r\n\t\t\t\t\t\ttz.splice(3, 0, \":\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\ts = tz.join(\"\");\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"dojox.date.islamic.locale.formatPattern: invalid pattern char: \"+pattern);\r\n\t\t\t}\r\n\t\t\tif(pad){ s = string.pad(s, l); }\r\n\t\t\treturn s;\r\n\t\t});\r\n\t}\r\n\t\r\n\t// based on and similar to dojo.date.locale.format\r\n\tilocale.format = function(/*dojox/date/islamic/Date*/dateObject, /*Object?*/options){\r\n\t\t// summary:\r\n\t\t//\t\tFormat a Date object as a String, using  settings.\r\n\t\toptions = options || {};\r\n\r\n\t\tvar locale = i18n.normalizeLocale(options.locale);\r\n\t\tvar formatLength = options.formatLength || 'short';\r\n\t\tvar bundle = ilocale._getIslamicBundle(locale);\r\n\t\tvar str = [];\r\n\r\n\t\tvar sauce = lang.hitch(this, formatPattern, dateObject, bundle, locale, options.fullYear);\r\n\t\tif(options.selector == \"year\"){\r\n\t\t\tvar year = dateObject.getFullYear();\r\n\t\t\treturn year;\r\n\t\t}\r\n\t\tif(options.selector != \"time\"){\r\n\t\t\tvar datePattern = options.datePattern || bundle[\"dateFormat-\"+formatLength];\r\n\t\t\tif(datePattern){str.push(_processPattern(datePattern, sauce));}\r\n\t\t}\r\n\t\tif(options.selector != \"date\"){\r\n\t\t\tvar timePattern = options.timePattern || bundle[\"timeFormat-\"+formatLength];\r\n\t\t\tif(timePattern){str.push(_processPattern(timePattern, sauce));}\r\n\t\t}\r\n\t\tvar result = str.join(\" \"); //TODO: use locale-specific pattern to assemble date + time\r\n\r\n\t\treturn result; // String\r\n\t};\r\n\r\n\tilocale.regexp = function(/*object?*/options){\r\n\t\t// summary:\r\n\t\t//\t\tBuilds the regular needed to parse a islamic.Date\r\n\r\n\t\t//\tbased on and similar to dojo.date.locale.regexp\r\n\r\n\t\treturn ilocale._parseInfo(options).regexp; // String\r\n\t};\r\n\r\n\tilocale._parseInfo = function(/*oblect?*/options){\r\n\t/* based on and similar to dojo.date.locale._parseInfo */\r\n\r\n\t\toptions = options || {};\r\n\t\tvar locale = i18n.normalizeLocale(options.locale);\r\n\t\tvar bundle = ilocale._getIslamicBundle(locale);\r\n\t\tvar formatLength = options.formatLength || 'short';\r\n\t\tvar datePattern = options.datePattern || bundle[\"dateFormat-\" + formatLength];\r\n\t\tvar timePattern = options.timePattern || bundle[\"timeFormat-\" + formatLength];\r\n\r\n\t\tvar pattern;\r\n\t\tif(options.selector == 'date'){\r\n\t\t\tpattern = datePattern;\r\n\t\t}else if(options.selector == 'time'){\r\n\t\t\tpattern = timePattern;\r\n\t\t}else{\r\n\t\t\tpattern = (typeof (timePattern) == \"undefined\") ? datePattern : datePattern + ' ' + timePattern;\r\n\t\t}\r\n\r\n\t\tvar tokens = [];\r\n\t\r\n\t\tvar re = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));\r\n\t\treturn {regexp: re, tokens: tokens, bundle: bundle};\r\n\t};\r\n\r\n\tilocale.parse = function(/*String*/value, /*Object?*/options){\r\n\t\t// summary:\r\n\t\t//\t\tThis function parse string date value according to options\r\n\r\n\t\t// based on and similar to dojo.date.locale.parse\r\n\r\n\t\tvalue =  value.replace(/[\\u200E\\u200F\\u202A\\u202E]/g, \"\"); //remove bidi non-printing chars\r\n\r\n\t\tif(!options){ options={}; }\r\n\t\tvar info = ilocale._parseInfo(options);\r\n\r\n\t\tvar tokens = info.tokens, bundle = info.bundle;\r\n\t\tvar regexp = info.regexp.replace(/[\\u200E\\u200F\\u202A\\u202E]/g, \"\"); //remove bidi non-printing chars from the pattern\r\n\t\tvar re = new RegExp(\"^\" + regexp + \"$\");\r\n\r\n\t\tvar match = re.exec(value);\r\n\r\n\t\tvar locale = i18n.normalizeLocale(options.locale);\r\n\r\n\t\tif(!match){ return null; } // null\r\n\t\r\n\t\tvar date, date1;\r\n\t\r\n\t\tvar result = [1389,0,1,0,0,0,0];  //FIXME: islamic date for [1970,0,1,0,0,0,0] used in gregorian locale\r\n\t\tvar amPm = \"\";\r\n\t\tvar mLength = 0;\r\n\t\tvar widthList = [\"abbr\", \"wide\", \"narrow\"];\r\n\t\tvar valid = arr.every(match, function(v, i){\r\n\t\t\tif(!i){return true;}\r\n\t\t\tvar token=tokens[i-1];\r\n\t\t\tvar l=token.length;\r\n\t\t\tswitch(token.charAt(0)){\r\n\t\t\t\tcase 'y':\r\n\t\t\t\t\tresult[0] = Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'M':\r\n\t\t\t\t\tif(l>2){\r\n\t\t\t\t\t\tvar months = bundle['months-format-' + widthList[l-3]].concat();\r\n\t\t\t\t\t\tif(!options.strict){\r\n\t\t\t\t\t\t\t//Tolerate abbreviating period in month part\r\n\t\t\t\t\t\t\t//Case-insensitive comparison\r\n\t\t\t\t\t\t\tv = v.replace(\".\",\"\").toLowerCase();\r\n\t\t\t\t\t\t\tmonths = arr.map(months, function(s){ return s ? s.replace(\".\",\"\").toLowerCase() : s; } );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tv = arr.indexOf(months, v);\r\n\t\t\t\t\t\tif(v == -1){\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmLength = l;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tv--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult[1] = Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'D':\r\n\t\t\t\t\tresult[1] = 0;\r\n\t\t\t\t\t// fallthrough...\r\n\t\t\t\tcase 'd':\r\n\t\t\t\t\t\tresult[2] =  Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'a': //am/pm\r\n\t\t\t\t\tvar am = options.am || bundle['dayPeriods-format-wide-am'],\r\n\t\t\t\t\t\tpm = options.pm || bundle['dayPeriods-format-wide-pm'];\r\n\t\t\t\t\tif(!options.strict){\r\n\t\t\t\t\t\tvar period = /\\./g;\r\n\t\t\t\t\t\tv = v.replace(period,'').toLowerCase();\r\n\t\t\t\t\t\tam = am.replace(period,'').toLowerCase();\r\n\t\t\t\t\t\tpm = pm.replace(period,'').toLowerCase();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(options.strict && v != am && v != pm){\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// we might not have seen the hours field yet, so store the state and apply hour change later\r\n\t\t\t\t\tamPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'K': //hour (1-24)\r\n\t\t\t\t\tif(v == 24){ v = 0; }\r\n\t\t\t\t\t// fallthrough...\r\n\t\t\t\tcase 'h': //hour (1-12)\r\n\t\t\t\tcase 'H': //hour (0-23)\r\n\t\t\t\tcase 'k': //hour (0-11)\r\n\t\t\t\t\t//in the 12-hour case, adjusting for am/pm requires the 'a' part\r\n\t\t\t\t\t//which could come before or after the hour, so we will adjust later\r\n\t\t\t\t\tresult[3] = Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'm': //minutes\r\n\t\t\t\t\tresult[4] = Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 's': //seconds\r\n\t\t\t\t\tresult[5] = Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'S': //milliseconds\r\n\t\t\t\t\tresult[6] = Number(v);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t});\r\n\r\n\t\tvar hours = +result[3];\r\n\t\tif(amPm === 'p' && hours < 12){\r\n\t\t\tresult[3] = hours + 12; //e.g., 3pm -> 15\r\n\t\t}else if(amPm === 'a' && hours == 12){\r\n\t\t\tresult[3] = 0; //12am -> 0\r\n\t\t}\r\n\t\tvar dateObject = new IDate(result[0], result[1], result[2], result[3], result[4], result[5], result[6]);\r\n\t\treturn dateObject;\r\n\t};\r\n\r\n\tfunction _processPattern(pattern, applyPattern, applyLiteral, applyAll){\r\n\t\t// summary:\r\n\t\t//\t\tProcess a pattern with literals in it\r\n\r\n\t\t// Break up on single quotes, treat every other one as a literal, except '' which becomes '\r\n\t\tvar identity = function(x){return x;};\r\n\t\tapplyPattern = applyPattern || identity;\r\n\t\tapplyLiteral = applyLiteral || identity;\r\n\t\tapplyAll = applyAll || identity;\r\n\r\n\t\t//split on single quotes (which escape literals in date format strings)\r\n\t\t//but preserve escaped single quotes (e.g., o''clock)\r\n\t\tvar chunks = pattern.match(/(''|[^'])+/g);\r\n\t\tvar literal = pattern.charAt(0) == \"'\";\r\n\r\n\t\tarr.forEach(chunks, function(chunk, i){\r\n\t\t\tif(!chunk){\r\n\t\t\t\tchunks[i]='';\r\n\t\t\t}else{\r\n\t\t\t\tchunks[i]=(literal ? applyLiteral : applyPattern)(chunk);\r\n\t\t\t\tliteral = !literal;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn applyAll(chunks.join(''));\r\n\t}\r\n\r\n\tfunction _buildDateTimeRE  (tokens, bundle, options, pattern){\r\n\t\t// based on and similar to dojo.date.locale._buildDateTimeRE\r\n\r\n\t\tpattern = regexp.escapeString(pattern);\r\n\t\tvar locale = i18n.normalizeLocale(options.locale);\r\n\t\r\n\t\treturn pattern.replace(/([a-z])\\1*/ig, function(match){\r\n\r\n\t\t\t\t// Build a simple regexp.  Avoid captures, which would ruin the tokens list\r\n\t\t\t\tvar s;\r\n\t\t\t\tvar c = match.charAt(0);\r\n\t\t\t\tvar l = match.length;\r\n\t\t\t\tvar p2 = '', p3 = '';\r\n\t\t\t\tif(options.strict){\r\n\t\t\t\t\tif(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }\r\n\t\t\t\t\tif(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }\r\n\t\t\t\t}else{\r\n\t\t\t\t\tp2 = '0?'; p3 = '0{0,2}';\r\n\t\t\t\t}\r\n\t\t\t\tswitch(c){\r\n\t\t\t\t\tcase 'y':\r\n\t\t\t\t\t\ts = '\\\\d+';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'M':\r\n\t\t\t\t\t\ts = (l>2) ?  '\\\\S+ ?\\\\S+' : p2+'[1-9]|1[0-2]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'd':\r\n\t\t\t\t\t\ts = '[12]\\\\d|'+p2+'[1-9]|3[01]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'E':\r\n\t\t\t\t\t\ts = '\\\\S+';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'h': //hour (1-12)\r\n\t\t\t\t\t\ts = p2+'[1-9]|1[0-2]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'k': //hour (0-11)\r\n\t\t\t\t\t\ts = p2+'\\\\d|1[01]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'H': //hour (0-23)\r\n\t\t\t\t\t\ts = p2+'\\\\d|1\\\\d|2[0-3]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'K': //hour (1-24)\r\n\t\t\t\t\t\ts = p2+'[1-9]|1\\\\d|2[0-4]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'm':\r\n\t\t\t\t\tcase 's':\r\n\t\t\t\t\t\ts = p2+'\\\\d|[0-5]\\\\d';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'S':\r\n\t\t\t\t\t\ts = '\\\\d{'+l+'}';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'a':\r\n\t\t\t\t\t\tvar am = options.am || bundle['dayPeriods-format-wide-am'],\r\n\t\t\t\t\t\t\tpm = options.pm || bundle['dayPeriods-format-wide-pm'];\r\n\t\t\t\t\t\tif(options.strict){\r\n\t\t\t\t\t\t\ts = am + '|' + pm;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\ts = am + '|' + pm;\r\n\t\t\t\t\t\t\tif(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }\r\n\t\t\t\t\t\t\tif(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\ts = \".*\";\r\n\t\t\t\t}\r\n\t\t\t\tif(tokens){ tokens.push(match); }\r\n\t\t\t\treturn \"(\" + s + \")\"; // add capture\r\n\t\t\t}).replace(/[\\xa0 ]/g, \"[\\\\s\\\\xa0]\"); // normalize whitespace.  Need explicit handling of \\xa0 for IE. */\r\n\t}\r\n\r\n\tvar _customFormats = [];\r\n\tilocale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){\r\n\t\t// summary:\r\n\t\t//\t\tAdd a reference to a bundle containing localized custom formats to be\r\n\t\t//\t\tused by date/time formatting and parsing routines.\r\n\t\t_customFormats.push({pkg:packageName,name:bundleName});\r\n\t};\r\n\r\n\tilocale._getIslamicBundle = function(/*String*/locale){\r\n\t\tvar islamic = {};\r\n\t\tarr.forEach(_customFormats, function(desc){\r\n\t\t\tvar bundle = i18n.getLocalization(desc.pkg, desc.name, locale);\r\n\t\t\tislamic = lang.mixin(islamic, bundle);\r\n\t\t}, this);\r\n\t\treturn islamic; /*Object*/\r\n\t};\r\n\r\n\tilocale.addCustomFormats(\"dojo.cldr\",\"islamic\");\r\n\r\n\tilocale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale, /*dojox/date/islamic/Date?*/date){\r\n\t\t// summary:\r\n\t\t//\t\tUsed to get localized strings from dojo.cldr for day or month names.\r\n\t\tvar label;\r\n\t\tvar lookup = ilocale._getIslamicBundle(locale);\r\n\t\tvar props = [item, context, type];\r\n\t\tif(context == 'standAlone'){\r\n\t\t\tvar key = props.join('-');\r\n\t\t\tlabel = lookup[key];\r\n\t\t\t// Fall back to 'format' flavor of name\r\n\t\t\tif(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr\r\n\t\t}\r\n\t\tprops[1] = 'format';\r\n\t\r\n\t\t// return by copy so changes won't be made accidentally to the in-memory model\r\n\t\treturn (label || lookup[props.join('-')]).concat(); /*Array*/\r\n\t};\r\n\r\n\r\n\tilocale.weekDays = ilocale.getNames('days', 'wide', 'format');\r\n\r\n\tilocale.months = ilocale.getNames('months', 'wide', 'format');\r\n\r\n\treturn ilocale;\r\n});\r\n"]}