{"version":3,"sources":["date/hebrew/locale.js"],"names":["define","dojox","lang","arr","dd","i18n","regexp","string","HDate","numerals","hlocale","getObject","formatPattern","dateObject","bundle","locale","fullYear","pattern","replace","match","s","pad","c","charAt","l","length","widthList","getYearHebrewLetters","getFullYear","String","m","getMonth","isLeapYear","getMonthHebrewLetters","getNames","getDateLocalized","getDate","d","getDay","propD","join","timePeriod","getHours","h","getMinutes","getSeconds","Math","round","getMilliseconds","pow","Error","_processPattern","applyPattern","applyLiteral","applyAll","identity","x","chunks","literal","forEach","chunk","i","_buildDateTimeRE","tokens","options","escapeString","normalizeLocale","p2","strict","am","pm","toLowerCase","push","getLocalization","format","formatLength","_getHebrewBundle","str","sauce","hitch","this","selector","year","datePattern","timePattern","_parseInfo","undefined","parse","value","info","RegExp","exec","result","amPm","mLength","hours","every","v","token","parseYearHebrewLetters","Number","months","leapmonths","map","monthName","indexOf","parseMonthHebrewLetters","parseDayHebrewLetters","period","setMonth","_customFormats","addCustomFormats","packageName","bundleName","pkg","name","hebrew","desc","mixin","item","type","context","date","label","lookup","props","concat"],"mappings":"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","file":"../../../date/hebrew/locale.js","sourcesContent":["define([\"../..\", \"dojo/_base/lang\", \"dojo/_base/array\", \"dojo/date\", \"dojo/i18n\", \"dojo/regexp\", \"dojo/string\", \"./Date\", \"./numerals\", \"dojo/i18n!dojo/cldr/nls/hebrew\"],\r\n\tfunction(dojox, lang, arr, dd, i18n, regexp, string, HDate, numerals){\r\n\r\n\tvar hlocale = lang.getObject(\"date.hebrew.locale\", true, dojox);\r\n\r\n\t//Load the bundles containing localization information for\r\n\t// names and formats\r\n\ti18n.getLocalization(\"dojo.cldr\", \"hebrew\");\r\n\r\n\t// Format a pattern without literals\r\n\tfunction formatPattern(dateObject, bundle, locale, fullYear,  pattern){\r\n\r\n\t\treturn pattern.replace(/([a-z])\\1*/ig, function(match){\r\n\t\t\tvar s, pad;\r\n\t\t\tvar c = match.charAt(0);\r\n\t\t\tvar l = match.length;\r\n\t\t\tvar widthList = [\"abbr\", \"wide\", \"narrow\"];\r\n\t\t\t\r\n\t\t\tswitch(c){\r\n\t\t\t\tcase 'G':\r\n\t\t\t\t\ts = bundle[(l < 4) ? \"eraAbbr\" : \"eraNames\"][0];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'y':\r\n\t\t\t\t\tif(locale.match(/^he(?:-.+)?$/)){\r\n\t\t\t\t\t\ts = numerals.getYearHebrewLetters(dateObject.getFullYear());\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\ts = String(dateObject.getFullYear());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'M':\r\n\t\t\t\t\tvar m = dateObject.getMonth();\r\n\t\t\t\t\tif(l<3){\r\n\t\t\t\t\t\tif(!dateObject.isLeapYear(dateObject.getFullYear()) && m>5){m--;}\r\n\t\t\t\t\t\tif(locale.match(/^he(?:-.+)?$/)){\r\n\t\t\t\t\t\t\ts = numerals.getMonthHebrewLetters(m);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\ts = m+1; pad = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tvar monthNames = hlocale.getNames('months',widthList[l-3], 'format', locale, dateObject);\r\n\t\t\t\t\t\ts = monthNames[m];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'd':\r\n\t\t\t\t\tif(locale.match(/^he(?:-.+)?$/)){\r\n\t\t\t\t\t\ts =  dateObject.getDateLocalized(locale);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\ts = dateObject.getDate(); pad = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'E':\r\n\t\t\t\t\tvar d = dateObject.getDay();\r\n\t\t\t\t\tif(l<3){\r\n\t\t\t\t\t\ts = d+1; pad = true;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tvar propD = [\"days\", \"format\", widthList[l-3]].join(\"-\");\r\n\t\t\t\t\t\ts = bundle[propD][d];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'a':\r\n\t\t\t\t\tvar timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';\r\n\t\t\t\t\ts = bundle['dayPeriods-format-wide-' + timePeriod];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'h':\r\n\t\t\t\tcase 'H':\r\n\t\t\t\tcase 'K':\r\n\t\t\t\tcase 'k':\r\n\t\t\t\t\tvar h = dateObject.getHours();\r\n\t\t\t\t\t// strange choices in the date format make it impossible to write this succinctly\r\n\t\t\t\t\tswitch (c){\r\n\t\t\t\t\t\tcase 'h': // 1-12\r\n\t\t\t\t\t\t\ts = (h % 12) || 12;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'H': // 0-23\r\n\t\t\t\t\t\t\ts = h;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'K': // 0-11\r\n\t\t\t\t\t\t\ts = (h % 12);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'k': // 1-24\r\n\t\t\t\t\t\t\ts = h || 24;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'm':\r\n\t\t\t\t\ts = dateObject.getMinutes(); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 's':\r\n\t\t\t\t\ts = dateObject.getSeconds(); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'S':\r\n\t\t\t\t\ts = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'z':\r\n\t\t\t\t\ts = \"\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error(\"dojox.date.hebrew.locale.formatPattern: invalid pattern char: \"+pattern);\r\n\t\t\t}\r\n\t\t\tif(pad){ s = string.pad(s, l); }\r\n\t\t\treturn s;\r\n\t\t});\r\n\t}\r\n\t\r\n\thlocale.format = function(/*dojox/date/hebrewDate*/dateObject, /*object?*/options){\r\n\t\t// summary:\r\n\t\t//\t\tFormat a Date object as a String, using  settings.\r\n\t\t// description:\r\n\t\t//\t\tCreate a string from a hebrew.Date object using a known pattern.\r\n\t\t//\t\tBy default, this method formats both date and time from dateObject.\r\n\t\t//\t\tDefault formatting lengths is 'short'\r\n\t\t// dateObject:\r\n\t\t//\t\tthe date and/or time to be formatted.  If a time only is formatted,\r\n\t\t//\t\tthe values in the year, month, and day fields are irrelevant.  The\r\n\t\t//\t\topposite is true when formatting only dates.\r\n\r\n\t\t// based on and similar to dojo.date.locale.format\r\n\r\n\t\toptions = options || {};\r\n\r\n\t\tvar locale = i18n.normalizeLocale(options.locale);\r\n\t\tvar formatLength = options.formatLength || 'short';\r\n\t\tvar bundle = hlocale._getHebrewBundle(locale);\r\n\t\tvar str = [];\r\n\r\n\t\tvar sauce = lang.hitch(this, formatPattern, dateObject, bundle, locale, options.fullYear);\r\n\t\tif(options.selector == \"year\"){\r\n\t\t\tvar year = dateObject.getFullYear();\r\n\t\t\treturn locale.match(/^he(?:-.+)?$/) ?\r\n\t\t\t\tnumerals.getYearHebrewLetters(year) : year;\r\n\t\t}\r\n\t\tif(options.selector != \"time\"){\r\n\t\t\tvar datePattern = options.datePattern || bundle[\"dateFormat-\"+formatLength];\r\n\t\t\tif(datePattern){str.push(_processPattern(datePattern, sauce));}\r\n\t\t}\r\n\t\tif(options.selector != \"date\"){\r\n\t\t\tvar timePattern = options.timePattern || bundle[\"timeFormat-\"+formatLength];\r\n\t\t\tif(timePattern){str.push(_processPattern(timePattern, sauce));}\r\n\t\t}\r\n\t\tvar result = str.join(\" \"); //TODO: use locale-specific pattern to assemble date + time\r\n\r\n\t\treturn result; // String\r\n\t};\r\n\r\n\thlocale.regexp = function(/*object?*/options){\r\n\t\t// summary:\r\n\t\t//\t\tBuilds the regular needed to parse a hebrew.Date\r\n\r\n\t\t//\tbased on and similar to dojo.date.locale.regexp\r\n\r\n\t\treturn hlocale._parseInfo(options).regexp; // String\r\n\t};\r\n\r\n\thlocale._parseInfo = function(/*oblect?*/options){\r\n\t/* based on and similar to dojo.date.locale._parseInfo */\r\n\r\n\t\toptions = options || {};\r\n\t\tvar locale = i18n.normalizeLocale(options.locale);\r\n\t\tvar bundle = hlocale._getHebrewBundle(locale);\r\n\r\n\t\tvar formatLength = options.formatLength || 'short';\r\n\t\tvar datePattern = options.datePattern || bundle[\"dateFormat-\" + formatLength];\r\n\t\tvar timePattern = options.timePattern || bundle[\"timeFormat-\" + formatLength];\r\n\r\n\t\tvar pattern;\r\n\t\tif(options.selector == 'date'){\r\n\t\t\tpattern = datePattern;\r\n\t\t}else if(options.selector == 'time'){\r\n\t\t\tpattern = timePattern;\r\n\t\t}else{\r\n\t\t\tpattern = (timePattern === undefined) ? datePattern : datePattern + ' ' + timePattern; //hebrew resource file does not contain time patterns - a bug?\r\n\t\t}\r\n\r\n\t\tvar tokens = [];\r\n\t\r\n\t\tvar re = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));\r\n\t\treturn {regexp: re, tokens: tokens, bundle: bundle};\r\n\t};\r\n\r\n\thlocale.parse = function(/*String*/value, /*Object?*/options){\r\n\t\t// summary:\r\n\t\t//\t\tThis function parse string date value according to options\r\n\t\t// example:\r\n\t\t//\t|\tvar dateHebrew = dojox.date.hebrew.locale.parse('11/10/5740', {datePattern:'dd/MM/yy', selector:'date'});\r\n\t\t//\t|\tin Hebrew locale string for parsing contains Hebrew Numerals\r\n\t\t//\t|\r\n\t\t//\t|\t  options = {datePattern:'dd MMMM yy', selector:'date'};\r\n\t\t//\t|\r\n\t\t//\t|\t   y - year\r\n\t\t//\t|\t   M, MM  - short month\r\n\t\t//\t|\t  MMM, MMMM - long month\r\n\t\t//\t|\t  d - date\r\n\t\t//\t|\t  a - am, pm\r\n\t\t//\t|\t   E, EE, EEE, EEEE  - week day\r\n\t\t//\t|\r\n\t\t//\t|\t    h, H, k, K, m, s, S,  -  time format\r\n\r\n\t\t// based on and similar to dojo.date.locale.parse\r\n\r\n\t\tvalue =  value.replace(/[\\u200E\\u200F\\u202A-\\u202E]/g, \"\"); //remove special chars\r\n\r\n\t\tif(!options){options={};}\r\n\t\tvar info = hlocale._parseInfo(options);\r\n\t\r\n\t\tvar tokens = info.tokens, bundle = info.bundle;\r\n\t\tvar re = new RegExp(\"^\" + info.regexp + \"$\");\r\n\t\r\n\t\tvar match = re.exec(value);\r\n\r\n\t\tvar locale = i18n.normalizeLocale(options.locale);\r\n\r\n\t\tif(!match){ return null; } // null\r\n\t\r\n\t\tvar date, date1;\r\n\t\r\n\t\t//var result = [1970,0,1,0,0,0,0]; //\r\n\t\tvar result = [5730,3,23,0,0,0,0];  // hebrew date for [1970,0,1,0,0,0,0] used in gregorian locale\r\n\t\tvar amPm = \"\";\r\n\t\tvar mLength = 0;\r\n\t\tvar widthList = [\"abbr\", \"wide\", \"narrow\"];\r\n\t\tvar valid = arr.every(match, function(v, i){\r\n\t\t\tif(!i){return true;}\r\n\t\t\tvar token=tokens[i-1];\r\n\t\t\tvar l=token.length;\r\n\t\t\tswitch(token.charAt(0)){\r\n\t\t\t\tcase 'y':\r\n\t\t\t\t\tif(locale.match(/^he(?:-.+)?$/)){\r\n\t\t\t\t\t\tresult[0] = numerals.parseYearHebrewLetters(v);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tresult[0] = Number(v);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'M':\r\n\t\t\t\t\t//if  it is short format, month is one letter or two letter with \"geresh\"\r\n\t\t\t\t\tif(l>2){\r\n\t\t\t\t\t\t//we do not know here if the year is leap or not\r\n\t\t\t\t\t\tvar months = hlocale.getNames('months', widthList[l-3], 'format', locale, new HDate(5769, 1, 1)),\r\n\t\t\t\t\t\t\tleapmonths = hlocale.getNames('months', widthList[l-3], 'format', locale, new HDate(5768, 1, 1));\r\n\t\t\t\t\t\tif(!options.strict){\r\n\t\t\t\t\t\t\t//Tolerate abbreviating period in month part\r\n\t\t\t\t\t\t\t//Case-insensitive comparison\r\n\t\t\t\t\t\t\tv = v.replace(\".\",\"\").toLowerCase();\r\n\t\t\t\t\t\t\tmonths = arr.map(months, function(s){ return s ? s.replace(\".\",\"\").toLowerCase() : s; } );\r\n\t\t\t\t\t\t\tleapmonths = arr.map(leapmonths, function(s){ return s ? s.replace(\".\",\"\").toLowerCase() : s; } );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar monthName = v;\r\n\t\t\t\t\t\tv = arr.indexOf(months, monthName);\r\n\t\t\t\t\t\tif(v == -1){\r\n\t\t\t\t\t\t\tv = arr.indexOf(leapmonths, monthName);\r\n\t\t\t\t\t\t\tif(v == -1){\r\n\t\t\t\t\t\t\t\t//console.debug(\"dojox.date.hebrew.locale.parse: Could not parse month name:  second   \" + v +\"'.\");\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmLength = l;\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tif(locale.match(/^he(?:-.+)?$/)){\r\n\t\t\t\t\t\t\tv = numerals.parseMonthHebrewLetters(v);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tv--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult[1] = Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'D':\r\n\t\t\t\t\tresult[1] = 0;\r\n\t\t\t\t\t// fallthrough...\r\n\t\t\t\tcase 'd':\r\n\t\t\t\t\tif(locale.match(/^he(?:-.+)?$/)){\r\n\t\t\t\t\t\tresult[2] = numerals.parseDayHebrewLetters(v);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tresult[2] = Number(v);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'a': //am/pm\r\n\t\t\t\t\tvar am = options.am || bundle['dayPeriods-format-wide-am'],\r\n\t\t\t\t\t\tpm = options.pm || bundle['dayPeriods-format-wide-pm'];\r\n\t\t\t\t\tif(!options.strict){\r\n\t\t\t\t\t\tvar period = /\\./g;\r\n\t\t\t\t\t\tv = v.replace(period,'').toLowerCase();\r\n\t\t\t\t\t\tam = am.replace(period,'').toLowerCase();\r\n\t\t\t\t\t\tpm = pm.replace(period,'').toLowerCase();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(options.strict && v != am && v != pm){\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// we might not have seen the hours field yet, so store the state and apply hour change later\r\n\t\t\t\t\tamPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'K': //hour (1-24)\r\n\t\t\t\t\tif(v == 24){ v = 0; }\r\n\t\t\t\t\t// fallthrough...\r\n\t\t\t\tcase 'h': //hour (1-12)\r\n\t\t\t\tcase 'H': //hour (0-23)\r\n\t\t\t\tcase 'k': //hour (0-11)\r\n\t\t\t\t\t//in the 12-hour case, adjusting for am/pm requires the 'a' part\r\n\t\t\t\t\t//which could come before or after the hour, so we will adjust later\r\n\t\t\t\t\tresult[3] = Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'm': //minutes\r\n\t\t\t\t\tresult[4] = Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 's': //seconds\r\n\t\t\t\t\tresult[5] = Number(v);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'S': //milliseconds\r\n\t\t\t\t\tresult[6] = Number(v);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t});\r\n\r\n\t\tvar hours = +result[3];\r\n\t\tif(amPm === 'p' && hours < 12){\r\n\t\t\tresult[3] = hours + 12; //e.g., 3pm -> 15\r\n\t\t}else if(amPm === 'a' && hours == 12){\r\n\t\t\tresult[3] = 0; //12am -> 0\r\n\t\t}\r\n\t\tvar dateObject = new HDate(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // hebrew.Date\r\n\t\t//for non leap year, the index of the short month start from adar should be increased by 1\r\n\t\tif(mLength < 3 && result[1] >= 5 && !dateObject.isLeapYear(dateObject.getFullYear())){\r\n\t\t\tdateObject.setMonth(result[1]+1);\r\n\t\t}\r\n\t\treturn dateObject; // hebrew.Date\r\n\t};\r\n\r\n\r\n\tfunction _processPattern(pattern, applyPattern, applyLiteral, applyAll){\r\n\t\t// summary:\r\n\t\t//\t\tProcess a pattern with literals in it\r\n\r\n\t\t// Break up on single quotes, treat every other one as a literal, except '' which becomes '\r\n\t\tvar identity = function(x){return x;};\r\n\t\tapplyPattern = applyPattern || identity;\r\n\t\tapplyLiteral = applyLiteral || identity;\r\n\t\tapplyAll = applyAll || identity;\r\n\r\n\t\t//split on single quotes (which escape literals in date format strings)\r\n\t\t//but preserve escaped single quotes (e.g., o''clock)\r\n\t\tvar chunks = pattern.match(/(''|[^'])+/g);\r\n\t\tvar literal = pattern.charAt(0) == \"'\";\r\n\r\n\t\tarr.forEach(chunks, function(chunk, i){\r\n\t\t\tif(!chunk){\r\n\t\t\t\tchunks[i]='';\r\n\t\t\t}else{\r\n\t\t\t\tchunks[i]=(literal ? applyLiteral : applyPattern)(chunk);\r\n\t\t\t\tliteral = !literal;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn applyAll(chunks.join(''));\r\n\t}\r\n\r\n\tfunction _buildDateTimeRE  (tokens, bundle, options, pattern){\r\n\t\t// based on and similar to dojo.date.locale._buildDateTimeRE\r\n\r\n\t\tpattern = regexp.escapeString(pattern);\r\n\t\tvar locale = i18n.normalizeLocale(options.locale);\r\n\t\r\n\t\treturn pattern.replace(/([a-z])\\1*/ig, function(match){\r\n\r\n\t\t\t\t// Build a simple regexp.  Avoid captures, which would ruin the tokens list\r\n\t\t\t\tvar s;\r\n\t\t\t\tvar c = match.charAt(0);\r\n\t\t\t\tvar l = match.length;\r\n\t\t\t\tvar p2 = '', p3 = '';\r\n\t\t\t\tif(options.strict){\r\n\t\t\t\t\tif(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }\r\n\t\t\t\t\tif(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }\r\n\t\t\t\t}else{\r\n\t\t\t\t\tp2 = '0?'; p3 = '0{0,2}';\r\n\t\t\t\t}\r\n\t\t\t\tswitch(c){\r\n\t\t\t\t\tcase 'y':\r\n\t\t\t\t\t\ts = '\\\\S+';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'M':\r\n\t\t\t\t\t\tif(locale.match('^he(?:-.+)?$')){\r\n\t\t\t\t\t\t\ts = (l>2) ? '\\\\S+ ?\\\\S+' : '\\\\S{1,4}';\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\ts = (l>2) ?  '\\\\S+ ?\\\\S+' : p2+'[1-9]|1[0-3]';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'd':\r\n\t\t\t\t\t\tif(locale.match('^he(?:-.+)?$')){\r\n\t\t\t\t\t\t\ts = '\\\\S[\\'\\\"\\'\\u05F3]{1,2}\\\\S?';\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\ts = '[12]\\\\d|'+p2+'[1-9]|30';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'E':\r\n\t\t\t\t\t\tif(locale.match('^he(?:-.+)?$')){\r\n\t\t\t\t\t\t\ts = (l>3) ? '\\\\S+ ?\\\\S+' : '\\\\S';\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\ts = '\\\\S+';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'h': //hour (1-12)\r\n\t\t\t\t\t\ts = p2+'[1-9]|1[0-2]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'k': //hour (0-11)\r\n\t\t\t\t\t\ts = p2+'\\\\d|1[01]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'H': //hour (0-23)\r\n\t\t\t\t\t\ts = p2+'\\\\d|1\\\\d|2[0-3]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'K': //hour (1-24)\r\n\t\t\t\t\t\ts = p2+'[1-9]|1\\\\d|2[0-4]';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'm':\r\n\t\t\t\t\tcase 's':\r\n\t\t\t\t\t\ts = p2+'\\\\d|[0-5]\\\\d';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'S':\r\n\t\t\t\t\t\ts = '\\\\d{'+l+'}';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'a':\r\n\t\t\t\t\t\tvar am = options.am || bundle['dayPeriods-format-wide-am'],\r\n\t\t\t\t\t\t\tpm = options.pm || bundle['dayPeriods-format-wide-pm'];\r\n\t\t\t\t\t\tif(options.strict){\r\n\t\t\t\t\t\t\ts = am + '|' + pm;\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\ts = am + '|' + pm;\r\n\t\t\t\t\t\t\tif(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }\r\n\t\t\t\t\t\t\tif(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\ts = \".*\";\r\n\t\t\t\t}\r\n\t\t\t\tif(tokens){ tokens.push(match); }\r\n\t\t\t\treturn \"(\" + s + \")\"; // add capture\r\n\t\t\t}).replace(/[\\xa0 ]/g, \"[\\\\s\\\\xa0]\"); // normalize whitespace.  Need explicit handling of \\xa0 for IE. */\r\n\t}\r\n\r\n\tvar _customFormats = [];\r\n\thlocale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){\r\n\t\t// summary:\r\n\t\t//\t\tAdd a reference to a bundle containing localized custom formats to be\r\n\t\t//\t\tused by date/time formatting and parsing routines.\r\n\t\t// description:\r\n\t\t//\t\tThe user may add custom localized formats where the bundle has properties following the\r\n\t\t//\t\tsame naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`\r\n\t\t//\t\tThe pattern string should match the format used by the CLDR.\r\n\t\t//\t\tSee dojo.date.locale.format() for details.\r\n\t\t//\t\tThe resources must be loaded by dojo.requireLocalization() prior to use\r\n\r\n\t\t_customFormats.push({pkg:packageName,name:bundleName});\r\n\t};\r\n\r\n\thlocale._getHebrewBundle = function(/*String*/locale){\r\n\t\tvar hebrew = {};\r\n\t\tarr.forEach(_customFormats, function(desc){\r\n\t\t\tvar bundle = i18n.getLocalization(desc.pkg, desc.name, locale);\r\n\t\t\thebrew = lang.mixin(hebrew, bundle);\r\n\t\t}, this);\r\n\t\treturn hebrew; /*Object*/\r\n\t};\r\n\r\n\thlocale.addCustomFormats(\"dojo.cldr\",\"hebrew\");\r\n\r\n\thlocale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale, /*dojox/date/hebrew/Date?*/date){\r\n\t\t// summary:\r\n\t\t//\t\tUsed to get localized strings from dojo.cldr for day or month names.\r\n\t\t// item:\r\n\t\t//\t\t'months' || 'days'\r\n\t\t// type:\r\n\t\t//\t\t'wide' || 'narrow' || 'abbr' (e.g. \"Monday\", \"Mon\", or \"M\" respectively, in English)\r\n\t\t// use:\r\n\t\t//\t\t'standAlone' || 'format' (default)\r\n\t\t// locale:\r\n\t\t//\t\toverride locale used to find the names\r\n\t\t// date:\r\n\t\t//\t\trequired for item=months to determine leap month name\r\n\r\n\t\t// using  var monthNames = dojox.date.hebrew.locale.getNames('months', 'wide', 'format', 'he', new hebrewDate(5768, 2, 12));\r\n\r\n\t\tvar label,\r\n\t\t\tlookup = hlocale._getHebrewBundle(locale),\r\n\t\t\tprops = [item, context, type];\r\n\t\tif(context == 'standAlone'){\r\n\t\t\tvar key = props.join('-');\r\n\t\t\tlabel = lookup[key];\r\n\t\t\t// Fall back to 'format' flavor of name\r\n\t\t\tif(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr\r\n\t\t}\r\n\t\tprops[1] = 'format';\r\n\t\r\n\t\t// return by copy so changes won't be made accidentally to the in-memory model\r\n\t\tvar result = (label || lookup[props.join('-')]).concat();\r\n\r\n\t\tif(item == \"months\"){\r\n\t\t\tif(date.isLeapYear(date.getFullYear())){\r\n\t\t\t\t// Adar I (6th position in the array) will be used.\r\n\t\t\t\t// Substitute the leap month Adar II for the regular Adar (7th position)\r\n\t\t\t\tprops.push(\"leap\");\r\n\t\t\t\tresult[6] = lookup[props.join('-')];\r\n\t\t\t}else{\r\n\t\t\t\t// Remove Adar I but leave an empty position in the array\r\n\t\t\t\tdelete result[5];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result; /*Array*/\r\n\t};\r\n\r\n\treturn hlocale;\r\n});\r\n"]}