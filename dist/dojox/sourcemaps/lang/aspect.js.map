{"version":3,"sources":["lang/aspect.js"],"names":["dojo","provide","context","d","aop","dojox","lang","aspect","ap","Array","prototype","contextStack","Advice","this","next_before","prev_before","next_around","prev_around","next_afterReturning","prev_afterReturning","next_afterThrowing","prev_afterThrowing","counter","extend","add","advice","dyn","isFunction","node","dynamic","_add","topic","subtopic","full","next","prev","remove","_remove","isEmpty","advise","obj","method","methods","j","length","t","RegExp","i","test","push","isArray","adviseRaw","advices","m","al","name","o","ao","x","ret","a","e","self","arguments","callee","instance","joinPoint","depth","around","dynAdvices","dynIndex","before","apply","target","proceed","afterThrowing","call","after","afterReturning","ls","_listeners","destroy","pop","targetName","unadvise","handle","empty","_listener","getDispatcher","getContext","getContextStack","c"],"mappings":"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","file":"../../lang/aspect.js","sourcesContent":["dojo.provide(\"dojox.lang.aspect\");\r\n\r\n(function(){\r\n\tvar d = dojo, aop = dojox.lang.aspect, ap = Array.prototype,\r\n\t\tcontextStack = [], context;\r\n\t\t\r\n\t// this class implements a topic-based double-linked list\r\n\tvar Advice = function(){\r\n\t\tthis.next_before = this.prev_before =\r\n\t\tthis.next_around = this.prev_around =\r\n\t\tthis.next_afterReturning = this.prev_afterReturning =\r\n\t\tthis.next_afterThrowing = this.prev_afterThrowing =\r\n\t\t\tthis;\r\n\t\tthis.counter = 0;\r\n\t};\r\n\td.extend(Advice, {\r\n\t\tadd: function(advice){\r\n\t\t\tvar dyn = d.isFunction(advice),\r\n\t\t\t\tnode = {advice: advice, dynamic: dyn};\r\n\t\t\tthis._add(node, \"before\", \"\", dyn, advice);\r\n\t\t\tthis._add(node, \"around\", \"\", dyn, advice);\r\n\t\t\tthis._add(node, \"after\", \"Returning\", dyn, advice);\r\n\t\t\tthis._add(node, \"after\", \"Throwing\", dyn, advice);\r\n\t\t\t++this.counter;\r\n\t\t\treturn node;\r\n\t\t},\r\n\t\t_add: function(node, topic, subtopic, dyn, advice){\r\n\t\t\tvar full = topic + subtopic;\r\n\t\t\tif(dyn || advice[topic] || (subtopic && advice[full])){\r\n\t\t\t\tvar next = \"next_\" + full, prev = \"prev_\" + full;\r\n\t\t\t\t(node[prev] = this[prev])[next] = node;\r\n\t\t\t\t(node[next] = this)[prev] = node;\r\n\t\t\t}\r\n\t\t},\r\n\t\tremove: function(node){\r\n\t\t\tthis._remove(node, \"before\");\r\n\t\t\tthis._remove(node, \"around\");\r\n\t\t\tthis._remove(node, \"afterReturning\");\r\n\t\t\tthis._remove(node, \"afterThrowing\");\r\n\t\t\t--this.counter;\r\n\t\t},\r\n\t\t_remove: function(node, topic){\r\n\t\t\tvar next = \"next_\" + topic, prev = \"prev_\" + topic;\r\n\t\t\tif(node[next]){\r\n\t\t\t\tnode[next][prev] = node[prev];\r\n\t\t\t\tnode[prev][next] = node[next];\r\n\t\t\t}\r\n\t\t},\r\n\t\tisEmpty: function(){\r\n\t\t\treturn !this.counter;\r\n\t\t}\r\n\t});\r\n\r\n\tvar getDispatcher = function(){\r\n\t\r\n\t\treturn function(){\r\n\t\t\t\r\n\t\t\tvar self = arguments.callee,\t// the join point\r\n\t\t\t\tadvices = self.advices,\t\t// list of advices for this joinpoint\r\n\t\t\t\tret, i, a, e, t;\r\n\r\n\t\t\t// push context\r\n\t\t\tif(context){ contextStack.push(context); }\r\n\t\t\tcontext = {\r\n\t\t\t\tinstance: this,\t\t\t\t\t// object instance\r\n\t\t\t\tjoinPoint: self,\t\t\t\t// join point\r\n\t\t\t\tdepth: contextStack.length,\t\t// current level of depth starting from 0\r\n\t\t\t\taround: advices.prev_around,\t// pointer to the current around advice\r\n\t\t\t\tdynAdvices: [],\t\t\t\t\t// array of dynamic advices if any\r\n\t\t\t\tdynIndex: 0\t\t\t\t\t\t// index of a dynamic advice\r\n\t\t\t};\r\n\r\n\t\t\ttry{\r\n\t\t\t\t// process before events\r\n\t\t\t\tfor(i = advices.prev_before; i != advices; i = i.prev_before){\r\n\t\t\t\t\tif(i.dynamic){\r\n\t\t\t\t\t\t// instantiate a dynamic advice\r\n\t\t\t\t\t\tcontext.dynAdvices.push(a = new i.advice(context));\r\n\t\t\t\t\t\tif(t = a.before){ // intentional assignment\r\n\t\t\t\t\t\t\tt.apply(a, arguments);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tt = i.advice;\r\n\t\t\t\t\t\tt.before.apply(t, arguments);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// process around and after events\r\n\t\t\t\ttry{\r\n\t\t\t\t\t// call the around advice or the original method\r\n\t\t\t\t\tret = (advices.prev_around == advices ? self.target : aop.proceed).apply(this, arguments);\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\t// process after throwing and after events\r\n\t\t\t\t\tcontext.dynIndex = context.dynAdvices.length;\r\n\t\t\t\t\tfor(i = advices.next_afterThrowing; i != advices; i = i.next_afterThrowing){\r\n\t\t\t\t\t\ta = i.dynamic ? context.dynAdvices[--context.dynIndex] : i.advice;\r\n\t\t\t\t\t\tif(t = a.afterThrowing){ // intentional assignment\r\n\t\t\t\t\t\t\tt.call(a, e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(t = a.after){ // intentional assignment\r\n\t\t\t\t\t\t\tt.call(a);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// continue the exception processing\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t\t// process after returning and after events\r\n\t\t\t\tcontext.dynIndex = context.dynAdvices.length;\r\n\t\t\t\tfor(i = advices.next_afterReturning; i != advices; i = i.next_afterReturning){\r\n\t\t\t\t\ta = i.dynamic ? context.dynAdvices[--context.dynIndex] : i.advice;\r\n\t\t\t\t\tif(t = a.afterReturning){ // intentional assignment\r\n\t\t\t\t\t\tt.call(a, ret);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(t = a.after){ // intentional assignment\r\n\t\t\t\t\t\tt.call(a);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// process dojo.connect() listeners\r\n\t\t\t\tvar ls = self._listeners;\r\n\t\t\t\tfor(i in ls){\r\n\t\t\t\t\tif(!(i in ap)){\r\n\t\t\t\t\t\tls[i].apply(this, arguments);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}finally{\r\n\t\t\t\t// destroy dynamic advices\r\n\t\t\t\tfor(i = 0; i < context.dynAdvices.length; ++i){\r\n\t\t\t\t\ta = context.dynAdvices[i];\r\n\t\t\t\t\tif(a.destroy){\r\n\t\t\t\t\t\ta.destroy();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// pop context\r\n\t\t\t\tcontext = contextStack.length ? contextStack.pop() : null;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn ret;\r\n\t\t};\r\n\t};\r\n\r\n\taop.advise = function(/*Object*/ obj,\r\n\t\t\t\t\t\t/*String|RegExp|Array*/ method,\r\n\t\t\t\t\t\t/*Object|Function|Array*/ advice\r\n\t\t\t\t\t\t){\r\n\t\t// summary:\r\n\t\t//\t\tAttach AOP-style advices to a method.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tAttaches AOP-style advices to a method. Can attach several\r\n\t\t//\t\tadvices at once and operate on several methods of an object.\r\n\t\t//\t\tThe latter is achieved when a RegExp is specified as\r\n\t\t//\t\ta method name, or an array of strings and regular expressions\r\n\t\t//\t\tis used. In this case all functional methods that\r\n\t\t//\t\tsatisfy the RegExp condition are processed. This function\r\n\t\t//\t\treturns a handle, which can be used to unadvise, or null,\r\n\t\t//\t\tif advising has failed.\r\n\t\t//\r\n\t\t//\t\tThis function is a convenience wrapper for\r\n\t\t//\t\tdojox.lang.aspect.adviseRaw().\r\n\t\t//\r\n\t\t// obj:\r\n\t\t//\t\tA source object for the advised function. Cannot be a DOM node.\r\n\t\t//\t\tIf this object is a constructor, its prototype is advised.\r\n\t\t//\r\n\t\t// method:\r\n\t\t//\t\tA string name of the function in obj. In case of RegExp all\r\n\t\t//\t\tmethods of obj matching the regular expression are advised.\r\n\t\t//\r\n\t\t// advice:\r\n\t\t//\t\tAn object, which defines advises, or a function, which\r\n\t\t//\t\treturns such object, or an array of previous items.\r\n\t\t//\t\tThe advice object can define following member functions:\r\n\t\t//\t\tbefore, around, afterReturning, afterThrowing, after.\r\n\t\t//\t\tIf the function is supplied, it is called with a context\r\n\t\t//\t\tobject once per call to create a temporary advice object, which\r\n\t\t//\t\tis destroyed after the processing. The temporary advice object\r\n\t\t//\t\tcan implement a destroy() method, if it wants to be called when\r\n\t\t//\t\tnot needed.\r\n\t\t\r\n\t\tif(typeof obj != \"object\"){\r\n\t\t\tobj = obj.prototype;\r\n\t\t}\r\n\r\n\t\tvar methods = [];\r\n\t\tif(!(method instanceof Array)){\r\n\t\t\tmethod = [method];\r\n\t\t}\r\n\t\t\r\n\t\t// identify advised methods\r\n\t\tfor(var j = 0; j < method.length; ++j){\r\n\t\t\tvar t = method[j];\r\n\t\t\tif(t instanceof RegExp){\r\n\t\t\t\tfor(var i in obj){\r\n\t\t\t\t\tif(d.isFunction(obj[i]) && t.test(i)){\r\n\t\t\t\t\t\tmethods.push(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif(d.isFunction(obj[t])){\r\n\t\t\t\t\tmethods.push(t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(!d.isArray(advice)){ advice = [advice]; }\r\n\r\n\t\treturn aop.adviseRaw(obj, methods, advice);\t// Object\r\n\t};\r\n\t\r\n\taop.adviseRaw = function(/*Object*/ obj,\r\n\t\t\t\t\t\t/*Array*/ methods,\r\n\t\t\t\t\t\t/*Array*/ advices\r\n\t\t\t\t\t\t){\r\n\t\t// summary:\r\n\t\t//\t\tAttach AOP-style advices to methods.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tAttaches AOP-style advices to object's methods. Can attach several\r\n\t\t//\t\tadvices at once and operate on several methods of the object.\r\n\t\t//\t\tThe latter is achieved when a RegExp is specified as\r\n\t\t//\t\ta method name. In this case all functional methods that\r\n\t\t//\t\tsatisfy the RegExp condition are processed. This function\r\n\t\t//\t\treturns a handle, which can be used to unadvise, or null,\r\n\t\t//\t\tif advising has failed.\r\n\t\t//\r\n\t\t// obj:\r\n\t\t//\t\tA source object for the advised function.\r\n\t\t//\t\tCannot be a DOM node.\r\n\t\t//\r\n\t\t// methods:\r\n\t\t//\t\tAn array of method names (strings) to be advised.\r\n\t\t//\r\n\t\t// advices:\r\n\t\t//\t\tAn array of advices represented by objects or functions that\r\n\t\t//\t\treturn such objects on demand during the event processing.\r\n\t\t//\t\tThe advice object can define following member functions:\r\n\t\t//\t\tbefore, around, afterReturning, afterThrowing, after.\r\n\t\t//\t\tIf the function is supplied, it is called with a context\r\n\t\t//\t\tobject once per call to create a temporary advice object, which\r\n\t\t//\t\tis destroyed after the processing. The temporary advice object\r\n\t\t//\t\tcan implement a destroy() method, if it wants to be called when\r\n\t\t//\t\tnot needed.\r\n\r\n\t\tif(!methods.length || !advices.length){ return null; }\r\n\t\t\r\n\t\t// attach advices\r\n\t\tvar m = {}, al = advices.length;\r\n\t\tfor(var i = methods.length - 1; i >= 0; --i){\r\n\t\t\tvar name = methods[i], o = obj[name], ao = new Array(al), t = o.advices;\r\n\t\t\t// create a stub, if needed\r\n\t\t\tif(!t){\r\n\t\t\t\tvar x = obj[name] = getDispatcher();\r\n\t\t\t\tx.target = o.target || o;\r\n\t\t\t\tx.targetName = name;\r\n\t\t\t\tx._listeners = o._listeners || [];\r\n\t\t\t\tx.advices = new Advice;\r\n\t\t\t\tt = x.advices;\r\n\t\t\t}\r\n\t\t\t// attach advices\r\n\t\t\tfor(var j = 0; j < al; ++j){\r\n\t\t\t\tao[j] = t.add(advices[j]);\r\n\t\t\t}\r\n\t\t\tm[name] = ao;\r\n\t\t}\r\n\t\t\r\n\t\treturn [obj, m];\t// Object\r\n\t};\r\n\r\n\taop.unadvise = function(/*Object*/ handle){\r\n\t\t// summary:\r\n\t\t//\t\tDetach previously attached AOP-style advices.\r\n\t\t//\r\n\t\t// handle:\r\n\t\t//\t\tThe object returned by dojox.lang.aspect.advise().\r\n\t\t\r\n\t\tif(!handle){ return; }\r\n\t\tvar obj = handle[0], methods = handle[1];\r\n\t\tfor(var name in methods){\r\n\t\t\tvar o = obj[name], t = o.advices, ao = methods[name];\r\n\t\t\tfor(var i = ao.length - 1; i >= 0; --i){\r\n\t\t\t\tt.remove(ao[i]);\r\n\t\t\t}\r\n\t\t\tif(t.isEmpty()){\r\n\t\t\t\t// check if we can remove all stubs\r\n\t\t\t\tvar empty = true, ls = o._listeners;\r\n\t\t\t\tif(ls.length){\r\n\t\t\t\t\tfor(i in ls){\r\n\t\t\t\t\t\tif(!(i in ap)){\r\n\t\t\t\t\t\t\tempty = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(empty){\r\n\t\t\t\t\t// revert to the original method\r\n\t\t\t\t\tobj[name] = o.target;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// replace with the dojo.connect() stub\r\n\t\t\t\t\tvar x = obj[name] = d._listener.getDispatcher();\r\n\t\t\t\t\tx.target = o.target;\r\n\t\t\t\t\tx._listeners = ls;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\taop.getContext = function(){\r\n\t\t// summary:\r\n\t\t//\t\tReturns the context information for the advice in effect.\r\n\t\t\r\n\t\treturn context;\t// Object\r\n\t};\r\n\t\r\n\taop.getContextStack = function(){\r\n\t\t// summary:\r\n\t\t//\t\tReturns the context stack, which reflects executing advices\r\n\t\t//\t\tup to this point. The array is ordered from oldest to newest.\r\n\t\t//\t\tIn order to get the active context use dojox.lang.aspect.getContext().\r\n\t\t\r\n\t\treturn contextStack;\t// Array\r\n\t};\r\n\t\r\n\taop.proceed = function(){\r\n\t\t// summary:\r\n\t\t//\t\tCall the original function (or the next level around advice) in an around advice code.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tCalls the original function (or the next level around advice).\r\n\t\t//\t\tAccepts and passes on any number of arguments, and returns a value.\r\n\t\t//\t\tThis function is valid only in the content of around calls.\r\n\t\t\r\n\t\tvar joinPoint = context.joinPoint, advices = joinPoint.advices;\r\n\t\tfor(var c = context.around; c != advices; c = context.around){\r\n\t\t\tcontext.around = c.prev_around;\t// advance the pointer\r\n\t\t\tif(c.dynamic){\r\n\t\t\t\tvar a = context.dynAdvices[context.dynIndex++], t = a.around;\r\n\t\t\t\tif(t){\r\n\t\t\t\t\treturn t.apply(a, arguments);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\treturn c.advice.around.apply(c.advice, arguments);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn joinPoint.target.apply(context.instance, arguments);\r\n\t};\r\n})();\r\n\r\n/*\r\nAspect = {\r\n\tbefore: function(arguments){...},\r\n\taround: function(arguments){...returns value...},\r\n\tafterReturning: function(ret){...},\r\n\tafterThrowing: function(excp){...},\r\n\tafter: function(){...}\r\n};\r\n\r\nContext = {\r\n\tinstance:  ..., // the instance we operate on\r\n\tjoinPoint: ...,\t// Object (see below)\r\n\tdepth:     ...\t// current depth of the context stack\r\n};\r\n\r\nJoinPoint = {\r\n\ttarget:     ...,\t// the original function being wrapped\r\n\ttargetName: ...\t\t// name of the method\r\n};\r\n*/\r\n"]}