{"version":3,"sources":["lang/functional/linrec.js"],"names":["dojo","provide","require","df","dojox","lang","functional","inline","inlineLambda","_r_y_a","linrec","cond","then","before","after","c","t","b","a","cs","ts","bs","as","dict1","dict2","add2dict","x","lambda","locals1","keys","locals2","f","Function","concat","length","join"],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,gCAEbD,KAAKE,QAAQ,gCACbF,KAAKE,QAAQ,8BAcb,WACC,IAAIC,EAAKC,MAAMC,KAAKC,WAAYC,EAASJ,EAAGK,aACjCC,GAAU,KAAM,QAE3BN,EAAGO,OAAS,SACkBC,EACAC,EACAC,EACAC,GAwB7B,IAAIC,EAAGC,EAAGC,EAAGC,EAAGC,EAAIC,EAAIC,EAAIC,EAAIC,KAAYC,KAC3CC,EAAW,SAASC,GAAIH,EAAMG,GAAK,GAClB,iBAARf,EACTQ,EAAKZ,EAAOI,EAjCT,KAiCmBc,IAEtBV,EAAIZ,EAAGwB,OAAOhB,GACdQ,EAAK,qBACLK,EAAM,WAAa,GAEF,iBAARZ,EACTQ,EAAKb,EAAOK,EAxCT,KAwCmBa,IAEtBT,EAAIb,EAAGwB,OAAOf,GACdQ,EAAK,wBAEc,iBAAVP,EACTQ,EAAKd,EAAOM,EA9CT,KA8CqBY,IAExBR,EAAId,EAAGwB,OAAOd,GACdQ,EAAK,qBACLG,EAAM,WAAa,GAED,iBAATV,EACTQ,EAAKf,EAAOO,EAAOL,EAAQgB,IAE3BP,EAAIf,EAAGwB,OAAOb,GACdQ,EAAK,0BACLE,EAAM,WAAa,GAEpB,IAAII,EAAUzB,EAAG0B,KAAKN,GAAQO,EAAU3B,EAAG0B,KAAKL,GAC/CO,EAAI,IAAIC,YAAa,yBAAyBC,OAC7CL,EAAQM,OAAS,IAAMN,EAAQO,KAAK,KAAO,GAC3CL,EAAQI,OAAS,iBAAmBJ,EAAQK,KAAK,KAAOnB,EAAI,gBAAkB,GAC9E,UACAG,EACA,OACAE,EACA,uBACAD,EACA,wBACAE,EACA,eAMF,OAJGP,IAAIgB,EAAEhB,EAAIA,GACVC,IAAIe,EAAEf,EAAIA,GACVC,IAAIc,EAAEd,EAAIA,GACVC,IAAIa,EAAEb,EAAIA,GACNa,GA/ET","file":"../../../lang/functional/linrec.js","sourcesContent":["dojo.provide(\"dojox.lang.functional.linrec\");\r\n\r\ndojo.require(\"dojox.lang.functional.lambda\");\r\ndojo.require(\"dojox.lang.functional.util\");\r\n\r\n// This module provides recursion combinators:\r\n//\t- a linear recursion combinator.\r\n\r\n// Acknowledgements:\r\n//\t- recursion combinators are inspired by Manfred von Thun's article\r\n//\t\t\"Recursion Theory and Joy\"\r\n//\t\t(http://www.latrobe.edu.au/philosophy/phimvt/joy/j05cmp.html)\r\n\r\n// Notes:\r\n//\t- recursion combinators produce a function, which implements\r\n//\ttheir respective recusion patterns. String lambdas are inlined, if possible.\r\n\r\n(function(){\r\n\tvar df = dojox.lang.functional, inline = df.inlineLambda,\r\n\t\t_x =\"_x\", _r_y_a = [\"_r\", \"_y.a\"];\r\n\r\n\tdf.linrec = function(\r\n\t\t\t\t\t/*Function|String|Array*/ cond,\r\n\t\t\t\t\t/*Function|String|Array*/ then,\r\n\t\t\t\t\t/*Function|String|Array*/ before,\r\n\t\t\t\t\t/*Function|String|Array*/ after){\r\n\t\t// summary:\r\n\t\t//\t\tGenerates a function for the linear recursion pattern.\r\n\t\t//\t\tAll parameter functions are called in the context of \"this\" object.\r\n\t\t// cond:\r\n\t\t//\t\tThe lambda expression, which is used to detect the termination of recursion.\r\n\t\t//\t\tIt accepts the same parameter as the generated recursive function itself.\r\n\t\t//\t\tThis function should return \"true\", if the recursion should be stopped,\r\n\t\t//\t\tand the \"then\" part should be executed. Otherwise the recursion will proceed.\r\n\t\t// then:\r\n\t\t//\t\tThe lambda expression, which is called upon termination of the recursion.\r\n\t\t//\t\tIt accepts the same parameters as the generated recursive function itself.\r\n\t\t//\t\tThe returned value will be returned as the value of the generated function.\r\n\t\t// before:\r\n\t\t//\t\tThe lambda expression, which is called before the recursive step.\r\n\t\t//\t\tIt accepts the same parameter as the generated recursive function itself.\r\n\t\t//\t\tThe returned value should be an array, which is used to call\r\n\t\t//\t\tthe generated function recursively.\r\n\t\t// above:\r\n\t\t//\t\tThe lambda expression, which is called after the recursive step.\r\n\t\t//\t\tIt accepts two parameters: the returned value from the recursive step, and\r\n\t\t//\t\tthe original array of parameters used with all other functions.\r\n\t\t//\t\tThe returned value will be returned as the value of the generated function.\r\n\r\n\t\tvar c, t, b, a, cs, ts, bs, as, dict1 = {}, dict2 = {},\r\n\t\t\tadd2dict = function(x){ dict1[x] = 1; };\r\n\t\tif(typeof cond == \"string\"){\r\n\t\t\tcs = inline(cond, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tc = df.lambda(cond);\r\n\t\t\tcs = \"_c.apply(this, _x)\";\r\n\t\t\tdict2[\"_c=_t.c\"] = 1;\r\n\t\t}\r\n\t\tif(typeof then == \"string\"){\r\n\t\t\tts = inline(then, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tt = df.lambda(then);\r\n\t\t\tts = \"_t.t.apply(this, _x)\";\r\n\t\t}\r\n\t\tif(typeof before == \"string\"){\r\n\t\t\tbs = inline(before, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tb = df.lambda(before);\r\n\t\t\tbs = \"_b.apply(this, _x)\";\r\n\t\t\tdict2[\"_b=_t.b\"] = 1;\r\n\t\t}\r\n\t\tif(typeof after == \"string\"){\r\n\t\t\tas = inline(after, _r_y_a, add2dict);\r\n\t\t}else{\r\n\t\t\ta = df.lambda(after);\r\n\t\t\tas = \"_a.call(this, _r, _y.a)\";\r\n\t\t\tdict2[\"_a=_t.a\"] = 1;\r\n\t\t}\r\n\t\tvar locals1 = df.keys(dict1), locals2 = df.keys(dict2),\r\n\t\t\tf = new Function([], \"var _x=arguments,_y,_r\".concat(\t// Function\r\n\t\t\t\tlocals1.length ? \",\" + locals1.join(\",\") : \"\",\r\n\t\t\t\tlocals2.length ? \",_t=_x.callee,\" + locals2.join(\",\") : t ? \",_t=_x.callee\" : \"\",\r\n\t\t\t\t\";for(;!\",\r\n\t\t\t\tcs,\r\n\t\t\t\t\";_x=\",\r\n\t\t\t\tbs,\r\n\t\t\t\t\"){_y={p:_y,a:_x}}_r=\",\r\n\t\t\t\tts,\r\n\t\t\t\t\";for(;_y;_y=_y.p){_r=\",\r\n\t\t\t\tas,\r\n\t\t\t\t\"}return _r\"\r\n\t\t\t));\r\n\t\tif(c){ f.c = c; }\r\n\t\tif(t){ f.t = t; }\r\n\t\tif(b){ f.b = b; }\r\n\t\tif(a){ f.a = a; }\r\n\t\treturn f;\r\n\t};\r\n})();\r\n\r\n/*\r\nFor documentation only:\r\n\r\n1) The original recursive version:\r\n\r\nvar linrec1 = function(cond, then, before, after){\r\n\tvar cond   = df.lambda(cond),\r\n\t\tthen   = df.lambda(then),\r\n\t\tbefore = df.lambda(before),\r\n\t\tafter  = df.lambda(after);\r\n\treturn function(){\r\n\t\tif(cond.apply(this, arguments)){\r\n\t\t\treturn then.apply(this, arguments);\r\n\t\t}\r\n\t\tvar args = before.apply(this, arguments);\r\n\t\tvar ret  = arguments.callee.apply(this, args);\r\n\t\treturn after.call(this, ret, arguments);\r\n\t};\r\n};\r\n\r\n2) The original iterative version (before minification and inlining):\r\n\r\nvar linrec2 = function(cond, then, before, after){\r\n\tvar cond   = df.lambda(cond),\r\n\t\tthen   = df.lambda(then),\r\n\t\tbefore = df.lambda(before),\r\n\t\tafter  = df.lambda(after);\r\n\treturn function(){\r\n\t\tvar args = arguments, top, ret;\r\n\t\t// 1st part\r\n\t\tfor(; !cond.apply(this, args); args = before.apply(this, args)){\r\n\t\t\ttop = {prev: top, args: args};\r\n\t\t}\r\n\t\tret = then.apply(this, args);\r\n\t\t//2nd part\r\n\t\tfor(; top; top = top.prev){\r\n\t\t\tret = after.call(this, ret, top.args);\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n};\r\n\r\n*/"]}