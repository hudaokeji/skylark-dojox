{"version":3,"sources":["lang/functional/numrec.js"],"names":["dojo","provide","require","df","dojox","lang","functional","inline","inlineLambda","_r_i","numrec","then","after","a","as","dict","x","lambda","locals","keys","f","Function","concat","length","join","t"],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,gCAEbD,KAAKE,QAAQ,gCACbF,KAAKE,QAAQ,8BAcb,WACC,IAAIC,EAAKC,MAAMC,KAAKC,WAAYC,EAASJ,EAAGK,aAC3CC,GAAQ,KAAM,MAEfN,EAAGO,OAAS,SAAoBC,EAAgCC,GAsB/D,IAAIC,EAAGC,EAAIC,KAEQ,iBAATH,EACTE,EAAKP,EAAOK,EAAOH,EAFR,SAASO,GAAID,EAAKC,GAAK,KAIlCH,EAAIV,EAAGc,OAAOL,GACdE,EAAK,yBAEN,IAAII,EAASf,EAAGgB,KAAKJ,GACpBK,EAAI,IAAIC,UAAU,MAAO,qCAAqCC,OAC7DJ,EAAOK,OAAS,IAAML,EAAOM,KAAK,KAAO,GACzCX,EAAI,WAAa,GACjB,6BACAC,EACA,eAIF,OAFAM,EAAEK,EAAId,EACHE,IAAIO,EAAEP,EAAIA,GACNO,GA5CT","file":"../../../lang/functional/numrec.js","sourcesContent":["dojo.provide(\"dojox.lang.functional.numrec\");\r\n\r\ndojo.require(\"dojox.lang.functional.lambda\");\r\ndojo.require(\"dojox.lang.functional.util\");\r\n\r\n// This module provides recursion combinators:\r\n//\t- a simplified numeric linear recursion combinator.\r\n\r\n// Acknowledgements:\r\n//\t- recursion combinators are inspired by Manfred von Thun's article\r\n//\t\t\"Recursion Theory and Joy\"\r\n//\t\t(http://www.latrobe.edu.au/philosophy/phimvt/joy/j05cmp.html)\r\n\r\n// Notes:\r\n//\t- recursion combinators produce a function, which implements\r\n//\ttheir respective recusion patterns. String lambdas are inlined, if possible.\r\n\r\n(function(){\r\n\tvar df = dojox.lang.functional, inline = df.inlineLambda,\r\n\t\t_r_i = [\"_r\", \"_i\"];\r\n\r\n\tdf.numrec = function(/*Object*/ then, /*Function|String|Array*/ after){\r\n\t\t// summary:\r\n\t\t//\t\tGenerates a function for the simplified numeric linear recursion pattern.\r\n\t\t//\t\tAll parameter functions are called in the context of \"this\" object.\r\n\t\t// description:\r\n\t\t//\t\tThis is a simplification of the linear recursion combinator:\r\n\t\t//\t\t- the generated function takes one numeric parameter \"x\",\r\n\t\t//\t\t- the \"cond\" is fixed and checks for 0.\r\n\t\t//\t\t- the \"before\" is fixed and the generated function is called with \"x - 1\".\r\n\t\t//\t\t- the \"above is called with two parameters: the return from the generated\r\n\t\t//\t\tfunction, and with \"x\".\r\n\t\t//\t\t- as you can see the recursion is done by decreasing the parameter,\r\n\t\t//\t\tand calling itself until it reaches 0.\r\n\t\t// then:\r\n\t\t//\t\tThe value, which is used upon termination of the recursion.\r\n\t\t//\t\tIt will be returned as the value of the generated function.\r\n\t\t// above:\r\n\t\t//\t\tThe lambda expression, which is called after the recursive step.\r\n\t\t//\t\tIt accepts two parameters: the returned value from the recursive step, and\r\n\t\t//\t\tthe original parameter. The returned value will be returned as the value of\r\n\t\t//\t\tthe generated function.\r\n\r\n\t\tvar a, as, dict = {},\r\n\t\t\tadd2dict = function(x){ dict[x] = 1; };\r\n\t\tif(typeof after == \"string\"){\r\n\t\t\tas = inline(after, _r_i, add2dict);\r\n\t\t}else{\r\n\t\t\ta = df.lambda(after);\r\n\t\t\tas = \"_a.call(this, _r, _i)\";\r\n\t\t}\r\n\t\tvar locals = df.keys(dict),\r\n\t\t\tf = new Function([\"_x\"], \"var _t=arguments.callee,_r=_t.t,_i\".concat(\t// Function\r\n\t\t\t\tlocals.length ? \",\" + locals.join(\",\") : \"\",\r\n\t\t\t\ta ? \",_a=_t.a\" : \"\",\r\n\t\t\t\t\";for(_i=1;_i<=_x;++_i){_r=\",\r\n\t\t\t\tas,\r\n\t\t\t\t\"}return _r\"\r\n\t\t\t));\r\n\t\tf.t = then;\r\n\t\tif(a){ f.a = a; }\r\n\t\treturn f;\r\n\t};\r\n})();\r\n\r\n/*\r\nFor documentation only:\r\n\r\n1) The original recursive version:\r\n\r\nvar numrec1 = function(then, after){\r\n\tvar after = df.lambda(after);\r\n\treturn function(x){\r\n\t\treturn x ? after.call(this, arguments.callee.call(this, x - 1), x) : then;\r\n\t};\r\n};\r\n\r\n2) The original iterative version (before minification and inlining):\r\n\r\nvar numrec2 = function(then, after){\r\n\tvar after = df.lambda(after);\r\n\treturn function(x){\r\n\t\tvar ret = then, i;\r\n\t\tfor(i = 1; i <= x; ++i){\r\n\t\t\tret = after.call(this, ret, i);\r\n\t\t}\r\n\t\treturn ret;\r\n\t};\r\n};\r\n\r\n*/"]}