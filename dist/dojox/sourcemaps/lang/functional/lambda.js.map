{"version":3,"sources":["lang/functional/lambda.js"],"names":["define","dojox","lang","arr","df","getObject","lcache","split","length","String","prototype","sep","r","this","call","m","exec","index","unshift","lambda","s","args","sects","pop","push","join","match","l","vars","replace","t","forEach","v","hasOwnProperty","body","mixin","rawLambda","buildLambda","Array","a","i","x","apply","arguments","Function","clearLambdaCache"],"mappings":";;;;;;;AAAAA,QAAQ,QAAS,kBAAmB,oBAAqB,SAASC,EAAOC,EAAMC,GAC9E,IAAIC,EAAKF,EAAKG,UAAU,mBAAmB,EAAMJ,GAmB7CK,KAGAC,EAAQ,KAAKA,MAAM,MAAMC,OAAS,EAAIC,OAAOC,UAAUH,MACzD,SAASI,GACP,IAAIC,EAAIC,KAAKN,MAAMO,KAAKD,KAAMF,GAC7BI,EAAIJ,EAAIK,KAAKH,MAEd,OADGE,GAAgB,GAAXA,EAAEE,OAAaL,EAAEM,QAAQ,IAC1BN,GAGPO,EAAS,SAAoBC,GAChC,IAAIC,KAAWC,EAAQf,EAAMO,KAAKM,EAAG,aACrC,GAAGE,EAAMd,OAAS,EACjB,KAAMc,EAAMd,QACXY,EAAIE,EAAMC,MACVF,EAAOC,EAAMC,MAAMhB,MAAM,gBACtBe,EAAMd,QAASc,EAAME,KAAK,aAAeH,EAAKI,KAAK,MAAQ,cAAgBL,EAAI,cAE9E,GAAGA,EAAEM,MAAM,SAChBL,GAAQ,SACJ,CACJ,IAAIM,EAAIP,EAAEM,MAAM,gCACfd,EAAIQ,EAAEM,MAAM,4BACb,GAAGC,GAAKf,EACJe,IACFN,EAAKG,KAAK,MACVJ,EAAI,KAAOA,GAETR,IACFS,EAAKG,KAAK,MACVJ,GAAQ,UAEL,CAGJ,IAAIQ,EAAOR,EACVS,QAAQ,uUAAwU,IAChVH,MAAM,6BAAgCI,KACvC3B,EAAI4B,QAAQH,EAAM,SAASI,GACtBF,EAAEG,eAAeD,KACpBX,EAAKG,KAAKQ,GACVF,EAAEE,GAAK,MAKX,OAAQX,KAAMA,EAAMa,KAAMd,IA+D3B,OAhDAlB,EAAKiC,MAAM/B,GAEVgC,UAAW,SAAoBhB,GAU9B,OAAOD,EAAOC,IAEfiB,YAAa,SAAoBjB,GAShC,IAAIO,EAAIR,EAAOC,GACf,MAAO,YAAcO,EAAEN,KAAKI,KAAK,KAAO,aAAeE,EAAEO,KAAO,OAEjEf,OAAQ,SAAmCC,GAS1C,GAAe,mBAALA,EAAkB,OAAOA,EACnC,GAAGA,aAAakB,MAAQ,OAhDOC,EAgDQnB,GA/C/BZ,OACN,WACC,IAAIgC,EAAID,EAAE/B,OAAS,EAAGiC,EAAIrC,EAAGe,OAAOoB,EAAEC,IAAIE,MAAM7B,KAAM8B,WACtD,MAAMH,EAAGA,GAAK,IAAKA,EAAIC,EAAIrC,EAAGe,OAAOoB,EAAEC,IAAI1B,KAAKD,KAAM4B,GACtD,OAAOA,GAIR,SAASA,GAAI,OAAOA,GATV,IAAmBF,EAiD/B,GAAGjC,EAAO2B,eAAeb,GAAK,OAAOd,EAAOc,GAC5C,IAAIO,EAAIR,EAAOC,GACf,OAAOd,EAAOc,GAAK,IAAIwB,SAASjB,EAAEN,KAAM,WAAaM,EAAEO,KAAO,OAE/DW,iBAAkB,WAGjBvC,QAIKF","file":"../../../lang/functional/lambda.js","sourcesContent":["define([\"../..\", \"dojo/_base/lang\", \"dojo/_base/array\"], function(dojox, lang, arr){\r\n\tvar df = lang.getObject(\"lang.functional\", true, dojox);\r\n\r\n// This module adds high-level functions and related constructs:\r\n//\t- anonymous functions built from the string\r\n\r\n// Acknowledgements:\r\n//\t- lambda() is based on work by Oliver Steele\r\n//\t\t(http://osteele.com/sources/javascript/functional/functional.js)\r\n//\t\twhich was published under MIT License\r\n\r\n// Notes:\r\n//\t- lambda() produces functions, which after the compilation step are\r\n//\t\tas fast as regular JS functions (at least theoretically).\r\n\r\n// Lambda input values:\r\n//\t- returns functions unchanged\r\n//\t- converts strings to functions\r\n//\t- converts arrays to a functional composition\r\n\r\n\tvar lcache = {};\r\n\r\n\t// split() is augmented on IE6 to ensure the uniform behavior\r\n\tvar split = \"ab\".split(/a*/).length > 1 ? String.prototype.split :\r\n\t\t\tfunction(sep){\r\n\t\t\t\t var r = this.split.call(this, sep),\r\n\t\t\t\t\t m = sep.exec(this);\r\n\t\t\t\t if(m && m.index == 0){ r.unshift(\"\"); }\r\n\t\t\t\t return r;\r\n\t\t\t};\r\n\t\t\t\r\n\tvar lambda = function(/*String*/ s){\r\n\t\tvar args = [], sects = split.call(s, /\\s*->\\s*/m);\r\n\t\tif(sects.length > 1){\r\n\t\t\twhile(sects.length){\r\n\t\t\t\ts = sects.pop();\r\n\t\t\t\targs = sects.pop().split(/\\s*,\\s*|\\s+/m);\r\n\t\t\t\tif(sects.length){ sects.push(\"(function(\" + args.join(\", \") + \"){ return (\" + s + \"); })\"); }\r\n\t\t\t}\r\n\t\t}else if(s.match(/\\b_\\b/)){\r\n\t\t\targs = [\"_\"];\r\n\t\t}else{\r\n\t\t\tvar l = s.match(/^\\s*(?:[+*\\/%&|\\^\\.=<>]|!=)/m),\r\n\t\t\t\tr = s.match(/[+\\-*\\/%&|\\^\\.=<>!]\\s*$/m);\r\n\t\t\tif(l || r){\r\n\t\t\t\tif(l){\r\n\t\t\t\t\targs.push(\"$1\");\r\n\t\t\t\t\ts = \"$1\" + s;\r\n\t\t\t\t}\r\n\t\t\t\tif(r){\r\n\t\t\t\t\targs.push(\"$2\");\r\n\t\t\t\t\ts = s + \"$2\";\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\t// the point of the long regex below is to exclude all well-known\r\n\t\t\t\t// lower-case words from the list of potential arguments\r\n\t\t\t\tvar vars = s.\r\n\t\t\t\t\treplace(/(?:\\b[A-Z]|\\.[a-zA-Z_$])[a-zA-Z_$\\d]*|[a-zA-Z_$][a-zA-Z_$\\d]*:|this|true|false|null|undefined|typeof|instanceof|in|delete|new|void|arguments|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape|dojo|dijit|dojox|window|document|'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"/g, \"\").\r\n\t\t\t\t\tmatch(/([a-z_$][a-z_$\\d]*)/gi) || [], t = {};\r\n\t\t\t\tarr.forEach(vars, function(v){\r\n\t\t\t\t\tif(!t.hasOwnProperty(v)){\r\n\t\t\t\t\t\targs.push(v);\r\n\t\t\t\t\t\tt[v] = 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn {args: args, body: s};\t// Object\r\n\t};\r\n\r\n\tvar compose = function(/*Array*/ a){\r\n\t\treturn a.length ?\r\n\t\t\t\t\tfunction(){\r\n\t\t\t\t\t\tvar i = a.length - 1, x = df.lambda(a[i]).apply(this, arguments);\r\n\t\t\t\t\t\tfor(--i; i >= 0; --i){ x = df.lambda(a[i]).call(this, x); }\r\n\t\t\t\t\t\treturn x;\r\n\t\t\t\t\t}\r\n\t\t\t\t:\r\n\t\t\t\t\t// identity\r\n\t\t\t\t\tfunction(x){ return x; };\r\n\t};\r\n\r\n\tlang.mixin(df, {\r\n\t\t// lambda\r\n\t\trawLambda: function(/*String*/ s){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tbuilds a function from a snippet, or array (composing),\r\n\t\t\t//\t\treturns an object describing the function; functions are\r\n\t\t\t//\t\tpassed through unmodified.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method is to normalize a functional representation (a\r\n\t\t\t//\t\ttext snippet) to an object that contains an array of\r\n\t\t\t//\t\targuments, and a body , which is used to calculate the\r\n\t\t\t//\t\treturning value.\r\n\t\t\treturn lambda(s);\t// Object\r\n\t\t},\r\n\t\tbuildLambda: function(/*String*/ s){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tbuilds a function from a snippet, returns a string, which\r\n\t\t\t//\t\trepresents the function.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method returns a textual representation of a function\r\n\t\t\t//\t\tbuilt from the snippet. It is meant to be evaled in the\r\n\t\t\t//\t\tproper context, so local variables can be pulled from the\r\n\t\t\t//\t\tenvironment.\r\n\t\t\tvar l = lambda(s);\r\n\t\t\treturn \"function(\" + l.args.join(\",\") + \"){return (\" + l.body + \");}\";\t// String\r\n\t\t},\r\n\t\tlambda: function(/*Function|String|Array*/ s){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tbuilds a function from a snippet, or array (composing),\r\n\t\t\t//\t\treturns a function object; functions are passed through\r\n\t\t\t//\t\tunmodified.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThis method is used to normalize a functional\r\n\t\t\t//\t\trepresentation (a text snippet, an array, or a function) to\r\n\t\t\t//\t\ta function object.\r\n\t\t\tif(typeof s == \"function\"){ return s; }\r\n\t\t\tif(s instanceof Array){ return compose(s); }\r\n\t\t\tif(lcache.hasOwnProperty(s)){ return lcache[s]; }\r\n\t\t\tvar l = lambda(s);\r\n\t\t\treturn lcache[s] = new Function(l.args, \"return (\" + l.body + \");\");\t// Function\r\n\t\t},\r\n\t\tclearLambdaCache: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tclears internal cache of lambdas\r\n\t\t\tlcache = {};\r\n\t\t}\r\n\t});\r\n\t\r\n\treturn df;\r\n});\r\n"]}