{"version":3,"sources":["lang/functional/binrec.js"],"names":["dojo","provide","require","df","dojox","lang","functional","inline","inlineLambda","_z_r_r_z_a","binrec","cond","then","before","after","c","t","b","a","cs","ts","bs","as","dict1","dict2","add2dict","x","lambda","locals1","keys","locals2","f","Function","concat","length","join"],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,gCAEbD,KAAKE,QAAQ,gCACbF,KAAKE,QAAQ,8BAcb,WACC,IAAIC,EAAKC,MAAMC,KAAKC,WAAYC,EAASJ,EAAGK,aACjCC,GAAc,OAAQ,KAAM,QAEvCN,EAAGO,OAAS,SACkBC,EACAC,EACAC,EACAC,GAwB7B,IAAIC,EAAGC,EAAGC,EAAGC,EAAGC,EAAIC,EAAIC,EAAIC,EAAIC,KAAYC,KAC3CC,EAAW,SAASC,GAAIH,EAAMG,GAAK,GAClB,iBAARf,EACTQ,EAAKZ,EAAOI,EAjCT,KAiCmBc,IAEtBV,EAAIZ,EAAGwB,OAAOhB,GACdQ,EAAK,qBACLK,EAAM,WAAa,GAEF,iBAARZ,EACTQ,EAAKb,EAAOK,EAxCT,KAwCmBa,IAEtBT,EAAIb,EAAGwB,OAAOf,GACdQ,EAAK,sBAEc,iBAAVP,EACTQ,EAAKd,EAAOM,EA9CT,KA8CqBY,IAExBR,EAAId,EAAGwB,OAAOd,GACdQ,EAAK,qBACLG,EAAM,WAAa,GAED,iBAATV,EACTQ,EAAKf,EAAOO,EAAOL,EAAYgB,IAE/BP,EAAIf,EAAGwB,OAAOb,GACdQ,EAAK,gCACLE,EAAM,WAAa,GAEpB,IAAII,EAAUzB,EAAG0B,KAAKN,GAAQO,EAAU3B,EAAG0B,KAAKL,GAC/CO,EAAI,IAAIC,YAAa,4BAA4BC,OAChDL,EAAQM,OAAS,IAAMN,EAAQO,KAAK,KAAO,GAC3CL,EAAQI,OAAS,iBAAmBJ,EAAQK,KAAK,KAAO,GACxDnB,EAAKc,EAAQI,OAAS,WAAa,iBAAoB,GACvD,WACAf,EACA,QACAE,EACA,4DACAD,EACA,yCACAE,EACA,0DACAH,EACA,WACAE,EACA,qDACAF,EACA,OAMF,OAJGJ,IAAIgB,EAAEhB,EAAIA,GACVC,IAAIe,EAAEf,EAAIA,GACVC,IAAIc,EAAEd,EAAIA,GACVC,IAAIa,EAAEb,EAAIA,GACNa,GAtFT","file":"../../../lang/functional/binrec.js","sourcesContent":["dojo.provide(\"dojox.lang.functional.binrec\");\r\n\r\ndojo.require(\"dojox.lang.functional.lambda\");\r\ndojo.require(\"dojox.lang.functional.util\");\r\n\r\n// This module provides recursion combinators:\r\n//\t- a binary recursion combinator.\r\n\r\n// Acknowledgements:\r\n//\t- recursion combinators are inspired by Manfred von Thun's article\r\n//\t\t\"Recursion Theory and Joy\"\r\n//\t\t(http://www.latrobe.edu.au/philosophy/phimvt/joy/j05cmp.html)\r\n\r\n// Notes:\r\n//\t- recursion combinators produce a function, which implements\r\n//\ttheir respective recusion patterns. String lambdas are inlined, if possible.\r\n\r\n(function(){\r\n\tvar df = dojox.lang.functional, inline = df.inlineLambda,\r\n\t\t_x =\"_x\", _z_r_r_z_a = [\"_z.r\", \"_r\", \"_z.a\"];\r\n\r\n\tdf.binrec = function(\r\n\t\t\t\t\t/*Function|String|Array*/ cond,\r\n\t\t\t\t\t/*Function|String|Array*/ then,\r\n\t\t\t\t\t/*Function|String|Array*/ before,\r\n\t\t\t\t\t/*Function|String|Array*/ after){\r\n\t\t// summary:\r\n\t\t//\t\tGenerates a function for the binary recursion pattern.\r\n\t\t//\t\tAll parameter functions are called in the context of \"this\" object.\r\n\t\t// cond:\r\n\t\t//\t\tThe lambda expression, which is used to detect the termination of recursion.\r\n\t\t//\t\tIt accepts the same parameter as the generated recursive function itself.\r\n\t\t//\t\tThis function should return \"true\", if the recursion should be stopped,\r\n\t\t//\t\tand the \"then\" part should be executed. Otherwise the recursion will proceed.\r\n\t\t// then:\r\n\t\t//\t\tThe lambda expression, which is called upon termination of the recursion.\r\n\t\t//\t\tIt accepts the same parameters as the generated recursive function itself.\r\n\t\t//\t\tThe returned value will be returned as the value of the generated function.\r\n\t\t// before:\r\n\t\t//\t\tThe lambda expression, which is called before the recursive step.\r\n\t\t//\t\tIt accepts the same parameter as the generated recursive function itself.\r\n\t\t//\t\tThe returned value should be an array of two variable, which are used to call\r\n\t\t//\t\tthe generated function recursively twice in row starting from the first item.\r\n\t\t// above:\r\n\t\t//\t\tThe lambda expression, which is called after the recursive step.\r\n\t\t//\t\tIt accepts three parameters: two returned values from recursive steps, and\r\n\t\t//\t\tthe original array of parameters used with all other functions.\r\n\t\t//\t\tThe returned value will be returned as the value of the generated function.\r\n\r\n\t\tvar c, t, b, a, cs, ts, bs, as, dict1 = {}, dict2 = {},\r\n\t\t\tadd2dict = function(x){ dict1[x] = 1; };\r\n\t\tif(typeof cond == \"string\"){\r\n\t\t\tcs = inline(cond, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tc = df.lambda(cond);\r\n\t\t\tcs = \"_c.apply(this, _x)\";\r\n\t\t\tdict2[\"_c=_t.c\"] = 1;\r\n\t\t}\r\n\t\tif(typeof then == \"string\"){\r\n\t\t\tts = inline(then, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tt = df.lambda(then);\r\n\t\t\tts = \"_t.apply(this, _x)\";\r\n\t\t}\r\n\t\tif(typeof before == \"string\"){\r\n\t\t\tbs = inline(before, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tb = df.lambda(before);\r\n\t\t\tbs = \"_b.apply(this, _x)\";\r\n\t\t\tdict2[\"_b=_t.b\"] = 1;\r\n\t\t}\r\n\t\tif(typeof after == \"string\"){\r\n\t\t\tas = inline(after, _z_r_r_z_a, add2dict);\r\n\t\t}else{\r\n\t\t\ta = df.lambda(after);\r\n\t\t\tas = \"_a.call(this, _z.r, _r, _z.a)\";\r\n\t\t\tdict2[\"_a=_t.a\"] = 1;\r\n\t\t}\r\n\t\tvar locals1 = df.keys(dict1), locals2 = df.keys(dict2),\r\n\t\t\tf = new Function([], \"var _x=arguments,_y,_z,_r\".concat(\t// Function\r\n\t\t\t\tlocals1.length ? \",\" + locals1.join(\",\") : \"\",\r\n\t\t\t\tlocals2.length ? \",_t=_x.callee,\" + locals2.join(\",\") : \"\",\r\n\t\t\t\tt ? (locals2.length ? \",_t=_t.t\" : \"_t=_x.callee.t\") : \"\",\r\n\t\t\t\t\";while(!\",\r\n\t\t\t\tcs,\r\n\t\t\t\t\"){_r=\",\r\n\t\t\t\tbs,\r\n\t\t\t\t\";_y={p:_y,a:_r[1]};_z={p:_z,a:_x};_x=_r[0]}for(;;){do{_r=\",\r\n\t\t\t\tts,\r\n\t\t\t\t\";if(!_z)return _r;while(\\\"r\\\" in _z){_r=\",\r\n\t\t\t\tas,\r\n\t\t\t\t\";if(!(_z=_z.p))return _r}_z.r=_r;_x=_y.a;_y=_y.p}while(\",\r\n\t\t\t\tcs,\r\n\t\t\t\t\");do{_r=\",\r\n\t\t\t\tbs,\r\n\t\t\t\t\";_y={p:_y,a:_r[1]};_z={p:_z,a:_x};_x=_r[0]}while(!\",\r\n\t\t\t\tcs,\r\n\t\t\t\t\")}\"\r\n\t\t\t));\r\n\t\tif(c){ f.c = c; }\r\n\t\tif(t){ f.t = t; }\r\n\t\tif(b){ f.b = b; }\r\n\t\tif(a){ f.a = a; }\r\n\t\treturn f;\r\n\t};\r\n})();\r\n\r\n/*\r\nFor documentation only:\r\n\r\n1) The original recursive version:\r\n\r\nvar binrec1 = function(cond, then, before, after){\r\n\tvar cond   = df.lambda(cond),\r\n\t\tthen   = df.lambda(then),\r\n\t\tbefore = df.lambda(before),\r\n\t\tafter  = df.lambda(after);\r\n\treturn function(){\r\n\t\tif(cond.apply(this, arguments)){\r\n\t\t\treturn then.apply(this, arguments);\r\n\t\t}\r\n\t\tvar args = before.apply(this, arguments);\r\n\t\tvar ret1 = arguments.callee.apply(this, args[0]);\r\n\t\tvar ret2 = arguments.callee.apply(this, args[1]);\r\n\t\treturn after.call(this, ret1, ret2, arguments);\r\n\t};\r\n};\r\n\r\n2) The original iterative version (before minification and inlining):\r\n\r\nvar binrec2 = function(cond, then, before, after){\r\n\tvar cond   = df.lambda(cond),\r\n\t\tthen   = df.lambda(then),\r\n\t\tbefore = df.lambda(before),\r\n\t\tafter  = df.lambda(after);\r\n\treturn function(){\r\n\t\tvar top1, top2, ret, args = arguments;\r\n\t\t// first part: start the pump\r\n\t\twhile(!cond.apply(this, args)){\r\n\t\t\tret = before.apply(this, args);\r\n\t\t\ttop1 = {prev: top1, args: ret[1]};\r\n\t\t\ttop2 = {prev: top2, args: args};\r\n\t\t\targs = ret[0];\r\n\t\t}\r\n\t\tfor(;;){\r\n\t\t\t// second part: mop up\r\n\t\t\tdo{\r\n\t\t\t\tret = then.apply(this, args);\r\n\t\t\t\tif(!top2){\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}\r\n\t\t\t\twhile(\"ret\" in top2){\r\n\t\t\t\t\tret = after.call(this, top2.ret, ret, top2.args);\r\n\t\t\t\t\tif(!(top2 = top2.prev)){\r\n\t\t\t\t\t\treturn ret;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ttop2.ret = ret;\r\n\t\t\t\targs = top1.args;\r\n\t\t\t\ttop1 = top1.prev;\r\n\t\t\t}while(cond.apply(this, args));\r\n\t\t\t// first part (encore)\r\n\t\t\tdo{\r\n\t\t\t\tret = before.apply(this, args);\r\n\t\t\t\ttop1 = {prev: top1, args: ret[1]};\r\n\t\t\t\ttop2 = {prev: top2, args: args};\r\n\t\t\t\targs = ret[0];\r\n\t\t\t}while(!cond.apply(this, args));\r\n\t\t}\r\n\t};\r\n};\r\n\r\n*/"]}