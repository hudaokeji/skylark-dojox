{"version":3,"sources":["lang/functional/tailrec.js"],"names":["dojo","provide","require","df","dojox","lang","functional","inline","inlineLambda","tailrec","cond","then","before","c","t","b","cs","ts","bs","dict1","dict2","add2dict","x","lambda","locals1","keys","locals2","f","Function","concat","length","join"],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,iCAEbD,KAAKE,QAAQ,gCACbF,KAAKE,QAAQ,8BAcb,WACC,IAAIC,EAAKC,MAAMC,KAAKC,WAAYC,EAASJ,EAAGK,aAE5CL,EAAGM,QAAU,SACiBC,EACAC,EACAC,GAqB7B,IAAIC,EAAGC,EAAGC,EAAGC,EAAIC,EAAIC,EAAIC,KAAYC,KACpCC,EAAW,SAASC,GAAIH,EAAMG,GAAK,GAClB,iBAARZ,EACTM,EAAKT,EAAOG,EA7BgD,KA6BtCW,IAEtBR,EAAIV,EAAGoB,OAAOb,GACdM,EAAK,qBACLI,EAAM,WAAa,GAEF,iBAART,EACTM,EAAKV,EAAOI,EApCgD,KAoCtCU,IAEtBP,EAAIX,EAAGoB,OAAOZ,GACdM,EAAK,wBAEc,iBAAVL,EACTM,EAAKX,EAAOK,EA1CgD,KA0CpCS,IAExBN,EAAIZ,EAAGoB,OAAOX,GACdM,EAAK,qBACLE,EAAM,WAAa,GAEpB,IAAII,EAAUrB,EAAGsB,KAAKN,GAAQO,EAAUvB,EAAGsB,KAAKL,GAC/CO,EAAI,IAAIC,YAAa,gDAAgDC,OACpEL,EAAQM,OAAS,IAAMN,EAAQO,KAAK,KAAO,GAC3CL,EAAQI,OAAS,iBAAmBJ,EAAQK,KAAK,KAAOjB,EAAI,gBAAkB,GAC9E,UACAE,EACA,OACAE,EACA,YACAD,IAKF,OAHGJ,IAAIc,EAAEd,EAAIA,GACVC,IAAIa,EAAEb,EAAIA,GACVC,IAAIY,EAAEZ,EAAIA,GACNY,GA/DT","file":"../../../lang/functional/tailrec.js","sourcesContent":["dojo.provide(\"dojox.lang.functional.tailrec\");\r\n\r\ndojo.require(\"dojox.lang.functional.lambda\");\r\ndojo.require(\"dojox.lang.functional.util\");\r\n\r\n// This module provides recursion combinators:\r\n//\t- a tail recursion combinator.\r\n\r\n// Acknowledgements:\r\n//\t- recursion combinators are inspired by Manfred von Thun's article\r\n//\t\t\"Recursion Theory and Joy\"\r\n//\t\t(http://www.latrobe.edu.au/philosophy/phimvt/joy/j05cmp.html)\r\n\r\n// Notes:\r\n//\t- recursion combinators produce a function, which implements\r\n//\ttheir respective recusion patterns. String lambdas are inlined, if possible.\r\n\r\n(function(){\r\n\tvar df = dojox.lang.functional, inline = df.inlineLambda, _x =\"_x\";\r\n\r\n\tdf.tailrec = function(\r\n\t\t\t\t\t/*Function|String|Array*/ cond,\r\n\t\t\t\t\t/*Function|String|Array*/ then,\r\n\t\t\t\t\t/*Function|String|Array*/ before){\r\n\t\t// summary:\r\n\t\t//\t\tGenerates a function for the tail recursion pattern. This is the simplified\r\n\t\t//\t\tversion of the linear recursive combinator without the \"after\" function,\r\n\t\t//\t\tand with the modified \"before\" function. All parameter functions are called\r\n\t\t//\t\tin the context of \"this\" object.\r\n\t\t// cond:\r\n\t\t//\t\tThe lambda expression, which is used to detect the termination of recursion.\r\n\t\t//\t\tIt accepts the same parameter as the generated recursive function itself.\r\n\t\t//\t\tThis function should return \"true\", if the recursion should be stopped,\r\n\t\t//\t\tand the \"then\" part should be executed. Otherwise the recursion will proceed.\r\n\t\t// then:\r\n\t\t//\t\tThe lambda expression, which is called upon termination of the recursion.\r\n\t\t//\t\tIt accepts the same parameters as the generated recursive function itself.\r\n\t\t//\t\tThe returned value will be returned as the value of the generated function.\r\n\t\t// before:\r\n\t\t//\t\tThe lambda expression, which is called before the recursive step.\r\n\t\t//\t\tIt accepts the same parameter as the generated recursive function itself,\r\n\t\t//\t\tand returns an array of arguments for the next recursive call of\r\n\t\t//\t\tthe generated function.\r\n\r\n\t\tvar c, t, b, cs, ts, bs, dict1 = {}, dict2 = {},\r\n\t\t\tadd2dict = function(x){ dict1[x] = 1; };\r\n\t\tif(typeof cond == \"string\"){\r\n\t\t\tcs = inline(cond, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tc = df.lambda(cond);\r\n\t\t\tcs = \"_c.apply(this, _x)\";\r\n\t\t\tdict2[\"_c=_t.c\"] = 1;\r\n\t\t}\r\n\t\tif(typeof then == \"string\"){\r\n\t\t\tts = inline(then, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tt = df.lambda(then);\r\n\t\t\tts = \"_t.t.apply(this, _x)\";\r\n\t\t}\r\n\t\tif(typeof before == \"string\"){\r\n\t\t\tbs = inline(before, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tb = df.lambda(before);\r\n\t\t\tbs = \"_b.apply(this, _x)\";\r\n\t\t\tdict2[\"_b=_t.b\"] = 1;\r\n\t\t}\r\n\t\tvar locals1 = df.keys(dict1), locals2 = df.keys(dict2),\r\n\t\t\tf = new Function([], \"var _x=arguments,_t=_x.callee,_c=_t.c,_b=_t.b\".concat(\t// Function\r\n\t\t\t\tlocals1.length ? \",\" + locals1.join(\",\") : \"\",\r\n\t\t\t\tlocals2.length ? \",_t=_x.callee,\" + locals2.join(\",\") : t ? \",_t=_x.callee\" : \"\",\r\n\t\t\t\t\";for(;!\",\r\n\t\t\t\tcs,\r\n\t\t\t\t\";_x=\",\r\n\t\t\t\tbs,\r\n\t\t\t\t\");return \",\r\n\t\t\t\tts\r\n\t\t\t));\r\n\t\tif(c){ f.c = c; }\r\n\t\tif(t){ f.t = t; }\r\n\t\tif(b){ f.b = b; }\r\n\t\treturn f;\r\n\t};\r\n})();\r\n\r\n/*\r\nFor documentation only:\r\n\r\n1) The original recursive version:\r\n\r\nvar tailrec1 = function(cond, then, before){\r\n\tvar cond   = df.lambda(cond),\r\n\t\tthen   = df.lambda(then),\r\n\t\tbefore = df.lambda(before);\r\n\treturn function(){\r\n\t\tif(cond.apply(this, arguments)){\r\n\t\t\treturn then.apply(this, arguments);\r\n\t\t}\r\n\t\tvar args = before.apply(this, arguments);\r\n\t\treturn arguments.callee.apply(this, args);\r\n\t};\r\n};\r\n\r\n2) The original iterative version (before minification and inlining):\r\n\r\nvar tailrec2 = function(cond, then, before){\r\n\tvar cond   = df.lambda(cond),\r\n\t\tthen   = df.lambda(then),\r\n\t\tbefore = df.lambda(before);\r\n\treturn function(){\r\n\t\tvar args = arguments;\r\n\t\tfor(; !cond.apply(this, args); args = before.apply(this, args));\r\n\t\treturn then.apply(this, args);\r\n\t};\r\n};\r\n\r\n*/"]}