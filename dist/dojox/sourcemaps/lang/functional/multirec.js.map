{"version":3,"sources":["lang/functional/multirec.js"],"names":["dojo","provide","require","df","dojox","lang","functional","inline","inlineLambda","_y_r_y_o","multirec","cond","then","before","after","c","t","b","a","cs","ts","bs","as","dict1","dict2","add2dict","x","lambda","locals1","keys","locals2","f","Function","concat","length","join"],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,kCAEbD,KAAKE,QAAQ,gCACbF,KAAKE,QAAQ,8BAcb,WACC,IAAIC,EAAKC,MAAMC,KAAKC,WAAYC,EAASJ,EAAGK,aACjCC,GAAY,OAAQ,QAE/BN,EAAGO,SAAW,SACgBC,EACAC,EACAC,EACAC,GA0B7B,IAAIC,EAAGC,EAAGC,EAAGC,EAAGC,EAAIC,EAAIC,EAAIC,EAAIC,KAAYC,KAC3CC,EAAW,SAASC,GAAIH,EAAMG,GAAK,GAClB,iBAARf,EACTQ,EAAKZ,EAAOI,EAnCT,KAmCmBc,IAEtBV,EAAIZ,EAAGwB,OAAOhB,GACdQ,EAAK,qBACLK,EAAM,WAAa,GAEF,iBAARZ,EACTQ,EAAKb,EAAOK,EA1CT,KA0CmBa,IAEtBT,EAAIb,EAAGwB,OAAOf,GACdQ,EAAK,sBAEc,iBAAVP,EACTQ,EAAKd,EAAOM,EAhDT,KAgDqBY,IAExBR,EAAId,EAAGwB,OAAOd,GACdQ,EAAK,qBACLG,EAAM,WAAa,GAED,iBAATV,EACTQ,EAAKf,EAAOO,EAAOL,EAAUgB,IAE7BP,EAAIf,EAAGwB,OAAOb,GACdQ,EAAK,4BACLE,EAAM,WAAa,GAEpB,IAAII,EAAUzB,EAAG0B,KAAKN,GAAQO,EAAU3B,EAAG0B,KAAKL,GAC/CO,EAAI,IAAIC,YAAa,mCAAmCC,OACvDL,EAAQM,OAAS,IAAMN,EAAQO,KAAK,KAAO,GAC3CL,EAAQI,OAAS,wBAA0BJ,EAAQK,KAAK,KAAO,GAC/DnB,EAAKc,EAAQI,OAAS,WAAa,wBAA2B,GAC9D,gCACAZ,EACA,qBACAH,EACA,QACAC,EACA,qBACAC,EACA,2HAMF,OAJGN,IAAIgB,EAAEhB,EAAIA,GACVC,IAAIe,EAAEf,EAAIA,GACVC,IAAIc,EAAEd,EAAIA,GACVC,IAAIa,EAAEb,EAAIA,GACNa,GAlFT","file":"../../../lang/functional/multirec.js","sourcesContent":["dojo.provide(\"dojox.lang.functional.multirec\");\r\n\r\ndojo.require(\"dojox.lang.functional.lambda\");\r\ndojo.require(\"dojox.lang.functional.util\");\r\n\r\n// This module provides recursion combinators:\r\n//\t- a multi-way recursion combinator.\r\n\r\n// Acknowledgements:\r\n//\t- recursion combinators are inspired by Manfred von Thun's article\r\n//\t\t\"Recursion Theory and Joy\"\r\n//\t\t(http://www.latrobe.edu.au/philosophy/phimvt/joy/j05cmp.html)\r\n\r\n// Notes:\r\n//\t- recursion combinators produce a function, which implements\r\n//\ttheir respective recusion patterns. String lambdas are inlined, if possible.\r\n\r\n(function(){\r\n\tvar df = dojox.lang.functional, inline = df.inlineLambda,\r\n\t\t_x =\"_x\", _y_r_y_o = [\"_y.r\", \"_y.o\"];\r\n\r\n\tdf.multirec = function(\r\n\t\t\t\t\t/*Function|String|Array*/ cond,\r\n\t\t\t\t\t/*Function|String|Array*/ then,\r\n\t\t\t\t\t/*Function|String|Array*/ before,\r\n\t\t\t\t\t/*Function|String|Array*/ after){\r\n\t\t// summary:\r\n\t\t//\t\tGenerates a function for the multi-way recursion pattern.\r\n\t\t//\t\tAll parameter functions are called in the context of \"this\" object.\r\n\t\t// cond:\r\n\t\t//\t\tThe lambda expression, which is used to detect the termination of recursion.\r\n\t\t//\t\tIt accepts the same parameter as the generated recursive function itself.\r\n\t\t//\t\tThis function should return \"true\", if the recursion should be stopped,\r\n\t\t//\t\tand the \"then\" part should be executed. Otherwise the recursion will proceed.\r\n\t\t// then:\r\n\t\t//\t\tThe lambda expression, which is called upon termination of the recursion.\r\n\t\t//\t\tIt accepts the same parameters as the generated recursive function itself.\r\n\t\t//\t\tThe returned value will be returned as the value of the generated function.\r\n\t\t// before:\r\n\t\t//\t\tThe lambda expression, which is called before the recursive step.\r\n\t\t//\t\tIt accepts the same parameter as the generated recursive function itself.\r\n\t\t//\t\tThe returned value should be an array, which is used to call\r\n\t\t//\t\tthe generated function recursively. Each member of the array should be\r\n\t\t//\t\tan array of parameters. The length of it defines how many times\r\n\t\t//\t\tthe generated function is called recursively.\r\n\t\t// above:\r\n\t\t//\t\tThe lambda expression, which is called after the recursive step.\r\n\t\t//\t\tIt accepts two parameters: the array of returned values from recursive steps,\r\n\t\t//\t\tand the original array of parameters used with all other functions.\r\n\t\t//\t\tThe returned value will be returned as the value of the generated function.\r\n\r\n\t\tvar c, t, b, a, cs, ts, bs, as, dict1 = {}, dict2 = {},\r\n\t\t\tadd2dict = function(x){ dict1[x] = 1; };\r\n\t\tif(typeof cond == \"string\"){\r\n\t\t\tcs = inline(cond, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tc = df.lambda(cond);\r\n\t\t\tcs = \"_c.apply(this, _x)\";\r\n\t\t\tdict2[\"_c=_t.c\"] = 1;\r\n\t\t}\r\n\t\tif(typeof then == \"string\"){\r\n\t\t\tts = inline(then, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tt = df.lambda(then);\r\n\t\t\tts = \"_t.apply(this, _x)\";\r\n\t\t}\r\n\t\tif(typeof before == \"string\"){\r\n\t\t\tbs = inline(before, _x, add2dict);\r\n\t\t}else{\r\n\t\t\tb = df.lambda(before);\r\n\t\t\tbs = \"_b.apply(this, _x)\";\r\n\t\t\tdict2[\"_b=_t.b\"] = 1;\r\n\t\t}\r\n\t\tif(typeof after == \"string\"){\r\n\t\t\tas = inline(after, _y_r_y_o, add2dict);\r\n\t\t}else{\r\n\t\t\ta = df.lambda(after);\r\n\t\t\tas = \"_a.call(this, _y.r, _y.o)\";\r\n\t\t\tdict2[\"_a=_t.a\"] = 1;\r\n\t\t}\r\n\t\tvar locals1 = df.keys(dict1), locals2 = df.keys(dict2),\r\n\t\t\tf = new Function([], \"var _y={a:arguments},_x,_r,_z,_i\".concat(\t// Function\r\n\t\t\t\tlocals1.length ? \",\" + locals1.join(\",\") : \"\",\r\n\t\t\t\tlocals2.length ? \",_t=arguments.callee,\" + locals2.join(\",\") : \"\",\r\n\t\t\t\tt ? (locals2.length ? \",_t=_t.t\" : \"_t=arguments.callee.t\") : \"\",\r\n\t\t\t\t\";for(;;){for(;;){if(_y.o){_r=\",\r\n\t\t\t\tas,\r\n\t\t\t\t\";break}_x=_y.a;if(\",\r\n\t\t\t\tcs,\r\n\t\t\t\t\"){_r=\",\r\n\t\t\t\tts,\r\n\t\t\t\t\";break}_y.o=_x;_x=\",\r\n\t\t\t\tbs,\r\n\t\t\t\t\";_y.r=[];_z=_y;for(_i=_x.length-1;_i>=0;--_i){_y={p:_y,a:_x[_i],z:_z}}}if(!(_z=_y.z)){return _r}_z.r.push(_r);_y=_y.p}\"\r\n\t\t\t));\r\n\t\tif(c){ f.c = c; }\r\n\t\tif(t){ f.t = t; }\r\n\t\tif(b){ f.b = b; }\r\n\t\tif(a){ f.a = a; }\r\n\t\treturn f;\r\n\t};\r\n})();\r\n\r\n/*\r\nFor documentation only:\r\n\r\n1) The original recursive version:\r\n\r\nvar multirec1 = function(cond, then, before, after){\r\n\tvar cond   = df.lambda(cond),\r\n\t\tthen   = df.lambda(then),\r\n\t\tbefore = df.lambda(before),\r\n\t\tafter  = df.lambda(after);\r\n\treturn function(){\r\n\t\tif(cond.apply(this, arguments)){\r\n\t\t\treturn then.apply(this, arguments);\r\n\t\t}\r\n\t\tvar args = before.apply(this, arguments),\r\n\t\t\tret  = new Array(args.length);\r\n\t\tfor(var i = 0; i < args.length; ++i){\r\n\t\t\tret[i] = arguments.callee.apply(this, args[i]);\r\n\t\t}\r\n\t\treturn after.call(this, ret, arguments);\r\n\t};\r\n};\r\n\r\n2) The original iterative version (before minification and inlining):\r\n\r\nvar multirec2 = function(cond, then, before, after){\r\n\tvar cond   = df.lambda(cond),\r\n\t\tthen   = df.lambda(then),\r\n\t\tbefore = df.lambda(before),\r\n\t\tafter  = df.lambda(after);\r\n\treturn function(){\r\n\t\tvar top = {args: arguments}, args, ret, parent, i;\r\n\t\tfor(;;){\r\n\t\t\tfor(;;){\r\n\t\t\t\tif(top.old){\r\n\t\t\t\t\tret = after.call(this, top.ret, top.old);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\targs = top.args;\r\n\t\t\t\tif(cond.apply(this, args)){\r\n\t\t\t\t\tret = then.apply(this, args);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\ttop.old = args;\r\n\t\t\t\targs = before.apply(this, args);\r\n\t\t\t\ttop.ret = [];\r\n\t\t\t\tparent = top;\r\n\t\t\t\tfor(i = args.length - 1; i >= 0; --i){\r\n\t\t\t\t\ttop = {prev: top, args: args[i], parent: parent};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!(parent = top.parent)){\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t\tparent.ret.push(ret);\r\n\t\t\ttop = top.prev;\r\n\t\t}\r\n\t};\r\n};\r\n\r\n*/\r\n"]}