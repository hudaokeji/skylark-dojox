{"version":3,"sources":["lang/typed.js"],"names":["jsonSchema","inDojo","dojo","provide","require","dojox","json","schema","JSONSchema","Error","validatingFunction","func","getMethodDef","validatingFunc","methodDef","parameters","params","j","length","arguments","validate","toString","additionalParameters","returns","apply","this","i","__typedFunction__","instance","property","obj","result","_validate","valid","errorMessage","errors","message","TypeError","hasGetters","__defineGetter__","typedFunction","Class","__typedClass__","Wrapper","value","properties","methods","__props__","proto","hasOwnProperty","__proto__","self","__defineSetter__","prototype","declaredClass","setObject","lang","typed","config","typeCheckAllClasses","defaultDeclare","declare","name","clazz","mixin"],"mappings":"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","file":"../../lang/typed.js","sourcesContent":["(function(){\r\n\tvar jsonSchema, inDojo = typeof dojo != \"undefined\";\r\n\tif(inDojo){\r\n\t\tdojo.provide(\"dojox.lang.typed\");\r\n\t\tdojo.require(\"dojox.json.schema\");\r\n\t\tjsonSchema = dojox.json.schema;\r\n\t}else{\r\n\t\tif(typeof JSONSchema == \"undefined\"){\r\n\t\t\tthrow new Error(\"Dojo or JSON Schema library must be present\");\r\n\t\t}\r\n\t\tjsonSchema = JSONSchema;\r\n\t}\r\n\tfunction validatingFunction(func, getMethodDef){\r\n\t\tvar validatingFunc = function(){\r\n\t\t\tvar methodDef = getMethodDef();\r\n\t\t\tif(methodDef && methodDef.parameters){\r\n\t\t\t\tvar params = methodDef.parameters;\r\n\t\t\t\tfor(var j = 0; j < params.length; j++){\r\n\t\t\t\t\targuments[j] = validate(arguments[j], params[j], j.toString());\r\n\t\t\t\t}\r\n\t\t\t\tif(methodDef.additionalParameters){\r\n\t\t\t\t\tfor(;j < arguments.length; j++){\r\n\t\t\t\t\t\targuments[j] = validate(arguments[j], methodDef.additionalParameters, j.toString());\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar returns = func.apply(this, arguments);\r\n\t\t\tif(methodDef.returns){\r\n\t\t\t\tvalidate(returns, methodDef.returns);\r\n\t\t\t}\r\n\t\t\treturn returns;\r\n\t\t};\r\n\t\tvalidatingFunc.__typedFunction__ = true;\r\n\t\tfor(var i in func){\r\n\t\t\tvalidatingFunc[i] = func[i];\r\n\t\t}\r\n\t\treturn validatingFunc;\r\n\t}\r\n\tfunction identityFunc(obj){\r\n\t\treturn function(){\r\n\t\t\treturn obj;\r\n\t\t}\r\n\t}\r\n\tfunction validate(instance, schema, property){\r\n\t\t// summary:\r\n\t\t//\t\tThis checks to ensure that the result is valid and will throw an appropriate error message if it is not\r\n\t\t// result:\r\n\t\t//\t\tthe result returned from checkPropertyChange or validate\r\n\t\tif(typeof instance == \"function\" && schema && !instance.__typedFunction__){\r\n\t\t\tinstance = validatingFunction(instance, identityFunc(schema));\r\n\t\t}\r\n\t\tvar result = jsonSchema._validate(instance, schema, property);\r\n\t\tif(!result.valid){\r\n\t\t\tvar errorMessage = \"\"\r\n\t\t\tvar errors = result.errors;\r\n\t\t\tfor(var i = 0; i < errors.length; i++){\r\n\t\t\t\terrorMessage += errors[i].property + ' ' + errors[i].message + '\\n';\r\n\t\t\t}\r\n\t\t\tthrow new TypeError(errorMessage);\r\n\t\t}\r\n\t\treturn instance;\r\n\t}\r\n\tvar hasGetters = jsonSchema.__defineGetter__;\r\n\tvar typedFunction = function(Class){\r\n\t\t// summary:\r\n\t\t//\t\tAdds type checking to a class, returning a new class with typing enabled\r\n\t\tif(Class.__typedClass__){\r\n\t\t\t// type checking has already been added\r\n\t\t\treturn Class;\r\n\t\t}\r\n\t\tvar Wrapper = function(){\r\n\t\t\tvar i, value, properties = Wrapper.properties;\r\n\t\t\tvar methods = Wrapper.methods;\r\n\t\t\tClass.apply(this,arguments);\r\n\t\t\tthis.__props__ = {};\r\n\t\t\tfor(i in methods){\r\n\t\t\t\tvalue = this[i];\r\n\t\t\t\tif(value){\r\n\t\t\t\t\tif(!value.__typedFunction__){\r\n\t\t\t\t\t\t// add typing checking to the method, going up the proto chain to find the right one\r\n\t\t\t\t\t\tvar proto = this;\r\n\t\t\t\t\t\twhile(!proto.hasOwnProperty(i) && proto.__proto__){\r\n\t\t\t\t\t\t\tproto = proto.__proto__;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t(function(i){\r\n\t\t\t\t\t\t\tproto[i] = validatingFunction(value, function(){\r\n\t\t\t\t\t\t\t\treturn methods[i];\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t})(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\t(function(i){\r\n\t\t\t\t\t\tthis[i] = function(){\r\n\t\t\t\t\t\t\tthrow new TypeError(\"The method \" + i + \" is defined but not implemented\");\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t})(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(hasGetters){\r\n\t\t\t\tvar self = this;\r\n\t\t\t\tfor(i in properties){\r\n\t\t\t\t\t// add type checking to each property\r\n\t\t\t\t\tvalue = this[i];\r\n\t\t\t\t\tif(this.hasOwnProperty(i)){\r\n\t\t\t\t\t\tthis.__props__[i] = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(function(i){\r\n\t\t\t\t\t\tdelete self[i];\r\n\t\t\t\t\t\tself.__defineGetter__(i, function(){\r\n\t\t\t\t\t\t\treturn i in this.__props__ ? this.__props__[i] : this.__proto__[i];\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tself.__defineSetter__(i, function(value){\r\n\t\t\t\t\t\t\tvalidate(value, properties[i], i);\r\n\t\t\t\t\t\t\treturn this.__props__[i] = value;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t})(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvalidate(this, Wrapper);\r\n\t\t};\r\n\t\tWrapper.prototype = Class.prototype;\r\n\t\tfor(var i in Class){\r\n\t\t\tWrapper[i] = Class[i];\r\n\t\t}\r\n\t\tif(Class.prototype.declaredClass && inDojo){\r\n\t\t\tdojo.setObject(Class.prototype.declaredClass, Wrapper);\r\n\t\t}\r\n\t\tWrapper.__typedClass__ = true;\r\n\t\treturn Wrapper;\r\n\t};\r\n\tif(inDojo){\r\n\t\tdojox.lang.typed = typedFunction;\r\n\t\tif(dojo.config.typeCheckAllClasses){\r\n\t\t\t//\tThis will add type checking to all classes that will be declared via dojo.declare\r\n\t\t\t//\t(only ones to be declared in the future)\r\n\r\n\t\t\t// hook into all declared classes\r\n\t\t\tvar defaultDeclare = dojo.declare;\r\n\t\t\tdojo.declare = function(name){\r\n\t\t\t\tvar clazz = defaultDeclare.apply(this, arguments);\r\n\t\t\t\tclazz = typedFunction(clazz);\r\n\t\t\t\treturn clazz;\r\n\t\t\t};\r\n\t\t\tdojo.mixin(dojo.declare, defaultDeclare);\r\n\t\t}\r\n\t}else{\r\n\t\ttyped = typedFunction;\r\n\t}\r\n})();\r\n"]}