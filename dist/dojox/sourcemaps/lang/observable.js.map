{"version":3,"sources":["lang/observable.js"],"names":["dojo","provide","experimental","dojox","lang","observable","wrapped","onRead","onWrite","onInvoke","makeObservable","hiddenFunctions","makeInvoker","scope","i","arguments","obj","method","args","apply","lettableWin","factory","inc","getName","setName","cache","__observable","data__","Error","l","props","push","vbReservedWords","type","event","match","prop","signature","join","clazz","tname","gtname","cParts","length","vbEval","construct","console","log","newObj","e","val","Array","charAt","__defineGetter__","__defineSetter__","value","isIE","frame","document","body","createElement","appendChild","write","getElementById","style","display","doc","contentWindow","close","ReadOnlyProxy"],"mappings":"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","file":"../../lang/observable.js","sourcesContent":["dojo.provide(\"dojox.lang.observable\");\r\n// Used to create a wrapper object with monitored reads and writes\r\n//\r\ndojo.experimental(\"dojox.lang.observable\");\r\n// IMPORTANT DISCLAIMER:\r\n// This is experimental and based on hideous hacks.\r\n// There are severe limitations on the ability of wrapper objects:\r\n// Only properties that have vbscript-legal names are accessible (similar to JavaScript, but they can't start with an underscore).\r\n// The wrapper objects are not expando in IE, because they are built\r\n// from VBScript objects. This means you can't add new properties after an object is created.\r\n// The wrapper objects can not be used a prototype for other objects.\r\n// Only properties with primitive values can be wrapped.\r\n// This has performance implications as well.\r\ndojox.lang.observable = function(/*Object*/wrapped,/*function*/onRead,/*function*/onWrite,/*function*/onInvoke){\r\n\t// summary:\r\n\t//\t\tCreates a wrapper object, which can be observed. The wrapper object\r\n\t//\t\tis a proxy to the wrapped object. If you will be making multiple wrapper\r\n\t//\t\tobjects with the same set of listeners, it is recommended that you\r\n\t//\t\tuse makeObservable, as it is more memory efficient.\r\n\t// wrapped:\r\n\t//\t\tThe object to be wrapped and monitored for property access and modification\r\n\t// onRead:\r\n\t//\t\tSee dojox.lang.makeObservable.onRead\r\n\t// onWrite:\r\n\t//\t\tSee dojox.lang.makeObservable.onWrite\r\n\t// onInvoke:\r\n\t//\t\tSee dojox.lang.makeObservable.onInvoke\r\n\t\r\n\treturn dojox.lang.makeObservable(onRead,onWrite,onInvoke)(wrapped);\r\n};\r\ndojox.lang.makeObservable = function(/*function*/onRead,/*function*/onWrite,/*function*/onInvoke,/*Object*/hiddenFunctions){\r\n\t\t\r\n\t// summary:\r\n\t//\t\tCreates and returns an observable creator function. All the objects that\r\n\t//\t\tare created with the returned constructor will use the provided onRead and\r\n\t//\t\tonWrite listeners.\r\n\t//\t\tThe created constructor should be called with a single argument,\r\n\t//\t\tthe object that will be wrapped to be observed. The constructor will\r\n\t//\t\treturn the wrapper object.\r\n\t// onRead:\r\n\t//\t\tThis is called whenever one of the wrapper objects created\r\n\t//\t\tfrom the constructor has a property that is accessed. onRead\r\n\t//\t\twill be called with two arguments, the first being the wrapped object,\r\n\t//\t\tand the second is the name of property that is being accessed.\r\n\t//\t\tThe value that onRead returns will be used as the value returned\r\n\t//\t\tby the property access\r\n\t// onWrite:\r\n\t//\t\tThis is called whenever one of the wrapper objects created\r\n\t//\t\tfrom the constructor has a property that is modified. onWrite\r\n\t//\t\twill be called with three arguments, the first being the wrapped object,\r\n\t//\t\tthe second is the name of property that is being modified, and the\r\n\t//\t\tthird is the value that is being set on the property.\r\n\t// onInvoke:\r\n\t//\t\tThis is called when a method on the object is invoked. The first\r\n\t//\t\targument is the wrapper object, the second is the original wrapped object,\r\n\t//\t\tthe third is the method name, and the fourth is the arguments.\r\n\t//\r\n\t// hiddenFunctions:\r\n\t//\t\tallows you to define functions that should be delegated\r\n\t//\t\tbut may not be enumerable on the wrapped objects, so they must be\r\n\t//\t\texplicitly included\r\n\t// example:\r\n\t//\t\tThe following could be used to create a wrapper that would\r\n\t//\t\tprevent functions from being accessed on an object:\r\n\t// \t|\tfunction onRead(obj,prop){\r\n\t//\t|\t\treturn typeof obj[prop] == 'function' ? null : obj[prop];\r\n\t//\t|\t}\r\n\t//\t|\tvar observable = dojox.lang.makeObservable(onRead,onWrite);\r\n\t//\t|\tvar obj = {foo:1,bar:function(){}};\r\n\t//\t|\tobj = observable(obj);\r\n\t//\t|\tobj.foo -> 1\r\n\t//\t|\tobj.bar -> null\r\n\r\n\thiddenFunctions = hiddenFunctions || {};\r\n\tonInvoke = onInvoke || function(scope,obj,method,args){\r\n\t\t// default implementation for onInvoke, just passes the call through\r\n\t\treturn obj[method].apply(scope,args);\r\n\t};\r\n\tfunction makeInvoker(scope,wrapped,i){\r\n\t\treturn function(){\r\n\t\t\t// this is function used for all methods in the wrapper object\r\n\t\t\treturn onInvoke(scope,wrapped,i,arguments);\r\n\t\t};\r\n\t}\r\n\t\r\n\tif(dojox.lang.lettableWin){ // create the vb class\r\n\t\tvar factory = dojox.lang.makeObservable;\r\n\t\tfactory.inc = (factory.inc || 0) + 1;\r\n\t\t// create globals for the getters and setters so they can be accessed from the vbscript\r\n\t\tvar getName = \"gettable_\"+factory.inc;\r\n\t\tdojox.lang.lettableWin[getName] = onRead;\r\n\t\tvar setName = \"settable_\"+factory.inc;\r\n\t\tdojox.lang.lettableWin[setName] = onWrite;\r\n\t\tvar cache = {};\r\n\t\treturn function(wrapped){\r\n\t\t\tif(wrapped.__observable){ // if it already has an observable, use that\r\n\t\t\t\treturn wrapped.__observable;\r\n\t\t\t}\r\n\t\t\tif(wrapped.data__){\r\n\t\t\t\tthrow new Error(\"Can wrap an object that is already wrapped\");\r\n\t\t\t}\r\n\t\t\t// create the class\r\n\t\t\tvar props = [], i, l;\r\n\t\t\tfor(i in hiddenFunctions){\r\n\t\t\t\tprops.push(i);\r\n\t\t\t}\r\n\t\t\tvar vbReservedWords = {type:1,event:1};\r\n\t\t\t// find the unique signature for the class so we can reuse it if possible\r\n\t\t\tfor(i in wrapped){\r\n\t\t\t\tif(i.match(/^[a-zA-Z][\\w\\$_]*$/) && !(i in hiddenFunctions) && !(i in vbReservedWords)){ //can only do properties with valid vb names/tokens and primitive values\r\n\t\t\t\t\tprops.push(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar signature = props.join(\",\");\r\n\t\t\tvar prop,clazz = cache[signature];\r\n\t\t\tif(!clazz){\r\n\t\t\t\tvar tname = \"dj_lettable_\"+(factory.inc++);\r\n\t\t\t\tvar gtname = tname+\"_dj_getter\";\r\n\t\t\t\tvar cParts = [\r\n\t\t\t\t\t\"Class \"+tname,\r\n\t\t\t\t\t\"\tPublic data__\" // this our reference to the original object\r\n\t\t\t\t];\r\n\t\t\t\tfor(i=0, l=props.length; i<l; i++){\r\n\t\t\t\t\tprop = props[i];\r\n\t\t\t\t\tvar type = typeof wrapped[prop];\r\n\t\t\t\t\tif(type == 'function' || hiddenFunctions[prop]){ // functions must go in regular properties for delegation:/\r\n\t\t\t\t\t\tcParts.push(\"  Public \" + prop);\r\n\t\t\t\t\t}else if(type != 'object'){ // the getters/setters can only be applied to primitives\r\n\t\t\t\t\t\tcParts.push(\r\n\t\t\t\t\t\t\t\"\tPublic Property Let \"+prop+\"(val)\",\r\n\t\t\t\t\t\t\t\"\t\tCall \"+setName+\"(me.data__,\\\"\"+prop+\"\\\",val)\",\r\n\t\t\t\t\t\t\t\"\tEnd Property\",\r\n\t\t\t\t\t\t\t\"\tPublic Property Get \"+prop,\r\n\t\t\t\t\t\t\t\"\t\t\"+prop+\" = \"+getName+\"(me.data__,\\\"\"+prop+\"\\\")\",\r\n\t\t\t\t\t\t\t\"\tEnd Property\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcParts.push(\"End Class\");\r\n\t\t\t\tcParts.push(\r\n\t\t\t\t\t\"Function \"+gtname+\"()\",\r\n\t\t\t\t\t\"\tDim tmp\",\r\n\t\t\t\t\t\"\tSet tmp = New \"+tname,\r\n\t\t\t\t\t\"\tSet \"+gtname+\" = tmp\",\r\n\t\t\t\t\t\"End Function\");\r\n\t\t\t\tdojox.lang.lettableWin.vbEval(cParts.join(\"\\n\"));\r\n\t\t\t\t\t\r\n\t\t\t\t// Put the new class in the cache\r\n\t\t\t\tcache[signature] = clazz = function(){\r\n\t\t\t\t\treturn dojox.lang.lettableWin.construct(gtname); // the class can't be accessed, only called, so we have to wrap it with a function\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tconsole.log(\"starting5\");\r\n\t\t\tvar newObj = clazz();\r\n\t\t\tnewObj.data__ = wrapped;\r\n\t\t\tconsole.log(\"starting6\");\r\n\t\t\ttry {\r\n\t\t\t\twrapped.__observable = newObj;\r\n\t\t\t} catch(e){ // some objects are not expando\r\n\t\t\t}\r\n\t\t\tfor(i = 0,  l = props.length; i < l; i++){\r\n\t\t\t\tprop = props[i];\r\n\t\t\t\ttry {\r\n\t\t\t\tvar val = wrapped[prop];\r\n\t\t\t\t}\r\n\t\t\t\tcatch(e){\r\n\t\t\t\t\tconsole.log(\"error \",prop,e);\r\n\t\t\t\t}\r\n\t\t\t\tif(typeof val == 'function' || hiddenFunctions[prop]){ // we can make a delegate function here\r\n\t\t\t\t\tnewObj[prop] = makeInvoker(newObj,wrapped,prop);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn newObj;\r\n\t\t};\r\n\t}else{\r\n\t\treturn function(wrapped){ // do it with getters and setters\r\n\t\t\tif(wrapped.__observable){ // if it already has an observable, use that\r\n\t\t\t\treturn wrapped.__observable;\r\n\t\t\t}\r\n\t\t\tvar newObj = wrapped instanceof Array ? [] : {};\r\n\t\t\tnewObj.data__ = wrapped;\r\n\t\t\tfor(var i in wrapped){\r\n\t\t\t\tif(i.charAt(0) != '_'){\r\n\t\t\t\t\tif(typeof wrapped[i] == 'function'){\r\n\t\t\t\t\t\tnewObj[i] = makeInvoker(newObj,wrapped,i); // TODO: setup getters and setters so we can detect when this changes\r\n\t\t\t\t\t}else if(typeof wrapped[i] != 'object'){\r\n\t\t\t\t\t\t(function(i){\r\n\t\t\t\t\t\t\tnewObj.__defineGetter__(i,function(){\r\n\t\t\t\t\t\t\t\treturn onRead(wrapped,i);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\tnewObj.__defineSetter__(i,function(value){\r\n\t\t\t\t\t\t\t\treturn onWrite(wrapped,i,value);\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t})(i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(i in hiddenFunctions){\r\n\t\t\t\tnewObj[i] = makeInvoker(newObj,wrapped,i);\r\n\t\t\t}\r\n\t\t\twrapped.__observable = newObj;\r\n\t\t\treturn newObj;\r\n\t\t};\r\n\t}\r\n};\r\nif(!{}.__defineGetter__){\r\n\tif(dojo.isIE){\r\n\t\t// to setup the crazy lettable hack we need to\r\n\t\t// introduce vb script eval\r\n\t\t// the only way that seems to work for adding a VBScript to the page is with a document.write\r\n\t\t// document.write is not always available, so we use an iframe to do the document.write\r\n\t\t// the iframe also provides a good hiding place for all the global variables that we must\r\n\t\t// create in order for JScript and VBScript to interact.\r\n\t\tvar frame;\r\n\t\tif(document.body){ // if the DOM is ready we can add it\r\n\t\t\tframe = document.createElement(\"iframe\");\r\n\t\t\tdocument.body.appendChild(frame);\r\n\t\t}else{ // other we have to write it out\r\n\t\t\tdocument.write(\"<iframe id='dj_vb_eval_frame'></iframe>\");\r\n\t\t\tframe = document.getElementById(\"dj_vb_eval_frame\");\r\n\t\t}\r\n\t\tframe.style.display=\"none\";\r\n\t\tvar doc = frame.contentWindow.document;\r\n\t\tdojox.lang.lettableWin = frame.contentWindow;\r\n\t\tdoc.write('<html><head><script language=\"VBScript\" type=\"text/VBScript\">' +\r\n\t\t\t'Function vb_global_eval(code)' +\r\n\t\t\t\t'ExecuteGlobal(code)' +\r\n\t\t\t'End Function' +\r\n\t\t\t'</script>' +\r\n\t\t\t'<script type=\"text/javascript\">' +\r\n\t\t\t'function vbEval(code){ \\n' + // this has to be here to call it from another frame\r\n\t\t\t\t'return vb_global_eval(code);' +\r\n\t\t\t'}' +\r\n\t\t\t'function construct(name){ \\n' + // and this too\r\n\t\t\t\t'return window[name]();' +\r\n\t\t\t'}' +\r\n\t\t\t'</script>' +\r\n\t\t\t'</head><body>vb-eval</body></html>');\r\n\t\tdoc.close();\r\n\t}else{\r\n\t\tthrow new Error(\"This browser does not support getters and setters\");\r\n\t}\r\n}\r\n\r\ndojox.lang.ReadOnlyProxy =\r\n// summary:\r\n//\t\tProvides a read only proxy to another object, this can be\r\n//\t\tvery useful in object-capability systems\r\n// example:\r\n// \t|\tvar obj = {foo:\"bar\"};\r\n// \t|\tvar readonlyObj = dojox.lang.ReadOnlyProxy(obj);\r\n// \t|\treadonlyObj.foo = \"test\" // throws an error\r\n// \t|\tobj.foo = \"new bar\";\r\n// \t|\treadonlyObj.foo -> returns \"new bar\", always reflects the current value of the original (it is not just a copy)\r\ndojox.lang.makeObservable(function(obj,i){\r\n\t\treturn obj[i];\r\n\t},function(obj,i,value){\r\n\t\t// just ignore, exceptions don't seem to propagate through the VB stack.\r\n});\r\n"]}