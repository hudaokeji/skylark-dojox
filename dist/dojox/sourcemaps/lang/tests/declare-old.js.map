{"version":3,"sources":["lang/tests/declare-old.js"],"names":["dojo","provide","dojox","lang","tests","declareOld","className","superclass","props","mixins","dd","arguments","callee","isArray","shift","forEach","m","i","_delegate","ctor","extend","declaredClass","_constructor","constructor","prototype","setObject","mixin","base","bp","mp","_makeCtor","_extend","_core","preamble","fn","isFunction","nom","this","_construct","args","ii","c","s","ct","mct","a","apply","postscript","_findMixin","p","_findMethod","name","method","ptype","has","f","inherited","newArgs"],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,gCAMbC,MAAMC,KAAKC,MAAMC,WAAa,SAAoBC,EAAmCC,EAAuBC,GAgE3G,IAA2BC,EAAvBC,EAAKC,UAAUC,OAChBZ,KAAKa,QAAQN,KAEfA,GADAE,EAASF,GACWO,SAGlBL,GACFT,KAAKe,QAAQN,EAAQ,SAASO,EAAGC,GAChC,IAAID,EAAI,MAAMV,EAAY,YAAcW,EAAI,WAC5CV,EAAaG,EAAGQ,UAAUX,EAAYS,KAIxC,IAAIG,EAAOT,EAAGQ,UAAUX,GASxB,OAPAC,EAAQA,MACRW,EAAKC,OAAOZ,GAEZR,KAAKoB,OAAOD,GAAQE,cAAef,EAAWgB,aAAcd,EAAMe,cAElEJ,EAAKK,UAAUD,YAAcJ,EAEtBnB,KAAKyB,UAAUnB,EAAWa,IAGlCnB,KAAK0B,MAAMxB,MAAMC,KAAKC,MAAMC,YAC3Ba,UAAW,SAASS,EAAMD,GACzB,IAAIE,GAAMD,GAAQ,GAAGH,UAAWK,GAAMH,GAAS,GAAGF,UAAWd,EAAKR,MAAMC,KAAKC,MAAMC,WAE/Ec,EAAOT,EAAGoB,YAWd,OATA9B,KAAK0B,MAAMP,GAAQZ,WAAYqB,EAAIF,MAAOG,EAAIT,OAAQV,EAAGqB,UAEtDJ,IAAOR,EAAKK,UAAYxB,KAAKkB,UAAUU,IAE1C5B,KAAKoB,OAAOD,EAAMT,EAAGsB,MAAOH,GAAM,GAAKP,aAAc,KAAMW,SAAU,OAErEd,EAAKK,UAAUD,YAAcJ,EAE7BA,EAAKK,UAAUH,eAAiBO,GAAM,GAAGP,cAAgB,KAAOQ,GAAM,GAAGR,cAClEF,GAERY,QAAS,SAASvB,GACjB,IAAIS,EAAGiB,EACP,IAAIjB,KAAKT,EAAWR,KAAKmC,WAAWD,EAAG1B,EAAMS,OAAQ,GAAEA,KAAIiB,EAAGE,IAAInB,EAAEiB,EAAGf,KAAKkB,MAC5ErC,KAAKoB,OAAOiB,KAAM7B,IAEnBsB,UAAW,WAEV,OAAO,WAAYO,KAAKC,WAAW3B,aAEpCqB,OACCM,WAAY,SAASC,GACpB,IACkDC,EAAIN,EADlDO,EAAIF,EAAK3B,OAAQ8B,EAAID,EAAElC,WAAYoC,EAAKD,GAAKA,EAAEnB,YAClDP,EAAIyB,EAAEf,MAAOkB,EAAM5B,GAAKA,EAAEO,YAAasB,EAAIN,EAEzCM,EAAE,KAUoBX,EAAKW,EAAE,GAAGZ,YACjCY,EAAIX,EAAGY,MAAMT,KAAMQ,IAAMA,IAIvBX,EAAKO,EAAEjB,UAAUS,YAAYY,EAAIX,EAAGY,MAAMT,KAAMQ,IAAMA,GAKvDF,GAAMA,EAAGG,OAAQH,EAAGG,MAAMT,KAAMQ,GAEhCD,GAAOA,EAAIE,OAAQF,EAAIE,MAAMT,KAAMQ,IAElCL,EAAKC,EAAEjB,UAAUF,eAAgBkB,EAAGM,MAAMT,KAAME,GAEjDF,KAAKd,YAAYC,WAAaiB,EAAEjB,YAAcmB,EAAKN,KAAKU,aAAcJ,EAAGG,MAAMT,KAAME,IAEzFS,WAAY,SAAStB,GAEpB,IADA,IAA0BuB,EAAGjC,EAAzByB,EAAIJ,KAAKd,YACPkB,GAAE,CAGP,GAFAQ,EAAIR,EAAElC,YACNS,EAAIyB,EAAEf,QACEA,GAAUV,aAAaU,EAAMH,YAAe,OAAO0B,EAC3D,GAAGjC,GAAKA,EAAEgC,aAAehC,EAAIA,EAAEgC,WAAWtB,IAAU,OAAOV,EAC3DyB,EAAIQ,GAAKA,EAAE1B,cAGb2B,YAAa,SAASC,EAAMC,EAAQC,EAAOC,GAE1C,IAAab,EAAGzB,EAAGuC,EAAfN,EAAEI,EACN,EAAE,CAID,IAFArC,GADAyB,EAAIQ,EAAE1B,aACAG,SAEGV,EAAIqB,KAAKa,YAAYC,EAAMC,EAAQpC,EAAGsC,IAAQ,OAAOtC,EAE9D,IAAIuC,EAAIN,EAAEE,KAAWG,IAAQC,GAAKH,GAAW,OAAOH,EAEpDA,EAAIR,EAAElC,iBACA0C,GAEP,OAAQK,IAAQL,EAAIZ,KAAKW,WAAWK,KAAWhB,KAAKa,YAAYC,EAAMC,EAAQH,EAAGK,IAElFE,UAAW,SAASL,EAAMZ,EAAMkB,GAsC/B,IAAIZ,EAAIlC,UAEU,iBAARkC,EAAE,KACXY,EAAUlB,EAEVY,GADAZ,EAAOY,GACKvC,OAAOwB,KAEpBS,EAAIY,GAAWlB,EACf,IAAqDL,EAAIL,EAArDY,EAAIF,EAAK3B,OAAQqC,EAAIZ,KAAKd,YAAYC,UAE1C,GAAGa,KAAKc,IAASV,GAAKQ,EAAEE,IAASV,EAAE,CAIlC,KADAZ,GAAMY,EAAEtB,MAAQ,GAAGZ,YAAc8B,KAAKa,YAAYC,EAAMV,EAAGQ,GAAG,IACrD,MAAMZ,KAAKhB,cAAgB,uBAAyB8B,EAAO,aAEpEF,EAAIZ,KAAKa,YAAYC,EAAMV,EAAGZ,GAAI,GAInC,KADAK,EAAKe,GAAKA,EAAEE,IACH,MAAOtB,EAAGR,cAAgB,uBAAyB8B,EAAO,cAEnE,OAAOjB,EAAGY,MAAMT,KAAMQ","file":"../../../lang/tests/declare-old.js","sourcesContent":["dojo.provide(\"dojox.lang.tests.declare-old\");\r\n\r\n// the old file copied and modified here for testing\r\n\r\n// this file courtesy of the TurboAjax Group, licensed under a Dojo CLA\r\n\r\ndojox.lang.tests.declareOld = function(/*String*/ className, /*Function|Function[]*/ superclass, /*Object*/ props){\r\n\t// summary:\r\n\t//\t\tCreate a feature-rich constructor from compact notation\r\n\t//\r\n\t// description:\r\n\t//\t\tCreate a feature-rich constructor from compact notation\r\n\t//\r\n\t// className:\r\n\t//\t\tThe name of the constructor (loosely, a \"class\")\r\n\t//\t\tstored in the \"declaredClass\" property in the created prototype\r\n\t// superclass:\r\n\t//\t\tMay be null, a Function, or an Array of Functions. If an array,\r\n\t//\t\tthe first element is used as the prototypical ancestor and\r\n\t//\t\tany following Functions become mixin ancestors.\r\n\t// props:\r\n\t//\t\tAn object whose properties are copied to the\r\n\t//\t\tcreated prototype.\r\n\t//\t\tAdd an instance-initialization function by making it a property\r\n\t//\t\tnamed \"constructor\".\r\n\t// description:\r\n\t//\t\tCreate a constructor using a compact notation for inheritance and\r\n\t//\t\tprototype extension.\r\n\t//\r\n\t//\t\tAll superclasses (including mixins) must be Functions (not simple Objects).\r\n\t//\r\n\t//\t\tMixin ancestors provide a type of multiple inheritance. Prototypes of mixin\r\n\t//\t\tancestors are copied to the new class: changes to mixin prototypes will\r\n\t//\t\tnot affect classes to which they have been mixed in.\r\n\t//\r\n\t//\t\t\"className\" is cached in \"declaredClass\" property of the new class.\r\n\t//\r\n\t// example:\r\n\t//\t\tDeclare a class with no ancestors.\r\n\t//\t|\tdojo.declare(\"my.ClassyThing\", null, {\r\n\t//\t|\t\taProperty:\"string\",\r\n\t//\t|\t\tconstructor: function(args){\r\n\t//\t|\t\t\tdojo.mixin(this, args);\r\n\t//\t|\t\t}\r\n\t//\t|\t});\r\n\t//\r\n\t// example:\r\n\t//\t\tDeclare a class inheriting from my.classed.Foo\r\n\t//\t|\tdojo.declare(\"my.classes.Bar\", my.classes.Foo, {\r\n\t//\t|\t\t// properties to be added to the class prototype\r\n\t//\t|\t\tsomeValue: 2,\r\n\t//\t|\t\t// initialization function\r\n\t//\t|\t\tconstructor: function(){\r\n\t//\t|\t\t\tthis.myComplicatedObject = new ReallyComplicatedObject();\r\n\t//\t|\t\t},\r\n\t//\t|\t\t// other functions\r\n\t//\t|\t\tsomeMethod: function(){\r\n\t//\t|\t\t\tdoStuff();\r\n\t//\t|\t\t}\r\n\t//\t|\t);\r\n\t//\r\n\t// example:\r\n\t//\t\tDeclare a class inherting from two mixins, handling multiple constructor args\r\n\t//\t|\tdojo.declare(\"my.ComplexMix\", [my.BaseClass, my.MixedClass],{\r\n\t//\t|\t\tconstructor: function(a, b){\r\n\t//\t|\t\t\t// someone called `new my.ComplexMix(\"something\", \"maybesomething\");`\r\n\t//\t|\t\t}\r\n\t//\t|\t});\r\n\r\n\t// process superclass argument\r\n\tvar dd = arguments.callee, mixins;\r\n\tif(dojo.isArray(superclass)){\r\n\t\tmixins = superclass;\r\n\t\tsuperclass = mixins.shift();\r\n\t}\r\n\t// construct intermediate classes for mixins\r\n\tif(mixins){\r\n\t\tdojo.forEach(mixins, function(m, i){\r\n\t\t\tif(!m){ throw(className + \": mixin #\" + i + \" is null\"); } // It's likely a required module is not loaded\r\n\t\t\tsuperclass = dd._delegate(superclass, m);\r\n\t\t});\r\n\t}\r\n\t// create constructor\r\n\tvar ctor = dd._delegate(superclass);\r\n\t// extend with \"props\"\r\n\tprops = props || {};\r\n\tctor.extend(props);\r\n\t// more prototype decoration\r\n\tdojo.extend(ctor, { declaredClass: className, _constructor: props.constructor/*, preamble: null*/ });\r\n\t// special help for IE\r\n\tctor.prototype.constructor = ctor;\r\n\t// create named reference\r\n\treturn dojo.setObject(className, ctor); // Function\r\n};\r\n\r\ndojo.mixin(dojox.lang.tests.declareOld, {\r\n\t_delegate: function(base, mixin){\r\n\t\tvar bp = (base || 0).prototype, mp = (mixin || 0).prototype, dd = dojox.lang.tests.declareOld;\r\n\t\t// fresh constructor, fresh prototype\r\n\t\tvar ctor = dd._makeCtor();\r\n\t\t// cache ancestry\r\n\t\tdojo.mixin(ctor, { superclass: bp, mixin: mp, extend: dd._extend });\r\n\t\t// chain prototypes\r\n\t\tif(base){ ctor.prototype = dojo._delegate(bp); }\r\n\t\t// add mixin and core\r\n\t\tdojo.extend(ctor, dd._core, mp || 0, { _constructor: null, preamble: null });\r\n\t\t// special help for IE\r\n\t\tctor.prototype.constructor = ctor;\r\n\t\t// name this class for debugging\r\n\t\tctor.prototype.declaredClass = (bp || 0).declaredClass + '_' + (mp || 0).declaredClass;\r\n\t\treturn ctor;\r\n\t},\r\n\t_extend: function(props){\r\n\t\tvar i, fn;\r\n\t\tfor(i in props){ if(dojo.isFunction(fn=props[i]) && !0[i]){fn.nom=i;fn.ctor=this;} }\r\n\t\tdojo.extend(this, props);\r\n\t},\r\n\t_makeCtor: function(){\r\n\t\t// we have to make a function, but don't want to close over anything\r\n\t\treturn function(){ this._construct(arguments); };\r\n\t},\r\n\t_core: {\r\n\t\t_construct: function(args){\r\n\t\t\tvar c = args.callee, s = c.superclass, ct = s && s.constructor,\r\n\t\t\t\tm = c.mixin, mct = m && m.constructor, a = args, ii, fn;\r\n\t\t\t// side-effect of = used on purpose here, lint may complain, don't try this at home\r\n\t\t\tif(a[0]){\r\n\t\t\t\t// FIXME: preambles for each mixin should be allowed\r\n\t\t\t\t// FIXME:\r\n\t\t\t\t//\t\tshould we allow the preamble here NOT to modify the\r\n\t\t\t\t//\t\tdefault args, but instead to act on each mixin\r\n\t\t\t\t//\t\tindependently of the class instance being constructed\r\n\t\t\t\t//\t\t(for impedence matching)?\r\n\r\n\t\t\t\t// allow any first argument w/ a \"preamble\" property to act as a\r\n\t\t\t\t// class preamble (not exclusive of the prototype preamble)\r\n\t\t\t\tif(/*dojo.isFunction*/((fn = a[0].preamble))){\r\n\t\t\t\t\ta = fn.apply(this, a) || a;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// prototype preamble\r\n\t\t\tif((fn = c.prototype.preamble)){ a = fn.apply(this, a) || a; }\r\n\t\t\t// FIXME:\r\n\t\t\t//\t\tneed to provide an optional prototype-settable\r\n\t\t\t//\t\t\"_explicitSuper\" property which disables this\r\n\t\t\t// initialize superclass\r\n\t\t\tif(ct && ct.apply){ ct.apply(this, a); }\r\n\t\t\t// initialize mixin\r\n\t\t\tif(mct && mct.apply){ mct.apply(this, a); }\r\n\t\t\t// initialize self\r\n\t\t\tif((ii = c.prototype._constructor)){ ii.apply(this, args); }\r\n\t\t\t// post construction\r\n\t\t\tif(this.constructor.prototype == c.prototype && (ct = this.postscript)){ ct.apply(this, args); }\r\n\t\t},\r\n\t\t_findMixin: function(mixin){\r\n\t\t\tvar c = this.constructor, p, m;\r\n\t\t\twhile(c){\r\n\t\t\t\tp = c.superclass;\r\n\t\t\t\tm = c.mixin;\r\n\t\t\t\tif(m == mixin || (m instanceof mixin.constructor)){ return p; }\r\n\t\t\t\tif(m && m._findMixin && (m = m._findMixin(mixin))){ return m; }\r\n\t\t\t\tc = p && p.constructor;\r\n\t\t\t}\r\n\t\t},\r\n\t\t_findMethod: function(name, method, ptype, has){\r\n\t\t\t// consciously trading readability for bytes and speed in this low-level method\r\n\t\t\tvar p=ptype, c, m, f;\r\n\t\t\tdo{\r\n\t\t\t\tc = p.constructor;\r\n\t\t\t\tm = c.mixin;\r\n\t\t\t\t// find method by name in our mixin ancestor\r\n\t\t\t\tif(m && (m = this._findMethod(name, method, m, has))){ return m; }\r\n\t\t\t\t// if we found a named method that either exactly-is or exactly-is-not 'method'\r\n\t\t\t\tif((f = p[name]) && (has == (f == method))){ return p; }\r\n\t\t\t\t// ascend chain\r\n\t\t\t\tp = c.superclass;\r\n\t\t\t}while(p);\r\n\t\t\t// if we couldn't find an ancestor in our primary chain, try a mixin chain\r\n\t\t\treturn !has && (p = this._findMixin(ptype)) && this._findMethod(name, method, p, has);\r\n\t\t},\r\n\t\tinherited: function(name, args, newArgs){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCall an inherited member function of this declared class.\r\n\t\t\t//\r\n\t\t\t// description:\r\n\t\t\t//\t\tCall an inherited member function of this declared class, allowing advanced\r\n\t\t\t//\t\tmanipulation of passed arguments to inherited functions.\r\n\t\t\t//\t\tExplicitly cannot handle the case of intending to pass no `newArgs`, though\r\n\t\t\t//\t\thoping the use in conjunction with `dojo.hitch`. Calling an inherited\r\n\t\t\t//\t\tfunction directly via hitch() is not supported.\r\n\t\t\t//\r\n\t\t\t// name: String?\r\n\t\t\t//\t\tThe name of the method to call. If omitted, the special `arguments` passed is\r\n\t\t\t//\t\tused to determine the inherited function. All subsequent positional arguments\r\n\t\t\t//\t\tare shifted left if `name` has been omitted. (eg: args becomes name)\r\n\t\t\t//\r\n\t\t\t// args: Object\r\n\t\t\t//\t\tAn `arguments` object to pass along to the inherited function. Can be in the\r\n\t\t\t//\t\t`name` position if `name` has been omitted. This is a literal JavaScript `arguments`\r\n\t\t\t//\t\tobject, and must be passed.\r\n\t\t\t//\r\n\t\t\t// newArgs: Array?\r\n\t\t\t//\t\tAn Array of argument values to pass to the inherited function. If omitted,\r\n\t\t\t//\t\tthe original arguments are passed (determined from the `args` variable)\r\n\t\t\t//\r\n\t\t\t// example:\r\n\t\t\t//\t\tSimply call an inherited function with the same signature.\r\n\t\t\t//\t|\tthis.inherited(arguments);\r\n\t\t\t// example:\r\n\t\t\t//\t\tCall an inherited method, replacing the arguments passed with \"replacement\" and \"args\"\r\n\t\t\t//\t|\tthis.inherited(arguments, [replacement, args]);\r\n\t\t\t// example:\r\n\t\t\t//\t\tCall an inherited method, passing an explicit name.\r\n\t\t\t//\t|\tthis.inherited(\"method\", arguments);\r\n\t\t\t// example:\r\n\t\t\t//\t\tCall an inherited method by name, replacing the arguments:\r\n\t\t\t//\t|\tthis.inherited(\"method\", arguments, [replacement, args]);\r\n\r\n\t\t\tvar a = arguments;\r\n\t\t\t// some magic crap that alters `arguments` to shift in the case of missing `name`\r\n\t\t\tif(typeof a[0] != \"string\"){ // inline'd type check\r\n\t\t\t\tnewArgs = args;\r\n\t\t\t\targs = name;\r\n\t\t\t\tname = args.callee.nom;\r\n\t\t\t}\r\n\t\t\ta = newArgs || args; // WARNING: hitch()ed functions may pass a newArgs you aren't expecting.\r\n\t\t\tvar c = args.callee, p = this.constructor.prototype, fn, mp;\r\n\t\t\t// if not an instance override\r\n\t\t\tif(this[name] != c || p[name] == c){\r\n\t\t\t\t// start from memoized prototype, or\r\n\t\t\t\t// find a prototype that has property 'name' == 'c'\r\n\t\t\t\tmp = (c.ctor || 0).superclass || this._findMethod(name, c, p, true);\r\n\t\t\t\tif(!mp){ throw(this.declaredClass + ': inherited method \"' + name + '\" mismatch'); }\r\n\t\t\t\t// find a prototype that has property 'name' != 'c'\r\n\t\t\t\tp = this._findMethod(name, c, mp, false);\r\n\t\t\t}\r\n\t\t\t// we expect 'name' to be in prototype 'p'\r\n\t\t\tfn = p && p[name];\r\n\t\t\tif(!fn){ throw( mp.declaredClass + ': inherited method \"' + name + '\" not found'); }\r\n\t\t\t// if the function exists, invoke it in our scope\r\n\t\t\treturn fn.apply(this, a);\r\n\t\t}\r\n\t}\r\n});\r\n"]}