{"version":3,"sources":["lang/tests/observable.js"],"names":["dojo","provide","require","tests","register","t","console","log","testStrs","observable","dojox","lang","makeObservable","obj","i","push","value","scope","args","apply","newObj","foo","test","this","assertEqual","join","ReadOnlyProxy","bar","start","Date","getTime","store","item","property","lazyCallback","Deferred","rpc","_sync","addCallback","returned"],"mappings":";;;;;;;AAAAA,KAAKC,QAAQ,+BACbD,KAAKE,QAAQ,yBAGZC,MAAMC,SAAS,+BACd,SAAsCC,GACrCC,QAAQC,IAAI,SACZ,IAAIC,KACAC,EAAa,IAAIC,MAAMC,KAAKC,eAC/B,SAASC,EAAIC,GAEZ,OADAN,EAASO,KAAK,UAAYD,GACnBD,EAAIC,IAEZ,SAASD,EAAIC,EAAEE,GACdR,EAASO,KAAK,WAAaD,GAC3BD,EAAIC,GAAKE,GAEV,SAASC,EAAMJ,EAAIC,EAAEI,GAEpB,OADAV,EAASO,KAAK,YAAcD,GACrBD,EAAIC,GAAGK,MAAMF,EAAMC,KAOxBE,EAASX,GAJFY,IAAI,MAAMC,KAAK,WACxB,OAAOC,KAAKF,OAIdb,EAASO,KAAK,YAAcK,EAAOE,QACnCF,EAAOC,IAAM,MACbb,EAASO,KAAKK,EAAOC,KACrBhB,EAAEmB,YAAY,mEAAmEhB,EAASiB,KAAK,OAEhG,SAAkCpB,GACjC,IAAIG,KAIAY,EAASV,MAAMC,KAAKF,YAHbY,IAAI,MAAMC,KAAK,WACzB,OAAOC,KAAKF,MAE0B,SAASR,EAAIC,GAElD,OADAN,EAASO,KAAK,UAAYD,GACnBD,EAAIC,IACV,SAASD,EAAIC,EAAEE,GAChBR,EAASO,KAAK,WAAaD,GAC3BD,EAAIC,GAAKE,GACR,SAASC,EAAMJ,EAAIC,EAAEI,GAEtB,OADAV,EAASO,KAAK,YAAcD,GACrBD,EAAIC,GAAGK,MAAMF,EAAMC,KAG5BV,EAASO,KAAK,YAAcK,EAAOE,QACnCF,EAAOC,IAAM,MACbb,EAASO,KAAKK,EAAOC,KACrBhB,EAAEmB,YAAY,mEAAmEhB,EAASiB,KAAK,OAEhG,SAAuBpB,GACtBC,QAAQC,IAAI,SACZ,IAAIC,KACAK,GAAOQ,IAAI,OACXD,EAASV,MAAMC,KAAKe,cAAcb,GACtCL,EAASO,KAAKK,EAAOC,KACrBD,EAAOC,IAAM,UAEbb,EAASO,KAAKK,EAAOC,KACrBR,EAAIQ,IAAM,MACVb,EAASO,KAAKK,EAAOC,KACrBhB,EAAEmB,YAAY,cAAchB,EAASiB,KAAK,OAE3C,SAAcpB,GAkBb,IAjBA,IAGII,EAAa,IAAIC,MAAMC,KAAKC,eAC/B,SAASC,EAAIC,GACZ,OAAOD,EAAIC,IAEZ,SAASD,EAAIC,EAAEE,GACdH,EAAIC,GAAKE,GAEV,SAASC,EAAMJ,EAAIC,EAAEI,GACpB,OAAOL,EAAIC,GAAGK,MAAMF,EAAMC,KAGxBL,GAAOQ,IAAI,MAAMM,IAAI,OAErBC,GADSnB,EAAWI,IACZ,IAAIgB,MAAOC,WACfhB,EAAI,EAAGA,EAAI,IAAOA,KAI1B,IAAIiB,EACM,SAASC,EAAMC,EAASC,GAShC,IAAIlB,EAAQgB,EAAKC,GAWjB,OAVGjB,aAAiBhB,KAAKmC,UACxBzB,MAAM0B,IAAIC,OAASH,EACnBlB,EAAMsB,YAAY,SAASC,GAGzB,OAFAvB,EAAQuB,EACLL,GAAcA,EAAalB,GACvBA,WAGFN,MAAM0B,IAAIC,OACTH,GAAcA,EAAalB,GAC7BA,GAKT,IAFAV,QAAQC,KAAI,IAAIsB,MAAOC,UAAYF,GACnCA,GAAQ,IAAIC,MAAOC,UACfhB,EAAI,EAAGA,EAAI,IAAOA,IACjBiB,EAAelB,EAAI,OACnBkB,EAAelB,EAAI,OAIxB,IAFAP,QAAQC,KAAI,IAAIsB,MAAOC,UAAYF,GACnCA,GAAQ,IAAIC,MAAOC,UACfhB,EAAI,EAAGA,EAAI,IAAQA,KAEvBR,QAAQC,KAAI,IAAIsB,MAAOC,UAAYF","file":"../../../lang/tests/observable.js","sourcesContent":["dojo.provide(\"dojox.lang.tests.observable\");\r\ndojo.require(\"dojox.lang.observable\");\r\n\r\n(function(){\r\n\ttests.register(\"dojox.lang.tests.observable\", [\r\n\t\tfunction propertyAccessMakeObservable(t){\r\n\t\t\tconsole.log(\"start\");\r\n\t\t\tvar testStrs = [];\r\n\t\t\tvar observable = new dojox.lang.makeObservable(\r\n\t\t\t\tfunction(obj,i){\r\n\t\t\t\t\ttestStrs.push(\"onRead \" + i);\r\n\t\t\t\t\treturn obj[i];\r\n\t\t\t\t},\r\n\t\t\t\tfunction(obj,i,value){\r\n\t\t\t\t\ttestStrs.push(\"onWrite \" + i);\r\n\t\t\t\t\tobj[i] = value;\r\n\t\t\t\t},\r\n\t\t\t\tfunction(scope,obj,i,args){\r\n\t\t\t\t\ttestStrs.push(\"onInvoke \" + i);\r\n\t\t\t\t\treturn obj[i].apply(scope,args);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\tvar obj = {foo:\"bar\",test:function(){\r\n\t\t\t\t\treturn this.foo;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tvar newObj = observable(obj);\r\n\t\t\ttestStrs.push(\"returned \" + newObj.test());\r\n\t\t\tnewObj.foo = \"new\";\r\n\t\t\ttestStrs.push(newObj.foo);\r\n\t\t\tt.assertEqual(\"onInvoke test,onRead foo,returned bar,onWrite foo,onRead foo,new\",testStrs.join(','));\r\n\t\t},\r\n\t\tfunction propertyAccessObservable(t){\r\n\t\t\tvar testStrs = [];\r\n\t\t\tvar obj = {foo:\"bar\",test:function(){\r\n\t\t\t\treturn this.foo;\r\n\t\t\t}};\r\n\t\t\tvar newObj = dojox.lang.observable(obj,function(obj,i){\r\n\t\t\t\t\ttestStrs.push(\"onRead \" + i);\r\n\t\t\t\t\treturn obj[i];\r\n\t\t\t\t},function(obj,i,value){\r\n\t\t\t\t\ttestStrs.push(\"onWrite \" + i);\r\n\t\t\t\t\tobj[i] = value;\r\n\t\t\t\t},function(scope,obj,i,args){\r\n\t\t\t\t\ttestStrs.push(\"onInvoke \" + i);\r\n\t\t\t\t\treturn obj[i].apply(scope,args);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\ttestStrs.push(\"returned \" + newObj.test());\r\n\t\t\tnewObj.foo = \"new\";\r\n\t\t\ttestStrs.push(newObj.foo);\r\n\t\t\tt.assertEqual(\"onInvoke test,onRead foo,returned bar,onWrite foo,onRead foo,new\",testStrs.join(','));\r\n\t\t},\r\n\t\tfunction readonlyProxy(t){\r\n\t\t\tconsole.log(\"start\");\r\n\t\t\tvar testStrs = [];\r\n\t\t\tvar obj = {foo:\"bar\"};\r\n\t\t\tvar newObj = dojox.lang.ReadOnlyProxy(obj);\r\n\t\t\ttestStrs.push(newObj.foo);\r\n\t\t\tnewObj.foo = \"illegal\";\r\n\r\n\t\t\ttestStrs.push(newObj.foo);\r\n\t\t\tobj.foo = \"new\";\r\n\t\t\ttestStrs.push(newObj.foo);\r\n\t\t\tt.assertEqual(\"bar,bar,new\",testStrs.join(','));\r\n\t\t},\r\n\t\tfunction perf(t){\r\n\t\t\tvar getter = function(obj,i){\r\n\t\t\t\treturn obj[i];\r\n\t\t\t};\r\n\t\t\tvar observable = new dojox.lang.makeObservable(\r\n\t\t\t\tfunction(obj,i){\r\n\t\t\t\t\treturn obj[i];\r\n\t\t\t\t},\r\n\t\t\t\tfunction(obj,i,value){\r\n\t\t\t\t\tobj[i] = value;\r\n\t\t\t\t},\r\n\t\t\t\tfunction(scope,obj,i,args){\r\n\t\t\t\t\treturn obj[i].apply(scope,args);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\tvar obj = {foo:\"bar\",bar:'foo'};\r\n\t\t\tvar newObj = observable(obj);\r\n\t\t\tvar start = new Date().getTime();\r\n\t\t\tfor(var i = 0; i < 100000;i++){ // normal access\r\n\t\t\t\tvar a = obj.foo;\r\n\t\t\t\ta = obj.bar;\r\n\t\t\t}\r\n\t\t\tvar store = {\r\n\t\t\t\tgetValue:function(item, property,lazyCallback){\r\n\t\t\t\t\t// summary:\r\n\t\t\t\t\t//\tGets the value of an item's 'property'\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// item: /* object */\r\n\t\t\t\t\t// property: /* string */\r\n\t\t\t\t\t//\t\tproperty to look up value for\r\n\t\t\t\t\t// lazyCallback: /* function*/\r\n\t\t\t\t\t//\t\tnot part of the API, but if you are using lazy loading properties, you may provide a callback to resume, in order to have asynchronous loading\r\n\t\t\t\t\tvar value = item[property];\r\n\t\t\t\t\tif(value instanceof dojo.Deferred){\r\n\t\t\t\t\t\tdojox.rpc._sync = !lazyCallback; // tell the service to operate synchronously (I have some concerns about the \"thread\" safety with FF3, as I think it does event stacking on sync calls)\r\n\t\t\t\t\t\tvalue.addCallback(function(returned){\r\n\t\t\t\t\t\t\t\tvalue = returned;\r\n\t\t\t\t\t\t\t\tif(lazyCallback){lazyCallback(value);}\r\n\t\t\t\t\t\t\t\treturn value;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tdelete dojox.rpc._sync; // revert to normal async behavior\r\n\t\t\t\t\t}else if(lazyCallback){lazyCallback(value);}\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tconsole.log(new Date().getTime() - start);\r\n\t\t\tstart = new Date().getTime();\r\n\t\t\tfor(i = 0; i < 100000;i++){// observed access\r\n\t\t\t\ta = store.getValue(obj,\"foo\");\r\n\t\t\t\ta = store.getValue(obj,\"bar\");\r\n\t\t\t}\r\n\t\t\tconsole.log(new Date().getTime() - start);\r\n\t\t\tstart = new Date().getTime();\r\n\t\t\tfor(i = 0; i < 1000000;i++){ // measure the loop time itself\r\n\t\t\t}\r\n\t\t\tconsole.log(new Date().getTime() - start);\r\n\t\t}\r\n\t]);\r\n})();\r\n"]}