{"version":3,"sources":["json/schema.js"],"names":["define","dojo","dojox","getObject","json","schema","validate","instance","this","_validate","checkPropertyChange","value","property","mustBeValid","result","valid","TypeError","map","errors","error","message","join","_changing","checkProp","path","i","l","addError","push","Array","Object","name","checkType","type","unionErrors","j","length","priorErrors","theseErrors","readonly","undefined","optional","concat","disallow","items","minItems","maxItems","properties","objTypeDef","additionalProp","hasOwnProperty","charAt","propDef","requires","$schema","checkObj","additionalProperties","pattern","match","maxLength","minLength","minimum","maximum","found","enumer","maxDecimal","toString","RegExp"],"mappings":"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","file":"../../json/schema.js","sourcesContent":["define([\"dojo/_base/kernel\", \"dojox\", \"dojo/_base/array\"], function(dojo, dojox){\r\n\r\ndojo.getObject(\"json.schema\", true, dojox);\r\n\r\n\r\ndojox.json.schema.validate = function(/*Any*/instance,/*Object*/schema){\r\n\t// summary:\r\n\t//\t\tTo use the validator call this with an instance object and an optional schema object.\r\n\t//\t\tIf a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),\r\n\t//\t\tthat schema will be used to validate and the schema parameter is not necessary (if both exist,\r\n\t//\t\tboth validations will occur).\r\n\t// instance:\r\n\t//\t\tThe instance value/object to validate\r\n\t// schema:\r\n\t//\t\tThe schema to use to validate\r\n\t// description:\r\n\t//\t\tThe validate method will return an object with two properties:\r\n\t//\r\n\t//\t\t- valid: A boolean indicating if the instance is valid by the schema\r\n\t//\t\t- errors: An array of validation errors. If there are no errors, then an\r\n\t//\t\t  empty list will be returned. A validation error will have two properties:\r\n\t//\t\t- property: which indicates which property had the error\r\n\t//\t\t- message: which indicates what the error was\r\n\r\n\treturn this._validate(instance,schema,false);\r\n};\r\ndojox.json.schema.checkPropertyChange = function(/*Any*/value,/*Object*/schema, /*String*/ property){\r\n\t// summary:\r\n\t//\t\tThe checkPropertyChange method will check to see if an value can legally be in property with the given schema\r\n\t//\t\tThis is slightly different than the validate method in that it will fail if the schema is readonly and it will\r\n\t//\t\tnot check for self-validation, it is assumed that the passed in value is already internally valid.\r\n\t//\t\tThe checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for\r\n\t//\t\tinformation.\r\n\t// value:\r\n\t//\t\tThe new instance value/object to check\r\n\t// schema:\r\n\t//\t\tThe schema to use to validate\r\n\t// returns:\r\n\t//\t\tsee dojox.validate.jsonSchema.validate\r\n\r\n\treturn this._validate(value,schema, property || \"property\");\r\n};\r\ndojox.json.schema.mustBeValid = function(result){\r\n\t// summary:\r\n\t//\t\tThis checks to ensure that the result is valid and will throw an appropriate error message if it is not\r\n\t// result: the result returned from checkPropertyChange or validate\r\n\tif(!result.valid){\r\n\t\tthrow new TypeError(dojo.map(result.errors,function(error){return \"for property \" + error.property + ': ' + error.message;}).join(\", \"));\r\n\t}\r\n};\r\ndojox.json.schema._validate = function(/*Any*/instance,/*Object*/schema,/*Boolean*/ _changing){\r\n\t\r\n\tvar errors = [];\r\n\t\t// validate a value against a property definition\r\n\tfunction checkProp(value, schema, path,i){\r\n\t\tvar l;\r\n\t\tpath += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;\r\n\t\tfunction addError(message){\r\n\t\t\terrors.push({property:path,message:message});\r\n\t\t}\r\n\t\t\r\n\t\tif((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function')){\r\n\t\t\tif(typeof schema == 'function'){\r\n\t\t\t\tif(!(Object(value) instanceof schema)){\r\n\t\t\t\t\taddError(\"is not an instance of the class/constructor \" + schema.name);\r\n\t\t\t\t}\r\n\t\t\t}else if(schema){\r\n\t\t\t\taddError(\"Invalid schema/property definition \" + schema);\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif(_changing && schema.readonly){\r\n\t\t\taddError(\"is a readonly field, it can not be changed\");\r\n\t\t}\r\n\t\tif(schema['extends']){ // if it extends another schema, it must pass that schema as well\r\n\t\t\tcheckProp(value,schema['extends'],path,i);\r\n\t\t}\r\n\t\t// validate a value against a type definition\r\n\t\tfunction checkType(type,value){\r\n\t\t\tif(type){\r\n\t\t\t\tif(typeof type == 'string' && type != 'any' &&\r\n\t\t\t\t\t\t(type == 'null' ? value !== null : typeof value != type) &&\r\n\t\t\t\t\t\t!(value instanceof Array && type == 'array') &&\r\n\t\t\t\t\t\t!(type == 'integer' && value%1===0)){\r\n\t\t\t\t\treturn [{property:path,message:(typeof value) + \" value found, but a \" + type + \" is required\"}];\r\n\t\t\t\t}\r\n\t\t\t\tif(type instanceof Array){\r\n\t\t\t\t\tvar unionErrors=[];\r\n\t\t\t\t\tfor(var j = 0; j < type.length; j++){ // a union type\r\n\t\t\t\t\t\tif(!(unionErrors=checkType(type[j],value)).length){\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(unionErrors.length){\r\n\t\t\t\t\t\treturn unionErrors;\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(typeof type == 'object'){\r\n\t\t\t\t\tvar priorErrors = errors;\r\n\t\t\t\t\terrors = [];\r\n\t\t\t\t\tcheckProp(value,type,path);\r\n\t\t\t\t\tvar theseErrors = errors;\r\n\t\t\t\t\terrors = priorErrors;\r\n\t\t\t\t\treturn theseErrors;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\tif(value === undefined){\r\n\t\t\tif(!schema.optional){\r\n\t\t\t\taddError(\"is missing and it is not optional\");\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\terrors = errors.concat(checkType(schema.type,value));\r\n\t\t\tif(schema.disallow && !checkType(schema.disallow,value).length){\r\n\t\t\t\taddError(\" disallowed value was matched\");\r\n\t\t\t}\r\n\t\t\tif(value !== null){\r\n\t\t\t\tif(value instanceof Array){\r\n\t\t\t\t\tif(schema.items){\r\n\t\t\t\t\t\tif(schema.items instanceof Array){\r\n\t\t\t\t\t\t\tfor(i=0,l=value.length; i<l; i++){\r\n\t\t\t\t\t\t\t\terrors.concat(checkProp(value[i],schema.items[i],path,i));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tfor(i=0,l=value.length; i<l; i++){\r\n\t\t\t\t\t\t\t\terrors.concat(checkProp(value[i],schema.items,path,i));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(schema.minItems && value.length < schema.minItems){\r\n\t\t\t\t\t\taddError(\"There must be a minimum of \" + schema.minItems + \" in the array\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(schema.maxItems && value.length > schema.maxItems){\r\n\t\t\t\t\t\taddError(\"There must be a maximum of \" + schema.maxItems + \" in the array\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(schema.properties){\r\n\t\t\t\t\terrors.concat(checkObj(value,schema.properties,path,schema.additionalProperties));\r\n\t\t\t\t}\r\n\t\t\t\tif(schema.pattern && typeof value == 'string' && !value.match(schema.pattern)){\r\n\t\t\t\t\taddError(\"does not match the regex pattern \" + schema.pattern);\r\n\t\t\t\t}\r\n\t\t\t\tif(schema.maxLength && typeof value == 'string' && value.length > schema.maxLength){\r\n\t\t\t\t\taddError(\"may only be \" + schema.maxLength + \" characters long\");\r\n\t\t\t\t}\r\n\t\t\t\tif(schema.minLength && typeof value == 'string' && value.length < schema.minLength){\r\n\t\t\t\t\taddError(\"must be at least \" + schema.minLength + \" characters long\");\r\n\t\t\t\t}\r\n\t\t\t\tif(typeof schema.minimum !== undefined && typeof value == typeof schema.minimum &&\r\n\t\t\t\t\t\tschema.minimum > value){\r\n\t\t\t\t\taddError(\"must have a minimum value of \" + schema.minimum);\r\n\t\t\t\t}\r\n\t\t\t\tif(typeof schema.maximum !== undefined && typeof value == typeof schema.maximum &&\r\n\t\t\t\t\t\tschema.maximum < value){\r\n\t\t\t\t\taddError(\"must have a maximum value of \" + schema.maximum);\r\n\t\t\t\t}\r\n\t\t\t\tif(schema['enum']){\r\n\t\t\t\t\tvar enumer = schema['enum'];\r\n\t\t\t\t\tl = enumer.length;\r\n\t\t\t\t\tvar found;\r\n\t\t\t\t\tfor(var j = 0; j < l; j++){\r\n\t\t\t\t\t\tif(enumer[j]===value){\r\n\t\t\t\t\t\t\tfound=1;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(!found){\r\n\t\t\t\t\t\taddError(\"does not have a value in the enumeration \" + enumer.join(\", \"));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(typeof schema.maxDecimal == 'number' &&\r\n\t\t\t\t\t(value.toString().match(new RegExp(\"\\\\.[0-9]{\" + (schema.maxDecimal + 1) + \",}\")))){\r\n\t\t\t\t\taddError(\"may only have \" + schema.maxDecimal + \" digits of decimal places\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\t// validate an object against a schema\r\n\tfunction checkObj(instance,objTypeDef,path,additionalProp){\r\n\t\r\n\t\tif(typeof objTypeDef =='object'){\r\n\t\t\tif(typeof instance != 'object' || instance instanceof Array){\r\n\t\t\t\terrors.push({property:path,message:\"an object is required\"});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var i in objTypeDef){\r\n\t\t\t\tif(objTypeDef.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_')){\r\n\t\t\t\t\tvar value = instance[i];\r\n\t\t\t\t\tvar propDef = objTypeDef[i];\r\n\t\t\t\t\tcheckProp(value,propDef,path,i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(i in instance){\r\n\t\t\tif(instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp===false){\r\n\t\t\t\terrors.push({property:path,message:(typeof value) + \"The property \" + i +\r\n\t\t\t\t\t\t\" is not defined in the schema and the schema does not allow additional properties\"});\r\n\t\t\t}\r\n\t\t\tvar requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;\r\n\t\t\tif(requires && !(requires in instance)){\r\n\t\t\t\terrors.push({property:path,message:\"the presence of the property \" + i + \" requires that \" + requires + \" also be present\"});\r\n\t\t\t}\r\n\t\t\tvalue = instance[i];\r\n\t\t\tif(objTypeDef && typeof objTypeDef == 'object' && !(i in objTypeDef)){\r\n\t\t\t\tcheckProp(value,additionalProp,path,i);\r\n\t\t\t}\r\n\t\t\tif(!_changing && value && value.$schema){\r\n\t\t\t\terrors = errors.concat(checkProp(value,value.$schema,path,i));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn errors;\r\n\t}\r\n\tif(schema){\r\n\t\tcheckProp(instance,schema,'',_changing || '');\r\n\t}\r\n\tif(!_changing && instance && instance.$schema){\r\n\t\tcheckProp(instance,instance.$schema,'','');\r\n\t}\r\n\treturn {valid:!errors.length,errors:errors};\r\n};\r\n\r\nreturn dojox.json.schema;\r\n});\r\n"]}