{"version":3,"sources":["json/query.js"],"names":["define","dojo","lang","dojox","getObject","json","_slice","obj","start","end","step","len","length","results","Math","max","min","i","push","_find","name","Array","walk","val","_distinctFilter","array","callback","outArr","primitives","l","value","__included","query","depth","str","replace","t","charAt","prefix","call","makeRegex","a","b","c","d","e","f","g","match","substring","Error","oper","executor","eval","arguments","apply","this"],"mappings":";;;;;;;AAAAA,QAAQ,oBAAqB,kBAAmB,QAAS,oBAAqB,SAASC,KAAMC,KAAMC,OAsFlG,OApFAD,KAAKE,UAAU,QAAQ,EAAMD,OAE7BA,MAAME,KAAKC,OAAS,SAASC,EAAIC,EAAMC,EAAIC,GAE1C,IAAIC,EAAIJ,EAAIK,OAAOC,KACnBJ,EAAMA,GAAOE,EACbH,EAASA,EAAQ,EAAKM,KAAKC,IAAI,EAAEP,EAAMG,GAAOG,KAAKE,IAAIL,EAAIH,GAC3DC,EAAOA,EAAM,EAAKK,KAAKC,IAAI,EAAEN,EAAIE,GAAOG,KAAKE,IAAIL,EAAIF,GACnD,IAAI,IAAIQ,EAAET,EAAOS,EAAER,EAAKQ,GAAGP,EAC1BG,EAAQK,KAAKX,EAAIU,IAEpB,OAAOJ,GAERV,MAAME,KAAKc,MAAQ,SAAWZ,EAAIa,GAGjC,IAAIP,KAsBJ,GAAGO,aAAgBC,MAAM,CAExB,GAAgB,GAAbD,EAAKR,OAIP,OAAOL,EAAIa,EAAK,IAEjB,IAAI,IAAIH,EAAI,EAAGA,EAAIG,EAAKR,OAAQK,IAC/BJ,EAAQK,KAAKX,EAAIa,EAAKH,UA9BxB,SAASK,EAAKf,GAUb,IAAI,IAAIU,KATLG,KACQ,IAAPA,GAAiBb,aAAec,MAG1Bd,EAAIa,IAEZP,EAAQK,KAAKX,EAAIa,IAHjBP,EAAQK,KAAKX,IAMFA,EAAI,CAChB,IAAIgB,EAAMhB,EAAIU,GACVG,EAGKG,GAAqB,iBAAPA,GAEtBD,EAAKC,GAHLV,EAAQK,KAAKK,IAoBfD,CAAKf,GAEN,OAAOM,GAGRV,MAAME,KAAKmB,gBAAkB,SAASC,EAAOC,GAI5C,IAFA,IAAIC,KACAC,KACIX,EAAE,EAAEY,EAAEJ,EAAMb,OAAQK,EAAEY,IAAKZ,EAAE,CACpC,IAAIa,EAAQL,EAAMR,GACfS,EAASI,EAAOb,EAAGQ,KACD,iBAATK,GAAsBA,EAE5BA,EAAMC,aACTD,EAAMC,YAAa,EACnBJ,EAAOT,KAAKY,IAEJF,EAAWE,SAAeA,KAEnCF,EAAWE,SAAeA,IAAS,EACnCH,EAAOT,KAAKY,KAIf,IAAIb,EAAE,EAAEY,EAAEF,EAAOf,OAAQK,EAAEY,IAAKZ,EAE5BU,EAAOV,WACFU,EAAOV,GAAGc,WAGnB,OAAOJ,GAEDxB,MAAME,KAAK2B,MAAQ,SAAmBA,MAAiBzB,KA0F7D,IAAI0B,MAAQ,EACRC,OACJF,MAAQA,MAAMG,QAAQ,0CAA0C,SAASC,GAExE,MAAa,KAALA,IADRH,OAAc,KAALG,EAAW,EAAS,KAALA,GAAY,EAAI,GACZ,EAAK,KACf,KAAfA,EAAEC,OAAO,IAA4B,KAAfD,EAAEC,OAAO,GAAa,KAAOH,IAAIhB,KAAKkB,GAAK,GACjEA,IAEJ,IAAIE,OAAS,GACb,SAASC,KAAKnB,GAEbkB,OAASlB,EAAO,IAAMkB,OAEvB,SAASE,UAAUJ,EAAEK,EAAEC,EAAEC,EAAEC,EAAEC,EAAEC,EAAEC,GAEhC,OAAOb,IAAIa,GAAGC,MAAM,WAAkB,KAALF,EAC/B,KAAOZ,IAAIa,GAAGE,UAAU,EAAEf,IAAIa,GAAGnC,OAAO,GAAGuB,QAAQ,+BAA+B,UAAUA,QAAQ,YAAY,eAAsB,KAALW,EAAW,MAAQ,MAAQ,SAAWL,EAAI,IAC3KL,EAEHJ,MAAMG,QAAQ,kDAAkD,WAC/D,MAAM,IAAIe,MAAM,0BAGjBlB,MAAQA,MAAMG,QAAQ,mBAAmB,SACxCA,QAAQ,iCAAiC,SAASC,GACjD,MAAsB,KAAfA,EAAEC,OAAO,GAAYD,EACtB,KAALA,EAAW,QACVA,EAAEY,MAAM,iCAAmC,GAAK,SAAWZ,IAE9DD,QAAQ,mDAAmD,SAASC,EAAEK,EAAEC,GACvE,IAAIS,EAAOf,EAAEY,MAAM,8CACnB,GAAGG,EAAK,CACP,IAAIb,EAAS,GAOb,OANGF,EAAEY,MAAM,SAEVT,KAAK,oBACLD,EAAS,UAEVC,KAAKY,EAAK,GAAGH,MAAM,MAAQ,WAAaG,EAAK,GAAGH,MAAM,MAAQ,6BAA+B,eACtFV,EAAS,0BAA4Ba,EAAK,GAAK,KAGvD,OADAA,EAAOf,EAAEY,MAAM,uBAGP,gCAAkCG,EAAK,GAAGhB,QAAQ,kCAAkC,SAASC,EAAEK,EAAEC,GACtG,MAAO,WAAaA,EAAEP,QAAQ,QAAQ,KAAO,QAAUO,EAAEP,QAAQ,QAAQ,KACvE,gCAAsC,KAAJM,EAAU,GAAK,GAAI,mCAChB,KAAJA,GAAW,EAAI,GAAI,SACnD,eAENU,EAAOf,EAAEY,MAAM,4CAEdT,KAAK,qBACE,KAAOY,EAAK,IAAM,GAAK,KAAOA,EAAK,IAAM,GAAK,KAAOA,EAAK,IAAM,GAAK,KAE1Ef,EAAEY,MAAM,8BACVT,KAAK,qBACkB,KAAfH,EAAEC,OAAO,GACf,KAAOK,EAAI,IACVN,EAAEY,MAAM,KACP,IAAMZ,EACN,IAAM,KAEJA,IAERD,QAAQ,2EAA2EK,WACnFL,QAAQ,2EAA2E,SAASC,EAAEK,EAAEC,EAAEC,EAAEC,EAAEC,EAAEC,EAAEC,GACzG,OAAOP,UAAUJ,EAAEO,EAAEC,EAAEC,EAAEC,EAAEC,EAAEL,EAAED,KAEjCT,MAAQM,QAA6B,KAAnBN,MAAMK,OAAO,GAAY,GAAK,KAAOL,MAAMG,QAAQ,gBAAgB,SAASC,EAAEK,GAE/F,MAAY,KAALA,EAAW,IAAMP,IAAIO,KAK7B,IADA,IAAIW,SAAWC,KAAK,+DAAiErB,MAAQ,KACrFf,EAAI,EAAEA,EAAEqC,UAAU1C,OAAO,EAAEK,IAClCqC,UAAUrC,GAAKqC,UAAUrC,EAAE,GAE5B,OAAOV,IAAM6C,SAASG,MAAMC,KAAKF,WAAaF","file":"../../json/query.js","sourcesContent":["define([\"dojo/_base/kernel\", \"dojo/_base/lang\", \"dojox\", \"dojo/_base/array\"], function(dojo, lang, dojox){\r\n\r\n\tlang.getObject(\"json\", true, dojox);\r\n\r\n\tdojox.json._slice = function(obj,start,end,step){\r\n\t\t// handles slice operations: [3:6:2]\r\n\t\tvar len=obj.length,results = [];\r\n\t\tend = end || len;\r\n\t\tstart = (start < 0) ? Math.max(0,start+len) : Math.min(len,start);\r\n\t\tend = (end < 0) ? Math.max(0,end+len) : Math.min(len,end);\r\n\t  \tfor(var i=start; i<end; i+=step){\r\n\t  \t\tresults.push(obj[i]);\r\n\t  \t}\r\n\t\treturn results;\r\n\t};\r\n\tdojox.json._find = function e(obj,name){\r\n\t\t// handles ..name, .*, [*], [val1,val2], [val]\r\n\t\t// name can be a property to search for, undefined for full recursive, or an array for picking by index\r\n\t\tvar results = [];\r\n\t\tfunction walk(obj){\r\n\t\t\tif(name){\r\n\t\t\t\tif(name===true && !(obj instanceof Array)){\r\n\t\t\t\t\t//recursive object search\r\n\t\t\t\t\tresults.push(obj);\r\n\t\t\t\t}else if(obj[name]){\r\n\t\t\t\t\t// found the name, add to our results\r\n\t\t\t\t\tresults.push(obj[name]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor(var i in obj){\r\n\t\t\t\tvar val = obj[i];\r\n\t\t\t\tif(!name){\r\n\t\t\t\t\t// if we don't have a name we are just getting all the properties values (.* or [*])\r\n\t\t\t\t\tresults.push(val);\r\n\t\t\t\t}else if(val && typeof val == 'object'){\r\n\r\n\t\t\t\t\twalk(val);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(name instanceof Array){\r\n\t\t\t// this is called when multiple items are in the brackets: [3,4,5]\r\n\t\t\tif(name.length==1){\r\n\t\t\t\t// this can happen as a result of the parser becoming confused about commas\r\n\t\t\t\t// in the brackets like [@.func(4,2)]. Fixing the parser would require recursive\r\n\t\t\t\t// analsys, very expensive, but this fixes the problem nicely.\r\n\t\t\t\treturn obj[name[0]];\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < name.length; i++){\r\n\t\t\t\tresults.push(obj[name[i]]);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// otherwise we expanding\r\n\t\t\twalk(obj);\r\n\t\t}\r\n\t\treturn results;\r\n\t};\r\n\r\n\tdojox.json._distinctFilter = function(array, callback){\r\n\t\t// does the filter with removal of duplicates in O(n)\r\n\t\tvar outArr = [];\r\n\t\tvar primitives = {};\r\n\t\tfor(var i=0,l=array.length; i<l; ++i){\r\n\t\t\tvar value = array[i];\r\n\t\t\tif(callback(value, i, array)){\r\n\t\t\t\tif((typeof value == 'object') && value){\r\n\t\t\t\t\t// with objects we prevent duplicates with a marker property\r\n\t\t\t\t\tif(!value.__included){\r\n\t\t\t\t\t\tvalue.__included = true;\r\n\t\t\t\t\t\toutArr.push(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else if(!primitives[value + typeof value]){\r\n\t\t\t\t\t// with primitives we prevent duplicates by putting it in a map\r\n\t\t\t\t\tprimitives[value + typeof value] = true;\r\n\t\t\t\t\toutArr.push(value);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(i=0,l=outArr.length; i<l; ++i){\r\n\t\t\t// cleanup the marker properties\r\n\t\t\tif(outArr[i]){\r\n\t\t\t\tdelete outArr[i].__included;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn outArr;\r\n\t};\r\n\treturn dojox.json.query = function(/*String*/query,/*Object?*/obj){\r\n\t\t// summary:\r\n\t\t//\t\tPerforms a JSONQuery on the provided object and returns the results.\r\n\t\t//\t\tIf no object is provided (just a query), it returns a \"compiled\" function that evaluates objects\r\n\t\t//\t\taccording to the provided query.\r\n\t\t// query:\r\n\t\t//\t\tQuery string\r\n\t\t// obj:\r\n\t\t//\t\tTarget of the JSONQuery\r\n\t\t// description:\r\n\t\t//\t\tJSONQuery provides a comprehensive set of data querying tools including filtering,\r\n\t\t//\t\trecursive search, sorting, mapping, range selection, and powerful expressions with\r\n\t\t//\t\twildcard string comparisons and various operators. JSONQuery generally supersets\r\n\t\t//\t\tJSONPath and provides syntax that matches and behaves like JavaScript where\r\n\t\t//\t\tpossible.\r\n\t\t//\r\n\t\t//\t\tJSONQuery evaluations begin with the provided object, which can referenced with\r\n\t\t//\t\t$. From\r\n\t\t//\t\tthe starting object, various operators can be successively applied, each operating\r\n\t\t//\t\ton the result of the last operation.\r\n\t\t//\r\n\t\t//\t\tSupported Operators\r\n\t\t//\t\t--------------------\r\n\t\t//\r\n\t\t//\t\t- .property - This will return the provided property of the object, behaving exactly\r\n\t\t//\t\tlike JavaScript.\r\n\t\t//\t\t- [expression] - This returns the property name/index defined by the evaluation of\r\n\t\t//\t\tthe provided expression, behaving exactly like JavaScript.\r\n\t\t//\t\t- [?expression] - This will perform a filter operation on an array, returning all the\r\n\t\t//\t\titems in an array that match the provided expression. This operator does not\r\n\t\t//\t\tneed to be in brackets, you can simply use ?expression, but since it does not\r\n\t\t//\t\thave any containment, no operators can be used afterwards when used\r\n\t\t//\t\twithout brackets.\r\n\t\t//\t\t- [^?expression] - This will perform a distinct filter operation on an array. This behaves\r\n\t\t//\t\tas [?expression] except that it will remove any duplicate values/objects from the\r\n\t\t//\t\tresult set.\r\n\t\t//\t\t- [/expression], [\\expression], [/expression, /expression] - This performs a sort\r\n\t\t//\t\toperation on an array, with sort based on the provide expression. Multiple comma delimited sort\r\n\t\t//\t\texpressions can be provided for multiple sort orders (first being highest priority). /\r\n\t\t//\t\tindicates ascending order and \\ indicates descending order\r\n\t\t//\t\t- [=expression] - This performs a map operation on an array, creating a new array\r\n\t\t//\t\twith each item being the evaluation of the expression for each item in the source array.\r\n\t\t//\t\t- [start:end:step] - This performs an array slice/range operation, returning the elements\r\n\t\t//\t\tfrom the optional start index to the optional end index, stepping by the optional step number.\r\n\t\t//\t\t- [expr,expr] - This a union operator, returning an array of all the property/index values from\r\n\t\t//\t\tthe evaluation of the comma delimited expressions.\r\n\t\t//\t\t- .* or [*] - This returns the values of all the properties of the current object.\r\n\t\t//\t\t- $ - This is the root object, If a JSONQuery expression does not being with a $,\r\n\t\t//\t\tit will be auto-inserted at the beginning.\r\n\t\t//\t\t- @ - This is the current object in filter, sort, and map expressions. This is generally\r\n\t\t//\t\tnot necessary, names are auto-converted to property references of the current object\r\n\t\t//\t\tin expressions.\r\n\t\t//\t\t- ..property - Performs a recursive search for the given property name, returning\r\n\t\t//\t\tan array of all values with such a property name in the current object and any subobjects\r\n\t\t//\t\t- expr = expr - Performs a comparison (like JS's ==). When comparing to\r\n\t\t//\t\ta string, the comparison string may contain wildcards * (matches any number of\r\n\t\t//\t\tcharacters) and ? (matches any single character).\r\n\t\t//\t\t- expr ~ expr - Performs a string comparison with case insensitivity.\r\n\t\t//\t\t- ..[?expression] - This will perform a deep search filter operation on all the objects and\r\n\t\t//\t\tsubobjects of the current data. Rather than only searching an array, this will search\r\n\t\t//\t\tproperty values, arrays, and their children.\r\n\t\t//\t\t- $1,$2,$3, etc. - These are references to extra parameters passed to the query\r\n\t\t//\t\tfunction or the evaluator function.\r\n\t\t//\t\t- +, -, /, *, &, |, %, (, ), <, >, <=, >=, != - These operators behave just as they do\r\n\t\t//\t\tin JavaScript.\r\n\t\t//\r\n\t\t// \t|\tdojox.json.query(queryString,object)\r\n\t\t//\t\tand\r\n\t\t// \t|\tdojox.json.query(queryString)(object)\r\n\t\t//\t\talways return identical results. The first one immediately evaluates, the second one returns a\r\n\t\t//\t\tfunction that then evaluates the object.\r\n\t\t//\r\n\t\t// example:\r\n\t\t// \t|\tdojox.json.query(\"foo\",{foo:\"bar\"})\r\n\t\t//\t\tThis will return \"bar\".\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t|\tevaluator = dojox.json.query(\"?foo='bar'&rating>3\");\r\n\t\t//\t\tThis creates a function that finds all the objects in an array with a property\r\n\t\t//\t\tfoo that is equals to \"bar\" and with a rating property with a value greater\r\n\t\t//\t\tthan 3.\r\n\t\t//\t|\tevaluator([{foo:\"bar\",rating:4},{foo:\"baz\",rating:2}])\r\n\t\t//\t\tThis returns:\r\n\t\t// \t|\t{foo:\"bar\",rating:4}\r\n\t\t//\r\n\t\t// example:\r\n\t\t// \t|\tevaluator = dojox.json.query(\"$[?price<15.00][\\rating][0:10]\");\r\n\t\t// \t \tThis finds objects in array with a price less than 15.00 and sorts then\r\n\t\t//\t\tby rating, highest rated first, and returns the first ten items in from this\r\n\t\t//\t\tfiltered and sorted list.\r\n\t\tvar depth = 0;\r\n\t\tvar str = [];\r\n\t\tquery = query.replace(/\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'|[\\[\\]]/g,function(t){\r\n\t\t\tdepth += t == '[' ? 1 : t == ']' ? -1 : 0; // keep track of bracket depth\r\n\t\t\treturn (t == ']' && depth > 0) ? '`]' : // we mark all the inner brackets as skippable\r\n\t\t\t\t\t(t.charAt(0) == '\"' || t.charAt(0) == \"'\") ? \"`\" + (str.push(t) - 1) :// and replace all the strings\r\n\t\t\t\t\t\tt;\r\n\t\t});\r\n\t\tvar prefix = '';\r\n\t\tfunction call(name){\r\n\t\t\t// creates a function call and puts the expression so far in a parameter for a call\r\n\t\t\tprefix = name + \"(\" + prefix;\r\n\t\t}\r\n\t\tfunction makeRegex(t,a,b,c,d,e,f,g){\r\n\t\t\t// creates a regular expression matcher for when wildcards and ignore case is used\r\n\t\t\treturn str[g].match(/[\\*\\?]/) || f == '~' ?\r\n\t\t\t\t\t\"/^\" + str[g].substring(1,str[g].length-1).replace(/\\\\([btnfr\\\\\"'])|([^\\w\\*\\?])/g,\"\\\\$1$2\").replace(/([\\*\\?])/g,\"[\\\\w\\\\W]$1\") + (f == '~' ? '$/i' : '$/') + \".test(\" + a + \")\" :\r\n\t\t\t\t\tt;\r\n\t\t}\r\n\t\tquery.replace(/(\\]|\\)|push|pop|shift|splice|sort|reverse)\\s*\\(/,function(){\r\n\t\t\tthrow new Error(\"Unsafe function call\");\r\n\t\t});\r\n\r\n\t\tquery = query.replace(/([^<>=]=)([^=])/g,\"$1=$2\"). // change the equals to comparisons except operators ==, <=, >=\r\n\t\t\treplace(/@|(\\.\\s*)?[a-zA-Z\\$_]+(\\s*:)?/g,function(t){\r\n\t\t\t\treturn t.charAt(0) == '.' ? t : // leave .prop alone\r\n\t\t\t\t\tt == '@' ? \"$obj\" :// the reference to the current object\r\n\t\t\t\t\t(t.match(/:|^(\\$|Math|true|false|null)$/) ? \"\" : \"$obj.\") + t; // plain names should be properties of root... unless they are a label in object initializer\r\n\t\t\t}).\r\n\t\t\treplace(/\\.?\\.?\\[(`\\]|[^\\]])*\\]|\\?.*|\\.\\.([\\w\\$_]+)|\\.\\*/g,function(t,a,b){\r\n\t\t\t\tvar oper = t.match(/^\\.?\\.?(\\[\\s*\\^?\\?|\\^?\\?|\\[\\s*==)(.*?)\\]?$/); // [?expr] and ?expr and [=expr and =expr\r\n\t\t\t\tif(oper){\r\n\t\t\t\t\tvar prefix = '';\r\n\t\t\t\t\tif(t.match(/^\\./)){\r\n\t\t\t\t\t\t// recursive object search\r\n\t\t\t\t\t\tcall(\"dojox.json._find\");\r\n\t\t\t\t\t\tprefix = \",true)\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcall(oper[1].match(/\\=/) ? \"dojo.map\" : oper[1].match(/\\^/) ? \"dojox.json._distinctFilter\" : \"dojo.filter\");\r\n\t\t\t\t\treturn prefix + \",function($obj){return \" + oper[2] + \"})\";\r\n\t\t\t\t}\r\n\t\t\t\toper = t.match(/^\\[\\s*([\\/\\\\].*)\\]/); // [/sortexpr,\\sortexpr]\r\n\t\t\t\tif(oper){\r\n\t\t\t\t\t// make a copy of the array and then sort it using the sorting expression\r\n\t\t\t\t\treturn \".concat().sort(function(a,b){\" + oper[1].replace(/\\s*,?\\s*([\\/\\\\])\\s*([^,\\\\\\/]+)/g,function(t,a,b){\r\n\t\t\t\t\t\t\treturn \"var av= \" + b.replace(/\\$obj/,\"a\") + \",bv= \" + b.replace(/\\$obj/,\"b\") + // FIXME: Should check to make sure the $obj token isn't followed by characters\r\n\t\t\t\t\t\t\t\t\t\";if(av>bv||bv==null){return \" + (a== \"/\" ? 1 : -1) +\";}\\n\" +\r\n\t\t\t\t\t\t\t\t\t\"if(bv>av||av==null){return \" + (a== \"/\" ? -1 : 1) +\";}\\n\";\r\n\t\t\t\t\t}) + \"return 0;})\";\r\n\t\t\t\t}\r\n\t\t\t\toper = t.match(/^\\[(-?[0-9]*):(-?[0-9]*):?(-?[0-9]*)\\]/); // slice [0:3]\r\n\t\t\t\tif(oper){\r\n\t\t\t\t\tcall(\"dojox.json._slice\");\r\n\t\t\t\t\treturn \",\" + (oper[1] || 0) + \",\" + (oper[2] || 0) + \",\" + (oper[3] || 1) + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tif(t.match(/^\\.\\.|\\.\\*|\\[\\s*\\*\\s*\\]|,/)){ // ..prop and [*]\r\n\t\t\t\t\tcall(\"dojox.json._find\");\r\n\t\t\t\t\treturn (t.charAt(1) == '.' ?\r\n\t\t\t\t\t\t\t\",'\" + b + \"'\" : // ..prop\r\n\t\t\t\t\t\t\t\tt.match(/,/) ?\r\n\t\t\t\t\t\t\t\t\t\",\" + t : // [prop1,prop2]\r\n\t\t\t\t\t\t\t\t\t\"\") + \")\"; // [*]\r\n\t\t\t\t}\r\n\t\t\t\treturn t;\r\n\t\t\t}).\r\n\t\t\treplace(/(\\$obj\\s*((\\.\\s*[\\w_$]+\\s*)|(\\[\\s*`([0-9]+)\\s*`\\]))*)(==|~)\\s*`([0-9]+)/g,makeRegex). // create regex matching\r\n\t\t\treplace(/`([0-9]+)\\s*(==|~)\\s*(\\$obj\\s*((\\.\\s*[\\w_$]+)|(\\[\\s*`([0-9]+)\\s*`\\]))*)/g,function(t,a,b,c,d,e,f,g){ // and do it for reverse =\r\n\t\t\t\treturn makeRegex(t,c,d,e,f,g,b,a);\r\n\t\t\t});\r\n\t\tquery = prefix + (query.charAt(0) == '$' ? \"\" : \"$\") + query.replace(/`([0-9]+|\\])/g,function(t,a){\r\n\t\t\t//restore the strings\r\n\t\t\treturn a == ']' ? ']' : str[a];\r\n\t\t});\r\n\t\t// create a function within this scope (so it can use expand and slice)\r\n\r\n\t\tvar executor = eval(\"1&&function($,$1,$2,$3,$4,$5,$6,$7,$8,$9){var $obj=$;return \" + query + \"}\");\r\n\t\tfor(var i = 0;i<arguments.length-1;i++){\r\n\t\t\targuments[i] = arguments[i+1];\r\n\t\t}\r\n\t\treturn obj ? executor.apply(this,arguments) : executor;\r\n\t};\r\n\r\n});"]}