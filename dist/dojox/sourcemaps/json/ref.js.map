{"version":3,"sources":["json/ref.js"],"names":["define","array","djson","dojo","lang","stamp","dojox","getObject","json","ref","resolveJson","root","args","idAttribute","refAttribute","this","idAsRef","prefix","idPrefix","assignAbsoluteIds","index","timeStamps","reWalk","pathResolveRegex","addProp","_addProp","F","walk","it","stop","defaultId","needsPrefix","schema","defaultObject","i","update","val","id","undefined","replace","target","__id","schemas","Array","match","$ref","_loadObject","proto","prototype","time","properties","propertyDefinition","format","fromISOString","length","hasOwnProperty","Date","__parent","rewalking","path","toString","t","a","b","c","d","push","loader","__isDirty","old","charAt","getTime","onUpdate","isNaN","onLoad","fromJson","str","refObject","eval","e","SyntaxError","message","toJson","prettyPrint","indexSubObjects","useRefs","_useRefs","paths","generated","serialize","_indentStr","toISOString","zulu","__clientId","substring","nextIndent","toJsonIndentStr","newLine","sep","map","obj","join","output","keyStr","_escapeString","serializeFunctions","prop"],"mappings":";;;;;;;AAAAA,QACC,mBACA,kBACA,oBACA,kBACA,kBACA,SAED,SAASC,MAAOC,MAAOC,KAAMC,KAAMC,MAAOC,OAI1C,OAFAF,KAAKG,UAAU,QAAQ,EAAMD,OAEtBA,MAAME,KAAKC,KAUjBC,YAAa,SAAoBC,EAAkBC,GAgClD,IAOIH,EAPAI,GADJD,EAAOA,OACgBC,aAAe,KAClCC,EAAeC,KAAKD,aACpBE,EAAUJ,EAAKI,QACfC,EAASL,EAAKM,UAAY,GAC1BC,EAAoBP,EAAKO,kBACzBC,EAAQR,EAAKQ,UACbC,EAAaT,EAAKS,WACdC,KACJC,EAAmB,gDACnBC,EAAUT,KAAKU,SACfC,EAAI,aACR,SAASC,EAAKC,EAAIC,EAAMC,EAAWC,EAAaC,EAAQC,GAEtD,IAAIC,EAAGC,EAAQC,EAAKC,EAAKxB,KAAee,EAAKA,EAAGf,GAAeiB,GAC5DjB,KAAee,QAAeU,IAAPD,GAAqBN,KAC9CM,GAAMpB,EAASoB,GAAIE,QAAQhB,EAAiB,SAE7C,IAAIiB,EAASP,GAAiBL,EAC/B,QAAUU,IAAPD,EAAiB,CAUnB,GATGlB,IACFS,EAAGa,KAAOJ,IAERzB,EAAK8B,SAAcd,aAAce,SAC/BP,EAAMC,EAAGO,MAAM,uBAClBZ,EAASpB,EAAK8B,QAAQN,EAAI,KAIzBhB,EAAMiB,IAAST,aAAce,OAAWvB,EAAMiB,aAAeM,aAC/DH,EAASpB,EAAMiB,IACDQ,YACPL,EAAOM,YACdX,GAAS,MACL,CACH,IAAIY,EAAQf,GAAUA,EAAOgB,UAC3BD,IAEFrB,EAAEsB,UAAYD,EACdP,EAAS,IAAId,GAGfN,EAAMiB,GAAMG,EACTnB,IACFA,EAAWgB,GAAMzB,EAAKqC,MAGxB,KAAMjB,GAAO,CACZ,IAAIkB,EAAalB,EAAOkB,WACxB,GAAGA,EACF,IAAIhB,KAAKN,EAAG,CACX,IAAIuB,EAAqBD,EAAWhB,GACjCiB,GAAmD,aAA7BA,EAAmBC,QAAyC,iBAATxB,EAAGM,KAC9EN,EAAGM,GAAK7B,MAAMgD,cAAczB,EAAGM,KAIlCF,EAASA,EAAgB,QAE1B,IAAIsB,EAAS1B,EAAG0B,OAChB,IAAIpB,KAAKN,EAAG,CACX,GAAGM,GAAGoB,EACL,MAED,GAAG1B,EAAG2B,eAAerB,GAAG,CAEvB,GAAiB,iBADjBE,EAAIR,EAAGM,KACuBE,KAASA,aAAeoB,OAAc,YAALtB,EAO9D,IANAzB,EAAI2B,EAAItB,IAAkBE,GAAWoB,EAAIvB,KAC7BuB,EAAIqB,UACZ7B,GAAMN,IACRc,EAAIqB,SAAWjB,GAGd/B,EAAI,QAECmB,EAAGM,GACV,IAkBMwB,EAlBFC,EAAOlD,EAAImD,WAAWrB,QAAQ,eAAe,SAASK,MAAM,wCAWhE,GAVGxB,GAAOH,EAASR,GAAK8B,QAAQhB,EAAiB,SAChDd,EAAMW,GAAOH,EAASR,GAAK8B,QAAQhB,EAAiB,UAC3Cd,EAAgB,KAATkD,EAAK,IAAoB,QAATA,EAAK,IAAuB,IAATA,EAAK,GAAUhD,EAAOS,GAAOH,EAAS0C,EAAK,IAAIpB,QAAQhB,EAAiB,WAExHoC,EAAK,IACPA,EAAK,GAAGpB,QAAQ,kCAAkC,SAASsB,EAAEC,EAAEC,EAAEC,EAAEC,GAClExD,EAAMA,GAAOA,EAAIsD,EAAIA,EAAExB,QAAQ,WAAW,IAAM0B,KAIhDxD,EACF2B,EAAM3B,OAKN,IAAIoB,EAEC6B,GACHpC,EAAO4C,KAAK1B,GAEbkB,GAAY,GACZtB,EAAMT,EAAKS,GAAK,EAAOA,EAAItB,IAAe,EAAMqC,IAE5CL,YAAclC,EAAKuD,YAIrBtC,IAEHO,EAAMT,EACLS,EACAd,GAAQM,OACDU,IAAPD,OAAmBC,EAAYd,EAAQa,EAAIH,IAC3C,EACAiB,EAGAX,GAAUZ,GAA0B,iBAAbY,EAAON,IAAkBM,EAAON,KAM3D,GADAN,EAAGM,GAAKE,EACLI,GAAQZ,IAAOY,EAAO4B,UAAU,CAClC,IAAIC,EAAM7B,EAAON,GACjBM,EAAON,GAAKE,GACTD,GAAUC,IAAQiC,GAClB7B,EAAOM,aACS,KAAfZ,EAAEoC,OAAO,IAA4B,KAAfpC,EAAEoC,OAAO,IAAmB,QAALpC,GAC7CE,aAAeoB,MAAQa,aAAeb,MAAQpB,EAAImC,WAAaF,EAAIE,WACrD,mBAAPnC,GAAmC,mBAAPiC,GAAqBjC,EAAIwB,YAAcS,EAAIT,aAChFxC,EAAMoD,UACPpD,EAAMoD,SAAShC,EAAON,EAAEmC,EAAIjC,KAMhC,GAAGD,IAAWtB,KAAee,GAAMY,aAAkBG,QAEpD,IAAIT,KAAKM,EACR,IAAIA,EAAO4B,WAAa5B,EAAOe,eAAerB,KAAON,EAAG2B,eAAerB,KAAuB,KAAfA,EAAEoC,OAAO,IAA4B,KAAfpC,EAAEoC,OAAO,OAAgB9B,aAAkBG,OAAS8B,MAAMvC,IAK9J,IAJGd,EAAMoD,UAAiB,eAALtC,GAA2B,WAALA,GAC1Cd,EAAMoD,SAAShC,EAAON,EAAEM,EAAON,QAAGI,UAE5BE,EAAON,GACRM,aAAkBG,OAASH,EAAOc,aAAsChB,IAA5BE,EAAOA,EAAOc,OAAO,IAEtEd,EAAOc,cAKPlC,EAAMsD,QACRtD,EAAMsD,OAAOlC,GAGf,OAAOA,EAMR,OAJG7B,GAAuB,iBAARA,IACjBA,EAAOgB,EAAKhB,GAAK,EAAMC,EAAKkB,WAAW,GACvCH,EAAKL,GAAO,IAENX,GAIRgE,SAAU,SAAoBC,IAAgBhE,MAU7C,SAASH,IAAI+B,GACZ,IAAIqC,KAEJ,OADAA,EAAU9D,KAAKD,cAAgB0B,EACxBqC,EAER,IACC,IAAIlE,KAAOmE,KAAK,IAAMF,IAAM,KAC5B,MAAMG,GACN,MAAM,IAAIC,YAAY,wBAA0BD,EAAEE,QAAU,aAAcL,KAE3E,OAAGjE,KACKI,KAAKL,YAAYC,KAAMC,MAExBD,MAGRuE,OAAQ,SAAoBtD,EAAiBuD,EAAyBjE,EAAsBkE,GAgB3F,IAAIC,EAAUtE,KAAKuE,SACf9D,EAAUT,KAAKU,SACfX,EAAeC,KAAKD,aACxBI,EAAWA,GAAY,GACvB,IAAIqE,KACAC,KA4EJ,IAAIhF,EA3EJ,SAASiF,EAAU7D,EAAG+B,EAAK+B,GAC1B,GAAgB,iBAAN9D,GAAkBA,EAAG,CAE9B,GAAGA,aAAc4B,KAChB,MAAO,IAAMnD,MAAMsF,YAAY/D,GAAIgE,MAAK,IAAS,IAElD,IAAIvD,EAAKT,EAAGa,KACZ,GAAGJ,EAAG,CACL,GAAW,KAARsB,IAAiB0B,IAAYhD,EAAGO,MAAM,MAAS2C,EAAMlD,IAAK,CAC5D,IAAI5B,EAAM4B,EACO,KAAdA,EAAGiC,OAAO,KAEX7D,EADEmB,EAAGiE,YAAcxD,EACb,OAASA,EACPA,EAAGyD,UAAU,EAAG5E,EAASoC,SAAWpC,EAEtCmB,EAAGyD,UAAU5E,EAASoC,QAGtBjB,GAGR,IAAIwC,KAEJ,OADAA,EAAU/D,GAAgBL,EACnBP,MAAMgF,OAAOL,EAAWM,GAEhCxB,EAAOtB,OAEPT,EAAGa,KAAOkB,EACV6B,EAAU7B,GAAQ/B,EAEnB2D,EAAM5B,GAAQ/B,EACd8D,EAAaA,GAAc,GAC3B,IAAIK,EAAaZ,EAAcO,EAAaxF,MAAM8F,gBAAkB,GAChEC,EAAUd,EAAc,KAAO,GAC/Be,EAAMf,EAAc,IAAM,GAE9B,GAAGvD,aAAce,MAQhB,MAAO,IAPG1C,MAAMkG,IAAIvE,EAAI,SAASwE,EAAIlE,GACpC,IAAIE,EAAMqD,EAAUW,EAAK5E,EAAQmC,EAAMzB,GAAI6D,GAI3C,MAHiB,iBAAP3D,IACTA,EAAM,aAEA6D,EAAUF,EAAa3D,IAEdiE,KAAK,IAAMH,GAAOD,EAAUP,EAAa,IAG3D,IAAIY,KACJ,IAAI,IAAIpE,KAAKN,EACZ,GAAGA,EAAG2B,eAAerB,GAAG,CACvB,IAAIqE,EACJ,GAAe,iBAALrE,EACTqE,EAAS,IAAMrE,EAAI,QACd,CAAA,GAAe,iBAALA,GAAiC,KAAfA,EAAEoC,OAAO,IAA4B,KAAfpC,EAAEoC,OAAO,GAKhE,SAHAiC,EAASrG,MAAMsG,cAActE,GAK9B,IAAIE,EAAMqD,EAAU7D,EAAGM,GAAGV,EAAQmC,EAAMzB,GAAG6D,GAC3C,GAAiB,iBAAP3D,EAET,SAEDkE,EAAOpC,KAAK+B,EAAUF,EAAaQ,EAAS,IAAML,EAAM9D,GAG1D,MAAO,IAAMkE,EAAOD,KAAK,IAAMH,GAAOD,EAAUP,EAAa,IACxD,MAAgB,mBAAN9D,GAAoBtB,MAAME,KAAKC,IAAIgG,mBAC3C7E,EAAGgC,WAGJ1D,MAAMgF,OAAOtD,GAEV6D,CAAU7D,EAAG,IAAI,IAC5B,IAAIwD,EACH,IAAI,IAAIlD,KAAKsD,SACLA,EAAUtD,GAAGO,KAGtB,OAAOjC,GAERiB,SAAU,SAASY,EAAIqE,GACtB,OAAOrE,GAAMA,EAAGO,MAAM,KAAoB,GAAbP,EAAGiB,OAAc,GAAK,IAAM,KAAOoD,GAMjE5F,aAAc,OACdwE,UAAU,EACVmB,oBAAoB","file":"../../json/ref.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/_base/json\",\r\n\t\"dojo/_base/kernel\", \r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/date/stamp\",\r\n\t\"dojox\"\r\n],\r\nfunction(array, djson, dojo, lang, stamp, dojox){\r\n\r\nlang.getObject(\"json\", true, dojox);\r\n\r\nreturn dojox.json.ref = {\r\n\t// summary:\r\n\t//\t\tAdds advanced JSON {de}serialization capabilities to the base json library.\r\n\t//\t\tThis enhances the capabilities of dojo.toJson and dojo.fromJson,\r\n\t//\t\tadding referencing support, date handling, and other extra format handling.\r\n\t//\t\tOn parsing, references are resolved. When references are made to\r\n\t//\t\tids/objects that have been loaded yet, the loader function will be set to\r\n\t//\t\t_loadObject to denote a lazy loading (not loaded yet) object.\r\n\r\n\r\n\tresolveJson: function(/*Object*/ root, /*Object?*/ args){\r\n\t\t// summary:\r\n\t\t//\t\tIndexes and resolves references in the JSON object.\r\n\t\t// description:\r\n\t\t//\t\tA JSON Schema object that can be used to advise the handling of the JSON (defining ids, date properties, urls, etc)\r\n\t\t// root:\r\n\t\t//\t\tThe root object of the object graph to be processed\r\n\t\t// args:\r\n\t\t//\t\tObject with additional arguments:\r\n\t\t//\r\n\t\t//\t\t- The *index* parameter:\r\n\t\t//\t\t\tThis is the index object (map) to use to store an index of all the objects.\r\n\t\t//\t\t\tIf you are using inter-message referencing, you must provide the same object for each call.\r\n\t\t//\t\t- The *defaultId* parameter:\r\n\t\t//\t\t\tThis is the default id to use for the root object (if it doesn't define it's own id)\r\n\t\t//\t\t- The *idPrefix* parameter:\r\n\t\t//\t\t\tThis the prefix to use for the ids as they enter the index. This allows multiple tables\r\n\t\t//\t\t\tto use ids (that might otherwise collide) that enter the same global index.\r\n\t\t//\t\t\tidPrefix should be in the form \"/Service/\".  For example,\r\n\t\t//\t\t\tif the idPrefix is \"/Table/\", and object is encountered {id:\"4\",...}, this would go in the\r\n\t\t//\t\t\tindex as \"/Table/4\".\r\n\t\t//\t\t- The *idAttribute* parameter:\r\n\t\t//\t\t\tThis indicates what property is the identity property. This defaults to \"id\"\r\n\t\t//\t\t- The *assignAbsoluteIds* parameter:\r\n\t\t//\t\t\tThis indicates that the resolveJson should assign absolute ids (__id) as the objects are being parsed.\r\n\t\t//\t\t- The *schemas* parameter:\r\n\t\t//\t\t\tThis provides a map of schemas, from which prototypes can be retrieved\r\n\t\t//\t\t- The *loader* parameter:\r\n\t\t//\t\t\tThis is a function that is called added to the reference objects that can't be resolved (lazy objects)\r\n\t\t// returns:\r\n\t\t//\t\tAn object, the result of the processing\r\n\t\targs = args || {};\r\n\t\tvar idAttribute = args.idAttribute || 'id';\r\n\t\tvar refAttribute = this.refAttribute;\r\n\t\tvar idAsRef = args.idAsRef;\r\n\t\tvar prefix = args.idPrefix || '';\r\n\t\tvar assignAbsoluteIds = args.assignAbsoluteIds;\r\n\t\tvar index = args.index || {}; // create an index if one doesn't exist\r\n\t\tvar timeStamps = args.timeStamps;\r\n\t\tvar ref,reWalk=[];\r\n\t\tvar pathResolveRegex = /^(.*\\/)?(\\w+:\\/\\/)|[^\\/\\.]+\\/\\.\\.\\/|^.*\\/(\\/)/;\r\n\t\tvar addProp = this._addProp;\r\n\t\tvar F = function(){};\r\n\t\tfunction walk(it, stop, defaultId, needsPrefix, schema, defaultObject){\r\n\t\t\t// this walks the new graph, resolving references and making other changes\r\n\t\t \tvar i, update, val, id = idAttribute in it ? it[idAttribute] : defaultId;\r\n\t\t \tif(idAttribute in it || ((id !== undefined) && needsPrefix)){\r\n\t\t \t\tid = (prefix + id).replace(pathResolveRegex,'$2$3');\r\n\t\t \t}\r\n\t\t \tvar target = defaultObject || it;\r\n\t\t\tif(id !== undefined){ // if there is an id available...\r\n\t\t\t\tif(assignAbsoluteIds){\r\n\t\t\t\t\tit.__id = id;\r\n\t\t\t\t}\r\n\t\t\t\tif(args.schemas && (!(it instanceof Array)) && // won't try on arrays to do prototypes, plus it messes with queries\r\n\t\t \t\t\t\t\t(val = id.match(/^(.+\\/)[^\\.\\[]*$/))){ // if it has a direct table id (no paths)\r\n\t\t \t\t\tschema = args.schemas[val[1]];\r\n\t\t\t\t}\r\n\t\t\t\t// if the id already exists in the system, we should use the existing object, and just\r\n\t\t\t\t// update it... as long as the object is compatible\r\n\t\t\t\tif(index[id] && ((it instanceof Array) == (index[id] instanceof Array))){\r\n\t\t\t\t\ttarget = index[id];\r\n\t\t\t\t\tdelete target.$ref; // remove this artifact\r\n\t\t\t\t\tdelete target._loadObject;\r\n\t\t\t\t\tupdate = true;\r\n\t\t\t\t}else{\r\n\t\t\t\t \tvar proto = schema && schema.prototype; // and if has a prototype\r\n\t\t\t\t\tif(proto){\r\n\t\t\t\t\t\t// if the schema defines a prototype, that needs to be the prototype of the object\r\n\t\t\t\t\t\tF.prototype = proto;\r\n\t\t\t\t\t\ttarget = new F();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tindex[id] = target; // add the prefix, set _id, and index it\r\n\t\t\t\tif(timeStamps){\r\n\t\t\t\t\ttimeStamps[id] = args.time;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile(schema){\r\n\t\t\t\tvar properties = schema.properties;\r\n\t\t\t\tif(properties){\r\n\t\t\t\t\tfor(i in it){\r\n\t\t\t\t\t\tvar propertyDefinition = properties[i];\r\n\t\t\t\t\t\tif(propertyDefinition && propertyDefinition.format == 'date-time' && typeof it[i] == 'string'){\r\n\t\t\t\t\t\t\tit[i] = stamp.fromISOString(it[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tschema = schema[\"extends\"];\r\n\t\t\t}\r\n\t\t\tvar length = it.length;\r\n\t\t\tfor(i in it){\r\n\t\t\t\tif(i==length){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tif(it.hasOwnProperty(i)){\r\n\t\t\t\t\tval=it[i];\r\n\t\t\t\t\tif((typeof val =='object') && val && !(val instanceof Date) && i != '__parent'){\r\n\t\t\t\t\t\tref=val[refAttribute] || (idAsRef && val[idAttribute]);\r\n\t\t\t\t\t\tif(!ref || !val.__parent){\r\n\t\t\t\t\t\t\tif(it != reWalk){\r\n\t\t\t\t\t\t\t\tval.__parent = target;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(ref){ // a reference was found\r\n\t\t\t\t\t\t\t// make sure it is a safe reference\r\n\t\t\t\t\t\t\tdelete it[i];// remove the property so it doesn't resolve to itself in the case of id.propertyName lazy values\r\n\t\t\t\t\t\t\tvar path = ref.toString().replace(/(#)([^\\.\\[])/,'$1.$2').match(/(^([^\\[]*\\/)?[^#\\.\\[]*)#?([\\.\\[].*)?/); // divide along the path\r\n\t\t\t\t\t\t\tif(index[(prefix + ref).replace(pathResolveRegex,'$2$3')]){\r\n\t\t\t\t\t\t\t\tref = index[(prefix + ref).replace(pathResolveRegex,'$2$3')];\r\n\t\t\t\t\t\t\t}else if((ref = (path[1]=='$' || path[1]=='this' || path[1]=='') ? root : index[(prefix + path[1]).replace(pathResolveRegex,'$2$3')])){  // a $ indicates to start with the root, otherwise start with an id\r\n\t\t\t\t\t\t\t\t// if there is a path, we will iterate through the path references\r\n\t\t\t\t\t\t\t\tif(path[3]){\r\n\t\t\t\t\t\t\t\t\tpath[3].replace(/(\\[([^\\]]+)\\])|(\\.?([^\\.\\[]+))/g,function(t,a,b,c,d){\r\n\t\t\t\t\t\t\t\t\t\tref = ref && ref[b ? b.replace(/[\\\"\\'\\\\]/,'') : d];\r\n\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(ref){\r\n\t\t\t\t\t\t\t\tval = ref;\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t// otherwise, no starting point was found (id not found), if stop is set, it does not exist, we have\r\n\t\t\t\t\t\t\t\t// unloaded reference, if stop is not set, it may be in a part of the graph not walked yet,\r\n\t\t\t\t\t\t\t\t// we will wait for the second loop\r\n\t\t\t\t\t\t\t\tif(!stop){\r\n\t\t\t\t\t\t\t\t\tvar rewalking;\r\n\t\t\t\t\t\t\t\t\tif(!rewalking){\r\n\t\t\t\t\t\t\t\t\t\treWalk.push(target); // we need to rewalk it to resolve references\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\trewalking = true; // we only want to add it once\r\n\t\t\t\t\t\t\t\t\tval = walk(val, false, val[refAttribute], true, propertyDefinition);\r\n\t\t\t\t\t\t\t\t\t// create a lazy loaded object\r\n\t\t\t\t\t\t\t\t\tval._loadObject = args.loader;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\tif(!stop){ // if we are in stop, that means we are in the second loop, and we only need to check this current one,\r\n\t\t\t\t\t\t\t\t// further walking may lead down circular loops\r\n\t\t\t\t\t\t\t\tval = walk(\r\n\t\t\t\t\t\t\t\t\tval,\r\n\t\t\t\t\t\t\t\t\treWalk==it,\r\n\t\t\t\t\t\t\t\t\tid === undefined ? undefined : addProp(id, i), // the default id to use\r\n\t\t\t\t\t\t\t\t\tfalse,\r\n\t\t\t\t\t\t\t\t\tpropertyDefinition,\r\n\t\t\t\t\t\t\t\t\t// if we have an existing object child, we want to\r\n\t\t\t\t\t\t\t\t\t// maintain it's identity, so we pass it as the default object\r\n\t\t\t\t\t\t\t\t\ttarget != it && typeof target[i] == 'object' && target[i]\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tit[i] = val;\r\n\t\t\t\t\tif(target!=it && !target.__isDirty){// do updates if we are updating an existing object and it's not dirty\r\n\t\t\t\t\t\tvar old = target[i];\r\n\t\t\t\t\t\ttarget[i] = val; // only update if it changed\r\n\t\t\t\t\t\tif(update && val !== old && // see if it is different\r\n\t\t\t\t\t\t\t\t!target._loadObject && // no updates if we are just lazy loading\r\n\t\t\t\t\t\t\t\t!(i.charAt(0) == '_' && i.charAt(1) == '_') && i != \"$ref\" &&\r\n\t\t\t\t\t\t\t\t!(val instanceof Date && old instanceof Date && val.getTime() == old.getTime()) && // make sure it isn't an identical date\r\n\t\t\t\t\t\t\t\t!(typeof val == 'function' && typeof old == 'function' && val.toString() == old.toString()) && // make sure it isn't an indentical function\r\n\t\t\t\t\t\t\t\tindex.onUpdate){\r\n\t\t\t\t\t\t\tindex.onUpdate(target,i,old,val); // call the listener for each update\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tif(update && (idAttribute in it || target instanceof Array)){\r\n\t\t\t\t// this means we are updating with a full representation of the object, we need to remove deleted\r\n\t\t\t\tfor(i in target){\r\n\t\t\t\t\tif(!target.__isDirty && target.hasOwnProperty(i) && !it.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && !(target instanceof Array && isNaN(i))){\r\n\t\t\t\t\t\tif(index.onUpdate && i != \"_loadObject\" && i != \"_idAttr\"){\r\n\t\t\t\t\t\t\tindex.onUpdate(target,i,target[i],undefined); // call the listener for each update\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdelete target[i];\r\n\t\t\t\t\t\twhile(target instanceof Array && target.length && target[target.length-1] === undefined){\r\n\t\t\t\t\t\t\t// shorten the target if necessary\r\n\t\t\t\t\t\t\ttarget.length--;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tif(index.onLoad){\r\n\t\t\t\t\tindex.onLoad(target);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn target;\r\n\t\t}\r\n\t\tif(root && typeof root == 'object'){\r\n\t\t\troot = walk(root,false,args.defaultId, true); // do the main walk through\r\n\t\t\twalk(reWalk,false); // re walk any parts that were not able to resolve references on the first round\r\n\t\t}\r\n\t\treturn root;\r\n\t},\r\n\r\n\r\n\tfromJson: function(/*String*/ str,/*Object?*/ args){\r\n\t// summary:\r\n\t//\t\tevaluates the passed string-form of a JSON object.\r\n\t// str:\r\n\t//\t\ta string literal of a JSON item, for instance:\r\n\t// |\t'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'\r\n\t// args:\r\n\t//\t\tSee resolveJson\r\n\t// returns:\r\n\t//\t\tAn object, the result of the evaluation\r\n\t\tfunction ref(target){ // support call styles references as well\r\n\t\t\tvar refObject = {};\r\n\t\t\trefObject[this.refAttribute] = target;\r\n\t\t\treturn refObject;\r\n\t\t}\r\n\t\ttry{\r\n\t\t\tvar root = eval('(' + str + ')'); // do the eval\r\n\t\t}catch(e){\r\n\t\t\tthrow new SyntaxError(\"Invalid JSON string: \" + e.message + \" parsing: \"+ str);\r\n\t\t}\r\n\t\tif(root){\r\n\t\t\treturn this.resolveJson(root, args);\r\n\t\t}\r\n\t\treturn root;\r\n\t},\r\n\t\r\n\ttoJson: function(/*Object*/ it, /*Boolean?*/ prettyPrint, /*Object?*/ idPrefix, /*Object?*/ indexSubObjects){\r\n\t\t// summary:\r\n\t\t//\t\tCreate a JSON serialization of an object.\r\n\t\t//\t\tThis has support for referencing, including circular references, duplicate references, and out-of-message references\r\n\t\t//\t\tid and path-based referencing is supported as well and is based on http://www.json.com/2007/10/19/json-referencing-proposal-and-library/.\r\n\t\t// it:\r\n\t\t//\t\tan object to be serialized.\r\n\t\t// prettyPrint:\r\n\t\t//\t\tif true, we indent objects and arrays to make the output prettier.\r\n\t\t//\t\tThe variable dojo.toJsonIndentStr is used as the indent string\r\n\t\t//\t\t-- to use something other than the default (tab),\r\n\t\t//\t\tchange that variable before calling dojo.toJson().\r\n\t\t// idPrefix:\r\n\t\t//\t\tThe prefix that has been used for the absolute ids\r\n\t\t// returns:\r\n\t\t//\t\ta String representing the serialized version of the passed object.\r\n\t\tvar useRefs = this._useRefs;\r\n\t\tvar addProp = this._addProp;\r\n\t\tvar refAttribute = this.refAttribute;\r\n\t\tidPrefix = idPrefix || ''; // the id prefix for this context\r\n\t\tvar paths={};\r\n\t\tvar generated = {};\r\n\t\tfunction serialize(it,path,_indentStr){\r\n\t\t\tif(typeof it == 'object' && it){\r\n\t\t\t\tvar value;\r\n\t\t\t\tif(it instanceof Date){ // properly serialize dates\r\n\t\t\t\t\treturn '\"' + stamp.toISOString(it,{zulu:true}) + '\"';\r\n\t\t\t\t}\r\n\t\t\t\tvar id = it.__id;\r\n\t\t\t\tif(id){ // we found an identifiable object, we will just serialize a reference to it... unless it is the root\r\n\t\t\t\t\tif(path != '#' && ((useRefs && !id.match(/#/)) || paths[id])){\r\n\t\t\t\t\t\tvar ref = id;\r\n\t\t\t\t\t\tif(id.charAt(0)!='#'){\r\n\t\t\t\t\t\t\tif(it.__clientId == id){\r\n\t\t\t\t\t\t\t\tref = \"cid:\" + id;\r\n\t\t\t\t\t\t\t}else if(id.substring(0, idPrefix.length) == idPrefix){ // see if the reference is in the current context\r\n\t\t\t\t\t\t\t\t// a reference with a prefix matching the current context, the prefix should be removed\r\n\t\t\t\t\t\t\t\tref = id.substring(idPrefix.length);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t// a reference to a different context, assume relative url based referencing\r\n\t\t\t\t\t\t\t\tref = id;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar refObject = {};\r\n\t\t\t\t\t\trefObject[refAttribute] = ref;\r\n\t\t\t\t\t\treturn djson.toJson(refObject, prettyPrint);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpath = id;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tit.__id = path; // we will create path ids for other objects in case they are circular\r\n\t\t\t\t\tgenerated[path] = it;\r\n\t\t\t\t}\r\n\t\t\t\tpaths[path] = it;// save it here so they can be deleted at the end\r\n\t\t\t\t_indentStr = _indentStr || \"\";\r\n\t\t\t\tvar nextIndent = prettyPrint ? _indentStr + djson.toJsonIndentStr : \"\";\r\n\t\t\t\tvar newLine = prettyPrint ? \"\\n\" : \"\";\r\n\t\t\t\tvar sep = prettyPrint ? \" \" : \"\";\r\n\t\r\n\t\t\t\tif(it instanceof Array){\r\n\t\t\t\t\tvar res = array.map(it, function(obj,i){\r\n\t\t\t\t\t\tvar val = serialize(obj, addProp(path, i), nextIndent);\r\n\t\t\t\t\t\tif(typeof val != \"string\"){\r\n\t\t\t\t\t\t\tval = \"undefined\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn newLine + nextIndent + val;\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn \"[\" + res.join(\",\" + sep) + newLine + _indentStr + \"]\";\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar output = [];\r\n\t\t\t\tfor(var i in it){\r\n\t\t\t\t\tif(it.hasOwnProperty(i)){\r\n\t\t\t\t\t\tvar keyStr;\r\n\t\t\t\t\t\tif(typeof i == \"number\"){\r\n\t\t\t\t\t\t\tkeyStr = '\"' + i + '\"';\r\n\t\t\t\t\t\t}else if(typeof i == \"string\" && (i.charAt(0) != '_' || i.charAt(1) != '_')){\r\n\t\t\t\t\t\t\t// we don't serialize our internal properties __id and __clientId\r\n\t\t\t\t\t\t\tkeyStr = djson._escapeString(i);\r\n\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t// skip non-string or number keys\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvar val = serialize(it[i],addProp(path, i),nextIndent);\r\n\t\t\t\t\t\tif(typeof val != \"string\"){\r\n\t\t\t\t\t\t\t// skip non-serializable values\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toutput.push(newLine + nextIndent + keyStr + \":\" + sep + val);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn \"{\" + output.join(\",\" + sep) + newLine + _indentStr + \"}\";\r\n\t\t\t}else if(typeof it == \"function\" && dojox.json.ref.serializeFunctions){\r\n\t\t\t\treturn it.toString();\r\n\t\t\t}\r\n\t\r\n\t\t\treturn djson.toJson(it); // use the default serializer for primitives\r\n\t\t}\r\n\t\tvar json = serialize(it,'#','');\r\n\t\tif(!indexSubObjects){\r\n\t\t\tfor(var i in generated)  {// cleanup the temporary path-generated ids\r\n\t\t\t\tdelete generated[i].__id;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn json;\r\n\t},\r\n\t_addProp: function(id, prop){\r\n\t\treturn id + (id.match(/#/) ? id.length == 1 ? '' : '.' : '#') + prop;\r\n\t},\r\n\t// refAttribute: String\r\n\t//\t\tThis indicates what property is the reference property. This acts like the idAttribute\r\n\t//\t\texcept that this is used to indicate the current object is a reference or only partially\r\n\t//\t\tloaded. This defaults to \"$ref\".\r\n\trefAttribute: \"$ref\",\r\n\t_useRefs: false,\r\n\tserializeFunctions: false\r\n};\r\n});\r\n"]}