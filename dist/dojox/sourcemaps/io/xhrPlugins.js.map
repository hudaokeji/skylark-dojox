{"version":3,"sources":["io/xhrPlugins.js"],"names":["define","dojo","xhr","AdapterRegistry","registry","plainXhr","csXhrSupport","getPlainXhr","dojox","io","xhrPlugins","_defaultXhr","getObject","register","method","args","hasBody","match","apply","arguments","url","root","window","location","href","substring","length","addProxy","proxyUrl","encodeURIComponent","call","addCrossSiteXhr","httpAdapter","undefined","XMLHttpRequest","open","config","noRequestedWithHeaders","e","XDomainRequest","sync","normalXhrObj","_xhrObj","xdr","handler","status","readyState","setRequestHeader","getResponseHeader","header","contentType","onload","onprogress","onerror","dfd","fullHttpAdapter","noRawBody","content","parameters","i","putData","postData","headers","replace","toLowerCase","query","objectToQuery","_ioAddQueryToUrl","mixin"],"mappings":"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","file":"../../io/xhrPlugins.js","sourcesContent":["define([\"dojo/_base/kernel\", \"dojo/_base/xhr\", \"dojo/AdapterRegistry\"], function(dojo, xhr, AdapterRegistry){\r\n\tdojo.getObject(\"io.xhrPlugins\", true, dojox);\r\n\r\n\tvar registry;\r\n\tvar plainXhr;\r\n\tfunction getPlainXhr(){\r\n\t\treturn plainXhr = dojox.io.xhrPlugins.plainXhr = plainXhr || dojo._defaultXhr || xhr;\r\n\t}\r\n\tdojox.io.xhrPlugins.register = function(){\r\n\t\t// summary:\r\n\t\t//\t\toverrides the default xhr handler to implement a registry of\r\n\t\t//\t\txhr handlers\r\n\t\tvar plainXhr = getPlainXhr();\r\n\t\tif(!registry){\r\n\t\t\tregistry = new AdapterRegistry();\r\n\t\t\t// replaces the default xhr() method. Can we just use connect() instead?\r\n\t\t\tdojo[dojo._defaultXhr ? \"_defaultXhr\" : \"xhr\"] = function(/*String*/ method, /*dojo.__XhrArgs*/ args, /*Boolean?*/ hasBody){\r\n\t\t\t\treturn registry.match.apply(registry,arguments);\r\n\t\t\t};\r\n\t\t\tregistry.register(\r\n\t\t\t\t\"xhr\",\r\n\t\t\t\tfunction(method,args){\r\n\t\t\t\t\tif(!args.url.match(/^\\w*:\\/\\//)){\r\n\t\t\t\t\t\t// if it is not an absolute url (or relative to the\r\n\t\t\t\t\t\t// protocol) we can use this plain XHR\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar root = window.location.href.match(/^.*?\\/\\/.*?\\//)[0];\r\n\t\t\t\t\treturn args.url.substring(0, root.length) == root; // or check to see if we have the same path\r\n\t\t\t\t},\r\n\t\t\t\tplainXhr\r\n\t\t\t);\r\n\t\t}\r\n\t\treturn registry.register.apply(registry, arguments);\r\n\t};\r\n\tdojox.io.xhrPlugins.addProxy = function(proxyUrl){\r\n\t\t// summary:\r\n\t\t//\t\tadds a server side proxy xhr handler for cross-site URLs\r\n\t\t// proxyUrl:\r\n\t\t//\t\tThis is URL to send the requests to.\r\n\t\t// example:\r\n\t\t//\t\tDefine a proxy:\r\n\t\t//\t|\tdojox.io.xhrPlugins.addProxy(\"/proxy?url=\");\r\n\t\t//\t\tAnd then when you call:\r\n\t\t//\t|\tdojo.xhr(\"GET\",{url:\"http://othersite.com/file\"});\r\n\t\t//\t\tIt would result in the request (to your origin server):\r\n\t\t//\t|\tGET /proxy?url=http%3A%2F%2Fothersite.com%2Ffile HTTP/1.1\r\n\t\tvar plainXhr = getPlainXhr();\r\n\t\tdojox.io.xhrPlugins.register(\r\n\t\t\t\"proxy\",\r\n\t\t\tfunction(method,args){\r\n\t\t\t\t// this will match on URL\r\n\r\n\t\t\t\t// really can be used for anything, but plain XHR will take\r\n\t\t\t\t// precedent by order of loading\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t\tfunction(method,args,hasBody){\r\n\t\t\t\targs.url = proxyUrl + encodeURIComponent(args.url);\r\n\t\t\t\treturn plainXhr.call(dojo, method, args, hasBody);\r\n\t\t\t});\r\n\t};\r\n\tvar csXhrSupport;\r\n\tdojox.io.xhrPlugins.addCrossSiteXhr = function(url, httpAdapter){\r\n\t\t// summary:\r\n\t\t//\t\tAdds W3C Cross site XHR or XDomainRequest handling for the given URL prefix\r\n\t\t//\r\n\t\t// url:\r\n\t\t//\t\tRequests that start with this URL will be considered for using\r\n\t\t//\t\tcross-site XHR.\r\n\t\t//\r\n\t\t// httpAdapter: This allows for adapting HTTP requests that could not otherwise be\r\n\t\t//\t\tsent with XDR, so you can use a convention for headers and PUT/DELETE methods.\r\n\t\t//\r\n\t\t// description:\r\n\t\t//\t\tThis can be used for servers that support W3C cross-site XHR. In order for\r\n\t\t//\t\ta server to allow a client to make cross-site XHR requests,\r\n\t\t//\t\tit should respond with the header like:\r\n\t\t//\t|\tAccess-Control: allow <*>\r\n\t\t//\t\tsee: http://www.w3.org/TR/access-control/\r\n\t\tvar plainXhr = getPlainXhr();\r\n\t\tif(csXhrSupport === undefined && window.XMLHttpRequest){\r\n\t\t\t// just run this once to see if we have cross-site support\r\n\t\t\ttry{\r\n\t\t\t\tvar xhr = new XMLHttpRequest();\r\n\t\t\t\txhr.open(\"GET\",\"http://testing-cross-domain-capability.com\",true);\r\n\t\t\t\tcsXhrSupport = true;\r\n\t\t\t\tdojo.config.noRequestedWithHeaders = true;\r\n\t\t\t}catch(e){\r\n\t\t\t\tcsXhrSupport = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tdojox.io.xhrPlugins.register(\r\n\t\t\t\"cs-xhr\",\r\n\t\t\tfunction(method,args){\r\n\t\t\t\treturn (csXhrSupport ||\r\n\t\t\t\t\t\t(window.XDomainRequest && args.sync !== true &&\r\n\t\t\t\t\t\t\t(method == \"GET\" || method == \"POST\" || httpAdapter))) &&\r\n\t\t\t\t\t(args.url.substring(0,url.length) == url);\r\n\t\t\t},\r\n\t\t\tcsXhrSupport ? plainXhr : function(){\r\n\t\t\t\tvar normalXhrObj = dojo._xhrObj;\r\n\t\t\t\t// we will just substitute this in temporarily so we can use XDomainRequest instead of XMLHttpRequest\r\n\t\t\t\tdojo._xhrObj = function(){\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar xdr = new XDomainRequest();\r\n\t\t\t\t\txdr.readyState = 1;\r\n\t\t\t\t\txdr.setRequestHeader = function(){}; // just absorb them, we can't set headers :/\r\n\t\t\t\t\txdr.getResponseHeader = function(header){ // this is the only header we can access\r\n\t\t\t\t\t\treturn header == \"Content-Type\" ? xdr.contentType : null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// adapt the xdr handlers to xhr\r\n\t\t\t\t\tfunction handler(status, readyState){\r\n\t\t\t\t\t\treturn function(){\r\n\t\t\t\t\t\t\txdr.readyState = readyState;\r\n\t\t\t\t\t\t\txdr.status = status;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\txdr.onload = handler(200, 4);\r\n\t\t\t\t\txdr.onprogress = handler(200, 3);\r\n\t\t\t\t\txdr.onerror = handler(404, 4); // an error, who knows what the real status is\r\n\t\t\t\t\treturn xdr;\r\n\t\t\t\t};\r\n\t\t\t\tvar dfd = (httpAdapter ? httpAdapter(getPlainXhr()) : getPlainXhr()).apply(dojo,arguments);\r\n\t\t\t\tdojo._xhrObj = normalXhrObj;\r\n\t\t\t\treturn dfd;\r\n\t\t\t}\r\n\t\t);\r\n\t};\r\n\tdojox.io.xhrPlugins.fullHttpAdapter = function(plainXhr,noRawBody){\r\n\t\t// summary:\r\n\t\t//\t\tProvides a HTTP adaption.\r\n\t\t// description:\r\n\t\t//\t\tThe following convention is used:\r\n\t\t//\t\tmethod name -> ?http-method=PUT\r\n\t\t//\t\tHeader -> http-Header-Name=header-value\r\n\t\t//\t\tX-Header -> header_name=header-value\r\n\t\t// example:\r\n\t\t//\t\tdojox.io.xhrPlugins.addXdr(\"http://somesite.com\", dojox.io.xhrPlugins.fullHttpAdapter);\r\n\t\treturn function(method,args,hasBody){\r\n\t\t\tvar content = {};\r\n\t\t\tvar parameters = {};\r\n\t\t\tif(method != \"GET\"){\r\n\t\t\t\tparameters[\"http-method\"] = method;\r\n\t\t\t\tif(args.putData && noRawBody){\r\n\t\t\t\t\tcontent[\"http-content\"] = args.putData;\r\n\t\t\t\t\tdelete args.putData;\r\n\t\t\t\t\thasBody = false;\r\n\t\t\t\t}\r\n\t\t\t\tif(args.postData && noRawBody){\r\n\t\t\t\t\tcontent[\"http-content\"] = args.postData;\r\n\t\t\t\t\tdelete args.postData;\r\n\t\t\t\t\thasBody = false;\r\n\t\t\t\t}\r\n\t\t\t\tmethod = \"POST\";\r\n\t\t\t\r\n\t\t\t}\r\n\t\t\tfor(var i in args.headers){\r\n\t\t\t\tvar parameterName = i.match(/^X-/) ? i.substring(2).replace(/-/g,'_').toLowerCase() : (\"http-\" + i);\r\n\t\t\t\tparameters[parameterName] = args.headers[i];\r\n\t\t\t}\r\n\t\t\targs.query = dojo.objectToQuery(parameters);\r\n\t\t\tdojo._ioAddQueryToUrl(args);\r\n\t\t\targs.content = dojo.mixin(args.content || {},content);\r\n\t\t\treturn plainXhr.call(dojo,method,args,hasBody);\r\n\t\t};\r\n\t};\r\n\r\n\treturn dojox.io.xhrPlugins;\r\n});\r\n"]}