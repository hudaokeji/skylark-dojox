{"version":3,"sources":["io/httpParse.js"],"names":["define","dojo","getObject","dojox","io","httpParse","httpStream","topHeaders","partial","xhrs","streamLength","length","headers","httpParts","match","substring","headerParts","headerFollowingChar","headerStr","j","colonIndex","indexOf","replace","split","content","xhr","status","parseInt","statusText","readyState","getAllResponseHeaders","getResponseHeader","name","contentLength","push","responseText","_lastIndex"],"mappings":";;;;;;;AAAAA,QAAQ,qBAAsB,SAASC,GA8EvC,OA7EAA,EAAKC,UAAU,gBAAgB,EAAMC,OAErCA,MAAMC,GAAGC,UAAY,SAAmBC,EAAuBC,EAAwBC,GActF,IAAIC,KACAC,EAAeJ,EAAWK,OAC9B,EAAE,CACD,IAAIC,KACAC,EAAYP,EAAWQ,MAAM,eACjC,IAAID,EACH,OAAO,KAERP,EAAaA,EAAWS,UAAUF,EAAU,GAAGF,OAAO,GACtDE,EAAYA,EAAU,GACtB,IAAIG,EAAcV,EAAWQ,MAAM,eAAe,GAG9CG,GADJX,EAAaA,EAAWS,UAAUC,EAAYL,SACTI,UAAU,EAAE,GACjDT,EAAaA,EAAWS,UAAU,GAElC,IAAIG,EADJF,GAAeT,GAAc,IAAMS,EAEnCA,EAAcA,EAAYF,MAAM,qBAChC,IAAI,IAAIK,EAAI,EAAGA,EAAIH,EAAYL,OAAQQ,IAAI,CAC1C,IAAIC,EAAaJ,EAAYG,GAAGE,QAAQ,KACxCT,EAAQI,EAAYG,GAAGJ,UAAU,EAAEK,IAAeJ,EAAYG,GAAGJ,UAAUK,EAAW,GAAGE,QAAQ,2BAA2B,IAG7HT,EAAYA,EAAUU,MAAM,KAC5B,IAYIC,EAZAC,GACHC,OAASC,SAASd,EAAU,GAAG,IAC/Be,WAAaf,EAAU,GACvBgB,WAAa,EACbC,sBAAwB,WACvB,OAAOZ,GAERa,kBAAoB,SAASC,GAC5B,OAAOpB,EAAQoB,KAGbC,EAAgBrB,EAAQ,kBAE5B,GAAGqB,EAAc,CAChB,KAAGA,GAAiB3B,EAAWK,QAG9B,OAAOF,EAFPe,EAAUlB,EAAWS,UAAU,EAAEkB,QAI7B,GAAIT,EAAUlB,EAAWQ,MAAM,oCAEpCU,EAAUA,EAAQ,OACb,CAAA,GAAIhB,GAAkC,MAAvBS,EAIpB,OAAOR,EAFPe,EAAUlB,EAIXG,EAAKyB,KAAKT,GACVnB,EAAaA,EAAWS,UAAUS,EAAQb,QAC1Cc,EAAIU,aAAeX,EACnBC,EAAII,WAAa,EACjBJ,EAAIW,WAAa1B,EAAeJ,EAAWK,aACrCL,GACP,OAAOG,GAGDN,MAAMC,GAAGC","file":"../../io/httpParse.js","sourcesContent":["define([\"dojo/_base/kernel\"], function(dojo){\r\ndojo.getObject(\"io.httpParse\", true, dojox);\r\n\r\ndojox.io.httpParse = function(/*String*/httpStream, /*String?*/topHeaders,/*Boolean?*/ partial){\r\n\t// summary:\r\n\t//\t\tParses an HTTP stream for a message.\r\n\t// httpStream:\r\n\t//\t\tHTTP stream to parse\r\n\t// topHeaders:\r\n\t//\t\tExtra header information to add to each HTTP request (kind of HTTP inheritance)\r\n\t// partial:\r\n\t//\t\tA true value indicates that the stream may not be finished, it may end arbitrarily in mid stream.\r\n\t//\t\tThe last XHR object will have a special property _lastIndex that indicates the how far along\r\n\t//\t\tthe httpStream could be successfully parsed into HTTP messages.\r\n\t// returns:\r\n\t//\t\tReturns an array of XHR-like object for reading the headers for each message\r\n\t//\r\n\tvar xhrs=[];\r\n\tvar streamLength = httpStream.length;\r\n\tdo{\r\n\t\tvar headers = {};\r\n\t\tvar httpParts = httpStream.match(/(\\n*[^\\n]+)/);\r\n\t\tif(!httpParts){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\thttpStream = httpStream.substring(httpParts[0].length+1);\r\n\t\thttpParts = httpParts[1];\r\n\t\tvar headerParts = httpStream.match(/([^\\n]+\\n)*/)[0];\r\n\t\t \r\n\t\thttpStream = httpStream.substring(headerParts.length);\r\n\t\tvar headerFollowingChar = httpStream.substring(0,1);\r\n\t\thttpStream = httpStream.substring(1);\r\n\t\theaderParts = (topHeaders || \"\") + headerParts;\r\n\t\tvar headerStr = headerParts;\r\n\t\theaderParts = headerParts.match(/[^:\\n]+:[^\\n]+\\n/g); // parse the containing and contained response headers with the contained taking precedence (by going last)\r\n\t\tfor(var j = 0; j < headerParts.length; j++){\r\n\t\t\tvar colonIndex = headerParts[j].indexOf(':');\r\n\t\t\theaders[headerParts[j].substring(0,colonIndex)] = headerParts[j].substring(colonIndex+1).replace(/(^[ \\r\\n]*)|([ \\r\\n]*)$/g,''); // trim\r\n\t\t}\r\n\t\r\n\t\thttpParts = httpParts.split(' ');\r\n\t\tvar xhr = { // make it look like an xhr object, at least for the response part of the API\r\n\t\t\tstatus : parseInt(httpParts[1],10),\r\n\t\t\tstatusText : httpParts[2],\r\n\t\t\treadyState : 3, // leave it at 3 until we get a full body\r\n\t\t\tgetAllResponseHeaders : function(){\r\n\t\t\t\treturn headerStr;\r\n\t\t\t},\r\n\t\t\tgetResponseHeader : function(name){\r\n\t\t\t\treturn headers[name];\r\n\t\t\t}\r\n\t\t};\r\n\t\tvar contentLength = headers['Content-Length'];\r\n\t\tvar content;\r\n\t\tif(contentLength){\r\n\t\t\tif(contentLength <= httpStream.length){\r\n\t\t\t\tcontent = httpStream.substring(0,contentLength);\r\n\t\t\t}else{\r\n\t\t\t\treturn xhrs; // the content is not finished\r\n\t\t\t}\r\n\t\t}else if((content = httpStream.match(/(.*)HTTP\\/\\d\\.\\d \\d\\d\\d[\\w\\s]*\\n/))){ // assign content\r\n\t\t\t// if we spot another HTTP message coming up, we will just assign all the in between text to the content\r\n\t\t\tcontent = content[0];\r\n\t\t}else if(!partial || headerFollowingChar == '\\n'){\r\n\t\t\t// if we have to finish\r\n\t\t\tcontent = httpStream;\r\n\t\t}else{\r\n\t\t\treturn xhrs;\r\n\t\t}\r\n\t\txhrs.push(xhr); // add it to the list, since it is a full HTTP message\r\n\t\thttpStream = httpStream.substring(content.length); // move along the stream\r\n\t\txhr.responseText = content;\r\n\t\txhr.readyState = 4;\r\n\t\txhr._lastIndex = streamLength - httpStream.length; // need to pick up from where we left on streaming connections\r\n\t}while(httpStream);\r\n\treturn xhrs;\r\n};\r\n\r\nreturn dojox.io.httpParse;\r\n\r\n});\r\n"]}