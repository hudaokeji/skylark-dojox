{"version":3,"sources":["io/OAuth.js"],"names":["define","dojo","lang","array","xhr","dom","SHA1","getObject","dojox","io","OAuth","encode","this","s","length","encodeURIComponent","replace","decode","str","a","list","split","i","l","indexOf","tmp","push","decodeURIComponent","tab","addOAuth","args","oaa","o","oauth_consumer_key","consumer","key","oauth_nonce","tl","charAt","Math","floor","random","nonce","oauth_signature_method","sig_method","oauth_timestamp","Date","valueOf","oauth_version","token","oauth_token","content","mixin","baseString","method","formObject","miArgs","form","byId","actnNode","getAttributeNode","url","value","formToObject","map","keys","match","exec","p","protocol","toLowerCase","authority","port","lastIndexOf","substring","path","parseUrl","query","queryToObject","_url","item","isArray","j","jl","_parameters","convertArgs","sort","b","join","toUpperCase","sign","k","secret","data","type","Error","_hmac","signature","hasBody","xhrGet","xhrPost","xhrRawPost","xhrPut","xhrRawPut","xhrDelete"],"mappings":"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","file":"../../io/OAuth.js","sourcesContent":["define([\r\n\t\"dojo/_base/kernel\", // dojo\r\n\t\"dojo/_base/lang\", // mixin\r\n\t\"dojo/_base/array\", // isArray, map\r\n\t\"dojo/_base/xhr\", // formToObject, queryToObject, xhr\r\n\t\"dojo/dom\", // byId\r\n\t\"dojox/encoding/digests/SHA1\" // SHA1\r\n], function(dojo, lang, array, xhr, dom, SHA1){\r\ndojo.getObject(\"io.OAuth\", true, dojox);\r\n\r\ndojox.io.OAuth = new (function(){\r\n\t// summary:\r\n\t//\t\tHelper singleton for signing any kind of Ajax request using the OAuth 1.0 protocol.\r\n\t// description:\r\n\t//\t\tdojox.io.OAuth is a singleton class designed to allow anyone to sign a request,\r\n\t//\t\tbased on the OAuth 1.0 specification, made with any of the Dojo Toolkit's Ajax\r\n\t//\t\tmethods (such as dojo.xhr[verb], dojo.io.iframe, etc.).\r\n\t//\r\n\t//\t\tThe main method of dojox.io.OAuth is the sign method (see documentation for .sign);\r\n\t//\t\tthe idea is that you will \"sign\" the kwArgs object you'd normally pass to any of\r\n\t//\t\tthe Ajax methods, and then pass the signed object along.  As long as the token\r\n\t//\t\tobject used is valid (and the client's date and time are synced with a public\r\n\t//\t\ttime server), a signed object should be passed along correctly.\r\n\t//\r\n\t//\t\tdojox.io.OAuth does not deal with the OAuth handshake process at all.\r\n\t//\r\n\t//\t\tThis object was developed against the Netflix API (OAuth-based service); see\r\n\t//\t\thttp://developer.netflix.com for more details.\r\n\tvar encode = this.encode = function(s){\r\n\t\tif(!(\"\" + s).length){ return \"\"; }\r\n\t\treturn encodeURIComponent(s)\r\n\t\t\t.replace(/\\!/g, \"%21\")\r\n\t\t\t.replace(/\\*/g, \"%2A\")\r\n\t\t\t.replace(/\\'/g, \"%27\")\r\n\t\t\t.replace(/\\(/g, \"%28\")\r\n\t\t\t.replace(/\\)/g, \"%29\");\r\n\t};\r\n\r\n\tvar decode = this.decode = function(str){\r\n\t\t// summary:\r\n\t\t//\t\tBreak apart the passed string and decode.\r\n\t\t//\t\tSome special cases are handled.\r\n\t\tvar a=[], list=str.split(\"&\");\r\n\t\tfor(var i=0, l=list.length; i<l; i++){\r\n\t\t\tvar item=list[i];\r\n\t\t\tif(list[i]==\"\"){ continue; }\t//\tskip this one.\r\n\t\t\tif(list[i].indexOf(\"=\")>-1){\r\n\t\t\t\tvar tmp=list[i].split(\"=\");\r\n\t\t\t\ta.push([ decodeURIComponent(tmp[0]), decodeURIComponent(tmp[1]) ]);\r\n\t\t\t} else {\r\n\t\t\t\ta.push([ decodeURIComponent(list[i]), null ]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn a;\r\n\t};\r\n\r\n\tfunction parseUrl(url){\r\n\t\t// summary:\r\n\t\t//\t\tCreate a map out of the passed URL.  Need to pull any\r\n\t\t//\t\tquery string parameters off the URL for the base signature string.\r\n        var keys = [\r\n\t\t\t\t\"source\",\"protocol\",\"authority\",\"userInfo\",\r\n\t\t\t\t\"user\",\"password\",\"host\",\"port\",\r\n\t\t\t\t\"relative\",\"path\",\"directory\",\r\n\t\t\t\t\"file\",\"query\",\"anchor\"\r\n\t\t\t],\r\n\t\t\tparser=/^(?:([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*):?([^:@]*))?@)?([^:\\/?#]*)(?::(\\d*))?))?((((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/,\r\n\t\t\tmatch=parser.exec(url),\r\n\t\t\tmap = {},\r\n\t\t\ti=keys.length;\r\n\r\n\t\t//\tcreate the base map first.\r\n\t\twhile(i--){ map[keys[i]] = match[i] || \"\"; }\r\n\r\n\t\t//\tcreate the normalized version of the url and add it to the map\r\n\t\tvar p=map.protocol.toLowerCase(),\r\n\t\t\ta=map.authority.toLowerCase(),\r\n\t\t\tb=(p==\"http\"&&map.port==80)||(p==\"https\"&&map.port==443);\r\n\t\tif(b){\r\n\t\t\tif(a.lastIndexOf(\":\")>-1){\r\n\t\t\t\ta=a.substring(0, a.lastIndexOf(\":\"));\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar path=map.path||\"/\";\r\n\t\tmap.url=p+\"://\"+a+path;\r\n\r\n\t\t//\treturn the map\r\n\t\treturn map;\r\n\t}\r\n\r\n\tvar tab=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\";\r\n\tfunction nonce(length){\r\n\t\tvar s=\"\", tl=tab.length;\r\n\t\tfor(var i=0; i<length; i++){\r\n\t\t\ts+=tab.charAt(Math.floor(Math.random()*tl));\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\tfunction timestamp(){\r\n\t\treturn Math.floor(new Date().valueOf()/1000)-2;\r\n\t}\r\n\tfunction signature(data, key, type){\r\n\t\tif(type && type!=\"PLAINTEXT\" && type!=\"HMAC-SHA1\"){\r\n\t\t\tthrow new Error(\"dojox.io.OAuth: the only supported signature encodings are PLAINTEXT and HMAC-SHA1.\");\r\n\t\t}\r\n\r\n\t\tif(type==\"PLAINTEXT\"){\r\n\t\t\treturn key;\r\n\t\t} else {\r\n\t\t\t//\tassume SHA1 HMAC\r\n\t\t\treturn SHA1._hmac(data, key);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction key(args){\r\n\t\t// summary:\r\n\t\t//\t\treturn the key used to sign a message based on the token object.\r\n\t\treturn encode(args.consumer.secret)\r\n\t\t\t+ \"&\"\r\n\t\t\t+ (args.token && args.token.secret ? encode(args.token.secret) : \"\");\r\n\t}\r\n\r\n\tfunction addOAuth(/* dojo.__XhrArgs */args, /* dojox.io.__OAuthArgs */oaa){\r\n\t\t// summary:\r\n\t\t//\t\tAdd the OAuth parameters to the query string/content.\r\n\t\tvar o = {\r\n\t\t\toauth_consumer_key: oaa.consumer.key,\r\n\t\t\toauth_nonce: nonce(16),\r\n\t\t\toauth_signature_method: oaa.sig_method || \"HMAC-SHA1\",\r\n\t\t\toauth_timestamp: timestamp(),\r\n\t\t\toauth_version: \"1.0\"\r\n\t\t}\r\n\t\tif(oaa.token){\r\n\t\t\to.oauth_token = oaa.token.key;\r\n\t\t}\r\n\t\targs.content = dojo.mixin(args.content||{}, o);\r\n\t}\r\n\r\n\tfunction convertArgs(args){\r\n\t\t// summary:\r\n\t\t//\t\tBecause of the need to create a base string, we have to do\r\n\t\t//\t\tsome manual args preparation instead of relying on the internal\r\n\t\t//\t\tDojo xhr functions.  But we'll let dojo.xhr assemble things\r\n\t\t//\t\tas it normally would.\r\n\t\tvar miArgs = [{}], formObject;\r\n\r\n\t\tif(args.form){\r\n\t\t\tif(!args.content){ args.content = {}; }\r\n\t\t\tvar form = dojo.byId(args.form);\r\n\t\t\tvar actnNode = form.getAttributeNode(\"action\");\r\n\t\t\targs.url = args.url || (actnNode ? actnNode.value : null);\r\n\t\t\tformObject = dojo.formToObject(form);\r\n\t\t\tdelete args.form;\r\n\t\t}\r\n\t\tif(formObject){ miArgs.push(formObject); }\r\n\t\tif(args.content){ miArgs.push(args.content); }\r\n\r\n\t\t//\tpull anything off the query string\r\n\t\tvar map = parseUrl(args.url);\r\n\t\tif(map.query){\r\n\t\t\tvar tmp = dojo.queryToObject(map.query);\r\n\t\t\t//\tre-encode the values.  sigh\r\n\t\t\tfor(var p in tmp){ tmp[p] = encodeURIComponent(tmp[p]); }\r\n\t\t\tmiArgs.push(tmp);\r\n\t\t}\r\n\t\targs._url = map.url;\r\n\r\n\t\t//\tnow set up all the parameters as an array of 2 element arrays.\r\n\t\tvar a = [];\r\n\t\tfor(var i=0, l=miArgs.length; i<l; i++){\r\n\t\t\tvar item=miArgs[i];\r\n\t\t\tfor(var p in item){\r\n\t\t\t\tif(dojo.isArray(item[p])){\r\n\t\t\t\t\t//\thandle multiple values\r\n\t\t\t\t\tfor(var j=0, jl=item.length; j<jl; j++){\r\n\t\t\t\t\t\ta.push([ p, item[j] ]);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\ta.push([ p, item[p] ]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\targs._parameters = a;\r\n\t\treturn args;\r\n\t}\r\n\r\n\tfunction baseString(/* String */method, /* dojo.__XhrArgs */args, /* dojox.io.__OAuthArgs */oaa){\r\n\t\t//\tcreate and return the base string out of the args.\r\n\t\taddOAuth(args, oaa);\r\n\t\tconvertArgs(args);\r\n\r\n\t\tvar a = args._parameters;\r\n\r\n\t\t//\tsort the parameters\r\n\t\ta.sort(function(a,b){\r\n\t\t\tif(a[0]>b[0]){ return 1; }\r\n\t\t\tif(a[0]<b[0]){ return -1; }\r\n\t\t\tif(a[1]>b[1]){ return 1; }\r\n\t\t\tif(a[1]<b[1]){ return -1; }\r\n\t\t\treturn 0;\r\n\t\t});\r\n\r\n\t\t//\tencode.\r\n\t\tvar s = dojo.map(a, function(item){\r\n\t\t\treturn encode(item[0]) + \"=\" + encode((\"\"+item[1]).length ? item[1] : \"\");\r\n\t\t}).join(\"&\");\r\n\r\n\t\tvar baseString = method.toUpperCase()\r\n\t\t\t+ \"&\" + encode(args._url)\r\n\t\t\t+ \"&\" + encode(s);\r\n\t\treturn baseString;\r\n\t}\r\n\r\n\tfunction sign(method, args, oaa){\r\n\t\t//\treturn the oauth_signature for this message.\r\n\t\tvar k = key(oaa),\r\n\t\t\tmessage = baseString(method, args, oaa),\r\n\t\t\ts = signature(message, k, oaa.sig_method || \"HMAC-SHA1\");\r\n\t\targs.content[\"oauth_signature\"] = s;\r\n\t\treturn args;\r\n\t}\r\n\t\r\n\t/*=====\r\n\t \tdojox.io.OAuth.__AccessorArgs = {\r\n\t\t\t// key: String\r\n\t\t\t//\t\tThe key or token issued to either the consumer or by the OAuth service.\r\n\t\t\t// secret: String\r\n\t\t\t//\t\tThe secret (shared secret for consumers, issued secret by OAuth service).\r\n\t\t};\r\n\t\tdojox.io.OAuth.__OAuthArgs = {\r\n\t\t\t// consumer: dojox.io.OAuth.__AccessorArgs\r\n\t\t\t//\t\tThe consumer information issued to your OpenAuth application.\r\n\t\t\t// sig_method: String\r\n\t\t\t//\t\tThe method used to create the signature.  Should be PLAINTEXT or HMAC-SHA1.\r\n\t\t\t// token: dojox.io.OAuth.__AccessorArgs?\r\n\t\t\t//\t\tThe request token and secret issued by the OAuth service.  If not\r\n\t\t\t//\t\tissued yet, this should be null.\r\n\t\t};\r\n\t=====*/\r\n\r\n\t/*\r\n\t *\tProcess goes something like this:\r\n\t *\t1. prepare the base string\r\n\t *\t2. create the key\r\n\t *\t3. create the signature based on the base string and the key\r\n\t *\t4. send the request using dojo.xhr[METHOD].\r\n\t */\r\n\r\n\tthis.sign = function(/* String*/method, /* dojo.__XhrArgs */args, /* dojox.io.OAuth.__OAuthArgs */oaa){\r\n\t\t// summary:\r\n\t\t//\t\tGiven the OAuth access arguments, sign the kwArgs that you would pass\r\n\t\t//\t\tto any dojo Ajax method (dojo.xhr*, dojo.io.iframe, dojo.io.script).\r\n\t\t// example:\r\n\t\t//\t\tSign the kwArgs object for use with dojo.xhrGet:\r\n\t\t//\t|\tvar oaa = {\r\n\t\t//\t|\t\tconsumer: {\r\n\t\t//\t|\t\t\tkey: \"foobar\",\r\n\t\t//\t|\t\t\tsecret: \"barbaz\"\r\n\t\t//\t|\t\t}\r\n\t\t//\t|\t};\r\n\t\t//\t|\r\n\t\t//\t|\tvar args = dojox.io.OAuth.sign(\"GET\", myAjaxKwArgs, oaa);\r\n\t\t//\t|\tdojo.xhrGet(args);\r\n\t\treturn sign(method, args, oaa);\r\n\t};\r\n\r\n\r\n\t//\tTODO: handle redirect requests?\r\n\tthis.xhr = function(/* String */method, /* dojo.__XhrArgs */args, /* dojox.io.OAuth.__OAuthArgs */oaa, /* Boolean? */hasBody){\r\n\t\t/*\tsummary:\r\n\t\t *\t\tMake an XHR request that is OAuth signed.\r\n\t\t *\texample:\r\n\t\t *\t|\tvar dfd = dojox.io.OAuth.xhrGet({\r\n\t\t *\t|\t\turl: \"http://someauthdomain.com/path?foo=bar\",\r\n\t\t *\t|\t\tload: function(response, ioArgs){ }\r\n\t\t *\t|\t},\r\n\t\t *\t|\t{\r\n\t\t *\t|\t\tconsumer:{ key: \"lasdkf9asdnfsdf\", secret: \"9asdnfskdfysjr\" }\r\n\t\t *\t|\t});\r\n\t\t */\r\n\t\tsign(method, args, oaa);\r\n\t\treturn xhr(method, args, hasBody);\r\n\t};\r\n\r\n\tthis.xhrGet = function(/* dojo.__XhrArgs */args, /* dojox.io.OAuth.__OAuthArgs*/ oaa){\r\n\t\treturn this.xhr(\"GET\", args, oaa);\r\n\t};\r\n\tthis.xhrPost = this.xhrRawPost = function(/* dojo.__XhrArgs */args, /* dojox.io.OAuth.__OAuthArgs*/ oaa){\r\n\t\treturn this.xhr(\"POST\", args, oaa, true);\r\n\t};\r\n\tthis.xhrPut = this.xhrRawPut = function(/* dojo.__XhrArgs */args, /* dojox.io.OAuth.__OAuthArgs*/ oaa){\r\n\t\treturn this.xhr(\"PUT\", args, oaa, true);\r\n\t};\r\n\tthis.xhrDelete = function(/* dojo.__XhrArgs */args, /* dojox.io.OAuth.__OAuthArgs*/ oaa){\r\n\t\treturn this.xhr(\"DELETE\", args, oaa);\r\n\t};\r\n})();\r\n\r\nreturn dojox.io.OAuth;\r\n\r\n});\r\n"]}