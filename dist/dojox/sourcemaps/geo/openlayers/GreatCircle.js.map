{"version":3,"sources":["geo/openlayers/GreatCircle.js"],"names":["define","lang","openlayers","GeometryFeature","GreatCircle","toPointArray","p1","p2","increment","startLon","x","endLon","sl","Math","min","el","max","d2r","this","DEG2RAD","lat1","y","lon1","lat2","lon2","abs","TOLERANCE","PI","lon","elon","incr","wp","k","r2d","RAD2DEG","lat","atan","sin","cos","p","toLineString","OpenLayers","Geometry","LineString","toGeometryFeature","ls"],"mappings":";;;;;;;AAAAA,QACC,kBACA,UACA,qBACE,SAASC,EAAMC,EAAYC,GAmH7B,OAjHSD,EAAWE,aAEnBC,aAAc,SAASC,EAAIC,EAAIC,GAe9B,IAAIC,EAAWH,EAAGI,EACdC,EAASJ,EAAGG,EACZE,EAAKC,KAAKC,IAAIL,EAAUE,GACxBI,EAAKF,KAAKG,IAAIP,EAAUE,GAExBM,EAAMC,KAAKC,QACXC,EAAOd,EAAGe,EAAIJ,EACdK,EAAOhB,EAAGI,EAAIO,EACdM,EAAOhB,EAAGc,EAAIJ,EACdO,EAAOjB,EAAGG,EAAIO,EAEfJ,KAAKY,IAAIH,EAAOE,IAASN,KAAKQ,YAEhCF,EADQX,KAAKC,IAAIQ,EAAME,GACZX,KAAKc,IAGdd,KAAKY,IAAID,EAAOF,IAAST,KAAKc,IAC7BP,EAAOG,GAAQ,IACjBA,GAAQV,KAAKc,GAAK,MAWpB,IAPA,IAAIC,EAAMhB,EAAKK,EACXY,EAAOd,EAAKE,EACZa,EAAOtB,EAAYS,EACnBc,KACAC,EAAI,EACJC,EAAMf,KAAKgB,QAETN,GAAOC,GAAK,CACjBM,IAAMtB,KAAKuB,MAAMvB,KAAKwB,IAAIjB,GAAQP,KAAKyB,IAAIf,GAAQV,KAAKwB,IAAIT,EAAMJ,GAAQX,KAAKwB,IAAId,GAAQV,KAAKyB,IAAIlB,GAC7DP,KAAKwB,IAAIT,EAAMN,KAC3CT,KAAKyB,IAAIlB,GAAQP,KAAKyB,IAAIf,GAAQV,KAAKwB,IAAIf,EAAOE,KAC7D,IAAIe,GACH7B,EAAGkB,EAAMK,EACTZ,EAAGc,IAAMF,GAEVF,EAAGC,KAAOO,EACPX,EAAMC,GAASD,EAAME,GAASD,EAChCD,EAAMC,EAEND,GAAYE,EAGd,OAAOC,GAGRS,aAAc,SAASlC,EAAIC,EAAIC,GAe9B,IAAIuB,EAAKb,KAAKb,aAAaC,EAAIC,EAAIC,GAEnC,OADS,IAAIiC,WAAWC,SAASC,WAAWZ,IAI7Ca,kBAAmB,SAAStC,EAAIC,EAAIC,GAkBnC,IAAIqC,EAAK3B,KAAKsB,aAAalC,EAAIC,EAAIC,GACnC,OAAO,IAAIL,EAAgB0C,IAG5B1B,QAASN,KAAKc,GAAK,IAEnBO,QAAS,IAAMrB,KAAKc,GAEpBD,UAAW","file":"../../../geo/openlayers/GreatCircle.js","sourcesContent":["define([\r\n\t\"dojo/_base/lang\",\r\n\t\"./_base\",\r\n\t\"./GeometryFeature\"\r\n], function(lang, openlayers, GeometryFeature){\r\n\r\n\tvar gc = openlayers.GreatCircle = {\r\n\r\n\t\ttoPointArray: function(p1, p2, increment){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreate a geodetic line as an array of OpenLayers.Point.\r\n\t\t\t// description:\r\n\t\t\t//\t\tCreate a geodetic line as an array of OpenLayers.Point between the point p1\r\n\t\t\t//\t\tand the point p2. Result is a polyline approximation for which a new point is \r\n\t\t\t//\t\tcalculated every <em>increment</em> degrees.\r\n\t\t\t// p1: Point\r\n\t\t\t//\t\tThe first point of the geodetic line. x and y fields are longitude and\r\n\t\t\t//\t\tlatitude in decimal degrees.\r\n\t\t\t// p2: Point\r\n\t\t\t//\t\tThe second point of the geodetic line. x and y fields are longitude and\r\n\t\t\t//\t\tlatitude in decimal degrees.\r\n\t\t\t// increment: Float\r\n\t\t\t//\t\tThe value at which a new point is computed. \r\n\t\t\tvar startLon = p1.x;\r\n\t\t\tvar endLon = p2.x;\r\n\t\t\tvar sl = Math.min(startLon, endLon);\r\n\t\t\tvar el = Math.max(startLon, endLon);\r\n\r\n\t\t\tvar d2r = this.DEG2RAD;\r\n\t\t\tvar lat1 = p1.y * d2r;\r\n\t\t\tvar lon1 = p1.x * d2r;\r\n\t\t\tvar lat2 = p2.y * d2r;\r\n\t\t\tvar lon2 = p2.x * d2r;\r\n\r\n\t\t\tif(Math.abs(lon1 - lon2) <= this.TOLERANCE){\r\n\t\t\t\tvar l = Math.min(lon1, lon2);\r\n\t\t\t\tlon2 = l + Math.PI;\r\n\t\t\t}\r\n\r\n\t\t\tif(Math.abs(lon2 - lon1) == Math.PI){\r\n\t\t\t\tif(lat1 + lat2 == 0.0){\r\n\t\t\t\t\tlat2 += Math.PI / 180000000;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar lon = sl * d2r;\r\n\t\t\tvar elon = el * d2r;\r\n\t\t\tvar incr = increment * d2r;\r\n\t\t\tvar wp = [];\r\n\t\t\tvar k = 0;\r\n\t\t\tvar r2d = this.RAD2DEG;\r\n\r\n\t\t\twhile(lon <= elon){\r\n\t\t\t\tlat = Math.atan((Math.sin(lat1) * Math.cos(lat2) * Math.sin(lon - lon2) - Math.sin(lat2) * Math.cos(lat1)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* Math.sin(lon - lon1))\r\n\t\t\t\t\t\t\t\t\t\t\t\t/ (Math.cos(lat1) * Math.cos(lat2) * Math.sin(lon1 - lon2)));\r\n\t\t\t\tvar p = {\r\n\t\t\t\t\tx: lon * r2d,\r\n\t\t\t\t\ty: lat * r2d\r\n\t\t\t\t};\r\n\t\t\t\twp[k++] = p;\r\n\t\t\t\tif(lon < elon && (lon + incr) >= elon){\r\n\t\t\t\t\tlon = elon;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tlon = lon + incr;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn wp;\r\n\t\t},\r\n\r\n\t\ttoLineString: function(p1, p2, increment){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreate a geodetic line as an array of OpenLayers.Geometry.LineString.\r\n\t\t\t// description:\r\n\t\t\t//\t\tCreate a geodetic line as a OpenLayers.Geometry.LineString between the point p1\r\n\t\t\t//\t\tand the point p2. Result is a polyline approximation for which a new point is \r\n\t\t\t//\t\tcalculated every <em>increment</em> degrees.\r\n\t\t\t// p1: Point\r\n\t\t\t//\t\tThe first point of the geodetic line. x and y fields are longitude and\r\n\t\t\t//\t\tlatitude in decimal degrees.\r\n\t\t\t// p2: Point\r\n\t\t\t//\t\tThe second point of the geodetic line. x and y fields are longitude and\r\n\t\t\t//\t\tlatitude in decimal degrees.\r\n\t\t\t// increment: Float\r\n\t\t\t//\t\tThe value at which a new point is computed. \r\n\t\t\tvar wp = this.toPointArray(p1, p2, increment);\r\n\t\t\tvar ls = new OpenLayers.Geometry.LineString(wp);\r\n\t\t\treturn ls;\r\n\t\t},\r\n\r\n\t\ttoGeometryFeature: function(p1, p2, increment){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCreate a geodetic line as an array of dojox.geo.openlayers.GeometryFeature.\r\n\t\t\t// description:\r\n\t\t\t//\t\tCreate a geodetic line as a dojox.geo.openlayers.GeometryFeature between the point p1\r\n\t\t\t//\t\tant the point p2. Result is a polyline approximation for which a new point is \r\n\t\t\t//\t\tcalculated every <em>increment</em> degrees.\r\n\t\t\t// p1: Point\r\n\t\t\t//\t\tThe first point of the geodetic line. x and y fields are longitude and\r\n\t\t\t//\t\tlatitude in decimal degrees.\r\n\t\t\t// p2: Point\r\n\t\t\t//\t\tThe second point of the geodetic line. x and y fields are longitude and\r\n\t\t\t//\t\tlatitude in decimal degrees.\r\n\t\t\t// increment: Float\r\n\t\t\t//\t\tThe value at which a new point is computed. \r\n\t\t\t// returns:\r\n\t\t\t//\t\tThe geodetic line as a GeometryFeature\r\n\r\n\t\t\tvar ls = this.toLineString(p1, p2, increment);\r\n\t\t\treturn new GeometryFeature(ls); // GeometryFeature\r\n\t\t},\r\n\r\n\t\tDEG2RAD: Math.PI / 180,\r\n\r\n\t\tRAD2DEG: 180 / Math.PI,\r\n\r\n\t\tTOLERANCE: 0.00001\r\n\t};\r\n\t\r\n\treturn gc;\r\n});\r\n"]}