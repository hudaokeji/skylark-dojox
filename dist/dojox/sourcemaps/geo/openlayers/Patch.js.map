{"version":3,"sources":["geo/openlayers/Patch.js"],"names":["define","dojo","lang","sniff","gfx","shape","dgo","getObject","dojox","Patch","patchMethod","type","method","execBefore","execAfter","old","prototype","callee","call","this","arguments","ret","apply","patchGFX","vmlFixRawNodePath","rawNode","path","isIE","renderer","Line","Polyline","Path","Shape","fill","colors"],"mappings":";;;;;;;AAAAA,QACC,oBACA,kBACA,mBACA,YACA,mBACE,SAASC,EAAMC,EAAMC,EAAOC,EAAKC,GAEnC,IAAIC,EAAMJ,EAAKK,UAAU,kBAAkB,EAAMC,OA+DjD,OA7DAF,EAAIG,OAEHC,YAAa,SAAmBC,EAAgBC,EAAoBC,EACpEC,GAqBC,IAAIC,EAAMJ,EAAKK,UAAUJ,GACzBD,EAAKK,UAAUJ,GAAU,WACxB,IAAIK,EAASL,EACVC,GACFA,EAAWK,KAAKC,KAAMF,EAAQG,WAE/B,IAAIC,EAAMN,EAAIO,MAAMH,KAAMC,WAI1B,OAHGN,IACFO,EAAMP,EAAUI,KAAKC,KAAMF,EAAQI,EAAKD,YAAcC,GAEhDA,IAITE,SAAU,WAET,IAAIC,EAAoB,WACnBL,KAAKM,QAAQC,OAChBP,KAAKM,QAAQC,UAUZvB,EAAMwB,MAAQ,GAAsB,QAAjBvB,EAAIwB,WACzBT,KAAKT,YAAYN,EAAIyB,KAAM,WAAYL,EAAmB,MAC1DL,KAAKT,YAAYN,EAAI0B,SAAU,WAAYN,EAAmB,MAC9DL,KAAKT,YAAYN,EAAI2B,KAAM,WAAYP,EAAmB,MAE1DL,KAAKT,YAAYL,EAAM2B,MAAO,UAXR,WACnBb,KAAKM,QAAQQ,OAASd,KAAKM,QAAQQ,KAAKC,SAC1Cf,KAAKM,QAAQQ,KAAKC,YASwC,SAIvD5B,EAAIG","file":"../../../geo/openlayers/Patch.js","sourcesContent":["define([\r\n\t\"dojo/_base/kernel\",\r\n\t\"dojo/_base/lang\",\t// dojo.extend getObject\r\n\t\"dojo/_base/sniff\",\t// dojo.isIE\r\n\t\"dojox/gfx\",\r\n\t\"dojox/gfx/shape\"\r\n], function(dojo, lang, sniff, gfx, shape){\r\n\r\n\tvar dgo = lang.getObject(\"geo.openlayers\", true, dojox);\r\n\r\n\tdgo.Patch = {\r\n\r\n\t\tpatchMethod: function(/*Object*/type, /*String*/method, /*Function*/execBefore, /*Function*/\r\n\t\texecAfter){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tPatches the specified method of the given type so that the 'execBefore' (resp. 'execAfter') function is \r\n\t\t\t//\t\tcalled before (resp. after) invoking the legacy implementation.\r\n\t\t\t// description:\r\n\t\t\t//\t\tThe execBefore function is invoked with the following parameter:\r\n\t\t\t//\t\texecBefore(method, arguments) where 'method' is the patched method name and 'arguments' the arguments received\r\n\t\t\t//\t\tby the legacy implementation.\r\n\t\t\t//\t\tThe execAfter function is invoked with the following parameter:\r\n\t\t\t//\t\texecBefore(method, returnValue, arguments) where 'method' is the patched method name, 'returnValue' the value\r\n\t\t\t//\t\treturned by the legacy implementation and 'arguments' the arguments received by the legacy implementation.\r\n\t\t\t// type: Object\r\n\t\t\t//\t\tthe type to patch.\r\n\t\t\t// method: String\r\n\t\t\t//\t\tthe method name.\r\n\t\t\t// execBefore: Function\r\n\t\t\t//\t\tthe function to execute before the legacy implementation.\r\n\t\t\t// execAfter: Function\r\n\t\t\t//\t\tthe function to execute after the legacy implementation.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\tvar old = type.prototype[method];\r\n\t\t\ttype.prototype[method] = function(){\r\n\t\t\t\tvar callee = method;\r\n\t\t\t\tif(execBefore){\r\n\t\t\t\t\texecBefore.call(this, callee, arguments);\r\n\t\t\t\t}\r\n\t\t\t\tvar ret = old.apply(this, arguments);\r\n\t\t\t\tif(execAfter){\r\n\t\t\t\t\tret = execAfter.call(this, callee, ret, arguments) || ret;\r\n\t\t\t\t}\r\n\t\t\t\treturn ret;\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\tpatchGFX: function(){\r\n\r\n\t\t\tvar vmlFixRawNodePath = function(){\r\n\t\t\t\tif(!this.rawNode.path){\r\n\t\t\t\t\tthis.rawNode.path = {};\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tvar vmlFixFillColors = function(){\r\n\t\t\t\tif(this.rawNode.fill && !this.rawNode.fill.colors){\r\n\t\t\t\t\tthis.rawNode.fill.colors = {};\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tif(sniff.isIE <= 8 && gfx.renderer === \"vml\"){\r\n\t\t\t\tthis.patchMethod(gfx.Line, \"setShape\", vmlFixRawNodePath, null);\r\n\t\t\t\tthis.patchMethod(gfx.Polyline, \"setShape\", vmlFixRawNodePath, null);\r\n\t\t\t\tthis.patchMethod(gfx.Path, \"setShape\", vmlFixRawNodePath, null);\r\n\t\t\t\t\r\n\t\t\t\tthis.patchMethod(shape.Shape, \"setFill\", vmlFixFillColors, null);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn dgo.Patch;\r\n});\r\n"]}