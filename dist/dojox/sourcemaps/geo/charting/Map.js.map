{"version":3,"sources":["geo/charting/Map.js"],"names":["define","lang","arr","declare","html","dom","domGeom","domClass","xhr","connect","win","gfx","base","Feature","Marker","number","has","defaultColor","highlightColor","series","dataBindingAttribute","dataBindingValueFunction","dataStore","showTooltips","enableFeatureZoom","colorAnimationDuration","_idAttributes","_onSetListener","_onNewListener","_onDeleteListener","constructor","container","shapeData","style","this","containerBounds","_getContainerBounds","surface","createSurface","w","h","_createZoomingCursor","mapBackground","createRect","x","y","width","height","setFill","mapObj","createGroup","features","_init","length","get","url","handleAs","sync","load","hitch","position","contentBox","getMarginBox","getContentBox","_storedContainerBounds","resize","adjustMapCenter","adjustMapScale","animate","oldBounds","newBounds","setShape","setDimensions","marker","hide","_needTooltipRefresh","mapScale","getMapScale","newScale","boundBox","widthFactor","heightFactor","Math","sqrt","invariantMapPoint","screenCoordsToMapCoords","setMapCenterAndScale","_isMobileDevice","navigator","userAgent","indexOf","toLowerCase","setMarkerData","markerFile","handle","setDataBindingAttribute","prop","_queryDataStore","setDataBindingValueFunction","valueFunction","mapInstance","fetch","scope","onComplete","items","getIdentityAttributes","forEach","item","id","getValue","val","itemVal","isNaN","parse","setValue","_onSet","attribute","oldValue","newValue","feature","unsetValue","_onNew","newItem","parentItem","_onDelete","setDataStore","dataBindingProp","disconnect","addSeries","_addSeriesImpl","content","value","fitToMapArea","mapArea","pixelMargin","onAnimationEnd","scale","min","fitToMapContents","bbox","setMapCenter","centerX","centerY","currentScale","_createAnimation","onShape","fromTransform","toTransform","fromDx","dx","fromDy","dy","toDx","toDy","fromScale","xx","toScale","anim","fx","animateTransform","duration","shape","transform","name","start","end","listener","event","offsetX","offsetY","newTransform","matrix","Matrix2D","yy","currentTransform","getTransform","play","setTransform","getMapCenter","setMapScale","setMapScaleAt","fixedMapX","fixedMapY","invariantScreenPoint","mapCoordsToScreenCoords","mat","mapX","mapY","multiplyPoint","screenX","screenY","invMatrix","invert","deselectAll","select","selectedFeature","focused","layerExtent","featureNames","featureShape","init","_appendMarker","markerData","byId","mapZoomCursor","doc","createElement","attr","add","body","appendChild","onFeatureClick","onFeatureOver","onZoomEnd"],"mappings":"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","file":"../../../geo/charting/Map.js","sourcesContent":["define([\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/html\",\r\n\t\"dojo/dom\",\r\n\t\"dojo/dom-geometry\",\r\n\t\"dojo/dom-class\", \r\n\t\"dojo/_base/xhr\",\r\n\t\"dojo/_base/connect\",\r\n\t\"dojo/_base/window\", \r\n\t\"dojox/gfx\",\r\n\t\"./_base\",\r\n\t\"./Feature\",\r\n\t\"./_Marker\",\r\n\t\"dojo/number\",\r\n\t\"dojo/_base/sniff\"\r\n], function(lang, arr, declare, html, dom, domGeom, domClass, xhr, connect, win, gfx, base, Feature, Marker, number, has){\r\n\r\n\treturn declare(\"dojox.geo.charting.Map\", null, {\r\n\t\t// summary:\r\n\t\t//\t\tMap widget interacted with charting.\r\n\t\t// description:\r\n\t\t//\t\tSupport rendering Americas, AsiaPacific, ContinentalEurope, EuropeMiddleEastAfrica,\r\n\t\t//\t\tUSStates, WorldCountries, and WorldCountriesMercator by default.\r\n\t\t// example:\r\n\t\t//\t|\tvar usaMap = new dojox.geo.charting.Map(srcNode, \"dojotoolkit/dojox/geo/charting/resources/data/USStates.json\");\r\n\t\t//\t|\t<div id=\"map\" style=\"width:600px;height:400px;\"></div>\r\n\t\r\n\t\t// defaultColor: String\r\n\t\t//\t\tDefault map feature color, e.g: \"#B7B7B7\"\r\n\t\tdefaultColor:\"#B7B7B7\",\r\n\t\t// highlightColor: String\r\n\t\t//\t\tMap feature color when mouse over it, e.g: \"#\"\r\n\t\thighlightColor:\"#D5D5D5\",\r\n\t\t// series: Array\r\n\t\t//\t\tstack to data range, e.g: [{name:'label 1', min:20, max:70, color:'#DDDDDD'},{...},...]\r\n\t\tseries:[],\r\n\t\t\r\n\t\tdataBindingAttribute:null,\r\n\t\tdataBindingValueFunction:null,\r\n\t\tdataStore:null,\r\n\t\tshowTooltips: true,\r\n\t\tenableFeatureZoom: true,\r\n\t\tcolorAnimationDuration:0,\r\n\t\t_idAttributes:null,\r\n\t\t_onSetListener:null,\r\n\t\t_onNewListener:null,\r\n\t\t_onDeleteListener:null,\r\n\t\tconstructor: function(/*Node*/container, /*String|Object*/shapeData){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tConstructs a new Map instance.\r\n\t\t\t// container:\r\n\t\t\t//\t\tmap container html node/id.\r\n\t\t\t// shapeData:\r\n\t\t\t//\t\tmap shape data json object, or url to json file.\r\n\t\r\n\t\t\thtml.style(container, \"display\", \"block\");\r\n\t\r\n\t\t\tthis.container = container;\r\n\t\t\tvar containerBounds = this._getContainerBounds();\r\n\t\t\t// get map container coords\r\n\t\t\tthis.surface = gfx.createSurface(container, containerBounds.w, containerBounds.h);\r\n\t\r\n\t\t\tthis._createZoomingCursor();\r\n\t\r\n\t\t\t// add transparent background for event capture\r\n\t\t\tthis.mapBackground = this.surface.createRect({x: 0, y: 0, width: containerBounds.w, height: containerBounds.w}).setFill(\"rgba(0,0,0,0)\");\r\n\t\r\n\t\t\tthis.mapObj = this.surface.createGroup();\r\n\t\t\tthis.mapObj.features = {};\r\n\t\r\n\t\t\tif(typeof shapeData == \"object\"){\r\n\t\t\t\tthis._init(shapeData);\r\n\t\t\t}else{\r\n\t\t\t\t// load map shape file\r\n\t\t\t\tif(typeof shapeData == \"string\" && shapeData.length > 0){\r\n\t\t\t\t\txhr.get({\r\n\t\t\t\t\t\turl: shapeData,\r\n\t\t\t\t\t\thandleAs: \"json\",\r\n\t\t\t\t\t\tsync: true,\r\n\t\t\t\t\t\tload: lang.hitch(this, \"_init\")\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_getContainerBounds: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the bounds {x:, y:, w: ,h:} of the DOM node container in absolute coordinates\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\r\n\t\t\tvar position = domGeom.position(this.container,true);\r\n\t\t\tvar marginBox = domGeom.getMarginBox(this.container);\r\n\t\t\t// use contentBox for correct width and height - surface spans outside border otherwise\r\n\t\t\tvar contentBox = domGeom.getContentBox(this.container);\r\n\t\t\tthis._storedContainerBounds = {\r\n\t\t\t\t\tx: position.x,\r\n\t\t\t\t\ty: position.y,\r\n\t\t\t\t\tw: contentBox.w || 100,\r\n\t\t\t\t\th: contentBox.h || 100\r\n\t\t\t\t};\r\n\t\t\treturn this._storedContainerBounds;\r\n\t\t},\r\n\t\r\n\t\tresize: function(/**boolean**/ adjustMapCenter, /**boolean**/ adjustMapScale, /**boolean**/ animate){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tresize the underlying GFX surface to accommodate to parent DOM Node size change\r\n\t\t\t// adjustMapCenter: boolean\r\n\t\t\t//\t\tkeeps the center of the map when resizing the surface\r\n\t\t\t// adjustMapScale: boolean\r\n\t\t\t//\t\tadjusts the map scale to keep the visible portion of the map as much as possible\r\n\t\r\n\t\t\tvar oldBounds = this._storedContainerBounds;\r\n\t\t\tvar newBounds = this._getContainerBounds();\r\n\t\r\n\t\t\tif((oldBounds.w == newBounds.w) && (oldBounds.h == newBounds.h)){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\t// set surface dimensions, and background\r\n\t\t\tthis.mapBackground.setShape({width:newBounds.w, height:newBounds.h});\r\n\t\t\tthis.surface.setDimensions(newBounds.w,newBounds.h);\r\n\t\r\n\t\t\tthis.mapObj.marker.hide();\r\n\t\t\tthis.mapObj.marker._needTooltipRefresh = true;\r\n\t\r\n\t\t\tif(adjustMapCenter){\r\n\t\r\n\t\t\t\tvar mapScale = this.getMapScale();\r\n\t\t\t\tvar newScale = mapScale;\r\n\t\r\n\t\t\t\tif(adjustMapScale){\r\n\t\t\t\t\tvar bbox = this.mapObj.boundBox;\r\n\t\t\t\t\tvar widthFactor = newBounds.w / oldBounds.w;\r\n\t\t\t\t\tvar heightFactor = newBounds.h / oldBounds.h;\r\n\t\t\t\t\tnewScale = mapScale * Math.sqrt(widthFactor * heightFactor);\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//\tcurrent map center\r\n\t\t\t\tvar invariantMapPoint = this.screenCoordsToMapCoords(oldBounds.w/2,oldBounds.h/2);\r\n\t\r\n\t\t\t\t//\tapply new parameters\r\n\t\t\t\tthis.setMapCenterAndScale(invariantMapPoint.x,invariantMapPoint.y,newScale,animate);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_isMobileDevice: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\ttests whether the application is running on a mobile device (android or iOS)\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprivate\r\n\t\t\treturn (has(\"safari\")\r\n\t\t\t\t\t&& (navigator.userAgent.indexOf(\"iPhone\") > -1 ||\r\n\t\t\t\t\t\tnavigator.userAgent.indexOf(\"iPod\") > -1 ||\r\n\t\t\t\t\t\tnavigator.userAgent.indexOf(\"iPad\") > -1\r\n\t\t\t\t\t)) || (navigator.userAgent.toLowerCase().indexOf(\"android\") > -1);\r\n\t\t},\r\n\t\r\n\t\r\n\t\tsetMarkerData: function(/*String*/ markerFile){\r\n\t\t\t// summary:\r\n\t\t\t//\t\timport markers from outside file, associate with map feature by feature id\r\n\t\t\t//\t\twhich identified in map shape file, e.g: \"NY\":\"New York\"\r\n\t\t\t// markerFile:\r\n\t\t\t//\t\toutside marker data url, handled as json style.\r\n\t\t\t//\t\tdata format: {\"NY\":\"New York\",.....}\r\n\t\t\txhr.get({\r\n\t\t\t\turl: markerFile,\r\n\t\t\t\thandleAs: \"json\",\r\n\t\t\t\thandle: lang.hitch(this, \"_appendMarker\")\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\tsetDataBindingAttribute: function(/*String*/prop){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets the property name of the dataStore items to use as value (see Feature.setValue function)\r\n\t\t\t// prop: String\r\n\t\t\t//\t\tthe property\r\n\t\t\tthis.dataBindingAttribute = prop;\r\n\t\r\n\t\t\t// refresh data\r\n\t\t\tif(this.dataStore){\r\n\t\t\t\tthis._queryDataStore();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tsetDataBindingValueFunction: function(/* function */valueFunction){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets the function that extracts values from dataStore items,to use as Feature values (see Feature.setValue function)\r\n\t\t\t// valueFunction:\r\n\t\t\t//\t\tthe function\r\n\t\t\tthis.dataBindingValueFunction = valueFunction;\r\n\t\r\n\t\t\t// refresh data\r\n\t\t\tif(this.dataStore){\r\n\t\t\t\tthis._queryDataStore();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\r\n\t\r\n\t\t_queryDataStore: function(){\r\n\t\t\tif(!this.dataBindingAttribute || (this.dataBindingAttribute.length == 0)){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\tvar mapInstance = this;\r\n\t\t\tthis.dataStore.fetch({\r\n\t\t\t\tscope: this,\r\n\t\t\t\tonComplete: function(items){\r\n\t\t\t\t\tthis._idAttributes = mapInstance.dataStore.getIdentityAttributes({});\r\n\t\t\t\t\tarr.forEach(items, function(item){\r\n\t\t\t\t\t\tvar id = mapInstance.dataStore.getValue(item, this._idAttributes[0]);\r\n\t\t\t\t\t\tif(mapInstance.mapObj.features[id]){\r\n\t\t\t\t\t\t\tvar val = null;\r\n\t\t\t\t\t\t\tvar itemVal = mapInstance.dataStore.getValue(item, mapInstance.dataBindingAttribute);\r\n\t\t\t\t\t\t\tif(itemVal){\r\n\t\t\t\t\t\t\t\tif(this.dataBindingValueFunction){\r\n\t\t\t\t\t\t\t\t\tval = this.dataBindingValueFunction(itemVal);\r\n\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\tif(isNaN(val)){\r\n\t\t\t\t\t\t\t\t\t\t// regular parse\r\n\t\t\t\t\t\t\t\t\t\tval=number.parse(itemVal);\r\n\t\t\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\t\t\tval = itemVal;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(val){\r\n\t\t\t\t\t\t\t\tmapInstance.mapObj.features[id].setValue(val);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},this);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t},\r\n\t\r\n\t\t_onSet:function(item,attribute,oldValue,newValue){\r\n\t\t\t// look for matching feature\r\n\t\t\tvar id = this.dataStore.getValue(item, this._idAttributes[0]);\r\n\t\t\tvar feature = this.mapObj.features[id];\r\n\t\t\tif(feature && (attribute == this.dataBindingAttribute)){\r\n\t\t\t\tif(newValue){\r\n\t\t\t\t\tfeature.setValue(newValue);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tfeature.unsetValue();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onNew:function(newItem,  parentItem){\r\n\t\t\tvar id = this.dataStore.getValue(item, this._idAttributes[0]);\r\n\t\t\tvar feature = this.mapObj.features[id];\r\n\t\t\tif(feature && (attribute == this.dataBindingAttribute)){\r\n\t\t\t\tfeature.setValue(newValue);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_onDelete:function(item){\r\n\t\t\tvar id = item[this._idAttributes[0]];\r\n\t\t\tvar feature = this.mapObj.features[id];\r\n\t\t\tif(feature){\r\n\t\t\t\tfeature.unsetValue();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tsetDataStore: function(/*dojo/data/ItemFileReadStore*/ dataStore, /*String*/ dataBindingProp){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tpopulate data for each map feature from fetched data store\r\n\t\t\t// dataStore: dojo/data/ItemFileReadStore\r\n\t\t\t//\t\tthe dataStore to fetch the information from\r\n\t\t\t// dataBindingProp:\r\n\t\t\t//\t\tsets the property name of the dataStore items to use as value\r\n\t\t\tif(this.dataStore != dataStore){\r\n\t\t\t\t// disconnect previous listener if any\r\n\t\t\t\tif(this._onSetListener){\r\n\t\t\t\t\tconnect.disconnect(this._onSetListener);\r\n\t\t\t\t\tconnect.disconnect(this._onNewListener);\r\n\t\t\t\t\tconnect.disconnect(this._onDeleteListener);\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// set new dataStore\r\n\t\t\t\tthis.dataStore = dataStore;\r\n\t\r\n\t\t\t\t// install listener on new dataStore\r\n\t\t\t\tif(dataStore){\r\n\t\t\t\t\t_onSetListener = connect.connect(this.dataStore,\"onSet\",this,this._onSet);\r\n\t\t\t\t\t_onNewListener = connect.connect(this.dataStore,\"onNew\",this,this._onNew);\r\n\t\t\t\t\t_onDeleteListener = connect.connect(this.dataStore,\"onDelete\",this,this._onDelete);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(dataBindingProp){\r\n\t\t\t\tthis.setDataBindingAttribute(dataBindingProp);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\taddSeries: function(/*url|Object[]*/ series){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tsets ranges of data values (associated with label, color) to style map data values\r\n\t\t\t// series:\r\n\t\t\t//\t\tEither an url or an array of range objects such as : [{name:'label 1', min:20, max:70, color:'#DDDDDD'},{...},...]\r\n\t\r\n\t\t\tif(typeof series == \"object\"){\r\n\t\t\t\tthis._addSeriesImpl(series);\r\n\t\t\t}else{\r\n\t\t\t\t// load series file\r\n\t\t\t\tif(typeof series == \"string\" && series.length > 0){\r\n\t\t\t\t\txhr.get({\r\n\t\t\t\t\t\turl: series,\r\n\t\t\t\t\t\thandleAs: \"json\",\r\n\t\t\t\t\t\tsync: true,\r\n\t\t\t\t\t\tload: lang.hitch(this, function(content){\r\n\t\t\t\t\t\t\tthis._addSeriesImpl(content.series);\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_addSeriesImpl: function(/*Object[]*/series){\r\n\t\r\n\t\t\tthis.series = series;\r\n\t\r\n\t\t\t// refresh color scheme\r\n\t\t\tfor(var item in this.mapObj.features){\r\n\t\t\t\tvar feature = this.mapObj.features[item];\r\n\t\t\t\tfeature.setValue(feature.value);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\r\n\t\tfitToMapArea: function(mapArea, pixelMargin, animate, onAnimationEnd){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tset this component's transformation so that the specified area fits in the component (centered)\r\n\t\t\t// mapArea: Object\r\n\t\t\t//\t\tthe map area that needs to fill the component expressed as {x,y,w,h}\r\n\t\t\t// pixelMargin: int\r\n\t\t\t//\t\ta margin (in pixels) from the borders of the Map component.\r\n\t\t\t// animate: boolean\r\n\t\t\t//\t\ttrue if the transform change should be animated\r\n\t\t\t// onAnimationEnd: function\r\n\t\t\t//\t\ta callback function to be executed when the animation completes (if animate set to true).\r\n\t\r\n\t\t\tif(!pixelMargin){\r\n\t\t\t\tpixelMargin = 0;\r\n\t\t\t}\r\n\t\t\tvar width = mapArea.w,\r\n\t\t\t\theight = mapArea.h,\r\n\t\t\t\tcontainerBounds = this._getContainerBounds(),\r\n\t\t\t\tscale = Math.min((containerBounds.w - 2 * pixelMargin) / width,\r\n\t\t\t\t\t\t\t\t(containerBounds.h - 2 * pixelMargin) / height);\r\n\t\r\n\t\t\tthis.setMapCenterAndScale(mapArea.x + mapArea.w / 2,mapArea.y + mapArea.h / 2,scale,animate,onAnimationEnd);\r\n\t\t},\r\n\t\r\n\t\tfitToMapContents: function(pixelMargin,animate,/* callback function */onAnimationEnd){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tset this component's transformation so that the whole map data fits in the component (centered)\r\n\t\t\t// pixelMargin: int\r\n\t\t\t//\t\ta margin (in pixels) from the borders of the Map component.\r\n\t\t\t// animate: boolean\r\n\t\t\t//\t\ttrue if the transform change should be animated\r\n\t\t\t// onAnimationEnd: function\r\n\t\t\t//\t\ta callback function to be executed when the animation completes (if animate set to true).\r\n\t\r\n\t\t\t//transform map to fit container\r\n\t\t\tvar bbox = this.mapObj.boundBox;\r\n\t\t\tthis.fitToMapArea(bbox,pixelMargin,animate,onAnimationEnd);\r\n\t\t},\r\n\t\r\n\t\tsetMapCenter: function(centerX,centerY,animate,/* callback function */onAnimationEnd){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tset this component's transformation so that the map is centered on the specified map coordinates\r\n\t\t\t// centerX: float\r\n\t\t\t//\t\tthe X coordinate (in map coordinates) of the new center\r\n\t\t\t// centerY: float\r\n\t\t\t//\t\tthe Y coordinate (in map coordinates) of the new center\r\n\t\t\t// animate: boolean\r\n\t\t\t//\t\ttrue if the transform change should be animated\r\n\t\t\t// onAnimationEnd: function\r\n\t\t\t//\t\ta callback function to be executed when the animation completes (if animate set to true).\r\n\t\r\n\t\t\t// call setMapCenterAndScale with current map scale\r\n\t\t\tvar currentScale = this.getMapScale();\r\n\t\t\tthis.setMapCenterAndScale(centerX,centerY,currentScale,animate,onAnimationEnd);\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_createAnimation: function(onShape,fromTransform,toTransform,/* callback function */onAnimationEnd){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcreates a transform animation object (between two transforms) used internally\r\n\t\t\t// onShape: dojox.gfx.shape.Shape\r\n\t\t\t//\t\tThe target shape.\r\n\t\t\t// fromTransform: dojox.gfx.matrix.Matrix2D\r\n\t\t\t//\t\tthe start transformation (when animation begins)\r\n\t\t\t// toTransform: dojox.gfx.matrix.Matrix2D\r\n\t\t\t//\t\tthe end transormation (when animation ends)\r\n\t\t\t// onAnimationEnd: function\r\n\t\t\t//\t\tcallback function to be executed when the animation completes.\r\n\t\t\tvar fromDx = fromTransform.dx?fromTransform.dx:0;\r\n\t\t\tvar fromDy = fromTransform.dy?fromTransform.dy:0;\r\n\t\t\tvar toDx = toTransform.dx?toTransform.dx:0;\r\n\t\t\tvar toDy = toTransform.dy?toTransform.dy:0;\r\n\t\t\tvar fromScale = fromTransform.xx?fromTransform.xx:1.0;\r\n\t\t\tvar toScale = toTransform.xx?toTransform.xx:1.0;\r\n\t\r\n\t\t\tvar anim = gfx.fx.animateTransform({\r\n\t\t\t\tduration: 1000,\r\n\t\t\t\tshape: onShape,\r\n\t\t\t\ttransform: [{\r\n\t\t\t\t\tname: \"translate\",\r\n\t\t\t\t\tstart: [fromDx,fromDy],\r\n\t\t\t\t\tend: [toDx,toDy]\r\n\t\t\t\t},\r\n\t\t\t\t{\r\n\t\t\t\t\tname: \"scale\",\r\n\t\t\t\t\tstart: [fromScale],\r\n\t\t\t\t\tend: [toScale]\r\n\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t});\r\n\t\r\n\t\t\t//install callback\r\n\t\t\tif(onAnimationEnd){\r\n\t\t\t\tvar listener = connect.connect(anim,\"onEnd\",this,function(event){\r\n\t\t\t\t\tonAnimationEnd(event);\r\n\t\t\t\t\tconnect.disconnect(listener);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\r\n\t\t\treturn anim;\r\n\t\t},\r\n\t\r\n\t\r\n\t\tsetMapCenterAndScale: function(centerX,centerY,scale, animate,/* callback function */onAnimationEnd){\r\n\t\r\n\t\t\t// summary:\r\n\t\t\t//\t\tset this component's transformation so that the map is centered on the specified map coordinates\r\n\t\t\t//\t\tand scaled to the specified scale.\r\n\t\t\t// centerX: float\r\n\t\t\t//\t\tthe X coordinate (in map coordinates) of the new center\r\n\t\t\t// centerY: float\r\n\t\t\t//\t\tthe Y coordinate (in map coordinates) of the new center\r\n\t\t\t// scale: float\r\n\t\t\t//\t\tthe scale of the map\r\n\t\t\t// animate: boolean\r\n\t\t\t//\t\ttrue if the transform change should be animated\r\n\t\t\t// onAnimationEnd: function\r\n\t\t\t//\t\ta callback function to be executed when the animation completes (if animate set to true).\r\n\t\r\n\t\r\n\t\t\t// compute matrix parameters\r\n\t\t\tvar bbox = this.mapObj.boundBox;\r\n\t\t\tvar containerBounds = this._getContainerBounds();\r\n\t\t\tvar offsetX = containerBounds.w/2 - scale * (centerX - bbox.x);\r\n\t\t\tvar offsetY = containerBounds.h/2 - scale * (centerY - bbox.y);\r\n\t\t\tvar newTransform = new gfx.matrix.Matrix2D({xx: scale, yy: scale, dx:offsetX, dy:offsetY});\r\n\t\r\n\t\r\n\t\t\tvar currentTransform = this.mapObj.getTransform();\r\n\t\r\n\t\t\t// can animate only if specified AND currentTransform exists\r\n\t\t\tif(!animate || !currentTransform){\r\n\t\t\t\tthis.mapObj.setTransform(newTransform);\r\n\t\t\t}else{\r\n\t\t\t\tvar anim = this._createAnimation(this.mapObj,currentTransform,newTransform,onAnimationEnd);\r\n\t\t\t\tanim.play();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tgetMapCenter: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the map coordinates of the center of this Map component.\r\n\t\t\t// returns: point\r\n\t\t\t//\t\tthe center in map coordinates\r\n\t\t\tvar containerBounds = this._getContainerBounds();\r\n\t\t\treturn this.screenCoordsToMapCoords(containerBounds.w/2,containerBounds.h/2); // point\r\n\t\t},\r\n\t\r\n\t\tsetMapScale: function(scale,animate,/* callback function */onAnimationEnd){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tset this component's transformation so that the map is scaled to the specified scale.\r\n\t\t\t// scale: Number\r\n\t\t\t//\t\tthe scale ratio.\r\n\t\t\t// animate: boolean\r\n\t\t\t//\t\ttrue if the transform change should be animated\r\n\t\t\t// onAnimationEnd: function\r\n\t\t\t//\t\ta callback function to be executed when the animation completes (if animate set to true).\r\n\t\r\n\t\r\n\t\t\t// default invariant is map center\r\n\t\t\tvar containerBounds = this._getContainerBounds();\r\n\t\t\tvar invariantMapPoint = this.screenCoordsToMapCoords(containerBounds.w/2,containerBounds.h/2);\r\n\t\t\tthis.setMapScaleAt(scale,invariantMapPoint.x,invariantMapPoint.y,animate,onAnimationEnd);\r\n\t\t},\r\n\t\r\n\t\tsetMapScaleAt: function(scale,fixedMapX,fixedMapY,animate,/* callback function */onAnimationEnd){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tset this component's transformation so that the map is scaled to the specified scale, and the specified\r\n\t\t\t//\t\tpoint (in map coordinates) stays fixed on this Map component\r\n\t\t\t// scale: Number\r\n\t\t\t//\t\tthe scale ratio.\r\n\t\t\t// fixedMapX: float\r\n\t\t\t//\t\tthe X coordinate (in map coordinates) of the fixed screen point\r\n\t\t\t// fixedMapY: float\r\n\t\t\t//\t\tthe Y coordinate (in map coordinates) of the fixed screen point\r\n\t\t\t// animate: boolean\r\n\t\t\t//\t\ttrue if the transform change should be animated\r\n\t\t\t// onAnimationEnd: function\r\n\t\t\t//\t\ta callback function to be executed when the animation completes (if animate set to true).\r\n\t\r\n\t\r\n\t\t\tvar invariantMapPoint = null;\r\n\t\t\tvar invariantScreenPoint = null;\r\n\t\r\n\t\t\tinvariantMapPoint = {x: fixedMapX, y: fixedMapY};\r\n\t\t\tinvariantScreenPoint = this.mapCoordsToScreenCoords(invariantMapPoint.x,invariantMapPoint.y);\r\n\t\r\n\t\t\t// compute matrix parameters\r\n\t\t\tvar bbox = this.mapObj.boundBox;\r\n\t\t\tvar offsetX = invariantScreenPoint.x - scale * (invariantMapPoint.x - bbox.x);\r\n\t\t\tvar offsetY = invariantScreenPoint.y - scale * (invariantMapPoint.y - bbox.y);\r\n\t\t\tvar newTransform = new gfx.matrix.Matrix2D({xx: scale, yy: scale, dx:offsetX, dy:offsetY});\r\n\t\r\n\t\t\tvar currentTransform = this.mapObj.getTransform();\r\n\t\r\n\t\t\t// can animate only if specified AND currentTransform exists\r\n\t\t\tif(!animate || !currentTransform){\r\n\t\t\t\tthis.mapObj.setTransform(newTransform);\r\n\t\t\t}else{\r\n\t\t\t\tvar anim = this._createAnimation(this.mapObj,currentTransform,newTransform,onAnimationEnd);\r\n\t\t\t\tanim.play();\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tgetMapScale: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturns the scale of this Map component.\r\n\t\t\t// returns: float\r\n\t\t\t//\t\tthe scale\r\n\t\t\tvar mat = this.mapObj.getTransform();\r\n\t\t\tvar scale = mat?mat.xx:1.0;\r\n\t\t\treturn scale; // Number\r\n\t\t},\r\n\t\r\n\t\tmapCoordsToScreenCoords: function(mapX,mapY){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tconverts map coordinates to screen coordinates given the current transform of this Map component\r\n\t\t\t// mapX: Number\r\n\t\t\t//\t\tthe x coordinate of the point to convert.\r\n\t\t\t// mapY: Number\r\n\t\t\t//\t\tthe y coordinate of the point to convert.\r\n\t\t\t// returns: {x:,y:}\r\n\t\t\t//\t\tthe screen coordinates corresponding to the specified map coordinates.\r\n\t\t\tvar matrix = this.mapObj.getTransform();\r\n\t\t\tvar screenPoint = gfx.matrix.multiplyPoint(matrix, mapX, mapY);\r\n\t\t\treturn screenPoint; // point\r\n\t\t},\r\n\t\r\n\t\tscreenCoordsToMapCoords: function(screenX, screenY){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tconverts screen coordinates to map coordinates given the current transform of this Map component\r\n\t\t\t// screenX: Number\r\n\t\t\t//\t\tthe x coordinate of the point to convert.\r\n\t\t\t// screenY: Number\r\n\t\t\t//\t\tthe y coordinate of the point to convert.\r\n\t\t\t// returns:\r\n\t\t\t//\t\tthe map coordinates corresponding to the specified screen coordinates.\r\n\t\t\tvar invMatrix = gfx.matrix.invert(this.mapObj.getTransform());\r\n\t\t\tvar mapPoint = gfx.matrix.multiplyPoint(invMatrix, screenX, screenY);\r\n\t\t\treturn mapPoint; // point\r\n\t\t},\r\n\t\tdeselectAll: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tdeselect all features of map\r\n\t\t\tfor(var name in this.mapObj.features){\r\n\t\t\t\tthis.mapObj.features[name].select(false);\r\n\t\t\t}\r\n\t\t\tthis.selectedFeature = null;\r\n\t\t\tthis.focused = false;\r\n\t\t},\r\n\t\r\n\t\t_init: function(shapeData){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tinits this Map component.\r\n\t\r\n\t\t\t//transform map to fit container\r\n\t\t\tthis.mapObj.boundBox = {x: shapeData.layerExtent[0],\r\n\t\t\t\t\t\t\t\t\ty: shapeData.layerExtent[1],\r\n\t\t\t\t\t\t\t\t\tw: (shapeData.layerExtent[2] - shapeData.layerExtent[0]),\r\n\t\t\t\t\t\t\t\t\th: shapeData.layerExtent[3] - shapeData.layerExtent[1]};\r\n\t\t\tthis.fitToMapContents(3);\r\n\t\r\n\t\r\n\t\t\t//\tif there are \"features\", then implement them now.\r\n\t\t\tarr.forEach(shapeData.featureNames, function(item){\r\n\t\t\t\tvar featureShape = shapeData.features[item];\r\n\t\t\t\tfeatureShape.bbox.x = featureShape.bbox[0];\r\n\t\t\t\tfeatureShape.bbox.y = featureShape.bbox[1];\r\n\t\t\t\tfeatureShape.bbox.w = featureShape.bbox[2];\r\n\t\t\t\tfeatureShape.bbox.h = featureShape.bbox[3];\r\n\t\t\t\tvar feature = new Feature(this, item, featureShape);\r\n\t\t\t\tfeature.init();\r\n\t\t\t\tthis.mapObj.features[item] = feature;\r\n\t\t\t}, this);\r\n\t\r\n\t\r\n\t\t\t//\tset up a marker.\r\n\t\t\tthis.mapObj.marker = new Marker({}, this);\r\n\t\t},\r\n\t\t_appendMarker: function(markerData){\r\n\t\t\tthis.mapObj.marker = new Marker(markerData, this);\r\n\t\t},\r\n\t\t_createZoomingCursor: function(){\r\n\t\t\tif(!dom.byId(\"mapZoomCursor\")){\r\n\t\t\t\tvar mapZoomCursor = win.doc.createElement(\"div\");\r\n\t\t\t\thtml.attr(mapZoomCursor,\"id\",\"mapZoomCursor\");\r\n\t\t\t\tdomClass.add(mapZoomCursor,\"mapZoomIn\");\r\n\t\t\t\thtml.style(mapZoomCursor,\"display\",\"none\");\r\n\t\t\t\twin.body().appendChild(mapZoomCursor);\r\n\t\t\t}\r\n\t\t},\r\n\t\tonFeatureClick: function(feature){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInvoked when the specified feature is clicked.\r\n\t\t\t// feature: dojox.geo.charting.Feature\r\n\t\t\t//\t\tA Feature.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\t\tonFeatureOver: function(feature){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInvoked when the specified feature is hovered.\r\n\t\t\t// feature: dojox.geo.charting.Feature\r\n\t\t\t//\t\tA Feature.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t},\r\n\t\tonZoomEnd:function(feature){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInvoked when the specified feature has been zoomed.\r\n\t\t\t// feature: dojox.geo.charting.Feature\r\n\t\t\t//\t\tA Feature.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tcallback\r\n\t\t}\r\n\t});\r\n});"]}