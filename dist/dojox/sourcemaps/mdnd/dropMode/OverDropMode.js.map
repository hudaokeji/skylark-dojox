{"version":3,"sources":["mdnd/dropMode/OverDropMode.js"],"names":["define","dojo","declare","connect","array","geom","odm","_oldXPoint","_oldYPoint","_oldBehaviour","constructor","this","_dragHandler","dojox","mdnd","areaManager","coords","size","m","_oldIndexArea","_lastValidIndexArea","addArea","areas","object","length","position","node","x","y","push","i","j","updateAreas","areaList","_updateArea","area","x2","w","initItems","forEach","items","obj","item","h","refreshItems","indexItem","added","height","margin","t","getDragPoint","mousePosition","getTargetArea","currentIndexArea","index","end","start","direction","compute","arguments","_checkInterval","startX","endX","startY","endY","offsetHeight","getDropIndex","targetArea","destroy","disconnect","_dropMode","dropMode","OverDropMode"],"mappings":"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","file":"../../../mdnd/dropMode/OverDropMode.js","sourcesContent":["define([\"dojo/_base/kernel\",\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/connect\",\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/dom-geometry\",\r\n\t\"dojox/mdnd/AreaManager\"\r\n],function(dojo, declare, connect, array, geom){\r\n\tvar odm = declare(\r\n\t\t\"dojox.mdnd.dropMode.OverDropMode\",\r\n\t\tnull,\r\n\t{\r\n\t\t// summary:\r\n\t\t//\t\tDefault class to find the nearest target only if the mouse is over an area.\r\n\t\r\n\t\t// _oldXPoint: Integer\r\n\t\t//\t\tused to save a X position\r\n\t\t_oldXPoint: null,\r\n\t\r\n\t\t// _oldYPoint: Integer\r\n\t\t//\t\tused to save a Y position\r\n\t\t_oldYPoint: null,\r\n\t\r\n\t\t// _oldBehaviour: Integer\r\n\t\t//\t\tsee getDragpoint()\r\n\t\t_oldBehaviour: \"up\",\r\n\t\r\n\t\tconstructor: function(){\r\n\t\t\t//console.log(\"dojox.mdnd.dropMode.OverDropMode ::: constructor\");\r\n\t\t\tthis._dragHandler = [\r\n\t\t\t\tconnect.connect(dojox.mdnd.areaManager(), \"onDragEnter\", function(coords, size){\r\n\t\t\t\t\tvar m = dojox.mdnd.areaManager();\r\n\t\t\t\t\tif(m._oldIndexArea == -1){\r\n\t\t\t\t\t\tm._oldIndexArea = m._lastValidIndexArea;\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddArea: function(/*Array*/areas, /*Object*/object){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdd a D&D Area into an array sorting by the x position.\r\n\t\t\t// areas:\r\n\t\t\t//\t\tarray of areas\r\n\t\t\t// object:\r\n\t\t\t//\t\tdata type of a DndArea\r\n\t\t\t// returns:\r\n\t\t\t//\t\ta sorted area\r\n\t\r\n\t\t\t//console.log(\"dojox.mdnd.dropMode.OverDropMode ::: addArea\");\r\n\t\t\tvar length = areas.length,\r\n\t\t\t\tposition = geom.position(object.node, true);\r\n\t\t\tobject.coords = {'x':position.x, 'y':position.y};\r\n\t\t\tif(length == 0){\r\n\t\t\t\tareas.push(object);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tvar x = object.coords.x;\r\n\t\t\t\tfor(var i = 0; i < length; i++){\r\n\t\t\t\t\tif(x < areas[i].coords.x){\r\n\t\t\t\t\t\tfor(var j = length-1; j >= i; j--)\r\n\t\t\t\t\t\t\tareas[j + 1] = areas[j];\r\n\t\t\t\t\t\tareas[i] = object;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(i == length){\r\n\t\t\t\t\tareas.push(object);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn areas;\t// Array\r\n\t\t},\r\n\t\r\n\t\tupdateAreas: function(/*Array*/areaList){\r\n\t\t\t// summary:\r\n\t\t\t//\t\trefresh areas position and size to determinate the nearest area to drop an item\r\n\t\t\t// description:\r\n\t\t\t//\t\tthe area position (and size) is equal to the postion of the domNode associated.\r\n\t\t\t// areaList:\r\n\t\t\t//\t\tarray of areas\r\n\t\r\n\t\t\t//console.log(\"dojox.mdnd.dropMode.OverDropMode ::: updateAreas\");\r\n\t\t\tvar length = areaList.length;\r\n\t\t\tfor(var i = 0; i < length; i++){\r\n\t\t\t\tthis._updateArea(areaList[i]);\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\t_updateArea : function(/*Object*/area){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tupdate the D&D area object (i.e. update coordinates of its DOM node)\r\n\t\t\t// area:\r\n\t\t\t//\t\tthe D&D area.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\r\n\t\t\t//console.log(\"dojox.mdnd.dropMode.OverDropMode ::: addArea\");\r\n\t\t\tvar position = geom.position(area.node, true);\r\n\t\t\tarea.coords.x = position.x;\r\n\t\t\tarea.coords.x2 = position.x + position.w;\r\n\t\t\tarea.coords.y = position.y;\r\n\t\t},\r\n\t\r\n\t\tinitItems: function(/*Object*/area){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tinitialize the horizontal line in order to determinate the drop zone.\r\n\t\t\t// area:\r\n\t\t\t//\t\tthe D&D area.\r\n\t\r\n\t\t\t//console.log(\"dojox.mdnd.dropMode.OverDropMode ::: initItems\");\r\n\t\t\tarray.forEach(area.items, function(obj){\r\n\t\t\t\t//get the vertical middle of the item\r\n\t\t\t\tvar node = obj.item.node;\r\n\t\t\t\tvar position = geom.position(node, true);\r\n\t\t\t\tvar y = position.y + position.h/2;\r\n\t\t\t\tobj.y = y;\r\n\t\t\t});\r\n\t\t\tarea.initItems = true;\r\n\t\t},\r\n\t\r\n\t\trefreshItems: function(/*Object*/area, /*Integer*/indexItem, /*Object*/size, /*Boolean*/added){\r\n\t\t\t// summary:\r\n\t\t\t//\t\ttake into account the drop indicator DOM element in order to compute horizontal lines\r\n\t\t\t// area:\r\n\t\t\t//\t\ta D&D area object\r\n\t\t\t// indexItem:\r\n\t\t\t//\t\tindex of a draggable item\r\n\t\t\t// size:\r\n\t\t\t//\t\tdropIndicator size\r\n\t\t\t// added:\r\n\t\t\t//\t\tboolean to know if a dropIndicator has been added or deleted\r\n\t\r\n\t\t\t//console.log(\"dojox.mdnd.dropMode.OverDropMode ::: refreshItems\", area, indexItem, size, added);\r\n\t\t\tif(indexItem == -1){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse if(area && size && size.h){\r\n\t\t\t\tvar height = size.h;\r\n\t\t\t\tif(area.margin){\r\n\t\t\t\t\theight += area.margin.t;\r\n\t\t\t\t}\r\n\t\t\t\tvar length = area.items.length;\r\n\t\t\t\tfor(var i = indexItem; i < length; i++){\r\n\t\t\t\t\tvar item = area.items[i];\r\n\t\t\t\t\tif(added){\r\n\t\t\t\t\t\titem.y += height;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\titem.y -= height;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\tgetDragPoint: function(/*Object*/coords, /*Object*/size, /*Object*/mousePosition){\r\n\t\t\t// summary:\r\n\t\t\t//\t\treturn coordinates of the draggable item.\r\n\t\t\t//\r\n\t\t\t//\t\t- For X point : the x position of mouse\r\n\t\t\t//\t\t- For Y point : the y position of mouse\r\n\t\t\t// returns:\r\n\t\t\t//\t\tan object of coordinates\r\n\t\t\t//\t\texamples:{'x':10,'y':10}\r\n\t\t\t// coords:\r\n\t\t\t//\t\tan object encapsulating X and Y position\r\n\t\t\t// size:\r\n\t\t\t//\t\tan object encapsulating width and height values\r\n\t\t\t// mousePosition:\r\n\t\t\t//\t\tcoordinates of mouse\r\n\t\r\n\t\t\t//console.log(\"dojox.mdnd.OverDropMode ::: getDragPoint\");\r\n\t\t\treturn {\t\t\t// Object\r\n\t\t\t\t'x': mousePosition.x,\r\n\t\t\t\t'y': mousePosition.y\r\n\t\t\t\t}\r\n\t\t},\r\n\t\r\n\t\r\n\t\tgetTargetArea: function(/*Array*/areaList, /*Object*/ coords, /*integer*/currentIndexArea ){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tget the nearest D&D area.\r\n\t\t\t// areaList:\r\n\t\t\t//\t\ta list of D&D areas objects\r\n\t\t\t// coords:\r\n\t\t\t//\t\tcoordinates [x,y] of the dragItem (see getDragPoint())\r\n\t\t\t// currentIndexArea:\r\n\t\t\t//\t\tan index representing the active D&D area\r\n\t\t\t// returns:\r\n\t\t\t//\t\tthe index of the D&D area\r\n\t\r\n\t\t\t//console.log(\"dojox.mdnd.dropMode.OverDropMode ::: getTargetArea\");\r\n\t\t\tvar index = 0;\r\n\t\t\tvar x = coords.x;\r\n\t\t\tvar y = coords.y;\r\n\t\t\tvar end = areaList.length;\r\n\t\t\tvar start = 0, direction = \"right\", compute = false;\r\n\t\t\tif(currentIndexArea == -1 || arguments.length < 3){\r\n\t\t\t\t// first time : Need to search the nearest area in all areas.\r\n\t\t\t\tcompute = true;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t// check if it's always the same area\r\n\t\t\t\tif(this._checkInterval(areaList, currentIndexArea, x, y)){\r\n\t\t\t\t\tindex = currentIndexArea;\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(this._oldXPoint < x){\r\n\t\t\t\t\t\tstart = currentIndexArea + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tstart = currentIndexArea - 1;\r\n\t\t\t\t\t\tend = 0;\r\n\t\t\t\t\t\tdirection = \"left\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcompute = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(compute){\r\n\t\t\t\tif(direction === \"right\"){\r\n\t\t\t\t\tfor(var i = start; i < end; i++){\r\n\t\t\t\t\t\tif(this._checkInterval(areaList, i, x, y)){\r\n\t\t\t\t\t\t\tindex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(i == end){\r\n\t\t\t\t\t\tindex = -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfor(var i = start; i >= end; i--){\r\n\t\t\t\t\t\tif(this._checkInterval(areaList, i, x, y)){\r\n\t\t\t\t\t\t\tindex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(i == end-1){\r\n\t\t\t\t\t\tindex = -1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis._oldXPoint = x;\r\n\t\t\treturn index; // Integer\r\n\t\t},\r\n\t\r\n\t\t_checkInterval: function(/*Array*/areaList, /*Integer*/index, /*Coord*/x, /*Coord*/y){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tcheck if the dragNode is in the interval.\r\n\t\t\t// returns:\r\n\t\t\t//\t\ttrue if the dragNode is in intervall\r\n\t\t\t// areaList:\r\n\t\t\t//\t\ta list of D&D areas objects\r\n\t\t\t// index:\r\n\t\t\t//\t\tindex of a D&D area (to get the interval)\r\n\t\t\t// x:\r\n\t\t\t//\t\tcoordinate x, of the dragNode (see getDragPoint())\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\r\n\t\t\t//console.log(\"dojox.mdnd.dropMode.OverDropMode ::: _checkInterval\");\r\n\t\t\tvar area = areaList[index];\r\n\t\t\tvar node = area.node;\r\n\t\t\tvar coords = area.coords;\r\n\t\t\tvar startX = coords.x;\r\n\t\t\tvar endX = coords.x2;\r\n\t\t\tvar startY = coords.y;\r\n\t\t\tvar endY = startY + node.offsetHeight;\r\n\t\t\tif(startX <= x && x <= endX && startY <= y && y <= endY){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false; // Boolean\r\n\t\t},\r\n\t\r\n\t\tgetDropIndex: function(/*Object*/ targetArea, /*Object*/ coords){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturn the index where the drop has to be placed.\r\n\t\t\t// targetArea:\r\n\t\t\t//\t\ta D&D area object.\r\n\t\t\t// coords:\r\n\t\t\t//\t\tcoordinates [x,y] of the draggable item.\r\n\t\t\t// returns:\r\n\t\t\t//\t\ta number or -1 if the area has no children or the drop index represents the last position in to the area\r\n\t\r\n\t\t\t//console.log(\"dojox.mdnd.dropMode.OverDropMode ::: getDropIndex\");\r\n\t\t\tvar length = targetArea.items.length;\r\n\t\t\tvar coordinates = targetArea.coords;\r\n\t\t\tvar y = coords.y;\r\n\t\t\tif(length > 0){\r\n\t\t\t\t// course all children in the target area.\r\n\t\t\t\tfor(var i = 0; i < length; i++){\r\n\t\t\t\t\t// compare y value with y value of children\r\n\t\t\t\t\tif(y < targetArea.items[i].y){\r\n\t\t\t\t\t\treturn i;\t// integer\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\tif(i == length-1){\r\n\t\t\t\t\t\t\treturn -1; // integer\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn -1;\t//integer\r\n\t\t},\r\n\t\r\n\t\tdestroy: function(){\r\n\t\t\tarray.forEach(this._dragHandler, connect.disconnect);\r\n\t\t}\r\n\t});\r\n\t\r\n\tdojox.mdnd.areaManager()._dropMode = new dojox.mdnd.dropMode.OverDropMode();\r\n\treturn odm;\r\n});\r\n"]}