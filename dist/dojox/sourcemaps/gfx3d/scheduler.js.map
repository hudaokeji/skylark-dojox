{"version":3,"sources":["gfx3d/scheduler.js"],"names":["define","lang","arrayUtil","declare","gfx3d","vectorUtil","scheduler","zOrder","buffer","order","sort","a","b","bsp","outline","p","BinarySearchTree","forEach","slice","item","add","iterate","it","getZOrder","getOutline","BST","constructor","obj","this","plus","minus","object","o","orient","normal","normalize","v","n","every","Math","floor","dotProduct","substract","sorted","subs","x","y","z","concat","push","drawer","conservative","todos","objects","viewport","destroy","draw","lighting","chart"],"mappings":";;;;;;;AAAAA,QACC,kBACA,mBACA,qBACA,UACA,YACE,SAASC,EAAMC,EAAWC,EAASC,EAAOC,GAE7CD,EAAME,WACLC,OAAQ,SAASC,EAAQC,GAKxB,OAJAA,EAAQA,GAAgBL,EAAME,UAAUG,MACxCD,EAAOE,KAAK,SAASC,EAAGC,GACvB,OAAOH,EAAMG,GAAKH,EAAME,KAElBH,GAGRK,IAAK,SAASL,EAAQM,GAErBA,EAAUA,GAAoBV,EAAME,UAAUQ,QAC9C,IAAIC,EAAI,IAAIX,EAAME,UAAUU,iBAAiBR,EAAO,GAAIM,GAExD,OADAZ,EAAUe,QAAQT,EAAOU,MAAM,GAAI,SAASC,GAAOJ,EAAEK,IAAID,EAAML,KACxDC,EAAEM,QAAQP,IAIlBL,MAAO,SAASa,GACf,OAAOA,EAAGC,aAGXT,QAAS,SAASQ,GACjB,OAAOA,EAAGE,eAIZ,IAAIC,EAAMtB,EAAQ,yCAA0C,MAC3DuB,YAAa,SAASC,EAAKb,GAa1Bc,KAAKC,KAAO,KACZD,KAAKE,MAAQ,KACbF,KAAKG,OAASJ,EAEd,IAAIK,EAAIlB,EAAQa,GAChBC,KAAKK,OAASD,EAAE,GAChBJ,KAAKM,OAAS7B,EAAW8B,UAAUH,IAGpCZ,IAAK,SAASO,EAAKb,GAClB,IACCkB,EAAIlB,EAAQa,GACZS,EAAI/B,EACJgC,EAAIT,KAAKM,OACTvB,EAAIiB,KAAKK,OACTR,EAAMrB,EAAME,UAAUU,iBAEvB,GACCd,EAAUoC,MAAMN,EAAG,SAASb,GAC3B,OAAOoB,KAAKC,MATA,GASgBJ,EAAEK,WAAWJ,EAAGD,EAAEM,UAAUvB,EAAMR,MAAQ,IAGpEiB,KAAKE,MACPF,KAAKE,MAAMV,IAAIO,EAAKb,GAEpBc,KAAKE,MAAQ,IAAIL,EAAIE,EAAKb,OAEtB,CAAA,IACLZ,EAAUoC,MAAMN,EAAG,SAASb,GAC3B,OAAOoB,KAAKC,MAnBA,GAmBgBJ,EAAEK,WAAWJ,EAAGD,EAAEM,UAAUvB,EAAMR,MAAQ,IAcvE,KAAM,iEAXHiB,KAAKC,KACPD,KAAKC,KAAKT,IAAIO,EAAKb,GAEnBc,KAAKC,KAAO,IAAIJ,EAAIE,EAAKb,KAY5BO,QAAS,SAASP,GACjB,IACIsB,EAAI/B,EACJsC,KACAC,EAAO,KAkBX,OAdCA,EADEL,KAAKC,MANM,GAMWJ,EAAEK,WAAWb,KAAKM,OAAQE,EAAEM,WADzCG,EAAG,EAAGC,EAAG,EAAGC,GAAI,KACyCnB,KAAKK,WAAa,GAC9EL,KAAKC,KAAMD,KAAKE,QAEhBF,KAAKE,MAAOF,KAAKC,OAGlB,KACPc,EAASA,EAAOK,OAAOJ,EAAK,GAAGvB,YAGhCsB,EAAOM,KAAKrB,KAAKG,QAEda,EAAK,KACPD,EAASA,EAAOK,OAAOJ,EAAK,GAAGvB,YAEzBsB,KAkCT,OA7BAvC,EAAM8C,QACLC,aAAc,SAASC,EAAOC,EAASC,GAEtCpD,EAAUe,QAAQW,KAAKyB,QAAS,SAASlC,GACxCA,EAAKoC,YAENrD,EAAUe,QAAQoC,EAAS,SAASlC,GACnCA,EAAKqC,KAAKF,EAASG,aAGrBC,MAAO,SAASN,EAAOC,EAASC,GAK/BpD,EAAUe,QAAQW,KAAKwB,MAAO,SAASjC,GACtCA,EAAKqC,KAAKF,EAASG,eAQrBnD,UAAWF,EAAME,UACjB4C,OAAQ9C,EAAM8C,OACdlC,iBAAkBS","file":"../../gfx3d/scheduler.js","sourcesContent":["define([\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/_base/array\",\t// dojo.forEach, dojo.every\r\n\t\"dojo/_base/declare\",\t// declare\r\n\t\"./_base\",\r\n\t\"./vector\"\r\n], function(lang, arrayUtil, declare, gfx3d, vectorUtil){\r\n\r\ngfx3d.scheduler = {\r\n\tzOrder: function(buffer, order){\r\n\t\torder = order ? order : gfx3d.scheduler.order;\r\n\t\tbuffer.sort(function(a, b){\r\n\t\t\treturn order(b) - order(a);\r\n\t\t});\r\n\t\treturn buffer;\r\n\t},\r\n\r\n\tbsp: function(buffer, outline){\r\n\t\t// console.debug(\"BSP scheduler\");\r\n\t\toutline = outline ? outline : gfx3d.scheduler.outline;\r\n\t\tvar p = new gfx3d.scheduler.BinarySearchTree(buffer[0], outline);\r\n\t\tarrayUtil.forEach(buffer.slice(1), function(item){ p.add(item, outline); });\r\n\t\treturn p.iterate(outline);\r\n\t},\r\n\r\n\t// default implementation\r\n\torder: function(it){\r\n\t\treturn it.getZOrder();\r\n\t},\r\n\r\n\toutline: function(it){\r\n\t\treturn it.getOutline();\r\n\t}\r\n};\r\n\r\nvar BST = declare(\"dojox.gfx3d.scheduler.BinarySearchTree\", null, {\r\n\tconstructor: function(obj, outline){\r\n\t\t// summary:\r\n\t\t//\t\tbuild the binary search tree, using binary space partition algorithm.\r\n\t\t//\t\tThe idea is for any polygon, for example, (a, b, c), the space is divided by\r\n\t\t//\t\tthe plane into two space: plus and minus.\r\n\t\t//\t\t\r\n\t\t//\t\tfor any arbitrary vertex p, if(p - a) dotProduct n = 0, p is inside the plane,\r\n\t\t//\t\t> 0, p is in the plus space, vice versa for minus space.\r\n\t\t//\t\tn is the normal vector that is perpendicular the plate, defined as:\r\n\t\t// |\t\tn = ( b - a) crossProduct ( c - a )\r\n\t\t//\t\t\r\n\t\t//\t\tin this implementation, n is declared as normal, ,a is declared as orient.\r\n\t\t// obj: dojox.gfx3d.Object\r\n\t\tthis.plus = null;\r\n\t\tthis.minus = null;\r\n\t\tthis.object = obj;\r\n\r\n\t\tvar o = outline(obj);\r\n\t\tthis.orient = o[0];\r\n\t\tthis.normal = vectorUtil.normalize(o);\r\n\t},\r\n\r\n\tadd: function(obj, outline){\r\n\t\tvar epsilon = 0.5,\r\n\t\t\to = outline(obj),\r\n\t\t\tv = vectorUtil,\r\n\t\t\tn = this.normal,\r\n\t\t\ta = this.orient,\r\n\t\t\tBST = gfx3d.scheduler.BinarySearchTree;\r\n\r\n\t\tif(\r\n\t\t\tarrayUtil.every(o, function(item){\r\n\t\t\t\treturn Math.floor(epsilon + v.dotProduct(n, v.substract(item, a))) <= 0;\r\n\t\t\t})\r\n\t\t){\r\n\t\t\tif(this.minus){\r\n\t\t\t\tthis.minus.add(obj, outline);\r\n\t\t\t}else{\r\n\t\t\t\tthis.minus = new BST(obj, outline);\r\n\t\t\t}\r\n\t\t}else if(\r\n\t\t\tarrayUtil.every(o, function(item){\r\n\t\t\t\treturn Math.floor(epsilon + v.dotProduct(n, v.substract(item, a))) >= 0;\r\n\t\t\t})\r\n\t\t){\r\n\t\t\tif(this.plus){\r\n\t\t\t\tthis.plus.add(obj, outline);\r\n\t\t\t} else {\r\n\t\t\t\tthis.plus = new BST(obj, outline);\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t/*\r\n\t\t\tarrayUtil.forEach(o, function(item){\r\n\t\t\t\tconsole.debug(v.dotProduct(n, v.substract(item, a)));\r\n\t\t\t});\r\n\t\t\t*/\r\n\t\t\tthrow \"The case: polygon cross siblings' plate is not implemented yet\";\r\n\t\t}\r\n\t},\r\n\r\n\titerate: function(outline){\r\n\t\tvar epsilon = 0.5;\r\n\t\tvar v = vectorUtil;\r\n\t\tvar sorted = [];\r\n\t\tvar subs = null;\r\n\t\t// FIXME: using Infinity here?\r\n\t\tvar view = {x: 0, y: 0, z: -10000};\r\n\t\tif(Math.floor( epsilon + v.dotProduct(this.normal, v.substract(view, this.orient))) <= 0){\r\n\t\t\tsubs = [this.plus, this.minus];\r\n\t\t}else{\r\n\t\t\tsubs = [this.minus, this.plus];\r\n\t\t}\r\n\r\n\t\tif(subs[0]){\r\n\t\t\tsorted = sorted.concat(subs[0].iterate());\r\n\t\t}\r\n\r\n\t\tsorted.push(this.object);\r\n\r\n\t\tif(subs[1]){\r\n\t\t\tsorted = sorted.concat(subs[1].iterate());\r\n\t\t}\r\n\t\treturn sorted;\r\n\t}\r\n\r\n});\r\n\r\ngfx3d.drawer = {\r\n\tconservative: function(todos, objects, viewport){\r\n\t\t// console.debug('conservative draw');\r\n\t\tarrayUtil.forEach(this.objects, function(item){\r\n\t\t\titem.destroy();\r\n\t\t});\r\n\t\tarrayUtil.forEach(objects, function(item){\r\n\t\t\titem.draw(viewport.lighting);\r\n\t\t});\r\n\t},\r\n\tchart: function(todos, objects, viewport){\r\n\t\t// NOTE: ondemand may require the todos' objects to use setShape\r\n\t\t// to redraw themselves to maintain the z-order.\r\n\r\n\t\t// console.debug('chart draw');\r\n\t\tarrayUtil.forEach(this.todos, function(item){\r\n\t\t\titem.draw(viewport.lighting);\r\n\t\t});\r\n\t}\r\n\t// More aggressive optimization may re-order the DOM nodes using the order\r\n\t// of objects, and only elements of todos call setShape.\r\n};\r\n\r\nvar api = { \r\n\tscheduler: gfx3d.scheduler,\r\n\tdrawer: gfx3d.drawer,\r\n\tBinarySearchTree: BST\r\n};\r\n\r\nreturn api;\r\n});"]}