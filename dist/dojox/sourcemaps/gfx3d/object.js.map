{"version":3,"sources":["gfx3d/object.js"],"names":["define","arrayUtil","declare","lang","gfx","matrixUtil2d","gfx3d","schedulerExtensions","Gradient","VectorUtil","matrixUtil","lightUtil","scheduler","constructor","this","object","matrix","cache","renderer","parent","strokeStyle","fillStyle","shape","setObject","newObject","makeParameters","setTransform","clone","normalize","identity","applyRightTransform","applyLeftTransform","applyTransform","setFill","fill","setStroke","stroke","toStdFill","lighting","normal","type","finish","color","invalidate","addTodo","destroy","p","getParent","remove","render","camera","draw","getZOrder","getOutline","Object","objects","todos","schedule","zOrder","_draw","drawer","conservative","forEach","item","deep","m","multiply","every","push","length","defaultEdges","style","Array","points","z","map","multiplyPoint","c","setShape","createPath","setAbsoluteMode","moveTo","x","y","slice","lineTo","closePath","i","defaultOrbit","angles","Math","PI","center","marks","radius","cos","sin","A","xx","substract","xy","xz","yx","yy","yz","zx","zy","zz","dx","dy","dz","B","pow","X","invert","theta","atan2","probes","rotate","a","b","d","rx","sqrt","ry","cx","cy","createEllipse","rotateAt","defaultPath3d","segments","absolute","last","path","_collectArgs","array","args","t","_validSegments","l","_pushSegment","action","segment","group","toLowerCase","arguments","pt","defaultTriangles","pool","bsp","it","clear","createGroup","createPolyline","defaultQuads","concat","defaultPolygon","defaultCube","polygons","top","g","bottom","e","f","h","defaultCylinder","sum","height","gradient","isNaN","v","centers","dotProduct","incident","arcTo","translate","Group","dimension","lights","setCameraTransform","applyCameraRightTransform","applyCameraLeftTransform","applyCameraTransform","setLights","ambient","specular","sources","Model","addLights","setDimensions","dim","w","isString","width","parseInt","rawNode","trs","cameraRotateXg","cameraTranslate","Viewport","nodeType","_creators","createEdges","edges","create3DObject","Edges","createTriangles","tris","Triangles","createQuads","quads","Quads","createPolygon","Polygon","createOrbit","orbit","Orbit","createCube","cube","Cube","createCylinder","cylinder","Cylinder","createPath3d","Path3d","createScene","Scene","objectType","rawObject","obj","adopt","abandon","silently","splice","setScheduler","setDrawer","extend","Surface","createViewport","viewport","createObject","getDimensions"],"mappings":"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","file":"../../gfx3d/object.js","sourcesContent":["define([\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/lang\",\r\n\t\"dojox/gfx\",\r\n\t\"dojox/gfx/matrix\",\r\n\t\"./_base\",\r\n\t\"./scheduler\",\r\n\t\"./gradient\",\r\n\t\"./vector\",\r\n\t\"./matrix\",\r\n\t\"./lighting\"\r\n\t/*===== , \"dojox/gfx/shape\" =====*/\t\t// gfx.Surface\r\n], function(arrayUtil,declare,lang,gfx,matrixUtil2d,gfx3d,schedulerExtensions,Gradient,VectorUtil,matrixUtil,lightUtil){\r\n\r\nvar scheduler = schedulerExtensions.scheduler;\r\n\t\r\n// FIXME: why the \"out\" var here?\r\nvar out = function(o, x){\r\n\tif(arguments.length > 1){\r\n\t\t// console.debug(\"debug:\", o);\r\n\t\to = x;\r\n\t}\r\n\tvar e = {};\r\n\tfor(var i in o){\r\n\t\tif(i in e){ continue; }\r\n\t\t// console.debug(\"debug:\", i, typeof o[i], o[i]);\r\n\t}\r\n};\r\n\r\ndeclare(\"dojox.gfx3d.Object\", null, {\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta Object object, which knows how to map\r\n\t\t//\t\t3D objects to 2D shapes.\r\n\r\n\t\t// object: Object\r\n\t\t//\t\tan abstract Object object\r\n\t\t//\t\t(see dojox.gfx3d.defaultEdges,\r\n\t\t//\t\tdojox.gfx3d.defaultTriangles,\r\n\t\t//\t\tdojox.gfx3d.defaultQuads\r\n\t\t//\t\tdojox.gfx3d.defaultOrbit\r\n\t\t//\t\tdojox.gfx3d.defaultCube\r\n\t\t//\t\tor dojox.gfx3d.defaultCylinder)\r\n\t\tthis.object = null;\r\n\r\n\t\t// matrix: dojox.gfx3d.matrix\r\n\t\t//\t\tworld transform\r\n\t\tthis.matrix = null;\r\n\r\n\t\t// cache:\r\n\t\t//\t\tbuffer for intermediate result, used late for draw()\r\n\t\tthis.cache = null;\r\n\r\n\t\t// renderer:\r\n\t\t//\t\ta reference for the Viewport\r\n\t\tthis.renderer = null;\r\n\r\n\t\t// parent:\r\n\t\t//\t\ta reference for parent, Scene or Viewport object\r\n\t\tthis.parent = null;\r\n\r\n\t\t// strokeStyle: Object\r\n\t\t//\t\ta stroke object\r\n\t\tthis.strokeStyle = null;\r\n\r\n\t\t// fillStyle: Object\r\n\t\t//\t\ta fill object or texture object\r\n\t\tthis.fillStyle = null;\r\n\r\n\t\t// shape: dojox.gfx.Shape\r\n\t\t//\t\tan underlying 2D shape\r\n\t\tthis.shape = null;\r\n\t},\r\n\r\n\tsetObject: function(newObject){\r\n\t\t// summary:\r\n\t\t//\t\tsets a Object object\r\n\t\t// object: Object\r\n\t\t//\t\tan abstract Object object\r\n\t\t//\t\t(see dojox.gfx3d.defaultEdges,\r\n\t\t//\t\tdojox.gfx3d.defaultTriangles,\r\n\t\t//\t\tdojox.gfx3d.defaultQuads\r\n\t\t//\t\tdojox.gfx3d.defaultOrbit\r\n\t\t//\t\tdojox.gfx3d.defaultCube\r\n\t\t//\t\tor dojox.gfx3d.defaultCylinder)\r\n\t\tthis.object = gfx.makeParameters(this.object, newObject);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetTransform: function(matrix){\r\n\t\t// summary:\r\n\t\t//\t\tsets a transformation matrix\r\n\r\n\t\t// matrix: dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\ta matrix or a matrix-like object\r\n\t\t//\t\t(see an argument of dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\tthis.matrix = matrixUtil.clone(matrix ? matrixUtil.normalize(matrix) : gfx3d.identity, true);\r\n\r\n\t\treturn this;\t// self\r\n\t},\r\n\r\n\t// apply left & right transformation\r\n\t\r\n\tapplyRightTransform: function(matrix){\r\n\t\t// summary:\r\n\t\t//\t\tmultiplies the existing matrix with an argument on right side\r\n\t\t//\t\t(this.matrix * matrix)\r\n\t\t// matrix: dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\ta matrix or a matrix-like object\r\n\t\t//\t\t(see an argument of dojox.gfx.matrix.Matrix\r\n\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\treturn matrix ? this.setTransform([this.matrix, matrix]) : this;\t// self\r\n\t},\r\n\tapplyLeftTransform: function(matrix){\r\n\t\t// summary:\r\n\t\t//\t\tmultiplies the existing matrix with an argument on left side\r\n\t\t//\t\t(matrix * this.matrix)\r\n\t\t// matrix: dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\ta matrix or a matrix-like object\r\n\t\t//\t\t(see an argument of dojox.gfx.matrix.Matrix\r\n\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\treturn matrix ? this.setTransform([matrix, this.matrix]) : this;\t// self\r\n\t},\r\n\r\n\tapplyTransform: function(matrix){\r\n\t\t// summary:\r\n\t\t//\t\ta shortcut for dojox.gfx.Shape.applyRightTransform\r\n\t\t// matrix: dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\ta matrix or a matrix-like object\r\n\t\t//\t\t(see an argument of dojox.gfx.matrix.Matrix\r\n\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\treturn matrix ? this.setTransform([this.matrix, matrix]) : this;\t// self\r\n\t},\r\n\t\r\n\tsetFill: function(fill){\r\n\t\t// summary:\r\n\t\t//\t\tsets a fill object\r\n\t\t//\t\t(the default implementation is to delegate to\r\n\t\t//\t\tthe underlying 2D shape).\r\n\t\t// fill: Object\r\n\t\t//\t\ta fill object\r\n\t\t//\t\t(see dojox.gfx.defaultLinearGradient,\r\n\t\t//\t\tdojox.gfx.defaultRadialGradient,\r\n\t\t//\t\tdojox.gfx.defaultPattern,\r\n\t\t//\t\tdojo.Color\r\n\t\t//\t\tor dojox.gfx.MODEL)\r\n\t\tthis.fillStyle = fill;\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStroke: function(stroke){\r\n\t\t// summary:\r\n\t\t//\t\tsets a stroke object\r\n\t\t//\t\t(the default implementation simply ignores it)\r\n\t\t// stroke: Object\r\n\t\t//\t\ta stroke object\r\n\t\t//\t\t(see dojox.gfx.defaultStroke)\r\n\t\tthis.strokeStyle = stroke;\r\n\t\treturn this;\r\n\t},\r\n\r\n\ttoStdFill: function(lighting, normal){\r\n\t\treturn (this.fillStyle && typeof this.fillStyle['type'] != \"undefined\") ? \r\n\t\t\tlighting[this.fillStyle.type](normal, this.fillStyle.finish, this.fillStyle.color)\r\n\t\t\t: this.fillStyle;\r\n\t},\r\n\r\n\tinvalidate: function(){\r\n\t\tthis.renderer.addTodo(this);\r\n\t},\r\n\t\r\n\tdestroy: function(){\r\n\t\tif(this.shape){\r\n\t\t\tvar p = this.shape.getParent();\r\n\t\t\tif(p){\r\n\t\t\t\tp.remove(this.shape);\r\n\t\t\t}\r\n\t\t\tthis.shape = null;\r\n\t\t}\r\n\t},\r\n\r\n\t// All the 3D objects need to override the following virtual functions:\r\n\t// render, getZOrder, getOutline, draw, redraw if necessary.\r\n\r\n\trender: function(camera){\r\n\t\tthrow \"Pure virtual function, not implemented\";\r\n\t},\r\n\r\n\tdraw: function(lighting){\r\n\t\tthrow \"Pure virtual function, not implemented\";\r\n\t},\r\n\r\n\tgetZOrder: function(){\r\n\t\treturn 0;\r\n\t},\r\n\r\n\tgetOutline: function(){\r\n\t\treturn null;\r\n\t}\r\n\r\n});\r\n\r\ndeclare(\"dojox.gfx3d.Scene\", gfx3d.Object, {\r\n\t// summary:\r\n\t//\t\tthe Scene is just a container.\r\n\t\r\n\t// note: we have the following assumption:\r\n\t// all objects in the Scene are not overlapped with other objects\r\n\t// outside of the scene.\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta container of other 3D objects\r\n\t\tthis.objects= [];\r\n\t\tthis.todos = [];\r\n\t\tthis.schedule = scheduler.zOrder;\r\n\t\tthis._draw = gfx3d.drawer.conservative;\r\n\t},\r\n\r\n\tsetFill: function(fill){\r\n\t\tthis.fillStyle = fill;\r\n\t\tarrayUtil.forEach(this.objects, function(item){\r\n\t\t\titem.setFill(fill);\r\n\t\t});\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetStroke: function(stroke){\r\n\t\tthis.strokeStyle = stroke;\r\n\t\tarrayUtil.forEach(this.objects, function(item){\r\n\t\t\titem.setStroke(stroke);\r\n\t\t});\r\n\t\treturn this;\r\n\t},\r\n\r\n\trender: function(camera, deep){\r\n\t\tvar m = matrixUtil.multiply(camera, this.matrix);\r\n\t\tif(deep){\r\n\t\t\tthis.todos = this.objects;\r\n\t\t}\r\n\t\tarrayUtil.forEach(this.todos, function(item){ item.render(m, deep); });\r\n\t},\r\n\r\n\tdraw: function(lighting){\r\n\t\tthis.objects = this.schedule(this.objects);\r\n\t\tthis._draw(this.todos, this.objects, this.renderer);\r\n\t},\r\n\r\n\taddTodo: function(newObject){\r\n\t\t// FIXME: use indexOf?\r\n\t\tif(arrayUtil.every(this.todos, function(item){ return item != newObject; })){\r\n\t\t\tthis.todos.push(newObject);\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t},\r\n\r\n\tinvalidate: function(){\r\n\t\tthis.parent.addTodo(this);\r\n\t},\r\n\r\n\tgetZOrder: function(){\r\n\t\tvar zOrder = 0;\r\n\t\tarrayUtil.forEach(this.objects, function(item){ zOrder += item.getZOrder(); });\r\n\t\treturn (this.objects.length > 1) ?  zOrder / this.objects.length : 0;\r\n\t}\r\n});\r\n\r\n\r\ndeclare(\"dojox.gfx3d.Edges\", gfx3d.Object, {\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta generic edge in 3D viewport\r\n\t\tthis.object = lang.clone(gfx3d.defaultEdges);\r\n\t},\r\n\r\n\tsetObject: function(/*Points[]|Object*/ newObject, /*String?*/ style){\r\n\t\t// summary:\r\n\t\t//\t\tsetup the object\r\n\t\tthis.object = gfx.makeParameters(this.object, (newObject instanceof Array) ? { points: newObject, style: style } : newObject);\r\n\t\treturn this;\r\n\t},\r\n\r\n\tgetZOrder: function(){\r\n\t\tvar zOrder = 0;\r\n\t\tarrayUtil.forEach(this.cache, function(item){ zOrder += item.z;} );\r\n\t\treturn (this.cache.length > 1) ?  zOrder / this.cache.length : 0;\r\n\t},\r\n\r\n\trender: function(camera){\r\n\t\tvar m = matrixUtil.multiply(camera, this.matrix);\r\n\t\tthis.cache = arrayUtil.map(this.object.points, function(item){\r\n\t\t\treturn matrixUtil.multiplyPoint(m, item);\r\n\t\t});\r\n\t},\r\n\r\n\tdraw: function(){\r\n\t\tvar c = this.cache;\r\n\t\tif(this.shape){\r\n\t\t\tthis.shape.setShape(\"\")\r\n\t\t}else{\r\n\t\t\tthis.shape = this.renderer.createPath();\r\n\t\t}\r\n\t\tvar p = this.shape.setAbsoluteMode(\"absolute\");\r\n\r\n\t\tif(this.object.style == \"strip\" || this.object.style == \"loop\"){\r\n\t\t\tp.moveTo(c[0].x, c[0].y);\r\n\t\t\tarrayUtil.forEach(c.slice(1), function(item){\r\n\t\t\t\tp.lineTo(item.x, item.y);\r\n\t\t\t});\r\n\t\t\tif(this.object.style == \"loop\"){\r\n\t\t\t\tp.closePath();\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tfor(var i = 0; i < this.cache.length; ){\r\n\t\t\t\tp.moveTo(c[i].x, c[i].y);\r\n\t\t\t\ti ++;\r\n\t\t\t\tp.lineTo(c[i].x, c[i].y);\r\n\t\t\t\ti ++;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// FIXME: doe setFill make sense here?\r\n\t\tp.setStroke(this.strokeStyle);\r\n\t}\r\n});\r\n\r\ndeclare(\"dojox.gfx3d.Orbit\", gfx3d.Object, {\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta generic edge in 3D viewport\r\n\t\tthis.object = lang.clone(gfx3d.defaultOrbit);\r\n\t},\r\n\r\n\trender: function(camera){\r\n\t\tvar m = matrixUtil.multiply(camera, this.matrix);\r\n\t\tvar angles = [0, Math.PI/4, Math.PI/3];\r\n\t\tvar center = matrixUtil.multiplyPoint(m, this.object.center);\r\n\t\tvar marks = arrayUtil.map(angles, function(item){\r\n\t\t\treturn {x: this.center.x + this.radius * Math.cos(item),\r\n\t\t\t\ty: this.center.y + this.radius * Math.sin(item), z: this.center.z};\r\n\t\t\t}, this.object);\r\n\r\n\t\tmarks = arrayUtil.map(marks, function(item){\r\n\t\t\treturn matrixUtil.multiplyPoint(m, item);\r\n\t\t});\r\n\r\n\t\tvar normal = VectorUtil.normalize(marks);\r\n\r\n\t\tmarks = arrayUtil.map(marks, function(item){\r\n\t\t\treturn VectorUtil.substract(item, center);\r\n\t\t});\r\n\r\n\t\t// Use the algorithm here:\r\n\t\t// http://www.3dsoftware.com/Math/PlaneCurves/EllipseAlgebra/\r\n\t\t// After we normalize the marks, the equation is:\r\n\t\t// a x^2 + 2b xy + cy^2 + f = 0: let a = 1\r\n\t\t// so the final equation is:\r\n\t\t//\t\t[ xy, y^2, 1] * [2b, c, f]' = [ -x^2 ]'\r\n\r\n\t\tvar A = {\r\n\t\t\txx: marks[0].x * marks[0].y, xy: marks[0].y * marks[0].y, xz: 1,\r\n\t\t\tyx: marks[1].x * marks[1].y, yy: marks[1].y * marks[1].y, yz: 1,\r\n\t\t\tzx: marks[2].x * marks[2].y, zy: marks[2].y * marks[2].y, zz: 1,\r\n\t\t\tdx: 0, dy: 0, dz: 0\r\n\t\t};\r\n\t\tvar B = arrayUtil.map(marks, function(item){\r\n\t\t\treturn -Math.pow(item.x, 2);\r\n\t\t});\r\n\r\n\t\t// X is 2b, c, f\r\n\t\tvar X = matrixUtil.multiplyPoint(matrixUtil.invert(A),B[0], B[1], B[2]);\r\n\t\tvar theta = Math.atan2(X.x, 1 - X.y) / 2;\r\n\r\n\t\t// rotate the marks back to the canonical form\r\n\t\tvar probes = arrayUtil.map(marks, function(item){\r\n\t\t\treturn matrixUtil2d.multiplyPoint(matrixUtil2d.rotate(-theta), item.x, item.y);\r\n\t\t});\r\n\r\n\t\t// we are solving the equation: Ax = b\r\n\t\t// A = [x^2, y^2] X = [1/a^2, 1/b^2]', b = [1, 1]'\r\n\t\t// so rx = Math.sqrt(1/ ( inv(A)[1:] * b ) );\r\n\t\t// so ry = Math.sqrt(1/ ( inv(A)[2:] * b ) );\r\n\r\n\t\tvar a = Math.pow(probes[0].x, 2);\r\n\t\tvar b = Math.pow(probes[0].y, 2);\r\n\t\tvar c = Math.pow(probes[1].x, 2);\r\n\t\tvar d = Math.pow(probes[1].y, 2);\r\n\r\n\t\t// the invert matrix is\r\n\t\t// 1/(ad -bc) [ d, -b; -c, a];\r\n\t\tvar rx = Math.sqrt( (a*d - b*c)/ (d-b) );\r\n\t\tvar ry = Math.sqrt( (a*d - b*c)/ (a-c) );\r\n\r\n\t\tthis.cache = {cx: center.x, cy: center.y, rx: rx, ry: ry, theta: theta, normal: normal};\r\n\t},\r\n\r\n\tdraw: function(lighting){\r\n\t\tif(this.shape){\r\n\t\t\tthis.shape.setShape(this.cache);\r\n\t\t} else {\r\n\t\t\tthis.shape = this.renderer.createEllipse(this.cache);\r\n\t\t}\r\n\t\tthis.shape.applyTransform(matrixUtil2d.rotateAt(this.cache.theta, this.cache.cx, this.cache.cy))\r\n\t\t\t.setStroke(this.strokeStyle)\r\n\t\t\t.setFill(this.toStdFill(lighting, this.cache.normal));\r\n\t}\r\n});\r\n\r\ndeclare(\"dojox.gfx3d.Path3d\", gfx3d.Object, {\r\n\t// This object is still very immature !\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta generic line\r\n\r\n\t\t//\t(this is a helper object, which is defined for convenience)\r\n\t\tthis.object = lang.clone(gfx3d.defaultPath3d);\r\n\t\tthis.segments = [];\r\n\t\tthis.absolute = true;\r\n\t\tthis.last = {};\r\n\t\tthis.path = \"\";\r\n\t},\r\n\r\n\t_collectArgs: function(array, args){\r\n\t\t// summary:\r\n\t\t//\t\tconverts an array of arguments to plain numeric values\r\n\t\t// array: Array\r\n\t\t//\t\tan output argument (array of numbers)\r\n\t\t// args: Array\r\n\t\t//\t\tan input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)\r\n\t\tfor(var i = 0; i < args.length; ++i){\r\n\t\t\tvar t = args[i];\r\n\t\t\tif(typeof(t) == \"boolean\"){\r\n\t\t\t\tarray.push(t ? 1 : 0);\r\n\t\t\t}else if(typeof(t) == \"number\"){\r\n\t\t\t\tarray.push(t);\r\n\t\t\t}else if(t instanceof Array){\r\n\t\t\t\tthis._collectArgs(array, t);\r\n\t\t\t}else if(\"x\" in t && \"y\" in t){\r\n\t\t\t\tarray.push(t.x);\r\n\t\t\t\tarray.push(t.y);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// a dictionary, which maps segment type codes to a number of their argemnts\r\n\t_validSegments: {m: 3, l: 3,  z: 0},\r\n\r\n\t_pushSegment: function(action, args){\r\n\t\t// summary:\r\n\t\t//\t\tadds a segment\r\n\t\t// action: String\r\n\t\t//\t\tvalid SVG code for a segment's type\r\n\t\t// args: Array\r\n\t\t//\t\ta list of parameters for this segment\r\n\t\tvar group = this._validSegments[action.toLowerCase()], segment;\r\n\t\tif(typeof(group) == \"number\"){\r\n\t\t\tif(group){\r\n\t\t\t\tif(args.length >= group){\r\n\t\t\t\t\tsegment = {action: action, args: args.slice(0, args.length - args.length % group)};\r\n\t\t\t\t\tthis.segments.push(segment);\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\tsegment = {action: action, args: []};\r\n\t\t\t\tthis.segments.push(segment);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tmoveTo: function(){\r\n\t\t// summary:\r\n\t\t//\t\tforms a move segment\r\n\t\tvar args = [];\r\n\t\tthis._collectArgs(args, arguments);\r\n\t\tthis._pushSegment(this.absolute ? \"M\" : \"m\", args);\r\n\t\treturn this; // self\r\n\t},\r\n\tlineTo: function(){\r\n\t\t// summary:\r\n\t\t//\t\tforms a line segment\r\n\t\tvar args = [];\r\n\t\tthis._collectArgs(args, arguments);\r\n\t\tthis._pushSegment(this.absolute ? \"L\" : \"l\", args);\r\n\t\treturn this; // self\r\n\t},\r\n\r\n\tclosePath: function(){\r\n\t\t// summary:\r\n\t\t//\t\tcloses a path\r\n\t\tthis._pushSegment(\"Z\", []);\r\n\t\treturn this; // self\r\n\t},\r\n\r\n\trender: function(camera){\r\n\t\t// TODO: we need to get the ancestors' matrix\r\n\t\tvar m = matrixUtil.multiply(camera, this.matrix);\r\n\t\t// iterate all the segments and convert them to 2D canvas\r\n\t\t// TODO consider the relative mode\r\n\t\tvar path = \"\";\r\n\t\tvar _validSegments = this._validSegments;\r\n\t\tarrayUtil.forEach(this.segments, function(item){\r\n\t\t\tpath += item.action;\r\n\t\t\tfor(var i = 0; i < item.args.length; i+= _validSegments[item.action.toLowerCase()] ){\r\n\t\t\t\tvar pt = matrixUtil.multiplyPoint(m, item.args[i], item.args[i+1], item.args[i+2])\r\n\t\t\t\tpath += \" \" + pt.x + \" \" + pt.y;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.cache =  path;\r\n\t},\r\n\r\n\t_draw: function(){\r\n\t\treturn this.parent.createPath(this.cache);\r\n\t}\r\n});\r\n\r\ndeclare(\"dojox.gfx3d.Triangles\", gfx3d.Object, {\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta generic triangle\r\n\r\n\t\t//\t(this is a helper object, which is defined for convenience)\r\n\t\tthis.object = lang.clone(gfx3d.defaultTriangles);\r\n\t},\r\n\r\n\tsetObject: function(/*Points[]|Object*/ newObject, /*String?*/ style){\r\n\t\t// summary:\r\n\t\t//\t\tsetup the object\r\n\t\tif(newObject instanceof Array){\r\n\t\t\tthis.object = gfx.makeParameters(this.object, { points: newObject, style: style } );\r\n\t\t} else {\r\n\t\t\tthis.object = gfx.makeParameters(this.object, newObject);\r\n\t\t}\r\n\t\treturn this;\r\n\t},\r\n\trender: function(camera){\r\n\t\tvar m = matrixUtil.multiply(camera, this.matrix);\r\n\t\tvar c = arrayUtil.map(this.object.points, function(item){\r\n\t\t\treturn matrixUtil.multiplyPoint(m, item);\r\n\t\t});\r\n\t\tthis.cache = [];\r\n\t\tvar pool = c.slice(0, 2);\r\n\t\tvar center = c[0];\r\n\t\tif(this.object.style == \"strip\"){\r\n\t\t\tarrayUtil.forEach(c.slice(2), function(item){\r\n\t\t\t\tpool.push(item);\r\n\t\t\t\tpool.push(pool[0]);\r\n\t\t\t\tthis.cache.push(pool);\r\n\t\t\t\tpool = pool.slice(1, 3);\r\n\t\t\t}, this);\r\n\t\t} else if(this.object.style == \"fan\"){\r\n\t\t\tarrayUtil.forEach(c.slice(2), function(item){\r\n\t\t\t\tpool.push(item);\r\n\t\t\t\tpool.push(center);\r\n\t\t\t\tthis.cache.push(pool);\r\n\t\t\t\tpool = [center, item];\r\n\t\t\t}, this);\r\n\t\t} else {\r\n\t\t\tfor(var i = 0; i < c.length; ){\r\n\t\t\t\tthis.cache.push( [ c[i], c[i+1], c[i+2], c[i] ]);\r\n\t\t\t\ti += 3;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdraw: function(lighting){\r\n\t\t// use the BSP to schedule\r\n\t\tthis.cache = scheduler.bsp(this.cache, function(it){  return it; });\r\n\t\tif(this.shape){\r\n\t\t\tthis.shape.clear();\r\n\t\t} else {\r\n\t\t\tthis.shape = this.renderer.createGroup();\r\n\t\t}\r\n\t\tarrayUtil.forEach(this.cache, function(item){\r\n\t\t\tthis.shape.createPolyline(item)\r\n\t\t\t\t.setStroke(this.strokeStyle)\r\n\t\t\t\t.setFill(this.toStdFill(lighting, VectorUtil.normalize(item)));\r\n\t\t}, this);\r\n\t},\r\n\r\n\tgetZOrder: function(){\r\n\t\tvar zOrder = 0;\r\n\t\tarrayUtil.forEach(this.cache, function(item){\r\n\t\t\t\tzOrder += (item[0].z + item[1].z + item[2].z) / 3; });\r\n\t\treturn (this.cache.length > 1) ?  zOrder / this.cache.length : 0;\r\n\t}\r\n});\r\n\r\ndeclare(\"dojox.gfx3d.Quads\", gfx3d.Object, {\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta generic quad\r\n\r\n\t\t//\t(this is a helper object, which is defined for convenience)\r\n\t\tthis.object = lang.clone(gfx3d.defaultQuads);\r\n\t},\r\n\r\n\tsetObject: function(/*Points[]|Object*/ newObject, /*String?*/ style){\r\n\t\t// summary:\r\n\t\t//\t\tsetup the object\r\n\t\tthis.object = gfx.makeParameters(this.object, (newObject instanceof Array) ? \r\n\t\t\t{ points: newObject, style: style } \r\n\t\t\t\t: newObject );\r\n\t\treturn this;\r\n\t},\r\n\trender: function(camera){\r\n\t\tvar m = matrixUtil.multiply(camera, this.matrix), i;\r\n\t\tvar c = arrayUtil.map(this.object.points, function(item){\r\n\t\t\treturn matrixUtil.multiplyPoint(m, item);\r\n\t\t});\r\n\t\tthis.cache = [];\r\n\t\tif(this.object.style == \"strip\"){\r\n\t\t\tvar pool = c.slice(0, 2);\r\n\t\t\tfor(i = 2; i < c.length; ){\r\n\t\t\t\tpool = pool.concat( [ c[i], c[i+1], pool[0] ] );\r\n\t\t\t\tthis.cache.push(pool);\r\n\t\t\t\tpool = pool.slice(2,4);\r\n\t\t\t\ti += 2;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tfor(i = 0; i < c.length; ){\r\n\t\t\t\tthis.cache.push( [c[i], c[i+1], c[i+2], c[i+3], c[i] ] );\r\n\t\t\t\ti += 4;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tdraw: function(lighting){\r\n\t\t// use the BSP to schedule\r\n\t\tthis.cache = gfx3d.scheduler.bsp(this.cache, function(it){  return it; });\r\n\t\tif(this.shape){\r\n\t\t\tthis.shape.clear();\r\n\t\t}else{\r\n\t\t\tthis.shape = this.renderer.createGroup();\r\n\t\t}\r\n\t\t// using naive iteration to speed things up a bit by avoiding function call overhead\r\n\t\tfor(var x=0; x<this.cache.length; x++){\r\n\t\t\tthis.shape.createPolyline(this.cache[x])\r\n\t\t\t\t.setStroke(this.strokeStyle)\r\n\t\t\t\t.setFill(this.toStdFill(lighting, VectorUtil.normalize(this.cache[x])));\r\n\t\t}\r\n\t\t/*\r\n\t\tdojo.forEach(this.cache, function(item){\r\n\t\t\tthis.shape.createPolyline(item)\r\n\t\t\t\t.setStroke(this.strokeStyle)\r\n\t\t\t\t.setFill(this.toStdFill(lighting, dojox.gfx3d.vector.normalize(item)));\r\n\t\t}, this);\r\n\t\t*/\r\n\t},\r\n\r\n\tgetZOrder: function(){\r\n\t\tvar zOrder = 0;\r\n\t\t// using naive iteration to speed things up a bit by avoiding function call overhead\r\n\t\tfor(var x=0; x<this.cache.length; x++){\r\n\t\t\tvar i = this.cache[x];\r\n\t\t\tzOrder += (i[0].z + i[1].z + i[2].z + i[3].z) / 4;\r\n\t\t}\r\n\t\t/*\r\n\t\tdojo.forEach(this.cache, function(item){\r\n\t\t\t\tzOrder += (item[0].z + item[1].z + item[2].z + item[3].z) / 4; });\r\n\t\t*/\r\n\t\treturn (this.cache.length > 1) ?  zOrder / this.cache.length : 0;\r\n\t}\r\n});\r\n\r\ndeclare(\"dojox.gfx3d.Polygon\", gfx3d.Object, {\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta generic polygon\r\n\r\n\t\t//\t(this is a helper object, which is defined for convenience)\r\n\t\tthis.object = lang.clone(gfx3d.defaultPolygon);\r\n\t},\r\n\r\n\tsetObject: function(/*Points[]|Object*/ newObject){\r\n\t\t// summary:\r\n\t\t//\t\tsetup the object\r\n\t\tthis.object = gfx.makeParameters(this.object, (newObject instanceof Array) ? {path: newObject} : newObject)\r\n\t\treturn this;\r\n\t},\r\n\r\n\trender: function(camera){\r\n\t\tvar m = matrixUtil.multiply(camera, this.matrix);\r\n\t\tthis.cache = arrayUtil.map(this.object.path, function(item){\r\n\t\t\treturn matrixUtil.multiplyPoint(m, item);\r\n\t\t});\r\n\t\t// add the first point to close the polyline\r\n\t\tthis.cache.push(this.cache[0]);\r\n\t},\r\n\r\n\tdraw: function(lighting){\r\n\t\tif(this.shape){\r\n\t\t\tthis.shape.setShape({points: this.cache});\r\n\t\t}else{\r\n\t\t\tthis.shape = this.renderer.createPolyline({points: this.cache});\r\n\t\t}\r\n\r\n\t\tthis.shape.setStroke(this.strokeStyle)\r\n\t\t\t.setFill(this.toStdFill(lighting, matrixUtil.normalize(this.cache)));\r\n\t},\r\n\r\n\tgetZOrder: function(){\r\n\t\tvar zOrder = 0;\r\n\t\t// using naive iteration to speed things up a bit by avoiding function call overhead\r\n\t\tfor(var x=0; x<this.cache.length; x++){\r\n\t\t\tzOrder += this.cache[x].z;\r\n\t\t}\r\n\t\treturn (this.cache.length > 1) ?  zOrder / this.cache.length : 0;\r\n\t},\r\n\r\n\tgetOutline: function(){\r\n\t\treturn this.cache.slice(0, 3);\r\n\t}\r\n});\r\n\r\ndeclare(\"dojox.gfx3d.Cube\", gfx3d.Object, {\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta generic cube\r\n\r\n\t\t//\t(this is a helper object, which is defined for convenience)\r\n\t\tthis.object = lang.clone(gfx3d.defaultCube);\r\n\t\tthis.polygons = [];\r\n\t},\r\n\r\n\tsetObject: function(/*Points[]|Object*/ newObject){\r\n\t\t// summary:\r\n\t\t//\t\tsetup the object\r\n\t\tthis.object = gfx.makeParameters(this.object, newObject);\r\n\t},\r\n\r\n\trender: function(camera){\r\n\t\t// parse the top, bottom to get 6 polygons:\r\n\t\tvar a = this.object.top;\r\n\t\tvar g = this.object.bottom;\r\n\t\tvar b = {x: g.x, y: a.y, z: a.z};\r\n\t\tvar c = {x: g.x, y: g.y, z: a.z};\r\n\t\tvar d = {x: a.x, y: g.y, z: a.z};\r\n\t\tvar e = {x: a.x, y: a.y, z: g.z};\r\n\t\tvar f = {x: g.x, y: a.y, z: g.z};\r\n\t\tvar h = {x: a.x, y: g.y, z: g.z};\r\n\t\tvar polygons = [a, b, c, d, e, f, g, h];\r\n\t\tvar m = matrixUtil.multiply(camera, this.matrix);\r\n\t\tvar p = arrayUtil.map(polygons, function(item){\r\n\t\t\treturn matrixUtil.multiplyPoint(m, item);\r\n\t\t});\r\n\t\ta = p[0]; b = p[1]; c = p[2]; d = p[3]; e = p[4]; f = p[5]; g = p[6]; h = p[7];\r\n\t\tthis.cache = [[a, b, c, d, a], [e, f, g, h, e], [a, d, h, e, a], [d, c, g, h, d], [c, b, f, g, c], [b, a, e, f, b]];\r\n\t},\r\n\r\n\tdraw: function(lighting){\r\n\t\t// use bsp to sort.\r\n\t\tthis.cache = gfx3d.scheduler.bsp(this.cache, function(it){ return it; });\r\n\t\t// only the last 3 polys are visible.\r\n\t\tvar cache = this.cache.slice(3);\r\n\r\n\t\tif(this.shape){\r\n\t\t\tthis.shape.clear();\r\n\t\t}else{\r\n\t\t\tthis.shape = this.renderer.createGroup();\r\n\t\t}\r\n\t\tfor(var x=0; x<cache.length; x++){\r\n\t\t\tthis.shape.createPolyline(cache[x])\r\n\t\t\t\t.setStroke(this.strokeStyle)\r\n\t\t\t\t.setFill(this.toStdFill(lighting, VectorUtil.normalize(cache[x])));\r\n\t\t}\r\n\t\t/*\r\n\t\tdojo.forEach(cache, function(item){\r\n\t\t\tthis.shape.createPolyline(item)\r\n\t\t\t\t.setStroke(this.strokeStyle)\r\n\t\t\t\t.setFill(this.toStdFill(lighting, dojox.gfx3d.vector.normalize(item)));\r\n\t\t}, this);\r\n\t\t*/\r\n\t},\r\n\r\n\tgetZOrder: function(){\r\n\t\tvar top = this.cache[0][0];\r\n\t\tvar bottom = this.cache[1][2];\r\n\t\treturn (top.z + bottom.z) / 2;\r\n\t}\r\n});\r\n\r\n\r\ndeclare(\"dojox.gfx3d.Cylinder\", gfx3d.Object, {\r\n\tconstructor: function(){\r\n\t\tthis.object = lang.clone(gfx3d.defaultCylinder);\r\n\t},\r\n\r\n\trender: function(camera){\r\n\t\t// get the bottom surface first\r\n\t\tvar m = matrixUtil.multiply(camera, this.matrix);\r\n\t\tvar angles = [0, Math.PI/4, Math.PI/3];\r\n\t\tvar center = matrixUtil.multiplyPoint(m, this.object.center);\r\n\t\tvar marks = arrayUtil.map(angles, function(item){\r\n\t\t\treturn {x: this.center.x + this.radius * Math.cos(item),\r\n\t\t\t\ty: this.center.y + this.radius * Math.sin(item), z: this.center.z};\r\n\t\t\t}, this.object);\r\n\r\n\t\tmarks = arrayUtil.map(marks, function(item){\r\n\t\t\treturn VectorUtil.substract(matrixUtil.multiplyPoint(m, item), center);\r\n\t\t});\r\n\r\n\t\t// Use the algorithm here:\r\n\t\t// http://www.3dsoftware.com/Math/PlaneCurves/EllipseAlgebra/\r\n\t\t// After we normalize the marks, the equation is:\r\n\t\t// a x^2 + 2b xy + cy^2 + f = 0: let a = 1\r\n\t\t// so the final equation is:\r\n\t\t//\t\t[ xy, y^2, 1] * [2b, c, f]' = [ -x^2 ]'\r\n\r\n\t\tvar A = {\r\n\t\t\txx: marks[0].x * marks[0].y, xy: marks[0].y * marks[0].y, xz: 1,\r\n\t\t\tyx: marks[1].x * marks[1].y, yy: marks[1].y * marks[1].y, yz: 1,\r\n\t\t\tzx: marks[2].x * marks[2].y, zy: marks[2].y * marks[2].y, zz: 1,\r\n\t\t\tdx: 0, dy: 0, dz: 0\r\n\t\t};\r\n\t\tvar B = arrayUtil.map(marks, function(item){\r\n\t\t\treturn -Math.pow(item.x, 2);\r\n\t\t});\r\n\r\n\t\t// X is 2b, c, f\r\n\t\tvar X = matrixUtil.multiplyPoint(matrixUtil.invert(A), B[0], B[1], B[2]);\r\n\t\tvar theta = Math.atan2(X.x, 1 - X.y) / 2;\r\n\r\n\t\t// rotate the marks back to the canonical form\r\n\t\tvar probes = arrayUtil.map(marks, function(item){\r\n\t\t\treturn matrixUtil2d.multiplyPoint(matrixUtil2d.rotate(-theta), item.x, item.y);\r\n\t\t});\r\n\r\n\t\t// we are solving the equation: Ax = b\r\n\t\t// A = [x^2, y^2] X = [1/a^2, 1/b^2]', b = [1, 1]'\r\n\t\t// so rx = Math.sqrt(1/ ( inv(A)[1:] * b ) );\r\n\t\t// so ry = Math.sqrt(1/ ( inv(A)[2:] * b ) );\r\n\r\n\t\tvar a = Math.pow(probes[0].x, 2);\r\n\t\tvar b = Math.pow(probes[0].y, 2);\r\n\t\tvar c = Math.pow(probes[1].x, 2);\r\n\t\tvar d = Math.pow(probes[1].y, 2);\r\n\r\n\t\t// the invert matrix is\r\n\t\t// 1/(ad - bc) [ d, -b; -c, a];\r\n\t\tvar rx = Math.sqrt((a * d - b * c) / (d - b));\r\n\t\tvar ry = Math.sqrt((a * d - b * c) / (a - c));\r\n\t\tif(rx < ry){\r\n\t\t\tvar t = rx;\r\n\t\t\trx = ry;\r\n\t\t\try = t;\r\n\t\t\ttheta -= Math.PI/2;\r\n\t\t}\r\n\r\n\t\tvar top = matrixUtil.multiplyPoint(m,\r\n\t\t\tVectorUtil.sum(this.object.center, {x: 0, y:0, z: this.object.height}));\r\n\r\n\t\tvar gradient = this.fillStyle.type == \"constant\" ? this.fillStyle.color\r\n\t\t\t: Gradient(this.renderer.lighting, this.fillStyle, this.object.center, this.object.radius, Math.PI, 2 * Math.PI, m);\r\n\t\tif(isNaN(rx) || isNaN(ry) || isNaN(theta)){\r\n\t\t\t// in case the cap is invisible (parallel to the incident vector)\r\n\t\t\trx = this.object.radius, ry = 0, theta = 0;\r\n\t\t}\r\n\t\tthis.cache = {center: center, top: top, rx: rx, ry: ry, theta: theta, gradient: gradient};\r\n\t},\r\n\r\n\tdraw: function(){\r\n\t\tvar c = this.cache, v = VectorUtil, m = matrixUtil2d,\r\n\t\t\tcenters = [c.center, c.top], normal = v.substract(c.top, c.center);\r\n\t\tif(v.dotProduct(normal, this.renderer.lighting.incident) > 0){\r\n\t\t\tcenters = [c.top, c.center];\r\n\t\t\tnormal = v.substract(c.center, c.top);\r\n\t\t}\r\n\r\n\t\tvar color = this.renderer.lighting[this.fillStyle.type](normal, this.fillStyle.finish, this.fillStyle.color),\r\n\t\t\td = Math.sqrt( Math.pow(c.center.x - c.top.x, 2) + Math.pow(c.center.y - c.top.y, 2) );\r\n\r\n\t\tif(this.shape){\r\n\t\t\tthis.shape.clear();\r\n\t\t}else{\r\n\t\t\tthis.shape = this.renderer.createGroup();\r\n\t\t}\r\n\t\t\r\n\t\tthis.shape.createPath(\"\")\r\n\t\t\t.moveTo(0, -c.rx)\r\n\t\t\t.lineTo(d, -c.rx)\r\n\t\t\t.lineTo(d, c.rx)\r\n\t\t\t.lineTo(0, c.rx)\r\n\t\t\t.arcTo(c.ry, c.rx, 0, true, true, 0, -c.rx)\r\n\t\t\t.setFill(c.gradient).setStroke(this.strokeStyle)\r\n\t\t\t.setTransform([m.translate(centers[0]),\r\n\t\t\t\tm.rotate(Math.atan2(centers[1].y - centers[0].y, centers[1].x - centers[0].x))]);\r\n\r\n\t\tif(c.rx > 0 && c.ry > 0){\r\n\t\t\tthis.shape.createEllipse({cx: centers[1].x, cy: centers[1].y, rx: c.rx, ry: c.ry})\r\n\t\t\t\t.setFill(color).setStroke(this.strokeStyle)\r\n\t\t\t\t.applyTransform(m.rotateAt(c.theta, centers[1]));\r\n\t\t}\r\n\t}\r\n});\r\n\r\n\r\n// the ultimate container of 3D world\r\ndeclare(\"dojox.gfx3d.Viewport\", gfx.Group, {\r\n\tconstructor: function(){\r\n\t\t// summary:\r\n\t\t//\t\ta viewport/container for 3D objects, which knows\r\n\t\t//\t\tthe camera and lightings\r\n\r\n\t\t// matrix: dojox.gfx3d.matrix\r\n\t\t//\t\tworld transform\r\n\r\n\t\t// dimension: Object\r\n\t\t//\t\tthe dimension of the canvas\r\n\t\tthis.dimension = null;\r\n\r\n\t\t// objects: Array\r\n\t\t//\t\tall 3d Objects\r\n\t\tthis.objects = [];\r\n\t\t// todos: Array\r\n\t\t//\t\tall 3d Objects that needs to redraw\r\n\t\tthis.todos = [];\r\n\r\n\t\t// FIXME: memory leak?\r\n\t\tthis.renderer = this;\r\n\t\t// Using zOrder as the default scheduler\r\n\t\tthis.schedule = gfx3d.scheduler.zOrder;\r\n\t\tthis.draw = gfx3d.drawer.conservative;\r\n\t\t// deep: boolean, true means the whole viewport needs to re-render, redraw\r\n\t\tthis.deep = false;\r\n\r\n\t\t// lights: Array\r\n\t\t//\t\tan array of light objects\r\n\t\tthis.lights = [];\r\n\t\tthis.lighting = null;\r\n\t},\r\n\r\n\tsetCameraTransform: function(matrix){\r\n\t\t// summary:\r\n\t\t//\t\tsets a transformation matrix\r\n\t\t// matrix: dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\ta matrix or a matrix-like object\r\n\t\t//\t\t(see an argument of dojox.gfx.matrix.Matrix\r\n\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\tthis.camera = matrixUtil.clone(matrix ? matrixUtil.normalize(matrix) : gfx3d.identity, true);\r\n\t\tthis.invalidate();\r\n\t\treturn this;\t// self\r\n\t},\r\n\r\n\tapplyCameraRightTransform: function(matrix){\r\n\t\t// summary:\r\n\t\t//\t\tmultiplies the existing matrix with an argument on right side\r\n\t\t//\t\t(this.matrix * matrix)\r\n\t\t// matrix: dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\ta matrix or a matrix-like object\r\n\t\t//\t\t(see an argument of dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\treturn matrix ? this.setCameraTransform([this.camera, matrix]) : this;\t// self\r\n\t},\r\n\r\n\tapplyCameraLeftTransform: function(matrix){\r\n\t\t// summary:\r\n\t\t//\t\tmultiplies the existing matrix with an argument on left side\r\n\t\t//\t\t(matrix * this.matrix)\r\n\t\t// matrix: dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\ta matrix or a matrix-like object\r\n\t\t//\t\t(see an argument of dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\treturn matrix ? this.setCameraTransform([matrix, this.camera]) : this;\t// self\r\n\t},\r\n\r\n\tapplyCameraTransform: function(matrix){\r\n\t\t// summary:\r\n\t\t//\t\ta shortcut for dojox.gfx3d.Object.applyRightTransform\r\n\t\t// matrix: dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\ta matrix or a matrix-like object\r\n\t\t//\t\t(see an argument of dojox.gfx3d.matrix.Matrix\r\n\t\t//\t\tconstructor for a list of acceptable arguments)\r\n\t\treturn this.applyCameraRightTransform(matrix); // self\r\n\t},\r\n\r\n\tsetLights: function(/* Array|Object */lights, /* Color? */ ambient,\r\n\t\t/* Color? */ specular){\r\n\t\t// summary:\r\n\t\t//\t\tset the lights\r\n\t\t// lights: Array\r\n\t\t//\t\tan array of light object\r\n\t\t//\t\tor lights object\r\n\t\t// ambient: Color\r\n\t\t//\t\tan ambient object\r\n\t\t// specular: Color\r\n\t\t//\t\tan specular object\r\n\t\tthis.lights = (lights instanceof Array) ? \r\n\t\t\t{sources: lights, ambient: ambient, specular: specular}\r\n\t\t\t\t: lights;\r\n\t\tvar view = {x: 0, y: 0, z: 1};\r\n\r\n\t\tthis.lighting = new lightUtil.Model(view, this.lights.sources,\r\n\t\t\t\tthis.lights.ambient, this.lights.specular);\r\n\t\tthis.invalidate();\r\n\t\treturn this;\r\n\t},\r\n\r\n\taddLights: function(lights){\r\n\t\t// summary:\r\n\t\t//\t\tadd new light/lights to the viewport.\r\n\t\t// lights: Array|Object\r\n\t\t//\t\tlight object(s)\r\n\t\treturn this.setLights(this.lights.sources.concat(lights));\r\n\t},\r\n\r\n\taddTodo: function(newObject){\r\n\t\t// NOTE: Viewport implements almost the same addTodo,\r\n\t\t// except calling invalidate, since invalidate is used as\r\n\t\t// any modification needs to redraw the object itself, call invalidate.\r\n\t\t// then call render.\r\n\t\tif(arrayUtil.every(this.todos,\r\n\t\t\tfunction(item){\r\n\t\t\t\treturn item != newObject;\r\n\t\t\t}\r\n\t\t)){\r\n\t\t\tthis.todos.push(newObject);\r\n\t\t}\r\n\t},\r\n\r\n\tinvalidate: function(){\r\n\t\tthis.deep = true;\r\n\t\tthis.todos = this.objects;\r\n\t},\r\n\r\n\tsetDimensions: function(dim){\r\n\t\tif(dim){\r\n\t\t\tvar w = lang.isString(dim.width) ? parseInt(dim.width)  : dim.width;\r\n\t\t\tvar h = lang.isString(dim.height) ? parseInt(dim.height) : dim.height;\r\n\t\t\t// there is no rawNode in canvas GFX implementation\r\n\t\t\tif(this.rawNode){\r\n\t\t\t\tvar trs = this.rawNode.style;\r\n\t\t\t\tif(trs){\r\n\t\t\t\t\ttrs.height = h;\r\n\t\t\t\t\ttrs.width = w;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// silverlight\r\n\t\t\t\t\tthis.rawNode.width = w;\r\n\t\t\t\t\tthis.rawNode.height = h;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.dimension = {\r\n\t\t\t\twidth:  w,\r\n\t\t\t\theight: h\r\n\t\t\t};\r\n\t\t}else{\r\n\t\t\tthis.dimension = null;\r\n\t\t}\r\n\t},\r\n\r\n\trender: function(){\r\n\t\t// summary:\r\n\t\t//\t\titerate all children and call their render callback function.\r\n\t\tif(!this.todos.length){ return; }\r\n\t\t// console.debug(\"Viewport::render\");\r\n\t\tvar m = matrixUtil;\r\n\t\t\r\n\t\t// Iterate the todos and call render to prepare the rendering:\r\n\t\tfor(var x=0; x<this.todos.length; x++){\r\n\t\t\tthis.todos[x].render(matrixUtil.normalize([\r\n\t\t\t\tm.cameraRotateXg(180),\r\n\t\t\t\tm.cameraTranslate(0, this.dimension.height, 0),\r\n\t\t\t\tthis.camera\r\n\t\t\t]), this.deep);\r\n\t\t}\r\n\r\n\t\tthis.objects = this.schedule(this.objects);\r\n\t\tthis.draw(this.todos, this.objects, this);\r\n\t\tthis.todos = [];\r\n\t\tthis.deep = false;\r\n\t}\r\n\r\n});\r\n\r\n//FIXME: Viewport cannot masquerade as a Group\r\ngfx3d.Viewport.nodeType = gfx.Group.nodeType;\r\n\r\ngfx3d._creators = {\r\n\t// summary:\r\n\t//\t\tobject creators\r\n\tcreateEdges: function(edges, style){\r\n\t\t// summary:\r\n\t\t//\t\tcreates an edge object\r\n\t\treturn this.create3DObject(gfx3d.Edges, edges, style);\t// dojox.gfx3d.Edge\r\n\t},\r\n\tcreateTriangles: function(tris, style){\r\n\t\t// summary:\r\n\t\t//\t\tcreates an triangle object\r\n\t\treturn this.create3DObject(gfx3d.Triangles, tris, style);\t// dojox.gfx3d.Edge\r\n\t},\r\n\tcreateQuads: function(quads, style){\r\n\t\t// summary:\r\n\t\t//\t\tcreates an quads object\r\n\t\treturn this.create3DObject(gfx3d.Quads, quads, style);\t// dojox.gfx3d.Edge\r\n\t},\r\n\tcreatePolygon: function(/*Points[]|Object*/ points){\r\n\t\t// summary:\r\n\t\t//\t\tcreates an polygon object\r\n\t\treturn this.create3DObject(gfx3d.Polygon, points);\t// dojox.gfx3d.Polygon\r\n\t},\r\n\r\n\tcreateOrbit: function(orbit){\r\n\t\t// summary:\r\n\t\t//\t\tcreates an Orbit object\r\n\t\treturn this.create3DObject(gfx3d.Orbit, orbit);\t// dojox.gfx3d.Cube\r\n\t},\r\n\r\n\tcreateCube: function(cube){\r\n\t\t// summary:\r\n\t\t//\t\tcreates an cube object\r\n\t\treturn this.create3DObject(gfx3d.Cube, cube);\t// dojox.gfx3d.Cube\r\n\t},\r\n\r\n\tcreateCylinder: function(cylinder){\r\n\t\t// summary:\r\n\t\t//\t\tcreates an cylinder object\r\n\t\treturn this.create3DObject(gfx3d.Cylinder, cylinder);\t// dojox.gfx3d.Cube\r\n\t},\r\n\r\n\tcreatePath3d: function(path){\r\n\t\t// summary:\r\n\t\t//\t\tcreates an 3d path object\r\n\t\treturn this.create3DObject(gfx3d.Path3d, path);\t// dojox.gfx3d.Edge\r\n\t},\r\n\tcreateScene: function(){\r\n\t\t// summary:\r\n\t\t//\t\tcreates a scene object\r\n\t\treturn this.create3DObject(gfx3d.Scene);\t// dojox.gfx3d.Scene\r\n\t},\r\n\r\n\tcreate3DObject: function(objectType, rawObject, style){\r\n\t\t// summary:\r\n\t\t//\t\tcreates an instance of the passed objectType class\r\n\t\t// objectType: Function\r\n\t\t//\t\ta class constructor to create an instance of\r\n\t\t// rawObject: Object\r\n\t\t//\t\tproperties to be passed in to the classes \"setShape\" method\r\n\t\tvar obj = new objectType();\r\n\t\tthis.adopt(obj);\r\n\t\tif(rawObject){ obj.setObject(rawObject, style); }\r\n\t\treturn obj;\t// dojox.gfx3d.Object\r\n\t},\r\n\t// todo : override the add/remove if necessary\r\n\tadopt: function(obj){\r\n\t\t// summary:\r\n\t\t//\t\tadds a shape to the list\r\n\t\tobj.renderer = this.renderer; // obj._setParent(this, null); more TODOs HERER?\r\n\t\tobj.parent = this;\r\n\t\tthis.objects.push(obj);\r\n\t\tthis.addTodo(obj);\r\n\t\treturn this;\r\n\t},\r\n\tabandon: function(obj, silently){\r\n\t\t// summary:\r\n\t\t//\t\tremoves a shape from the list\r\n\t\t// silently: Boolean?\r\n\t\t//\t\tif true, do not redraw a picture yet\r\n\t\tfor(var i = 0; i < this.objects.length; ++i){\r\n\t\t\tif(this.objects[i] == obj){\r\n\t\t\t\tthis.objects.splice(i, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// if(this.rawNode == shape.rawNode.parentNode){\r\n\t\t//\tthis.rawNode.removeChild(shape.rawNode);\r\n\t\t// }\r\n\t\t// obj._setParent(null, null);\r\n\t\tobj.parent = null;\r\n\t\treturn this;\t// self\r\n\t},\r\n\r\n\r\n\tsetScheduler: function(scheduler){\r\n\t\tthis.schedule = scheduler;\r\n\t},\r\n\r\n\tsetDrawer: function(drawer){\r\n\t\tthis.draw = drawer;\r\n\t}\r\n};\r\n\r\nlang.extend(gfx3d.Viewport, gfx3d._creators);\r\nlang.extend(gfx3d.Scene, gfx3d._creators);\r\ndelete gfx3d._creators;\r\n\r\n\r\n//FIXME: extending dojox.gfx.Surface and masquerading Viewport as Group is hacky!\r\n\r\n// Add createViewport to dojox.gfx.Surface\r\nlang.extend(gfx.Surface, {\r\n\tcreateViewport: function(){\r\n\t\t//FIXME: createObject is non-public method!\r\n\t\tvar viewport = this.createObject(gfx3d.Viewport, null, true);\r\n\t\t//FIXME: this may not work with dojox.gfx.Group !!\r\n\t\tviewport.setDimensions(this.getDimensions());\r\n\t\treturn viewport;\r\n\t}\r\n});\r\n\r\n\treturn gfx3d.Object;\r\n});\r\n"]}