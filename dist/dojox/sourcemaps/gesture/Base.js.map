{"version":3,"sources":["gesture/Base.js"],"names":["define","kernel","declare","array","lang","dom","on","touch","has","dojox","experimental","getObject","defaultEvent","subEvents","touchOnly","_elements","constructor","args","mixin","this","init","evt","call","_handle","_events","forEach","subEvt","push","console","warn","eventType","self","node","listener","a","arguments","length","nodeType","attachEvent","addEventListener","onHandle","_add","remove","_remove","type","element","_getGestureElement","target","data","handles","_press","hitch","_move","_release","_cancel","press","move","release","cancel","i","_process","phase","e","_locking","isLocked","currentTarget","tagName","preventDefault","fire","event","bubbles","cancelable","emit","some","_cleanHandles","indexOf","splice","x","lock","_lock","unLock","isDescendant","destroy"],"mappings":"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","file":"../../gesture/Base.js","sourcesContent":["define([\r\n\t\"dojo/_base/kernel\",\r\n\t\"dojo/_base/declare\",\r\n\t\"dojo/_base/array\",\r\n\t\"dojo/_base/lang\",\r\n\t\"dojo/dom\",\r\n\t\"dojo/on\",\r\n\t\"dojo/touch\",\r\n\t\"dojo/has\",\r\n\t\"../main\"\r\n], function(kernel, declare, array, lang, dom, on, touch, has, dojox){\r\n\t// module:\r\n\t//\t\tdojox/gesture/Base\r\n\t// summary:\r\n\t//\t\tThis module provides an abstract parental class for various gesture implementations.\r\n\t\r\n/*=====\r\n\tdojox.gesture.Base = {\r\n\t\t// summary:\r\n\t\t//\t\tAn abstract parental class for various gesture implementations.\r\n\t\t//\r\n\t\t//\t\tIt's mainly responsible for:\r\n\t\t//\r\n\t\t//\t\t1. Binding on() listening handlers for supported gesture events.\r\n\t\t//\r\n\t\t//\t\t2. Monitoring underneath events and process different phases - 'press'|'move'|'release'|'cancel'.\r\n\t\t//\r\n\t\t//\t\t3. Firing and bubbling gesture events with on() API.\r\n\t\t//\r\n\t\t//\t\tA gesture implementation only needs to extend this class and overwrite appropriate phase handlers:\r\n\t\t//\r\n\t\t//\t\t- press()|move()|release()|cancel for recognizing and firing gestures\r\n\t\t//\r\n\t\t// example:\r\n\t\t//\t\t1. A typical gesture implementation.\r\n\t\t//\r\n\t\t//\t\tSuppose we have dojox/gesture/a which provides 3 gesture events:\"a\", \"a.x\", \"a.y\" to be used as:\r\n\t\t//\t\t|\tdojo.connect(node, dojox.gesture.a, function(e){});\r\n\t\t//\t\t|\tdojo.connect(node, dojox.gesture.a.x, function(e){});\r\n\t\t//\t\t|\tdojo.connect(node, dojox.gesture.a.y, function(e){});\r\n\t\t//\r\n\t\t//\t\tThe definition of the gesture \"a\" may look like:\r\n\t\t//\t\t|\tdefine([..., \"./Base\"], function(..., Base){\r\n\t\t//\t\t|\t\tvar clz = declare(Base, {\r\n\t\t//\t\t|\t\t\tdefaultEvent: \"a\",\r\n\t\t//\t\t|\r\n\t\t//\t\t|\t\t\tsubEvents: [\"x\", \"y\"],\r\n\t\t//\t\t|\t\t\t\r\n\t\t//\t\t|\t\t\tpress: function(data, e){\r\n\t\t//\t\t|\t\t\t\tthis.fire(node, {type: \"a.x\", ...});\r\n\t\t//\t\t|\t\t\t},\r\n\t\t//\t\t|\t\t\tmove: function(data, e){\r\n\t\t//\t\t|\t\t\t\tthis.fire(node, {type: \"a.y\", ...});\r\n\t\t//\t\t|\t\t\t},\r\n\t\t//\t\t|\t\t\trelease: function(data, e){\r\n\t\t//\t\t|\t\t\t\tthis.fire(node, {type: \"a\", ...});\r\n\t\t//\t\t|\t\t\t},\r\n\t\t//\t\t|\t\t\tcancel: function(data, e){\r\n\t\t//\t\t|\t\t\t\t// clean up\r\n\t\t//\t\t|\t\t\t}\r\n\t\t//\t\t|\t\t});\r\n\t\t//\t\t|\r\n\t\t//\t\t|\t\t// in order to have a default instance for handy use\r\n\t\t//\t\t|\t\tdojox.gesture.a = new clz();\r\n\t\t//\t\t|\r\n\t\t//\t\t|\t\t// so that we can create new instances like\r\n\t\t//\t\t|\t\t// var mine = new dojox.gesture.a.A({...})\r\n\t\t//\t\t|\t\tdojox.gesture.a.A = clz;\r\n\t\t//\t\t|\r\n\t\t//\t\t|\t\treturn dojox.gesture.a;\r\n\t\t//\t\t|\t});\r\n\t\t//\r\n\t\t//\t\t2. A gesture can be used in the following ways(taking dojox.gesture.tap for example):\r\n\t\t//\r\n\t\t//\t\tA. Used with dojo.connect()\r\n\t\t//\t\t|\tdojo.connect(node, dojox.gesture.tap, function(e){});\r\n\t\t//\t\t|\tdojo.connect(node, dojox.gesture.tap.hold, function(e){});\r\n\t\t//\t\t|\tdojo.connect(node, dojox.gesture.tap.doubletap, function(e){});\t\t\r\n\t\t//\r\n\t\t//\t\tB. Used with dojo.on\r\n\t\t//\t\t|\tdefine([\"dojo/on\", \"dojox/gesture/tap\"], function(on, tap){\r\n\t\t//\t\t|\t\ton(node, tap, function(e){});\r\n\t\t//\t\t|\t\ton(node, tap.hold, function(e){});\r\n\t\t//\t\t|\t\ton(node, tap.doubletap, function(e){});\r\n\t\t//\r\n\t\t//\t\tC. Used with dojox.gesture.tap directly\r\n\t\t//\t\t|\tdojox.gesture.tap(node, function(e){});\r\n\t\t//\t\t|\tdojox.gesture.tap.hold(node, function(e){});\r\n\t\t//\t\t|\tdojox.gesture.tap.doubletap(node, function(e){});\r\n\t\t//\r\n\t\t//\t\tThough there is always a default gesture instance after being required, e.g \r\n\t\t//\t\t|\trequire([\"dojox/gesture/tap\"], function(){...});\r\n\t\t//\r\n\t\t//\t\tIt's possible to create a new one with different parameter setting:\r\n\t\t//\t\t|\tvar myTap = new dojox.gesture.tap.Tap({holdThreshold: 300});\r\n\t\t//\t\t|\tdojo.connect(node, myTap, function(e){});\r\n\t\t//\t\t|\tdojo.connect(node, myTap.hold, function(e){});\r\n\t\t//\t\t|\tdojo.connect(node, myTap.doubletap, function(e){});\r\n\t\t//\t\t\r\n\t\t//\t\tPlease refer to dojox/gesture/ for more gesture usages\r\n\t};\r\n=====*/\r\n\tkernel.experimental(\"dojox.gesture.Base\");\r\n\t\r\n\tlang.getObject(\"gesture\", true, dojox);\r\n\r\n\t// Declare an internal anonymous class which will only be exported by module return value\r\n\treturn declare(/*===== \"dojox.gesture.Base\", =====*/null, {\r\n\r\n\t\t// defaultEvent: [readonly] String\r\n\t\t//\t\tDefault event e.g. 'tap' is a default event of dojox.gesture.tap\r\n\t\tdefaultEvent: \" \",\r\n\r\n\t\t// subEvents: [readonly] Array\r\n\t\t//\t\tA list of sub events e.g ['hold', 'doubletap'],\r\n\t\t//\t\tused by being combined with defaultEvent like 'tap.hold', 'tap.doubletap' etc.\r\n\t\tsubEvents: [],\r\n\r\n\t\t// touchOnly: boolean\r\n\t\t//\t\tWhether the gesture is touch-device only\r\n\t\ttouchOnly : false,\r\n\r\n\t\t// _elements: Array\r\n\t\t//\t\tList of elements that wraps target node and gesture data\r\n\t\t_elements: null,\r\n\r\n\t\t/*=====\r\n\t\t// _lock: Dom\r\n\t\t//\t\tThe dom node whose descendants are all locked for processing\r\n\t\t_lock: null,\r\n\t\t\r\n\t\t// _events: [readonly] Array\r\n\t\t//\t\tThe complete list of supported gesture events with full name space\r\n\t\t//\t\te.g ['tap', 'tap.hold', 'tap.doubletap']\r\n\t\t_events: null,\r\n\t\t=====*/\r\n\r\n\t\tconstructor: function(args){\r\n\t\t\tlang.mixin(this, args);\r\n\t\t\tthis.init();\r\n\t\t},\r\n\t\tinit: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tInitialization works\r\n\t\t\tthis._elements = [];\r\n\r\n\t\t\tif(!has(\"touch\") && this.touchOnly){\r\n\t\t\t\tconsole.warn(\"Gestures:[\", this.defaultEvent, \"] is only supported on touch devices!\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// bind on() handlers for various events\r\n\t\t\tvar evt = this.defaultEvent;\r\n\t\t\tthis.call = this._handle(evt);\r\n\r\n\t\t\tthis._events = [evt];\r\n\t\t\tarray.forEach(this.subEvents, function(subEvt){\r\n\t\t\t\tthis[subEvt] = this._handle(evt + '.' + subEvt);\r\n\t\t\t\tthis._events.push(evt + '.' + subEvt);\r\n\t\t\t}, this);\r\n\t\t},\r\n\t\t_handle: function(/*String*/eventType){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tBind listen handler for the given gesture event(e.g. 'tap', 'tap.hold' etc.)\r\n\t\t\t//\t\tthe returned handle will be used internally by dojo/on\r\n\t\t\tvar self = this;\r\n\t\t\t//called by dojo/on\r\n\t\t\treturn function(node, listener){\r\n\t\t\t\t// normalize, arguments might be (null, node, listener)\r\n\t\t\t\tvar a = arguments;\r\n\t\t\t\tif(a.length > 2){\r\n\t\t\t\t\tnode = a[1];\r\n\t\t\t\t\tlistener = a[2];\r\n\t\t\t\t}\r\n\t\t\t\tvar isNode = node && (node.nodeType || node.attachEvent || node.addEventListener);\r\n\t\t\t\tif(!isNode){\r\n\t\t\t\t\treturn on(node, eventType, listener);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tvar onHandle = self._add(node, eventType, listener);\r\n\t\t\t\t\t// FIXME - users are supposed to explicitly call either\r\n\t\t\t\t\t// disconnect(signal) or signal.remove() to release resources\r\n\t\t\t\t\tvar signal = {\r\n\t\t\t\t\t\tremove: function(){\r\n\t\t\t\t\t\t\tonHandle.remove();\r\n\t\t\t\t\t\t\tself._remove(node, eventType);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\treturn signal;\r\n\t\t\t\t}\r\n\t\t\t}; // dojo/on handle\r\n\t\t},\r\n\t\t_add: function(/*Dom*/node, /*String*/type, /*function*/listener){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tBind dojo/on handlers for both gesture event(e.g 'tab.hold')\r\n\t\t\t//\t\tand underneath 'press'|'move'|'release' events\r\n\t\t\tvar element = this._getGestureElement(node);\r\n\t\t\tif(!element){\r\n\t\t\t\t// the first time listening to the node\r\n\t\t\t\telement = {\r\n\t\t\t\t\ttarget: node,\r\n\t\t\t\t\tdata: {},\r\n\t\t\t\t\thandles: {}\r\n\t\t\t\t};\r\n\r\n\t\t\t\tvar _press = lang.hitch(this, \"_process\", element, \"press\");\r\n\t\t\t\tvar _move = lang.hitch(this, \"_process\", element, \"move\");\r\n\t\t\t\tvar _release = lang.hitch(this, \"_process\", element, \"release\");\r\n\t\t\t\tvar _cancel = lang.hitch(this, \"_process\", element, \"cancel\");\r\n\r\n\t\t\t\tvar handles = element.handles;\r\n\t\t\t\tif(this.touchOnly){\r\n\t\t\t\t\thandles.press = on(node, 'touchstart', _press);\r\n\t\t\t\t\thandles.move = on(node, 'touchmove', _move);\r\n\t\t\t\t\thandles.release = on(node, 'touchend', _release);\r\n\t\t\t\t\thandles.cancel = on(node, 'touchcancel', _cancel);\r\n\t\t\t\t}else{\r\n\t\t\t\t\thandles.press = touch.press(node, _press);\r\n\t\t\t\t\thandles.move = touch.move(node, _move);\r\n\t\t\t\t\thandles.release = touch.release(node, _release);\r\n\t\t\t\t\thandles.cancel = touch.cancel(node, _cancel);\r\n\t\t\t\t}\r\n\t\t\t\tthis._elements.push(element);\r\n\t\t\t}\r\n\t\t\t// track num of listeners for the gesture event - type\r\n\t\t\t// so that we can release element if no more gestures being monitored\r\n\t\t\telement.handles[type] = !element.handles[type] ? 1 : ++element.handles[type];\r\n\r\n\t\t\treturn on(node, type, listener); //handle\r\n\t\t},\r\n\t\t_getGestureElement: function(/*Dom*/node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tObtain a gesture element for the give node\r\n\t\t\tvar i = 0, element;\r\n\t\t\tfor(; i < this._elements.length; i++){\r\n\t\t\t\telement = this._elements[i];\r\n\t\t\t\tif(element.target === node){\r\n\t\t\t\t\treturn element;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t_process: function(element, phase, e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcess and dispatch to appropriate phase handlers.\r\n\t\t\t//\t\tAlso provides the machinery for managing gesture bubbling.\r\n\t\t\t// description:\r\n\t\t\t//\t\t1. e._locking is used to make sure only the most inner node\r\n\t\t\t//\t\twill be processed for the same gesture, suppose we have:\r\n\t\t\t//\t|\ton(inner, dojox.gesture.tap, func1);\r\n\t\t\t//\t|\ton(outer, dojox.gesture.tap, func2);\r\n\t\t\t//\t\tonly the inner node will be processed by tap gesture, once matched,\r\n\t\t\t//\t\tthe 'tap' event will be bubbled up from inner to outer, dojo.StopEvent(e)\r\n\t\t\t//\t\tcan be used at any level to stop the 'tap' event.\r\n\t\t\t//\r\n\t\t\t//\t\t2. Once a node starts being processed, all it's descendant nodes will be locked.\r\n\t\t\t//\t\tThe same gesture won't be processed on its descendant nodes until the lock is released.\r\n\t\t\t// element: Object\r\n\t\t\t//\t\tGesture element\r\n\t\t\t// phase: String\r\n\t\t\t//\t\tPhase of a gesture to be processed, might be 'press'|'move'|'release'|'cancel'\r\n\t\t\t// e: Event\r\n\t\t\t//\t\tNative event\r\n\t\t\te._locking = e._locking || {};\r\n\t\t\tif(e._locking[this.defaultEvent] || this.isLocked(e.currentTarget)){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t// invoking gesture.press()|move()|release()|cancel()\r\n\t\t\t// #16900: same condition as in dojo/touch, to avoid breaking the editing of input fields.\r\n\t\t\tif((e.target.tagName != \"INPUT\" || e.target.type == \"radio\" || e.target.type == \"checkbox\")\r\n\t\t\t\t&& e.target.tagName != \"TEXTAREA\"){\r\n\t\t\t\te.preventDefault(); \r\n\t\t\t}\r\n\t\t\te._locking[this.defaultEvent] = true;\r\n\t\t\tthis[phase](element.data, e);\r\n\t\t},\r\n\t\tpress: function(data, e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcess the 'press' phase of a gesture\r\n\t\t},\r\n\t\tmove: function(data, e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcess the 'move' phase of a gesture\r\n\t\t},\r\n\t\trelease: function(data, e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcess the 'release' phase of a gesture\r\n\t\t},\r\n\t\tcancel: function(data, e){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tProcess the 'cancel' phase of a gesture\r\n\t\t},\r\n\t\tfire: function(node, event){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tFire a gesture event and invoke registered listeners\r\n\t\t\t//\t\ta simulated GestureEvent will also be sent along\r\n\t\t\t// node: DomNode\r\n\t\t\t//\t\tTarget node to fire the gesture\r\n\t\t\t// event: Object\r\n\t\t\t//\t\tAn object containing specific gesture info e.g {type: 'tap.hold'|'swipe.left'), ...}\r\n\t\t\t//\t\tall these properties will be put into a simulated GestureEvent when fired.\r\n\t\t\t//\t\tNote - Default properties in a native Event won't be overwritten, see on.emit() for more details.\r\n\t\t\tif(!node || !event){\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tevent.bubbles = true;\r\n\t\t\tevent.cancelable = true;\r\n\t\t\ton.emit(node, event.type, event);\r\n\t\t},\r\n\t\t_remove: function(/*Dom*/node, /*String*/type){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCheck and remove underneath handlers if node\r\n\t\t\t//\t\tis not being listened for 'this' gesture anymore,\r\n\t\t\t//\t\tthis happens when user removed all previous on() handlers.\r\n\t\t\tvar element = this._getGestureElement(node);\r\n\t\t\tif(!element || !element.handles){ return; }\r\n\t\t\t\r\n\t\t\telement.handles[type]--;\r\n\r\n\t\t\tvar handles = element.handles;\r\n\t\t\tif(!array.some(this._events, function(evt){\r\n\t\t\t\treturn handles[evt] > 0;\r\n\t\t\t})){\r\n\t\t\t\t// clean up if node is not being listened anymore\r\n\t\t\t\tthis._cleanHandles(handles);\r\n\t\t\t\tvar i = array.indexOf(this._elements, element);\r\n\t\t\t\tif(i >= 0){\r\n\t\t\t\t\tthis._elements.splice(i, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t_cleanHandles: function(/*Object*/handles){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tClean up on handles\r\n\t\t\tfor(var x in handles){\r\n\t\t\t\t//remove handles for \"press\"|\"move\"|\"release\"|\"cancel\"\r\n\t\t\t\tif(handles[x].remove){\r\n\t\t\t\t\thandles[x].remove();\r\n\t\t\t\t}\r\n\t\t\t\tdelete handles[x];\r\n\t\t\t}\r\n\t\t},\r\n\t\tlock: function(/*Dom*/node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tLock all descendants of the node.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\tthis._lock = node;\r\n\t\t},\r\n\t\tunLock: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRelease the lock\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\tthis._lock = null;\r\n\t\t},\r\n\t\tisLocked: function(node){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tCheck if the node is locked, isLocked(node) means\r\n\t\t\t//\t\twhether it's a descendant of the currently locked node.\r\n\t\t\t// tags:\r\n\t\t\t//\t\tprotected\r\n\t\t\tif(!this._lock || !node){\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn this._lock !== node && dom.isDescendant(node, this._lock);\r\n\t\t},\r\n\t\tdestroy: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRelease all handlers and resources\r\n\t\t\tarray.forEach(this._elements, function(element){\r\n\t\t\t\tthis._cleanHandles(element.handles);\r\n\t\t\t}, this);\r\n\t\t\tthis._elements = null;\r\n\t\t}\r\n\t});\r\n});"]}