{"version":3,"sources":["analytics/_base.js"],"names":["define","lang","config","ready","unload","has","request","JSON","ioQuery","script","Analytics","this","_data","_id","sendInterval","inTransitRetry","dataUrl","require","toUrl","sendMethod","maxRequestSize","addOnUnload","pushData","extend","schedulePusher","interval","setTimeout","hitch","addData","dataType","data","arguments","length","Array","prototype","slice","call","push","plugin","checkData","_inTransit","promise","get","getQueryPacket","preventCache","callbackParamName","post","id","stringify","then","content","query","objectToQuery","unshift","pop","_split","onPushComplete","results","setObject"],"mappings":";;;;;;;AAAAA,QAAQ,kBAAmB,oBAAqB,aAAc,oBACtD,mBAAoB,eAAgB,YAAa,gBAAiB,uBACvE,SAASC,EAAMC,EAAQC,EAAOC,EAAQC,EAAKC,EAASC,EAAMC,EAASC,GAErE,IAAIC,EAAY,WAKfC,KAAKC,SAGLD,KAAKE,IAAM,EAGXF,KAAKG,aAAeZ,EAAqB,cAAK,IAC9CS,KAAKI,eAAiBb,EAAuB,gBAAK,IAClDS,KAAKK,QAAUd,EAAqB,cAAKe,QAAQC,MAAM,6CACvDP,KAAKQ,WAAajB,EAAmB,YAAK,UAC1CS,KAAKS,eAAiBf,EAAI,MAAQ,IAAOH,EAAuB,gBAAK,IAKrEC,EAAMQ,KAAM,kBACZP,EAAOiB,YAAYV,KAAM,WACxBA,KAAKW,cAyGP,OArGArB,EAAKsB,OAAOb,GACXc,eAAgB,SAAkBC,GAGjCC,WAAWzB,EAAK0B,MAAMhB,KAAM,aAAcc,GAAYd,KAAKG,eAG5Dc,QAAS,SAASC,EAAUC,GAKxBC,UAAUC,OAAS,IAErBF,EAAOG,MAAMC,UAAUC,MAAMC,KAAKL,UAAU,IAG7CpB,KAAKC,MAAMyB,MAAOC,OAAQT,EAAUC,KAAMA,KAG3CS,UAAW,WAGP5B,KAAK6B,WACP7B,KAAKa,eAAeb,KAAKI,gBAIvBJ,KAAKW,YACRX,KAAKa,kBAGNF,SAAU,WAKT,GAAGX,KAAKC,MAAMoB,OAAO,CAIpB,IAAIS,EACJ,OAHA9B,KAAK6B,WAAa7B,KAAKC,MACvBD,KAAKC,SAEED,KAAKQ,YACX,IAAK,SACJsB,EAAUhC,EAAOiC,IAAI/B,KAAKgC,kBACzBC,aAAc,EACdC,kBAAmB,aAEpB,MACD,IAAK,UACL,QACCJ,EAAUnC,EAAQwC,KAAKnC,KAAKK,SAC3Bc,MACCiB,GAAIpC,KAAKE,MACTiB,KAAMvB,EAAKyC,UAAUrC,KAAK6B,eAM9B,OADAC,EAAQQ,KAAKhD,EAAK0B,MAAMhB,KAAM,mBACvB8B,EAER,OAAO,GAGRE,eAAgB,WAEf,OAAW,CACV,IAAIO,GACHH,GAAIpC,KAAKE,MACTiB,KAAMvB,EAAKyC,UAAUrC,KAAK6B,aAIvBW,EAAQxC,KAAKK,QAAU,IAAMR,EAAQ4C,cAAcF,GACvD,KAAGC,EAAMnB,OAASrB,KAAKS,gBAItB,OAAO+B,EAHPxC,KAAKC,MAAMyC,QAAQ1C,KAAK6B,WAAWc,OACnC3C,KAAK4C,OAAS,IAOjBC,eAAgB,SAASC,GAIrB9C,KAAK6B,mBACA7B,KAAK6B,WAGV7B,KAAKC,MAAMoB,OAAS,EACtBrB,KAAKa,eAAeb,KAAKI,gBAEzBJ,KAAKa,oBAMDvB,EAAKyD,UAAU,kBAAkB,IAAIhD","file":"../../analytics/_base.js","sourcesContent":["define([\"dojo/_base/lang\", \"dojo/_base/config\", \"dojo/ready\", \"dojo/_base/unload\",\r\n        \"dojo/_base/sniff\", \"dojo/request\", \"dojo/json\", \"dojo/io-query\", \"dojo/request/script\"\r\n], function(lang, config, ready, unload, has, request, JSON, ioQuery, script){\r\n\r\n\tvar Analytics = function(){\r\n\t\t// summary:\r\n\t\t//\t\twhere we store data until we're ready to send it off.\r\n\r\n\t\t// the data queue;\r\n\t\tthis._data = [];\r\n\r\n\t\t// id of messages for this session/page\r\n\t\tthis._id = 1;\r\n\r\n\t\t// some default values\r\n\t\tthis.sendInterval = config[\"sendInterval\"] || 5000;\r\n\t\tthis.inTransitRetry = config[\"inTransitRetry\"] || 200;\r\n\t\tthis.dataUrl = config[\"analyticsUrl\"] || require.toUrl(\"dojox/analytics/logger/dojoxAnalytics.php\");\r\n\t\tthis.sendMethod = config[\"sendMethod\"] || \"xhrPost\";\r\n\t\tthis.maxRequestSize = has(\"ie\") ? 2000 : config[\"maxRequestSize\"] || 4000;\r\n\r\n\t\t// while we can go ahead and being logging as soon as this constructor is completed\r\n\t\t// we're not going to schedule pushing data to the server until after the page\r\n\t\t// has completed loading\r\n\t\tready(this, \"schedulePusher\");\r\n\t\tunload.addOnUnload(this, function(){\r\n\t\t\tthis.pushData();\r\n\t\t});\r\n\t};\r\n\r\n\tlang.extend(Analytics, {\r\n\t\tschedulePusher: function(/* Int */interval){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tSchedule the data pushing routines to happen in interval ms\r\n\t\t\tsetTimeout(lang.hitch(this, \"checkData\"), interval || this.sendInterval);\r\n\t\t},\r\n\r\n\t\taddData: function(dataType, data){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tadd data to the queue. Will be pusshed to the server on the next\r\n\t\t\t//\t\tdata push\r\n\r\n\t\t\tif(arguments.length > 2){\r\n\t\t\t\t// FIXME: var c = dojo._toArray(arguments) ?\r\n\t\t\t\tdata = Array.prototype.slice.call(arguments,1);\r\n\t\t\t}\r\n\r\n\t\t\tthis._data.push({ plugin: dataType, data: data });\r\n\t\t},\r\n\r\n\t\tcheckData: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tTODOC?\r\n\t\t\tif(this._inTransit){\r\n\t\t\t\tthis.schedulePusher(this.inTransitRetry);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif(this.pushData()){ return; }\r\n\t\t\tthis.schedulePusher();\r\n\t\t},\r\n\r\n\t\tpushData: function(){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tpushes data to the server if any exists.  If a push is done, return\r\n\t\t\t//\t\tthe deferred after hooking up completion callbacks.  If there is no data\r\n\t\t\t//\t\tto be pushed, return false;\r\n\t\t\tif(this._data.length){\r\n\t\t\t\t// clear the queue\r\n\t\t\t\tthis._inTransit = this._data;\r\n\t\t\t\tthis._data = [];\r\n\t\t\t\tvar promise;\r\n\t\t\t\tswitch(this.sendMethod){\r\n\t\t\t\t\tcase \"script\":\r\n\t\t\t\t\t\tpromise = script.get(this.getQueryPacket(), {\r\n\t\t\t\t\t\t\tpreventCache: 1,\r\n\t\t\t\t\t\t\tcallbackParamName: \"callback\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"xhrPost\":\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tpromise = request.post(this.dataUrl, {\r\n\t\t\t\t\t\t\tdata:{\r\n\t\t\t\t\t\t\t\tid: this._id++,\r\n\t\t\t\t\t\t\t\tdata: JSON.stringify(this._inTransit)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tpromise.then(lang.hitch(this, \"onPushComplete\"));\r\n\t\t\t\treturn promise;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\r\n\t\tgetQueryPacket: function(){\r\n\t\t\t// TODOC\r\n\t\t\twhile(true){\r\n\t\t\t\tvar content = {\r\n\t\t\t\t\tid: this._id++,\r\n\t\t\t\t\tdata: JSON.stringify(this._inTransit)\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// FIXME would like a much better way to get the query down to length\r\n\t\t\t\tvar query = this.dataUrl + '?' + ioQuery.objectToQuery(content);\r\n\t\t\t\tif(query.length > this.maxRequestSize){\r\n\t\t\t\t\tthis._data.unshift(this._inTransit.pop());\r\n\t\t\t\t\tthis._split = 1;\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn query;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tonPushComplete: function(results){\r\n\t\t\t// summary:\r\n\t\t\t//\t\tIf our data push was successfully, remove the _inTransit data and schedule the next\r\n\t\t\t//\t\tparser run.\r\n\t\t\tif(this._inTransit){\r\n\t\t\t\tdelete this._inTransit;\r\n\t\t\t}\r\n\r\n\t\t\tif(this._data.length > 0){\r\n\t\t\t\tthis.schedulePusher(this.inTransitRetry);\r\n\t\t\t}else{\r\n\t\t\t\tthis.schedulePusher();\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\t// create the analytics singleton\r\n\treturn lang.setObject(\"dojox.analytics\",new Analytics());\r\n});\r\n"]}