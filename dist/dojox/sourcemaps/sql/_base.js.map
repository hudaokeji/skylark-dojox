{"version":3,"sources":["sql/_base.js"],"names":["dojo","provide","require","mixin","dojox","sql","dbName","debug","exists","open","this","_dbOpen","window","location","href","replace","length","substring","_initDb","db","exp","message","close","isIE","_exec","params","_autoClose","callback","password","args","_toArray","splice","_needsEncrypt","_needsDecrypt","_printDebugSQL","_SQLCrypto","rs","execute","_normalizeResults","console","e","google","gears","factory","create","setObject","off","onFrameworkEvent","msg","i","results","isValidRow","row","fieldCount","fieldName","fieldValue","field","push","next","test","declare","constructor","action","_execEncryptSQL","_execDecryptSQL","strippedSQL","_stripCryptoSQL","encryptColumns","_flagEncryptedArgs","self","_encrypt","finalArgs","resultSet","execError","needsDecrypt","_determineDecryptedColumns","_decrypt","finalResultSet","toString","_totalCrypto","_finishedCrypto","_finishedSpawningCrypto","_finalArgs","sqlParam","paramIndex","_crypto","encrypt","hitch","_finalResultSet","columnName","columnValue","_decryptSingleColumn","matches","match","encryptStatement","encryptValue","decryptStatement","decryptValue","tester","RegExp","currentParam","exec","currentMatch","lastMatch","needsEncrypt","leftContext","columnNames","String","split","forEach","column","currentRowIndex","decrypt","orig_sql","Function"],"mappings":"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","file":"../../sql/_base.js","sourcesContent":["dojo.provide(\"dojox.sql._base\");\r\ndojo.require(\"dojox.sql._crypto\");\r\n\r\ndojo.mixin(dojox.sql, {\r\n\t// summary:\r\n\t//\t\tExecutes a SQL expression.\r\n\t// description:\r\n\t// \t\tThere are four ways to call this:\r\n\t//\r\n\t// \t\t1. Straight SQL: dojox.sql(\"SELECT * FROM FOOBAR\");\r\n\t// \t\t2. SQL with parameters: dojox.sql(\"INSERT INTO FOOBAR VALUES (?)\", someParam)\r\n\t// \t\t3. Encrypting particular values:\r\n\t//\t\t\tdojox.sql(\"INSERT INTO FOOBAR VALUES (ENCRYPT(?))\", someParam, \"somePassword\", callback)\r\n\t// \t\t4. Decrypting particular values:\r\n\t//\t|\t\tdojox.sql(\"SELECT DECRYPT(SOMECOL1), DECRYPT(SOMECOL2) FROM\r\n\t//\t|\t\t\t\tFOOBAR WHERE SOMECOL3 = ?\", someParam,\r\n\t//\t|\t\t\t\t\"somePassword\", callback)\r\n\t//\r\n\t// \t\tFor encryption and decryption the last two values should be the the password for\r\n\t// \t\tencryption/decryption, and the callback function that gets the result set.\r\n\t//\r\n\t// \t\tNote: We only support ENCRYPT(?) statements, and\r\n\t// \t\tand DECRYPT(*) statements for now -- you can not have a literal string\r\n\t// \t\tinside of these, such as ENCRYPT('foobar')\r\n\t//\r\n\t// \t\tNote: If you have multiple columns to encrypt and decrypt, you can use the following\r\n\t// \t\tconvenience form to not have to type ENCRYPT(?)/DECRYPT(*) many times:\r\n\t//\r\n\t// | \tdojox.sql(\"INSERT INTO FOOBAR VALUES (ENCRYPT(?, ?, ?))\",\r\n\t// |\t\t\t\t\tsomeParam1, someParam2, someParam3,\r\n\t// |\t\t\t\t\t\"somePassword\", callback)\r\n\t// |\r\n\t// | \tdojox.sql(\"SELECT DECRYPT(SOMECOL1, SOMECOL2) FROM\r\n\t// |\t\t\t\tFOOBAR WHERE SOMECOL3 = ?\", someParam,\r\n\t// |\t\t\t\t\"somePassword\", callback)\r\n\r\n\tdbName: null,\r\n\t\r\n\t// debug: Boolean\r\n\t//\t\tIf true, then we print out any SQL that is executed\r\n\t//\t\tto the debug window\r\n\tdebug: (dojo.exists(\"dojox.sql.debug\") ? dojox.sql.debug:false),\r\n\r\n\topen: function(dbName){\r\n\t\tif(this._dbOpen && (!dbName || dbName == this.dbName)){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif(!this.dbName){\r\n\t\t\tthis.dbName = \"dot_store_\"\r\n\t\t\t\t+ window.location.href.replace(/[^0-9A-Za-z_]/g, \"_\");\r\n\t\t\t// database names in Gears are limited to 64 characters long\r\n\t\t\tif(this.dbName.length > 63){\r\n\t\t\t  this.dbName = this.dbName.substring(0, 63);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(!dbName){\r\n\t\t\tdbName = this.dbName;\r\n\t\t}\r\n\t\t\r\n\t\ttry{\r\n\t\t\tthis._initDb();\r\n\t\t\tthis.db.open(dbName);\r\n\t\t\tthis._dbOpen = true;\r\n\t\t}catch(exp){\r\n\t\t\tthrow exp.message||exp;\r\n\t\t}\r\n\t},\r\n\r\n\tclose: function(dbName){\r\n\t\t// on Internet Explorer, Google Gears throws an exception\r\n\t\t// \"Object not a collection\", when we try to close the\r\n\t\t// database -- just don't close it on this platform\r\n\t\t// since we are running into a Gears bug; the Gears team\r\n\t\t// said it's ok to not close a database connection\r\n\t\tif(dojo.isIE){ return; }\r\n\t\t\r\n\t\tif(!this._dbOpen && (!dbName || dbName == this.dbName)){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif(!dbName){\r\n\t\t\tdbName = this.dbName;\r\n\t\t}\r\n\t\t\r\n\t\ttry{\r\n\t\t\tthis.db.close(dbName);\r\n\t\t\tthis._dbOpen = false;\r\n\t\t}catch(exp){\r\n\t\t\tthrow exp.message||exp;\r\n\t\t}\r\n\t},\r\n\t\r\n\t_exec: function(params){\r\n\t\ttry{\r\n\t\t\t// get the Gears Database object\r\n\t\t\tthis._initDb();\r\n\t\t\r\n\t\t\t// see if we need to open the db; if programmer\r\n\t\t\t// manually called dojox.sql.open() let them handle\r\n\t\t\t// it; otherwise we open and close automatically on\r\n\t\t\t// each SQL execution\r\n\t\t\tif(!this._dbOpen){\r\n\t\t\t\tthis.open();\r\n\t\t\t\tthis._autoClose = true;\r\n\t\t\t}\r\n\t\t\r\n\t\t\t// determine our parameters\r\n\t\t\tvar sql = null;\r\n\t\t\tvar callback = null;\r\n\t\t\tvar password = null;\r\n\r\n\t\t\tvar args = dojo._toArray(params);\r\n\r\n\t\t\tsql = args.splice(0, 1)[0];\r\n\r\n\t\t\t// does this SQL statement use the ENCRYPT or DECRYPT\r\n\t\t\t// keywords? if so, extract our callback and crypto\r\n\t\t\t// password\r\n\t\t\tif(this._needsEncrypt(sql) || this._needsDecrypt(sql)){\r\n\t\t\t\tcallback = args.splice(args.length - 1, 1)[0];\r\n\t\t\t\tpassword = args.splice(args.length - 1, 1)[0];\r\n\t\t\t}\r\n\r\n\t\t\t// 'args' now just has the SQL parameters\r\n\r\n\t\t\t// print out debug SQL output if the developer wants that\r\n\t\t\tif(this.debug){\r\n\t\t\t\tthis._printDebugSQL(sql, args);\r\n\t\t\t}\r\n\r\n\t\t\t// handle SQL that needs encryption/decryption differently\r\n\t\t\t// do we have an ENCRYPT SQL statement? if so, handle that first\r\n\t\t\tvar crypto;\r\n\t\t\tif(this._needsEncrypt(sql)){\r\n\t\t\t\tcrypto = new dojox.sql._SQLCrypto(\"encrypt\", sql,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpassword, args,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback);\r\n\t\t\t\treturn null; // encrypted results will arrive asynchronously\r\n\t\t\t}else if(this._needsDecrypt(sql)){ // otherwise we have a DECRYPT statement\r\n\t\t\t\tcrypto = new dojox.sql._SQLCrypto(\"decrypt\", sql,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpassword, args,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback);\r\n\t\t\t\treturn null; // decrypted results will arrive asynchronously\r\n\t\t\t}\r\n\r\n\t\t\t// execute the SQL and get the results\r\n\t\t\tvar rs = this.db.execute(sql, args);\r\n\t\t\t\r\n\t\t\t// Gears ResultSet object's are ugly -- normalize\r\n\t\t\t// these into something JavaScript programmers know\r\n\t\t\t// how to work with, basically an array of\r\n\t\t\t// JavaScript objects where each property name is\r\n\t\t\t// simply the field name for a column of data\r\n\t\t\trs = this._normalizeResults(rs);\r\n\t\t\r\n\t\t\tif(this._autoClose){\r\n\t\t\t\tthis.close();\r\n\t\t\t}\r\n\t\t\r\n\t\t\treturn rs;\r\n\t\t}catch(exp){\r\n\t\t\texp = exp.message||exp;\r\n\t\t\t\r\n\t\t\tconsole.debug(\"SQL Exception: \" + exp);\r\n\t\t\t\r\n\t\t\tif(this._autoClose){\r\n\t\t\t\ttry{\r\n\t\t\t\t\tthis.close();\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\tconsole.debug(\"Error closing database: \"\r\n\t\t\t\t\t\t\t\t\t+ e.message||e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\r\n\t\t\tthrow exp;\r\n\t\t}\r\n\t\t\r\n\t\treturn null;\r\n\t},\r\n\r\n\t_initDb: function(){\r\n\t\tif(!this.db){\r\n\t\t\ttry{\r\n\t\t\t\tthis.db = google.gears.factory.create('beta.database', '1.0');\r\n\t\t\t}catch(exp){\r\n\t\t\t\tdojo.setObject(\"google.gears.denied\", true);\r\n\t\t\t\tif(dojox.off){\r\n\t\t\t\t  dojox.off.onFrameworkEvent(\"coreOperationFailed\");\r\n\t\t\t\t}\r\n\t\t\t\tthrow \"Google Gears must be allowed to run\";\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t_printDebugSQL: function(sql, args){\r\n\t\tvar msg = \"dojox.sql(\\\"\" + sql + \"\\\"\";\r\n\t\tfor(var i = 0; i < args.length; i++){\r\n\t\t\tif(typeof args[i] == \"string\"){\r\n\t\t\t\tmsg += \", \\\"\" + args[i] + \"\\\"\";\r\n\t\t\t}else{\r\n\t\t\t\tmsg += \", \" + args[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\tmsg += \")\";\r\n\t\r\n\t\tconsole.debug(msg);\r\n\t},\r\n\r\n\t_normalizeResults: function(rs){\r\n\t\tvar results = [];\r\n\t\tif(!rs){ return []; }\r\n\t\r\n\t\twhile(rs.isValidRow()){\r\n\t\t\tvar row = {};\r\n\t\t\r\n\t\t\tfor(var i = 0; i < rs.fieldCount(); i++){\r\n\t\t\t\tvar fieldName = rs.fieldName(i);\r\n\t\t\t\tvar fieldValue = rs.field(i);\r\n\t\t\t\trow[fieldName] = fieldValue;\r\n\t\t\t}\r\n\t\t\r\n\t\t\tresults.push(row);\r\n\t\t\r\n\t\t\trs.next();\r\n\t\t}\r\n\t\r\n\t\trs.close();\r\n\t\t\r\n\t\treturn results;\r\n\t},\r\n\r\n\t_needsEncrypt: function(sql){\r\n\t\treturn /encrypt\\([^\\)]*\\)/i.test(sql);\r\n\t},\r\n\r\n\t_needsDecrypt: function(sql){\r\n\t\treturn /decrypt\\([^\\)]*\\)/i.test(sql);\r\n\t}\r\n});\r\n\r\ndojo.declare(\"dojox.sql._SQLCrypto\", null, {\r\n\t// summary:\r\n\t//\t\tA private class encapsulating any cryptography that must be done\r\n\t// \t\ton a SQL statement. We instantiate this class and have it hold\r\n\t//\t\tit's state so that we can potentially have several encryption\r\n\t//\t\toperations happening at the same time by different SQL statements.\r\n\tconstructor: function(action, sql, password, args, callback){\r\n\t\tif(action == \"encrypt\"){\r\n\t\t\tthis._execEncryptSQL(sql, password, args, callback);\r\n\t\t}else{\r\n\t\t\tthis._execDecryptSQL(sql, password, args, callback);\r\n\t\t}\r\n\t},\r\n\t\r\n\t_execEncryptSQL: function(sql, password, args, callback){\r\n\t\t// strip the ENCRYPT/DECRYPT keywords from the SQL\r\n\t\tvar strippedSQL = this._stripCryptoSQL(sql);\r\n\t\r\n\t\t// determine what arguments need encryption\r\n\t\tvar encryptColumns = this._flagEncryptedArgs(sql, args);\r\n\t\r\n\t\t// asynchronously encrypt each argument that needs it\r\n\t\tvar self = this;\r\n\t\tthis._encrypt(strippedSQL, password, args, encryptColumns, function(finalArgs){\r\n\t\t\t// execute the SQL\r\n\t\t\tvar error = false;\r\n\t\t\tvar resultSet = [];\r\n\t\t\tvar exp = null;\r\n\t\t\ttry{\r\n\t\t\t\tresultSet = dojox.sql.db.execute(strippedSQL, finalArgs);\r\n\t\t\t}catch(execError){\r\n\t\t\t\terror = true;\r\n\t\t\t\texp = execError.message||execError;\r\n\t\t\t}\r\n\t\t\r\n\t\t\t// was there an error during SQL execution?\r\n\t\t\tif(exp != null){\r\n\t\t\t\tif(dojox.sql._autoClose){\r\n\t\t\t\t\ttry{ dojox.sql.close(); }catch(e){}\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\tcallback(null, true, exp.toString());\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\r\n\t\t\t// normalize SQL results into a JavaScript object\r\n\t\t\t// we can work with\r\n\t\t\tresultSet = dojox.sql._normalizeResults(resultSet);\r\n\t\t\r\n\t\t\tif(dojox.sql._autoClose){\r\n\t\t\t\tdojox.sql.close();\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\t// are any decryptions necessary on the result set?\r\n\t\t\tif(dojox.sql._needsDecrypt(sql)){\r\n\t\t\t\t// determine which of the result set columns needs decryption\r\n\t \t\t\tvar needsDecrypt = self._determineDecryptedColumns(sql);\r\n\r\n\t\t\t\t// now decrypt columns asynchronously\r\n\t\t\t\t// decrypt columns that need it\r\n\t\t\t\tself._decrypt(resultSet, needsDecrypt, password, function(finalResultSet){\r\n\t\t\t\t\tcallback(finalResultSet, false, null);\r\n\t\t\t\t});\r\n\t\t\t}else{\r\n\t\t\t\tcallback(resultSet, false, null);\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\t_execDecryptSQL: function(sql, password, args, callback){\r\n\t\t// strip the ENCRYPT/DECRYPT keywords from the SQL\r\n\t\tvar strippedSQL = this._stripCryptoSQL(sql);\r\n\t\r\n\t\t// determine which columns needs decryption; this either\r\n\t\t// returns the value *, which means all result set columns will\r\n\t\t// be decrypted, or it will return the column names that need\r\n\t\t// decryption set on a hashtable so we can quickly test a given\r\n\t\t// column name; the key is the column name that needs\r\n\t\t// decryption and the value is 'true' (i.e. needsDecrypt[\"someColumn\"]\r\n\t\t// would return 'true' if it needs decryption, and would be 'undefined'\r\n\t\t// or false otherwise)\r\n\t\tvar needsDecrypt = this._determineDecryptedColumns(sql);\r\n\t\r\n\t\t// execute the SQL\r\n\t\tvar error = false;\r\n\t\tvar resultSet = [];\r\n\t\tvar exp = null;\r\n\t\ttry{\r\n\t\t\tresultSet = dojox.sql.db.execute(strippedSQL, args);\r\n\t\t}catch(execError){\r\n\t\t\terror = true;\r\n\t\t\texp = execError.message||execError;\r\n\t\t}\r\n\t\r\n\t\t// was there an error during SQL execution?\r\n\t\tif(exp != null){\r\n\t\t\tif(dojox.sql._autoClose){\r\n\t\t\t\ttry{ dojox.sql.close(); }catch(e){}\r\n\t\t\t}\r\n\t\t\r\n\t\t\tcallback(resultSet, true, exp.toString());\r\n\t\t\treturn;\r\n\t\t}\r\n\t\r\n\t\t// normalize SQL results into a JavaScript object\r\n\t\t// we can work with\r\n\t\tresultSet = dojox.sql._normalizeResults(resultSet);\r\n\t\r\n\t\tif(dojox.sql._autoClose){\r\n\t\t\tdojox.sql.close();\r\n\t\t}\r\n\t\r\n\t\t// decrypt columns that need it\r\n\t\tthis._decrypt(resultSet, needsDecrypt, password, function(finalResultSet){\r\n\t\t\tcallback(finalResultSet, false, null);\r\n\t\t});\r\n\t},\r\n\r\n\t_encrypt: function(sql, password, args, encryptColumns, callback){\r\n\t\t//console.debug(\"_encrypt, sql=\"+sql+\", password=\"+password+\", encryptColumns=\"+encryptColumns+\", args=\"+args);\r\n\t\r\n\t\tthis._totalCrypto = 0;\r\n\t\tthis._finishedCrypto = 0;\r\n\t\tthis._finishedSpawningCrypto = false;\r\n\t\tthis._finalArgs = args;\r\n\t\r\n\t\tfor(var i = 0; i < args.length; i++){\r\n\t\t\tif(encryptColumns[i]){\r\n\t\t\t\t// we have an encrypt() keyword -- get just the value inside\r\n\t\t\t\t// the encrypt() parentheses -- for now this must be a ?\r\n\t\t\t\tvar sqlParam = args[i];\r\n\t\t\t\tvar paramIndex = i;\r\n\t\t\t\r\n\t\t\t\t// update the total number of encryptions we know must be done asynchronously\r\n\t\t\t\tthis._totalCrypto++;\r\n\t\t\t\r\n\t\t\t\t// FIXME: This currently uses DES as a proof-of-concept since the\r\n\t\t\t\t// DES code used is quite fast and was easy to work with. Modify dojox.sql\r\n\t\t\t\t// to be able to specify a different encryption provider through a\r\n\t\t\t\t// a SQL-like syntax, such as dojox.sql(\"SET ENCRYPTION BLOWFISH\"),\r\n\t\t\t\t// and modify the dojox.crypto.Blowfish code to be able to work using\r\n\t\t\t\t// a Google Gears Worker Pool\r\n\t\t\t\r\n\t\t\t\t// do the actual encryption now, asychronously on a Gears worker thread\r\n\t\t\t\tdojox.sql._crypto.encrypt(sqlParam, password, dojo.hitch(this, function(results){\r\n\t\t\t\t\t// set the new encrypted value\r\n\t\t\t\t\tthis._finalArgs[paramIndex] = results;\r\n\t\t\t\t\tthis._finishedCrypto++;\r\n\t\t\t\t\t// are we done with all encryption?\r\n\t\t\t\t\tif(this._finishedCrypto >= this._totalCrypto\r\n\t\t\t\t\t\t&& this._finishedSpawningCrypto){\r\n\t\t\t\t\t\tcallback(this._finalArgs);\r\n\t\t\t\t\t}\r\n\t\t\t\t}));\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tthis._finishedSpawningCrypto = true;\r\n\t},\r\n\r\n\t_decrypt: function(resultSet, needsDecrypt, password, callback){\r\n\t\t//console.debug(\"decrypt, resultSet=\"+resultSet+\", needsDecrypt=\"+needsDecrypt+\", password=\"+password);\r\n\t\t\r\n\t\tthis._totalCrypto = 0;\r\n\t\tthis._finishedCrypto = 0;\r\n\t\tthis._finishedSpawningCrypto = false;\r\n\t\tthis._finalResultSet = resultSet;\r\n\t\r\n\t\tfor(var i = 0; i < resultSet.length; i++){\r\n\t\t\tvar row = resultSet[i];\r\n\t\t\r\n\t\t\t// go through each of the column names in row,\r\n\t\t\t// seeing if they need decryption\r\n\t\t\tfor(var columnName in row){\r\n\t\t\t\tif(needsDecrypt == \"*\" || needsDecrypt[columnName]){\r\n\t\t\t\t\tthis._totalCrypto++;\r\n\t\t\t\t\tvar columnValue = row[columnName];\r\n\t\t\t\t\r\n\t\t\t\t\t// forming a closure here can cause issues, with values not cleanly\r\n\t\t\t\t\t// saved on Firefox/Mac OS X for some of the values above that\r\n\t\t\t\t\t// are needed in the callback below; call a subroutine that will form\r\n\t\t\t\t\t// a closure inside of itself instead\r\n\t\t\t\t\tthis._decryptSingleColumn(columnName, columnValue, password, i,\r\n\t\t\t\t\t\t\t\t\t\t\t\tfunction(finalResultSet){\r\n\t\t\t\t\t\tcallback(finalResultSet);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tthis._finishedSpawningCrypto = true;\r\n\t},\r\n\r\n\t_stripCryptoSQL: function(sql){\r\n\t\t// replace all DECRYPT(*) occurrences with a *\r\n\t\tsql = sql.replace(/DECRYPT\\(\\*\\)/ig, \"*\");\r\n\t\r\n\t\t// match any ENCRYPT(?, ?, ?, etc) occurrences,\r\n\t\t// then replace with just the question marks in the\r\n\t\t// middle\r\n\t\tvar matches = sql.match(/ENCRYPT\\([^\\)]*\\)/ig);\r\n\t\tif(matches != null){\r\n\t\t\tfor(var i = 0; i < matches.length; i++){\r\n\t\t\t\tvar encryptStatement = matches[i];\r\n\t\t\t\tvar encryptValue = encryptStatement.match(/ENCRYPT\\(([^\\)]*)\\)/i)[1];\r\n\t\t\t\tsql = sql.replace(encryptStatement, encryptValue);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// match any DECRYPT(COL1, COL2, etc) occurrences,\r\n\t\t// then replace with just the column names\r\n\t\t// in the middle\r\n\t\tmatches = sql.match(/DECRYPT\\([^\\)]*\\)/ig);\r\n\t\tif(matches != null){\r\n\t\t\tfor(i = 0; i < matches.length; i++){\r\n\t\t\t\tvar decryptStatement = matches[i];\r\n\t\t\t\tvar decryptValue = decryptStatement.match(/DECRYPT\\(([^\\)]*)\\)/i)[1];\r\n\t\t\t\tsql = sql.replace(decryptStatement, decryptValue);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\treturn sql;\r\n\t},\r\n\r\n\t_flagEncryptedArgs: function(sql, args){\r\n\t\t// capture literal strings that have question marks in them,\r\n\t\t// and also capture question marks that stand alone\r\n\t\tvar tester = new RegExp(/([\\\"][^\\\"]*\\?[^\\\"]*[\\\"])|([\\'][^\\']*\\?[^\\']*[\\'])|(\\?)/ig);\r\n\t\tvar matches;\r\n\t\tvar currentParam = 0;\r\n\t\tvar results = [];\r\n\t\twhile((matches = tester.exec(sql)) != null){\r\n\t\t\tvar currentMatch = RegExp.lastMatch+\"\";\r\n\r\n\t\t\t// are we a literal string? then ignore it\r\n\t\t\tif(/^[\\\"\\']/.test(currentMatch)){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// do we have an encrypt keyword to our left?\r\n\t\t\tvar needsEncrypt = false;\r\n\t\t\tif(/ENCRYPT\\([^\\)]*$/i.test(RegExp.leftContext)){\r\n\t\t\t\tneedsEncrypt = true;\r\n\t\t\t}\r\n\r\n\t\t\t// set the encrypted flag\r\n\t\t\tresults[currentParam] = needsEncrypt;\r\n\r\n\t\t\tcurrentParam++;\r\n\t\t}\r\n\t\r\n\t\treturn results;\r\n\t},\r\n\r\n\t_determineDecryptedColumns: function(sql){\r\n\t\tvar results = {};\r\n\r\n\t\tif(/DECRYPT\\(\\*\\)/i.test(sql)){\r\n\t\t\tresults = \"*\";\r\n\t\t}else{\r\n\t\t\tvar tester = /DECRYPT\\((?:\\s*\\w*\\s*\\,?)*\\)/ig;\r\n\t\t\tvar matches = tester.exec(sql);\r\n\t\t\twhile(matches){\r\n\t\t\t\tvar lastMatch = new String(RegExp.lastMatch);\r\n\t\t\t\tvar columnNames = lastMatch.replace(/DECRYPT\\(/i, \"\");\r\n\t\t\t\tcolumnNames = columnNames.replace(/\\)/, \"\");\r\n\t\t\t\tcolumnNames = columnNames.split(/\\s*,\\s*/);\r\n\t\t\t\tdojo.forEach(columnNames, function(column){\r\n\t\t\t\t\tif(/\\s*\\w* AS (\\w*)/i.test(column)){\r\n\t\t\t\t\t\tcolumn = column.match(/\\s*\\w* AS (\\w*)/i)[1];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresults[column] = true;\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tmatches = tester.exec(sql)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn results;\r\n\t},\r\n\r\n\t_decryptSingleColumn: function(columnName, columnValue, password, currentRowIndex,\r\n\t\t\t\t\t\t\t\t\t\t\tcallback){\r\n\t\t//console.debug(\"decryptSingleColumn, columnName=\"+columnName+\", columnValue=\"+columnValue+\", currentRowIndex=\"+currentRowIndex)\r\n\t\tdojox.sql._crypto.decrypt(columnValue, password, dojo.hitch(this, function(results){\r\n\t\t\t// set the new decrypted value\r\n\t\t\tthis._finalResultSet[currentRowIndex][columnName] = results;\r\n\t\t\tthis._finishedCrypto++;\r\n\t\t\t\r\n\t\t\t// are we done with all encryption?\r\n\t\t\tif(this._finishedCrypto >= this._totalCrypto\r\n\t\t\t\t&& this._finishedSpawningCrypto){\r\n\t\t\t\t//console.debug(\"done with all decrypts\");\r\n\t\t\t\tcallback(this._finalResultSet);\r\n\t\t\t}\r\n\t\t}));\r\n\t}\r\n});\r\n\r\n(function(){\r\n\r\n\tvar orig_sql = dojox.sql;\r\n\tdojox.sql = new Function(\"return dojox.sql._exec(arguments);\");\r\n\tdojo.mixin(dojox.sql, orig_sql);\r\n\t\r\n})();\r\n"]}