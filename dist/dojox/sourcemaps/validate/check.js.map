{"version":3,"sources":["validate/check.js"],"names":["define","kernel","lang","validate","experimental","check","form","profile","missing","invalid","results","isSuccessful","this","hasInvalid","hasMissing","length","getMissing","isMissing","elemname","i","getInvalid","isInvalid","_undef","name","object","trim","Array","elem","type","value","replace","uppercase","toUpperCase","lowercase","toLowerCase","ucfirst","word","substring","digit","required","isString","test","selectedIndex","options","checked","j","isObject","numRequired","selected","dependencies","target","constraints","tagName","indexOf","constraintResponse","isFunction","getObject","isArray","evaluateConstraint","isValid","field","message","confirm","constraint","fieldName","isValidSomething","params","slice","unshift","apply"],"mappings":"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","file":"../../validate/check.js","sourcesContent":["define([\"dojo/_base/kernel\", \"dojo/_base/lang\", \"./_base\"\r\n], function(kernel, lang, validate){\r\n\tkernel.experimental(\"dojox.validate.check\");\r\n\r\n/**\r\n\tFIXME: How much does this overlap with dojox.form.Manager and friends?\r\n\r\n\tProcedural API Description\r\n\r\n\t\tThe main aim is to make input validation expressible in a simple format.\r\n\t\tYou define profiles which declare the required and optional fields and any constraints they might have.\r\n\t\tThe results are provided as an object that makes it easy to handle missing and invalid input.\r\n\r\n\tUsage\r\n\r\n\t\tvar results = dojox.validate.check(form, profile);\r\n\r\n\tProfile Object\r\n\r\n\t\tvar profile = {\r\n\t\t\t// filters change the field value and are applied before validation.\r\n\t\t\ttrim: [\"tx1\", \"tx2\"],\r\n\t\t\tuppercase: [\"tx9\"],\r\n\t\t\tlowercase: [\"tx5\", \"tx6\", \"tx7\"],\r\n\t\t\tucfirst: [\"tx10\"],\r\n\t\t\tdigit: [\"tx11\"],\r\n\r\n\t\t\t// required input fields that are blank will be reported missing.\r\n\t\t\t// required radio button groups and drop-down lists with no selection will be reported missing.\r\n\t\t\t// checkbox groups and selectboxes can be required to have more than one value selected.\r\n\t\t\t// List required fields by name and use this notation to require more than one value: {checkboxgroup: 2}, {selectboxname: 3}.\r\n\t\t\trequired: [\"tx7\", \"tx8\", \"pw1\", \"ta1\", \"rb1\", \"rb2\", \"cb3\", \"s1\", {\"doubledip\":2}, {\"tripledip\":3}],\r\n\r\n\t\t\t// dependant/conditional fields are required if the target field is present and not blank.\r\n\t\t\t// At present only textbox, password, and textarea fields are supported.\r\n\t\t\tdependencies:\t{\r\n\t\t\t\tcc_exp: \"cc_no\",\r\n\t\t\t\tcc_type: \"cc_no\"\r\n\t\t\t},\r\n\r\n\t\t\t// Fields can be validated using any boolean valued function.\r\n\t\t\t// Custom validation fields can also return custom error messages. \r\n\t\t\t// Function name may also be written as a string (useful when passing form profile via JSON) \r\n\t\t\t// Use arrays to specify parameters in addition to the field value.\r\n\t\t\tconstraints: {\r\n\t\t\t\tfield_name1: myValidationFunction,\r\n\t\t\t\tfield_name2: [myValidationFunction, additional parameters],\r\n\t\t\t\tfield_name3: \"myValidationFunction\",\r\n\t\t\t\tfield_name4: [\"myValidationFunction\", {\"message\" : \"Value must be an integer. Please try again.\", additional parameters}]\r\n\t\t\t\tfield_name5: dojox.validate.isInteger,\r\n\t\t\t\tfield_name6: [dojox.validate.isValidDate, \"YYYY.MM.DD\"],\r\n\t\t\t\tfield_name7: [dojox.validate.isEmailAddress, false, true]\t\t\t},\r\n\r\n\t\t\t// Confirm is a sort of conditional validation.\r\n\t\t\t// It associates each field in its property list with another field whose value should be equal.\r\n\t\t\t// If the values are not equal, the field in the property list is reported as Invalid. Unless the target field is blank.\r\n\t\t\tconfirm: {\r\n\t\t\t\temail_confirm: \"email\",\r\n\t\t\t\tpw2: \"pw1\"\r\n\t\t\t}\r\n\t\t};\r\n\r\n\tResults Object\r\n\r\n\t\tisSuccessful(): Returns true if there were no invalid or missing fields, else it returns false.\r\n\t\thasMissing():  Returns true if the results contain any missing fields.\r\n\t\tgetMissing():  Returns a list of required fields that have values missing.\r\n\t\tisMissing(field):  Returns true if the field is required and the value is missing.\r\n\t\thasInvalid():  Returns true if the results contain fields with invalid data.\r\n\t\tgetInvalid():  Returns a list of fields that have invalid values and custom error messages (optional).\r\n\t\tisInvalid(field):  Returns true if the field has an invalid value.\r\n\r\n*/\r\n\r\nvalidate.check = function(/*HTMLFormElement*/form, /*Object*/profile){\r\n\t// summary:\r\n\t//\t\tvalidates user input of an HTML form based on input profile\r\n\t// description:\r\n\t//\t\treturns an object that contains several methods summarizing the results of the validation\r\n\t// form:\r\n\t//\t\tform to be validated\r\n\t// profile:\r\n\t//\t\tspecifies how the form fields are to be validated\r\n\t//\t\t{trim:Array, uppercase:Array, lowercase:Array, ucfirst:Array, digit:Array,\r\n\t//\t\trequired:Array, dependencies:Object, constraints:Object, confirm:Object}\r\n\r\n\t// Essentially private properties of results object\r\n\tvar missing = [];\r\n\tvar invalid = [];\r\n\r\n\t// results object summarizes the validation\r\n\tvar results = {\r\n\t\tisSuccessful: function() {return ( !this.hasInvalid() && !this.hasMissing() );},\r\n\t\thasMissing: function() {return ( missing.length > 0 );},\r\n\t\tgetMissing: function() {return missing;},\r\n\t\tisMissing: function(elemname) {\r\n\t\t\tfor(var i = 0; i < missing.length; i++){\r\n\t\t\t\tif(elemname == missing[i]){ return true; }\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\thasInvalid: function() {return ( invalid.length > 0 );},\r\n\t\tgetInvalid: function() {return invalid;},\r\n\t\tisInvalid: function(elemname){\r\n\t\t\tfor(var i = 0; i < invalid.length; i++){\r\n\t\t\t\tif(elemname == invalid[i]){ return true; }\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\r\n\tvar _undef = function(name,object){\r\n                return (typeof object[name] == \"undefined\");\r\n        };\r\n\r\n\t// Filters are applied before fields are validated.\r\n\t// Trim removes white space at the front and end of the fields.\r\n\tif(profile.trim instanceof Array){\r\n\t\tfor(var i = 0; i < profile.trim.length; i++){\r\n\t\t\tvar elem = form[profile.trim[i]];\r\n\t\t\tif(_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\r\n\t\t\telem.value = elem.value.replace(/(^\\s*|\\s*$)/g, \"\");\r\n\t\t}\r\n\t}\r\n\t// Convert to uppercase\r\n\tif(profile.uppercase instanceof Array){\r\n\t\tfor(var i = 0; i < profile.uppercase.length; i++){\r\n\t\t\tvar elem = form[profile.uppercase[i]];\r\n\t\t\tif(_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\r\n\t\t\telem.value = elem.value.toUpperCase();\r\n\t\t}\r\n\t}\r\n\t// Convert to lowercase\r\n\tif(profile.lowercase instanceof Array){\r\n\t\tfor (var i = 0; i < profile.lowercase.length; i++){\r\n\t\t\tvar elem = form[profile.lowercase[i]];\r\n\t\t\tif(_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\r\n\t\t\telem.value = elem.value.toLowerCase();\r\n\t\t}\r\n\t}\r\n\t// Uppercase first letter\r\n\tif(profile.ucfirst instanceof Array){\r\n\t\tfor(var i = 0; i < profile.ucfirst.length; i++){\r\n\t\t\tvar elem = form[profile.ucfirst[i]];\r\n\t\t\tif(_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\r\n\t\t\telem.value = elem.value.replace(/\\b\\w+\\b/g, function(word) { return word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase(); });\r\n\t\t}\r\n\t}\r\n\t// Remove non digits characters from the input.\r\n\tif(profile.digit instanceof Array){\r\n\t\tfor(var i = 0; i < profile.digit.length; i++){\r\n\t\t\tvar elem = form[profile.digit[i]];\r\n\t\t\tif(_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\r\n\t\t\telem.value = elem.value.replace(/\\D/g, \"\");\r\n\t\t}\r\n\t}\r\n\r\n\t// See if required input fields have values missing.\r\n\tif(profile.required instanceof Array){\r\n\t\tfor(var i = 0; i < profile.required.length; i++){\r\n\t\t\tif(!lang.isString(profile.required[i])){ continue; }\r\n\t\t\tvar elem = form[profile.required[i]];\r\n\t\t\t// Are textbox, textarea, or password fields blank.\r\n\t\t\tif(!_undef(\"type\", elem)\r\n\t\t\t\t&& (elem.type == \"text\" || elem.type == \"textarea\" || elem.type == \"password\" || elem.type == \"file\")\r\n\t\t\t\t&& /^\\s*$/.test(elem.value)){\r\n\t\t\t\tmissing[missing.length] = elem.name;\r\n\t\t\t}\r\n\t\t\t// Does drop-down box have option selected.\r\n\t\t\telse if(!_undef(\"type\", elem) && (elem.type == \"select-one\" || elem.type == \"select-multiple\")\r\n\t\t\t\t\t\t&& (elem.selectedIndex == -1\r\n\t\t\t\t\t\t|| /^\\s*$/.test(elem.options[elem.selectedIndex].value))){\r\n\t\t\t\tmissing[missing.length] = elem.name;\r\n\t\t\t}\r\n\t\t\t// Does radio button group (or check box group) have option checked.\r\n\t\t\telse if(elem instanceof Array){\r\n\t\t\t\tvar checked = false;\r\n\t\t\t\tfor(var j = 0; j < elem.length; j++){\r\n\t\t\t\t\tif (elem[j].checked) { checked = true; }\r\n\t\t\t\t}\r\n\t\t\t\tif(!checked){\r\n\t\t\t\t\tmissing[missing.length] = elem[0].name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// See if checkbox groups and select boxes have x number of required values.\r\n\tif(profile.required instanceof Array){\r\n\t\tfor (var i = 0; i < profile.required.length; i++){\r\n\t\t\tif(!lang.isObject(profile.required[i])){ continue; }\r\n\t\t\tvar elem, numRequired;\r\n\t\t\tfor(var name in profile.required[i]){\r\n\t\t\t\telem = form[name];\r\n\t\t\t\tnumRequired = profile.required[i][name];\r\n\t\t\t}\r\n\t\t\t// case 1: elem is a check box group\r\n\t\t\tif(elem instanceof Array){\r\n\t\t\t\tvar checked = 0;\r\n\t\t\t\tfor(var j = 0; j < elem.length; j++){\r\n\t\t\t\t\tif(elem[j].checked){ checked++; }\r\n\t\t\t\t}\r\n\t\t\t\tif(checked < numRequired){\r\n\t\t\t\t\tmissing[missing.length] = elem[0].name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// case 2: elem is a select box\r\n\t\t\telse if(!_undef(\"type\", elem) && elem.type == \"select-multiple\" ){\r\n\t\t\t\tvar selected = 0;\r\n\t\t\t\tfor(var j = 0; j < elem.options.length; j++){\r\n\t\t\t\t\tif (elem.options[j].selected && !/^\\s*$/.test(elem.options[j].value)) { selected++; }\r\n\t\t\t\t}\r\n\t\t\t\tif(selected < numRequired){\r\n\t\t\t\t\tmissing[missing.length] = elem.name;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Dependent fields are required when the target field is present (not blank).\r\n\t// Todo: Support dependent and target fields that are radio button groups, or select drop-down lists.\r\n\t// Todo: Make the dependency based on a specific value of the target field.\r\n\t// Todo: allow dependent fields to have several required values, like {checkboxgroup: 3}.\r\n\tif(lang.isObject(profile.dependencies)){\r\n\t\t// properties of dependencies object are the names of dependent fields to be checked\r\n\t\tfor(name in profile.dependencies){\r\n\t\t\tvar elem = form[name];\t// the dependent element\r\n\t\t\tif(_undef(\"type\", elem)){continue;}\r\n\t\t\tif(elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; } // limited support\r\n\t\t\tif(/\\S+/.test(elem.value)){ continue; }\t// has a value already\r\n\t\t\tif(results.isMissing(elem.name)){ continue; }\t// already listed as missing\r\n\t\t\tvar target = form[profile.dependencies[name]];\r\n\t\t\tif(target.type != \"text\" && target.type != \"textarea\" && target.type != \"password\"){ continue; }\t// limited support\r\n\t\t\tif(/^\\s*$/.test(target.value)){ continue; }\t// skip if blank\r\n\t\t\tmissing[missing.length] = elem.name;\t// ok the dependent field is missing\r\n\t\t}\r\n\t}\r\n\r\n\t// Find invalid input fields.\r\n\tif(lang.isObject(profile.constraints)){\r\n\t\t// constraint properties are the names of fields to be validated\r\n\t\tfor(name in profile.constraints){\r\n\t\t\tvar elem = form[name];\r\n\t\t\tif(!elem) {continue;}\r\n\r\n\t\t\t// skip if blank - its optional unless required, in which case it\r\n\t\t\t// is already listed as missing.\r\n\t\t\tif(!_undef(\"tagName\",elem)\r\n\t\t\t\t&& (elem.tagName.toLowerCase().indexOf(\"input\") >= 0\r\n\t\t\t\t\t|| elem.tagName.toLowerCase().indexOf(\"textarea\") >= 0)\r\n\t\t\t\t&& /^\\s*$/.test(elem.value)){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// constraintResponse should have two properties: isValid(bool), message(string)\r\n\t\t\tvar constraintResponse;\r\n\t\t\t// case 1: constraint value is validation function\r\n\t\t\tif(lang.isFunction(profile.constraints[name])){\r\n\t\t\t\tconstraintResponse = profile.constraints[name](elem.value);\r\n\t\t\t}else if(lang.isFunction(lang.getObject(name, false, profile.constraints))){\r\n\t\t\t\t// case 2: constraint value is validation function name as string\r\n\t\t\t\tconstraintResponse = lang.getObject(name, false, profile.constraints)(elem.value);\r\n\t\t\t}else if(lang.isArray(profile.constraints[name])){\r\n\r\n\t\t\t\t// handle nested arrays for multiple constraints\r\n\t\t\t\tif(lang.isArray(profile.constraints[name][0])){\r\n\t\t\t\t\tfor(var i=0; i<profile.constraints[name].length; i++){\r\n\t\t\t\t\t\tconstraintResponse = validate.evaluateConstraint(profile, profile.constraints[name][i], name, elem);\r\n\t\t\t\t\t\tif(!constraintResponse.isValid){ break; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// case 3: constraint value is array, first elem is function,\r\n\t\t\t\t\t// tail is parameters\r\n\t\t\t\t\tif(lang.isFunction(lang.getObject(name, false, profile.constraints))){\r\n\t\t\t\t\t\t\tconstraintResponse = validate.evaluateConstraint(profile, profile.constraints[profile.constraints[name]], name, elem);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\tconstraintResponse = validate.evaluateConstraint(profile, profile.constraints[name], name, elem);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if constraintResponse is false (backwards compatibility with last version) or if property isValid is false, return the invalid field name and/or the constraintResponse message\r\n\t\t\tif(!constraintResponse){\r\n\t\t\t\tinvalid[invalid.length] = elem.name;\r\n\t\t\t}else if(!constraintResponse.isValid){\r\n\t\t\t\tinvalid[invalid.length] = { field : elem.name, message : constraintResponse.message };\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Find unequal confirm fields and report them as Invalid.\r\n\tif(lang.isObject(profile.confirm)){\r\n\t\tfor(name in profile.confirm){\r\n\t\t\tvar elem = form[name];\t// the confirm element\r\n\t\t\tvar target = form[profile.confirm[name]];\r\n\t\t\tif (_undef(\"type\", elem) || _undef(\"type\", target) || (elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\")\r\n\t\t\t\t||(target.type != elem.type)\r\n\t\t\t\t||(target.value == elem.value)\t// it's valid\r\n\t\t\t\t||(results.isInvalid(elem.name))// already listed as invalid\r\n\t\t\t\t||(/^\\s*$/.test(target.value)))\t// skip if blank - only confirm if target has a value\r\n\t\t\t{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tinvalid[invalid.length] = elem.name;\r\n\t\t}\r\n\t}\r\n\treturn results; // Object\r\n};\r\n\r\n//TODO: evaluateConstraint doesn't use profile or fieldName args?\r\nvalidate.evaluateConstraint=function(profile, /*Array*/constraint, fieldName, elem){\r\n\t// summary:\r\n\t//\t\tEvaluates dojo.validate.check() constraints that are specified as array\r\n\t//\t\targuments\r\n\t// description:\r\n\t//\t\tThe arrays are expected to be in the format of:\r\n\t//\t|    constraints:{\r\n\t//\t|            fieldName: [functionToCall, param1, param2, etc.],\r\n\t//\t|            fieldName: [[functionToCallFirst, param1],[functionToCallSecond,param2]]\r\n\t//\t|    }\r\n\t//\r\n\t//\t\tThis function evaluates a single array function in the format of:\r\n\t//\t\t[functionName, argument1, argument2, etc]\r\n\t//\r\n\t//\t\tThe function will be parsed out and evaluated against the incoming parameters.\r\n\t// profile:\r\n\t//\t\tThe dojo.validate.check() profile that this evaluation is against.\r\n\t// constraint:\r\n\t//\t\tThe single [] array of function and arguments for the function.\r\n\t// fieldName:\r\n\t//\t\tThe form dom name of the field being validated.\r\n\t// elem:\r\n\t//\t\tThe form element field.\r\n\r\n \tvar isValidSomething = constraint[0];\r\n\tvar params = constraint.slice(1);\r\n\tparams.unshift(elem.value);\r\n\tif(typeof isValidSomething != \"undefined\" && typeof isValidSomething != \"string\"){\r\n\t\treturn isValidSomething.apply(null, params);\r\n\t}else if(typeof isValidSomething != \"undefined\" && typeof isValidSomething == \"string\"){\r\n\t\tif(lang.isFunction(lang.getObject(isValidSomething))){\r\n\t\t\treturn lang.getObject(isValidSomething).apply(null, params);\r\n\t\t}\r\n\t}\r\n\treturn false; // Boolean\r\n};\r\n\r\nreturn validate.check;\r\n});\r\n"]}