{"version":3,"sources":["store/transaction.js"],"names":["define","Memory","Cache","when","aspect","lang","defaultTransactionLogStore","stores","nextStoreId","options","masterStore","cachingStore","storeId","id","storeName","name","transactionLogStore","autoCommit","addToLog","method","execute","target","transactionStore","this","result","e","errorHandler","error","call","previousId","getIdentity","undefined","previous","get","add","objectId","before","object","existingId","put","remove","delegate","console","commit","query","map","action","store","notify","transaction"],"mappings":";;;;;;;AAAAA,QAAQ,oBAAqB,mBAAoB,YAAa,cAAe,mBAC5E,SAASC,EAAQC,EAAOC,EAAMC,EAAQC,GAUtC,IAAIC,EACAC,KACAC,EAAc,EAClB,OAAO,SAASC,GAEf,IAAIC,GADJD,EAAUA,OACgBC,YACtBC,EAAeF,EAAQE,aACvBC,EAAUF,EAAYG,IAAMH,EAAYI,WAAaJ,EAAYK,OAASL,EAAYG,GAAKL,KAC5FI,IACFL,EAAOK,GAAWF,GAEnB,IAAIM,EAAsBP,EAAQO,qBAAuBV,IACtDA,EAA6B,IAAIL,GAChCgB,GAAa,EACjB,SAASC,EAASC,GACjB,OAAO,SAASC,EAAQC,EAAQZ,GAC/B,IAAIa,EAAmBC,KACvB,GAAGN,EAAW,CAEb,IAAIO,EAASd,EAAYS,GAAQE,EAAQZ,GAUzC,OATAN,EAAKqB,EAAQ,KAAM,SAASC,GACxBH,EAAiBI,aAAaD,KAEhCR,GAAa,EACbR,EAAQkB,MAAQF,EAChBL,EAAQQ,KAAKN,EAAkBD,EAAQZ,GACvCQ,GAAa,KAGRO,EAGP,IAAIK,EAAwB,WAAXV,EAAsBE,EAASC,EAAiBQ,YAAYT,GAC7E,QAAkBU,IAAfF,EACF,IAAIG,EAAWrB,EAAasB,IAAIJ,GAEjC,OAAO1B,EAAK6B,EAAU,SAASA,GAC9B,OAAO7B,EAAKa,EAAoBkB,KAC/BC,SAAUN,EACVV,OAAQA,EACRE,OAAQA,EACRW,SAAUA,EACVvB,QAASA,EACTG,QAASA,IACN,WACH,OAAOS,OAeZ,OAPAjB,EAAOgC,OAAO1B,EAAa,SAAU,SAAS2B,EAAQC,GAClDD,EACF1B,EAAa4B,IAAIF,GAEjB1B,EAAa6B,OAAOF,KAGf,IAAIpC,EAAMG,EAAKoC,SAAS/B,GAC9B6B,IAAKrB,EAAS,OACdgB,IAAKhB,EAAS,OACdsB,OAAQtB,EAAS,UACjBQ,aAAc,SAASC,GAMtB,OADAe,QAAQf,MAAMA,IACP,GAERgB,OAAQ,WAEP1B,GAAa,EACb,IAAIK,EAAmBC,KAEvB,OAAOP,EAAoB4B,UAAUC,IAAI,SAASC,GAEjD,IAGItB,EAHAL,EAAS2B,EAAO3B,OAChB4B,EAAQxC,EAAOuC,EAAOlC,SACtBS,EAASyB,EAAOzB,OAEpB,IAECG,EAASuB,EAAM5B,GAAQE,EAAQyB,EAAOrC,SACtC,MAAMgB,GAEN,IAAc,KADdD,EAASF,EAAiBI,aAAaD,IAGtC,OAAOA,GACY,IAAXD,IAEM,QAAXL,EACFR,EAAa6B,OAAOM,EAAOX,UAE3BxB,EAAa4B,IAAIlB,GAElB0B,EAAMC,QAAUD,EAAMC,OAAkB,QAAX7B,EAAmB,KAAO2B,EAAOd,SAClD,WAAXb,OAAsBY,EAAYe,EAAOX,WAE3CX,EAASC,EAKV,OADAT,EAAoBwB,OAAOM,EAAOjC,IAC3BW,KAGTyB,YAAa,WAEZhC,GAAa,EACb,IAAIK,EAAmBC,KACvB,OACCoB,OAAQ,WACP,OAAOrB,EAAiBqB,cAIxBhC,EAAcF","file":"../../store/transaction.js","sourcesContent":["define(['dojo/store/Memory', 'dojo/store/Cache', 'dojo/when', 'dojo/aspect', 'dojo/_base/lang'],\r\n\tfunction(Memory, Cache, when, aspect, lang){\r\n// summary:\r\n//\t\tThis is a transaction managing store. When transaction is started, by calling store.transaction(),\r\n//\t\tall request operations (put, add, remove), are entered into a transaction log. When commit() is\r\n//\t\tcalled, the actions in the log are then committed. This store relies on three other stores,\r\n//\t\textending the dojo/store/Cache:\r\n//\t\t\t* masterStore - like with Cache, this store is the ultimate authority, and is usually connected to the backend\r\n//\t\t\t* cachingStore - This store includes local data, including changes within the current transaction\r\n//\t\t\t* transactionLogStore - This store holds the log of actions that need to be committed to the masterStore on the next commit\r\n\r\n\tvar defaultTransactionLogStore;\r\n\tvar stores = {};\r\n\tvar nextStoreId = 1;\r\n\treturn function(options){\r\n\t\toptions = options || {};\r\n\t\tvar masterStore = options.masterStore;\r\n\t\tvar cachingStore = options.cachingStore;\r\n\t\tvar storeId = masterStore.id || masterStore.storeName || masterStore.name || (masterStore.id = nextStoreId++);\r\n\t\tif(storeId){\r\n\t\t\tstores[storeId] = masterStore;\r\n\t\t}\r\n\t\tvar transactionLogStore = options.transactionLogStore || defaultTransactionLogStore ||\r\n\t\t\t\t(defaultTransactionLogStore = new Memory());\r\n\t\tvar autoCommit = true;\r\n\t\tfunction addToLog(method){\r\n\t\t\treturn function execute(target, options){\r\n\t\t\t\tvar transactionStore = this;\r\n\t\t\t\tif(autoCommit){\r\n\t\t\t\t\t// immediately perform the action\r\n\t\t\t\t\tvar result = masterStore[method](target, options);\r\n\t\t\t\t\twhen(result, null, function(e){\r\n\t\t\t\t\t\tif(transactionStore.errorHandler(e)){\r\n\t\t\t\t\t\t\t// failed, and the errorHandler has signaled that it should be requeued\r\n\t\t\t\t\t\t\tautoCommit = false;\r\n\t\t\t\t\t\t\toptions.error = e;\r\n\t\t\t\t\t\t\texecute.call(transactionStore, target, options);\r\n\t\t\t\t\t\t\tautoCommit = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t// add to the transaction log\r\n\t\t\t\t\tvar previousId = method === 'remove' ? target : transactionStore.getIdentity(target);\r\n\t\t\t\t\tif(previousId !== undefined){\r\n\t\t\t\t\t\tvar previous = cachingStore.get(previousId);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn when(previous, function(previous){\r\n\t\t\t\t\t\treturn when(transactionLogStore.add({\r\n\t\t\t\t\t\t\tobjectId: previousId,\r\n\t\t\t\t\t\t\tmethod: method,\r\n\t\t\t\t\t\t\ttarget: target,\r\n\t\t\t\t\t\t\tprevious: previous,\r\n\t\t\t\t\t\t\toptions: options,\r\n\t\t\t\t\t\t\tstoreId: storeId\r\n\t\t\t\t\t\t}), function(){\r\n\t\t\t\t\t\t\treturn target;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}\r\n\t\t// we need to listen for any notifications from the master store, and propagate these to the caching store\r\n\t\t// this arguably should actually be done in dojo/store/Cache\r\n\t\taspect.before(masterStore, 'notify', function(object, existingId){\r\n\t\t\tif(object){\r\n\t\t\t\tcachingStore.put(object);\r\n\t\t\t}else{\r\n\t\t\t\tcachingStore.remove(existingId);\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn new Cache(lang.delegate(masterStore, {\r\n\t\t\tput: addToLog('put'),\r\n\t\t\tadd: addToLog('add'),\r\n\t\t\tremove: addToLog('remove'),\r\n\t\t\terrorHandler: function(error){\r\n\t\t\t\t// this is called whenever an error occurs when attempting to commit transactional actions\r\n\t\t\t\t// this can return true to indicate that the action should be reattempted in the next commit\r\n\t\t\t\t// this can return false to indicate that the action should be reverted\r\n\t\t\t\t// if this returns undefined, no action will be taken\r\n\t\t\t\tconsole.error(error);\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t\tcommit: function(){\r\n\t\t\t\t// commit everything in the transaction log\r\n\t\t\t\tautoCommit = true;\r\n\t\t\t\tvar transactionStore = this;\r\n\t\t\t\t// query for everything in the log\r\n\t\t\t\treturn transactionLogStore.query({}).map(function(action){\r\n\t\t\t\t\t//var options = action.options || {};\r\n\t\t\t\t\tvar method = action.method;\r\n\t\t\t\t\tvar store = stores[action.storeId];\r\n\t\t\t\t\tvar target = action.target;\r\n\t\t\t\t\tvar result;\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\t// execute the queued action\r\n\t\t\t\t\t\tresult = store[method](target, action.options);\r\n\t\t\t\t\t}catch(e){\r\n\t\t\t\t\t\tresult = transactionStore.errorHandler(e);\r\n\t\t\t\t\t\tif(result === true){\r\n\t\t\t\t\t\t\t// don't remove it from the log, let it be executed again\r\n\t\t\t\t\t\t\treturn e;\r\n\t\t\t\t\t\t}else if(result === false){\r\n\t\t\t\t\t\t\t// revert, by sending out a notification and updating the caching store\r\n\t\t\t\t\t\t\tif(method === 'add'){\r\n\t\t\t\t\t\t\t\tcachingStore.remove(action.objectId);\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\tcachingStore.put(target);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tstore.notify && store.notify(method === 'add' ? null : action.previous,\r\n\t\t\t\t\t\t\t\tmethod === 'remove' ? undefined : action.objectId);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tresult = e;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// fired it, can remove now\r\n\t\t\t\t\t// TODO: handle async\r\n\t\t\t\t\ttransactionLogStore.remove(action.id);\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\ttransaction: function(){\r\n\t\t\t\t// start a new transaction (by just turning off autoCommit)\r\n\t\t\t\tautoCommit = false;\r\n\t\t\t\tvar transactionStore = this;\r\n\t\t\t\treturn {\r\n\t\t\t\t\tcommit: function(){\r\n\t\t\t\t\t\treturn transactionStore.commit();\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}), cachingStore, options);\r\n\t};\r\n});"]}