{"version":3,"sources":["store/db/IndexedDB.js"],"names":["define","declare","lang","Deferred","when","all","SimpleQueryEngine","QueryResults","makePromise","request","deferred","onsuccess","event","resolve","target","result","onerror","error","message","webkitErrorMessage","reject","promise","cursorQueue","maxConcurrent","cursorsRunning","wildcardRe","queueCursor","cursor","priority","retry","length","push","sort","a","b","cursorObject","pop","e","name","yes","queryFromFilter","source","promisedResults","started","callbacks","forEach","callback","thisObj","then","results","filter","value","i","l","call","total","done","map","mapped","errback","IDBKeyRange","window","webkitIDBKeyRange","constructor","options","safeMixin","this","store","dbConfig","index","indices","stores","storeName","cachedCount","preference","db","openRequest","indexedDB","open","parseInt","version","onupgradeneeded","storeConfig","objectStoreNames","contains","idbStore","transaction","objectStore","idProperty","createObjectStore","keyPath","autoIncrement","indexNames","indexed","createIndex","available","queryEngine","_currentTransaction","abort","commit","_getTransaction","oncomplete","console","_callOnStore","method","args","returnRequest","callOnStore","currentTransaction","allowRetry","apply","get","id","getIdentity","object","put","overwrite","add","remove","query","keyRange","start","count","Infinity","sortOption","sortOptions","sorter","totals","collectedCount","inCount","reduce","arguments","queues","collected","part","queue","addToQueue","nextInQueues","toMerge","every","next","nextSelected","indexOf","shift","queryResults","advance","bestIndex","filterValue","descending","cursorRequestArgs","queryId","JSON","stringify","bestIndexQuality","indexTries","tryIndex","indexName","quality","factor","indexDefinition","wildcard","range","newFilterValue","from","to","test","bound","excludeFrom","excludeTo","lowerBound","upperBound","first","match","only","item","some","slice","matchStart","RegExp","mainSort","attribute","postSorting","cachedPosition","offset","preFilterOffset","mixin","filteredResults","adjustTotal","countPromise","Math","round","openCursor","cursorRequest","join","matches","lastCursor","sortedResults","delegate","rawResults"],"mappings":"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","file":"../../../store/db/IndexedDB.js","sourcesContent":["define(['dojo/_base/declare', 'dojo/_base/lang', 'dojo/Deferred', 'dojo/when', 'dojo/promise/all', 'dojo/store/util/SimpleQueryEngine', 'dojo/store/util/QueryResults'],\r\n\tfunction(declare, lang, Deferred, when, all,  SimpleQueryEngine, QueryResults){\r\n\r\n\tfunction makePromise(request) {\r\n\t\tvar deferred = new Deferred();\r\n\t\trequest.onsuccess = function(event) {\r\n\t\t\tdeferred.resolve(event.target.result);\r\n\t\t};\r\n\t\trequest.onerror = function() {\r\n\t\t\trequest.error.message = request.webkitErrorMessage;\r\n\t\t\tdeferred.reject(request.error);\r\n\t\t};\r\n\t\treturn deferred.promise;\r\n\t}\r\n\r\n\t// we keep a queue of cursors, so we can prioritize the traversal of result sets\r\n\tvar cursorQueue = [];\r\n\tvar maxConcurrent = 1;\r\n\tvar cursorsRunning = 0;\r\n\tvar wildcardRe = /(.*)\\*$/;\r\n\tfunction queueCursor(cursor, priority, retry) {\r\n\t\t// process the cursor queue, possibly submitting a cursor for continuation\r\n\t\tif (cursorsRunning || cursorQueue.length) {\r\n\t\t\t// actively processing\r\n\t\t\tif (cursor) {\r\n\t\t\t\t// add to queue\r\n\t\t\t\tcursorQueue.push({cursor: cursor, priority: priority, retry: retry});\r\n\t\t\t\t// keep the queue in priority order\r\n\t\t\t\tcursorQueue.sort(function(a, b) {\r\n\t\t\t\t\treturn a.priority > b.priority ? 1 : -1;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (cursorsRunning >= maxConcurrent) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar cursorObject = cursorQueue.pop();\r\n\t\t\tcursor = cursorObject && cursorObject.cursor;\r\n\t\t}//else nothing in the queue, just shortcut directly to continuing the cursor\r\n\t\tif (cursor) {\r\n\t\t\ttry {\r\n\t\t\t\t// submit the continuation of the highest priority cursor\r\n\t\t\t\tcursor['continue']();\r\n\t\t\t\tcursorsRunning++;\r\n\t\t\t} catch(e) {\r\n\t\t\t\tif ((e.name === 'TransactionInactiveError' || e.name === 0) && cursorObject) { // == 0 is IndexedDBShim\r\n\t\t\t\t\t// if the cursor has been interrupted we usually need to create a new transaction, \r\n\t\t\t\t\t// handing control back to the query/filter function to open the cursor again\r\n\t\t\t\t\tcursorObject.retry();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow e;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction yes(){\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// a query results API based on a source with a filter method that is expected to be called only once.  All iterative methods are\r\n\t// implemented in terms of forEach that will call the filter only once and subsequently use the promised results.\r\n\t// will also copy the `total` property as well.\r\n\tfunction queryFromFilter(source) {\r\n\t\tvar promisedResults, started, callbacks = [];\r\n\t\t// this is the main iterative function that will ensure we will only do a low level iteratation of the result set once.\r\n\t\tfunction forEach(callback, thisObj) {\r\n\t\t\tif (started) {\r\n\t\t\t\t// we have already iterated the query results, just hook into the existing promised results\r\n\t\t\t\tcallback && promisedResults.then(function(results) {\r\n\t\t\t\t\tresults.forEach(callback, thisObj);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\t// first call, start the filter iterator, getting the results as a promise, so we can connect to that each subsequent time\r\n\t\t\t\tcallback && callbacks.push(callback);\r\n\t\t\t\tif(!promisedResults){\r\n\t\t\t\t\tpromisedResults = source.filter(function(value) {\r\n\t\t\t\t\t\tstarted = true;\r\n\t\t\t\t\t\tfor(var i = 0, l = callbacks.length; i < l; i++){\r\n\t\t\t\t\t\t\tcallbacks[i].call(thisObj, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn promisedResults;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttotal: source.total,\r\n\t\t\tfilter: function(callback, thisObj) {\r\n\t\t\t\tvar done;\r\n\t\t\t\treturn forEach(function(value) {\r\n\t\t\t\t\tif (!done) {\r\n\t\t\t\t\t\tdone = !callback.call(thisObj, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tforEach: forEach,\r\n\t\t\tmap: function(callback, thisObj) {\r\n\t\t\t\tvar mapped = [];\r\n\t\t\t\treturn forEach(function(value) {\r\n\t\t\t\t\tmapped.push(callback.call(thisObj, value));\r\n\t\t\t\t}).then(function() {\r\n\t\t\t\t\treturn mapped;\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tthen: function(callback, errback) {\r\n\t\t\t\treturn forEach().then(callback, errback);\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\tvar IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange;\r\n\treturn declare(null, {\r\n\t\t// summary:\r\n\t\t//\t\tThis is a basic store for IndexedDB. It implements dojo/store/api/Store.\r\n\r\n\t\tconstructor: function(options) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tThis is a basic store for IndexedDB.\r\n\t\t\t// options:\r\n\t\t\t//\t\tThis provides any configuration information that will be mixed into the store\r\n\r\n\t\t\tdeclare.safeMixin(this, options);\r\n\t\t\tvar store = this;\r\n\t\t\tvar dbConfig = this.dbConfig;\r\n\t\t\tthis.indices = dbConfig.stores[this.storeName];\r\n\t\t\tthis.cachedCount = {};\r\n\t\t\tfor (var index in store.indices) {\r\n\t\t\t\tvar value = store.indices[index];\r\n\t\t\t\tif (typeof value === 'number') {\r\n\t\t\t\t\tstore.indices[index] = {\r\n\t\t\t\t\t\tpreference: value\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.db = this.db || dbConfig.db;\r\n\r\n\t\t\tif (!this.db) {\r\n\t\t\t\tvar openRequest = dbConfig.openRequest;\r\n\t\t\t\tif (!openRequest) {\r\n\t\t\t\t\topenRequest = dbConfig.openRequest = window.indexedDB.open(dbConfig.name || 'dojo-db',\r\n\t\t\t\t\t\tparseInt(dbConfig.version, 10));\r\n\t\t\t\t\topenRequest.onupgradeneeded = function() {\r\n\t\t\t\t\t\tvar db = store.db = openRequest.result;\r\n\t\t\t\t\t\tfor (var storeName in dbConfig.stores) {\r\n\t\t\t\t\t\t\tvar storeConfig = dbConfig.stores[storeName];\r\n\t\t\t\t\t\t\tif (!db.objectStoreNames.contains(storeName)) {\r\n\t\t\t\t\t\t\t\tvar idProperty = storeConfig.idProperty || 'id';\r\n\t\t\t\t\t\t\t\tvar idbStore = db.createObjectStore(storeName, {\r\n\t\t\t\t\t\t\t\t\tkeyPath: idProperty,\r\n\t\t\t\t\t\t\t\t\tautoIncrement: storeConfig[idProperty] &&\r\n\t\t\t\t\t\t\t\t\t\tstoreConfig[idProperty].autoIncrement || false\r\n\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tidbStore = openRequest.transaction.objectStore(storeName);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tfor (var index in storeConfig) {\r\n\t\t\t\t\t\t\t\tif (!idbStore.indexNames.contains(index) && index !== 'autoIncrement' &&\r\n\t\t\t\t\t\t\t\t\t\tstoreConfig[index].indexed !== false) {\r\n\t\t\t\t\t\t\t\t\tidbStore.createIndex(index, index, storeConfig[index]);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\tdbConfig.available = makePromise(openRequest);\r\n\t\t\t\t}\r\n\t\t\t\tthis.available = dbConfig.available.then(function(db){\r\n\t\t\t\t\treturn store.db = db;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// idProperty: String\r\n\t\t//\t\tIndicates the property to use as the identity property. The values of this\r\n\t\t//\t\tproperty should be unique.\r\n\t\tidProperty: 'id',\r\n\r\n\t\tstoreName: '',\r\n\r\n\t\t// indices:\r\n\t\t//\t\ta hash of the preference of indices, indices that are likely to have very\r\n\t\t//\t\tunique values should have the highest numbers\r\n\t\t//\t\tas a reference, sorting is always set at 1, so properties that are higher than\r\n\t\t//\t\tone will trigger filtering with index and then sort the whole set.\r\n\t\t//\t\twe recommend setting boolean values at 0.1.\r\n\t\tindices: {\r\n\t\t\t/*\r\n\t\t\tproperty: {\r\n\t\t\t\tpreference: 1,\r\n\t\t\t\tmultiEntry: true\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t},\r\n\r\n\t\tqueryEngine: SimpleQueryEngine,\r\n\r\n\t\ttransaction: function() {\r\n\t\t\tvar store = this;\r\n\t\t\tthis._currentTransaction = null;// get rid of the last transaction\r\n\t\t\treturn {\r\n\t\t\t\tabort: function() {\r\n\t\t\t\t\tstore._currentTransaction.abort();\r\n\t\t\t\t},\r\n\t\t\t\tcommit: function() {\r\n\t\t\t\t\t// noop, idb does auto-commits\r\n\t\t\t\t\tstore._currentTransaction = null;// get rid of the last transaction\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_getTransaction: function() {\r\n\t\t\tif (!this._currentTransaction) {\r\n\t\t\t\tthis._currentTransaction = this.db.transaction([this.storeName], 'readwrite');\r\n\t\t\t\tvar store = this;\r\n\t\t\t\tthis._currentTransaction.oncomplete = function() {\r\n\t\t\t\t\t// null it out so we will use a new one next time\r\n\t\t\t\t\tstore._currentTransaction = null;\r\n\t\t\t\t};\r\n\t\t\t\tthis._currentTransaction.onerror = function(error) {\r\n\t\t\t\t\tconsole.error(error);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\treturn this._currentTransaction;\r\n\t\t},\r\n\r\n\t\t_callOnStore: function(method, args, index, returnRequest) {\r\n\t\t\t// calls a method on the IndexedDB store\r\n\t\t\tvar store = this;\r\n\t\t\treturn when(this.available, function callOnStore() {\r\n\t\t\t\tvar currentTransaction = store._currentTransaction;\r\n\t\t\t\tif (currentTransaction) {\r\n\t\t\t\t\tvar allowRetry = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentTransaction = store._getTransaction();\r\n\t\t\t\t}\r\n\t\t\t\tvar request, idbStore;\r\n\t\t\t\tif (allowRetry) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tidbStore = currentTransaction.objectStore(store.storeName);\r\n\t\t\t\t\t\tif (index) {\r\n\t\t\t\t\t\t\tidbStore = idbStore.index(index);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trequest = idbStore[method].apply(idbStore, args);\r\n\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\tif (e.name === 'TransactionInactiveError' || e.name === 'InvalidStateError') {\r\n\t\t\t\t\t\t\tstore._currentTransaction = null;\r\n\t\t\t\t\t\t\t//retry\r\n\t\t\t\t\t\t\treturn callOnStore();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tthrow e;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tidbStore = currentTransaction.objectStore(store.storeName);\r\n\t\t\t\t\tif (index) {\r\n\t\t\t\t\t\tidbStore = idbStore.index(index);\r\n\t\t\t\t\t}\r\n\t\t\t\t\trequest = idbStore[method].apply(idbStore, args);\r\n\t\t\t\t}\r\n\t\t\t\treturn returnRequest ? request : makePromise(request);\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tget: function(id) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tRetrieves an object by its identity.\r\n\t\t\t// id: Number\r\n\t\t\t//\t\tThe identity to use to lookup the object\r\n\t\t\t// options: Object?\r\n\t\t\t// returns: dojo//Deferred\r\n\r\n\t\t\treturn this._callOnStore('get',[id]);\r\n\t\t},\r\n\r\n\t\tgetIdentity: function(object) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tReturns an object's identity\r\n\t\t\t// object: Object\r\n\t\t\t//\t\tThe object to get the identity from\r\n\t\t\t// returns: Number\r\n\r\n\t\t\treturn object[this.idProperty];\r\n\t\t},\r\n\r\n\t\tput: function(object, options) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tStores an object.\r\n\t\t\t// object: Object\r\n\t\t\t//\t\tThe object to store.\r\n\t\t\t// options: __PutDirectives?\r\n\t\t\t//\t\tAdditional metadata for storing the data.  Includes an \"id\"\r\n\t\t\t//\t\tproperty if a specific id is to be used.\r\n\t\t\t// returns: dojo/Deferred\r\n\r\n\t\t\toptions = options || {};\r\n\t\t\tthis.cachedCount = {}; // clear the count cache\r\n\t\t\treturn this._callOnStore(options.overwrite === false ? 'add' : 'put',[object]);\r\n\t\t},\r\n\r\n\t\tadd: function(object, options) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tAdds an object.\r\n\t\t\t// object: Object\r\n\t\t\t//\t\tThe object to store.\r\n\t\t\t// options: __PutDirectives?\r\n\t\t\t//\t\tAdditional metadata for storing the data.  Includes an \"id\"\r\n\t\t\t//\t\tproperty if a specific id is to be used.\r\n\t\t\t// returns: dojo/Deferred\r\n\r\n\t\t\toptions = options || {};\r\n\t\t\toptions.overwrite = false;\r\n\t\t\treturn this.put(object, options);\r\n\t\t},\r\n\r\n\t\tremove: function(id) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tDeletes an object by its identity.\r\n\t\t\t// id: Number\r\n\t\t\t//\t\tThe identity to use to delete the object\r\n\t\t\t// returns: dojo/Deferred\r\n\r\n\t\t\tthis.cachedCount = {}; // clear the count cache\r\n\t\t\treturn this._callOnStore('delete', [id]);\r\n\t\t},\r\n\r\n\t\tquery: function(query, options) {\r\n\t\t\t// summary:\r\n\t\t\t//\t\tQueries the store for objects.\r\n\t\t\t// query: Object\r\n\t\t\t//\t\tThe query to use for retrieving objects from the store.\r\n\t\t\t// options: __QueryOptions?\r\n\t\t\t//\t\tThe optional arguments to apply to the resultset.\r\n\t\t\t// returns: dojo/store/api/Store.QueryResults\r\n\t\t\t//\t\tThe results of the query, extended with iterative methods.\r\n\r\n\t\t\toptions = options || {};\r\n\t\t\tvar start = options.start || 0;\r\n\t\t\tvar count = options.count || Infinity;\r\n\t\t\tvar sortOption = options.sort;\r\n\t\t\tvar store = this;\r\n\r\n\t\t\t// an array, do a union\r\n\t\t\tif (query.forEach) {\r\n\t\t\t\tvar sortOptions = {sort: sortOption};\r\n\t\t\t\tvar sorter = this.queryEngine({}, sortOptions);\r\n\t\t\t\tvar totals = [];\r\n\t\t\t\tvar collectedCount = 0;\r\n\t\t\t\tvar inCount = 0;\r\n\t\t\t\treturn queryFromFilter({\r\n\t\t\t\t\ttotal: {\r\n\t\t\t\t\t\tthen: function() {\r\n\t\t\t\t\t\t\t// do it lazily again\r\n\t\t\t\t\t\t\treturn all(totals).then(function(totals) {\r\n\t\t\t\t\t\t\t\treturn totals.reduce(function(a, b) {\r\n\t\t\t\t\t\t\t\t\treturn a + b;\r\n\t\t\t\t\t\t\t\t}) * collectedCount / (inCount || 1);\r\n\t\t\t\t\t\t\t}).then.apply(this, arguments);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tfilter: function(callback, thisObj) {\r\n\t\t\t\t\t\tvar index = 0;\r\n\t\t\t\t\t\tvar queues = [];\r\n\t\t\t\t\t\tvar done;\r\n\t\t\t\t\t\tvar collected = {};\r\n\t\t\t\t\t\tvar results = [];\r\n\t\t\t\t\t\t// wait for all the union segments to complete\r\n\t\t\t\t\t\treturn all(query.map(function(part, i) {\r\n\t\t\t\t\t\t\tvar queue = queues[i] = [];\r\n\t\t\t\t\t\t\tfunction addToQueue(object) {\r\n\t\t\t\t\t\t\t\t// to the queue that is kept for each individual query for merge sorting\r\n\t\t\t\t\t\t\t\tqueue.push(object);\r\n\t\t\t\t\t\t\t\tvar nextInQueues = []; // so we can index of the selected choice\r\n\t\t\t\t\t\t\t\tvar toMerge = [];\r\n\t\t\t\t\t\t\t\twhile(queues.every(function(queue) {\r\n\t\t\t\t\t\t\t\t\t\tif (queue.length > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tvar next = queue[0];\r\n\t\t\t\t\t\t\t\t\t\t\tif (next) {\r\n\t\t\t\t\t\t\t\t\t\t\t\ttoMerge.push(next);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\treturn nextInQueues.push(next);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t})){\r\n\t\t\t\t\t\t\t\t\tif (index >= start + count || toMerge.length === 0) {\r\n\t\t\t\t\t\t\t\t\t\tdone = true;\r\n\t\t\t\t\t\t\t\t\t\treturn; // exit filter loop\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tvar nextSelected = sorter(toMerge)[0];\r\n\t\t\t\t\t\t\t\t\t// shift it off the selected queue\r\n\t\t\t\t\t\t\t\t\tqueues[nextInQueues.indexOf(nextSelected)].shift();\r\n\t\t\t\t\t\t\t\t\tif (index++ >= start) {\r\n\t\t\t\t\t\t\t\t\t\tresults.push(nextSelected);\r\n\t\t\t\t\t\t\t\t\t\tif (!callback.call(thisObj, nextSelected)) {\r\n\t\t\t\t\t\t\t\t\t\t\tdone = true;\r\n\t\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tnextInQueues = [];// reset\r\n\t\t\t\t\t\t\t\t\ttoMerge = [];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tvar queryResults = store.query(part, sortOptions);\r\n\t\t\t\t\t\t\ttotals[i] = queryResults.total;\r\n\t\t\t\t\t\t\treturn queryResults.filter(function(object) {\r\n\t\t\t\t\t\t\t\tif (done) {\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tvar id = store.getIdentity(object);\r\n\t\t\t\t\t\t\t\tinCount++;\r\n\t\t\t\t\t\t\t\tif (id in collected) {\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tcollectedCount++;\r\n\t\t\t\t\t\t\t\tcollected[id] = true;\r\n\t\t\t\t\t\t\t\treturn addToQueue(object);\r\n\t\t\t\t\t\t\t}).then(function(results) {\r\n\t\t\t\t\t\t\t\t// null signifies the end of this particular query result\r\n\t\t\t\t\t\t\t\taddToQueue(null);\r\n\t\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t})).then(function() {\r\n\t\t\t\t\t\t\treturn results;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tvar keyRange;\r\n\t\t\tvar alreadySearchedProperty;\r\n\t\t\tvar queryId = JSON.stringify(query) + '-' + JSON.stringify(options.sort);\r\n\t\t\tvar advance;\r\n\t\t\tvar bestIndex, bestIndexQuality = 0;\r\n\t\t\tvar indexTries = 0;\r\n\t\t\tvar filterValue;\r\n\r\n\t\t\tfunction tryIndex(indexName, quality, factor) {\r\n\t\t\t\tindexTries++;\r\n\t\t\t\tvar indexDefinition = store.indices[indexName];\r\n\t\t\t\tif (indexDefinition && indexDefinition.indexed !== false) {\r\n\t\t\t\t\tquality = quality || indexDefinition.preference * (factor || 1) || 0.001;\r\n\t\t\t\t\tif (quality > bestIndexQuality) {\r\n\t\t\t\t\t\tbestIndexQuality = quality;\r\n\t\t\t\t\t\tbestIndex = indexName;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tindexTries++;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var i in query) {\r\n\t\t\t\t// test all the filters as possible indices to drive the query\r\n\t\t\t\tfilterValue = query[i];\r\n\t\t\t\tvar range = false;\r\n\t\t\t\tvar wildcard, newFilterValue = null;\r\n\r\n\t\t\t\tif (typeof filterValue === 'boolean') {\r\n\t\t\t\t\t// can't use booleans as filter keys\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (filterValue) {\r\n\t\t\t\t\tif (filterValue.from || filterValue.to) {\r\n\t\t\t\t\t\trange = true;\r\n\t\t\t\t\t\t(function(from, to) {\r\n\t\t\t\t\t\t\t// convert a to/from object to a testable object with a keyrange\r\n\t\t\t\t\t\t\tnewFilterValue = {\r\n\t\t\t\t\t\t\t\ttest: function(value) {\r\n\t\t\t\t\t\t\t\t\treturn !from || from <= value &&\r\n\t\t\t\t\t\t\t\t\t\t\t(!to || to >= value);\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\tkeyRange: from ?\r\n\t\t\t\t\t\t\t\t\t\t  to ?\r\n\t\t\t\t\t\t\t\t\t\t  IDBKeyRange.bound(from, to, filterValue.excludeFrom, filterValue.excludeTo) :\r\n\t\t\t\t\t\t\t\t\t\t  IDBKeyRange.lowerBound(from, filterValue.excludeFrom) :\r\n\t\t\t\t\t\t\t\t\t\t  IDBKeyRange.upperBound(to, filterValue.excludeTo)\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t})(filterValue.from, filterValue.to);\r\n\t\t\t\t\t} else if (typeof filterValue === 'object' && filterValue.contains) {\r\n\t\t\t\t\t\t// contains is for matching any value in a given array to any value in the target indices array\r\n\t\t\t\t\t\t// this expects a multiEntry: true index\r\n\t\t\t\t\t\t(function(contains) {\r\n\t\t\t\t\t\t\tvar keyRange, first = contains[0];\r\n\r\n\t\t\t\t\t\t\tvar wildcard = first && first.match && first.match(wildcardRe);\r\n\t\t\t\t\t\t\tif (wildcard) {\r\n\t\t\t\t\t\t\t\tfirst = wildcard[1];\r\n\t\t\t\t\t\t\t\tkeyRange = IDBKeyRange.bound(first, first + '~');\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tkeyRange = IDBKeyRange.only(first);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tnewFilterValue = {\r\n\t\t\t\t\t\t\t\ttest: function(value) {\r\n\t\t\t\t\t\t\t\t\treturn contains.every(function(item) {\r\n\t\t\t\t\t\t\t\t\t\tvar wildcard = item && item.match && item.match(wildcardRe);\r\n\t\t\t\t\t\t\t\t\t\tif (wildcard) {\r\n\t\t\t\t\t\t\t\t\t\t\titem = wildcard[1];\r\n\t\t\t\t\t\t\t\t\t\t\treturn value && value.some(function(part) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn part.slice(0, item.length) === item;\r\n\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\treturn value && value.indexOf(item) > -1;\r\n\t\t\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\tkeyRange: keyRange\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t})(filterValue.contains);\r\n\t\t\t\t\t} else if((wildcard = filterValue.match && filterValue.match(wildcardRe))) {\r\n\t\t\t\t\t\t// wildcard matching\r\n\t\t\t\t\t\tvar matchStart = wildcard[1];\r\n\t\t\t\t\t\tnewFilterValue = new RegExp('^' + matchStart);\r\n\t\t\t\t\t\tnewFilterValue.keyRange = IDBKeyRange.bound(matchStart, matchStart + '~');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (newFilterValue) {\r\n\t\t\t\t\tquery[i] = newFilterValue;\r\n\t\t\t\t}\r\n\t\t\t\ttryIndex(i, null, range ? 0.1 : 1);\r\n\t\t\t}\r\n\t\t\tvar descending;\r\n\t\t\tif (sortOption) {\r\n\t\t\t\t// this isn't necessarily the best heuristic to determine the best index\r\n\t\t\t\tvar mainSort = sortOption[0];\r\n\t\t\t\tif (mainSort.attribute === bestIndex || tryIndex(mainSort.attribute, 1)) {\r\n\t\t\t\t\tdescending = mainSort.descending;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// we need to sort afterwards now\r\n\t\t\t\t\tvar postSorting = true;\r\n\t\t\t\t\t// we have to retrieve everything in this case\r\n\t\t\t\t\tstart = 0;\r\n\t\t\t\t\tcount = Infinity;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar cursorRequestArgs;\r\n\t\t\tif (bestIndex) {\r\n\t\t\t\tif (bestIndex in query) {\r\n\t\t\t\t\t// we are filtering\r\n\t\t\t\t\tfilterValue = query[bestIndex];\r\n\t\t\t\t\tif (filterValue && (filterValue.keyRange)) {\r\n\t\t\t\t\t\tkeyRange = filterValue.keyRange;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tkeyRange = IDBKeyRange.only(filterValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\talreadySearchedProperty = bestIndex;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tkeyRange = null;\r\n\t\t\t\t}\r\n\t\t\t\tcursorRequestArgs = [keyRange, descending ? 'prev' : 'next'];\r\n\t\t\t} else {\r\n\t\t\t\t// no index, no arguments required\r\n\t\t\t\tcursorRequestArgs = [];\r\n\t\t\t}\r\n\t\t\t// console.log(\"using index\", bestIndex);\r\n\t\t\tvar cachedPosition = store.cachedPosition;\r\n\t\t\tif (cachedPosition && cachedPosition.queryId === queryId &&\r\n\t\t\t\t\tcachedPosition.offset < start && indexTries > 1) {\r\n\t\t\t\tadvance = cachedPosition.preFilterOffset + 1;\r\n\t\t\t\t// make a new copy, so we don't have concurrency issues\r\n\t\t\t\tstore.cachedPosition = cachedPosition = lang.mixin({}, cachedPosition);\r\n\t\t\t} else {\r\n\t\t\t\t// cache of the position, tracking our traversal progress\r\n\t\t\t\tcachedPosition = store.cachedPosition = {\r\n\t\t\t\t\toffset: -1,\r\n\t\t\t\t\tpreFilterOffset: -1,\r\n\t\t\t\t\tqueryId: queryId\r\n\t\t\t\t};\r\n\t\t\t\tif (indexTries < 2) {\r\n\t\t\t\t\t// can skip to advance\r\n\t\t\t\t\tcachedPosition.offset = cachedPosition.preFilterOffset = (advance = start) - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar filter = this.queryEngine(query);\r\n\t\t\t// this is adjusted so we can compute the total more accurately\r\n\t\t\tvar filteredResults = {\r\n\t\t\t\ttotal: {\r\n\t\t\t\t\tthen: function(callback) {\r\n\t\t\t\t\t\t// make this a lazy promise, only executing if we need to\r\n\t\t\t\t\t\tvar cachedCount = store.cachedCount[queryId];\r\n\t\t\t\t\t\tif (cachedCount){\r\n\t\t\t\t\t\t\treturn callback(adjustTotal(cachedCount));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvar countPromise = (keyRange ? store._callOnStore('count', [keyRange], bestIndex) : store._callOnStore('count'));\r\n\t\t\t\t\t\t\treturn (this.then = countPromise.then(adjustTotal)).then.apply(this, arguments);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfunction adjustTotal(total) {\r\n\t\t\t\t\t\t\t// we estimate the total count base on the matching rate\r\n\t\t\t\t\t\t\tstore.cachedCount[queryId] = total;\r\n\t\t\t\t\t\t\treturn Math.round((cachedPosition.offset + 1.01) / (cachedPosition.preFilterOffset + 1.01) * total);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tfilter: function(callback, thisObj) {\r\n\t\t\t\t\t// this is main implementation of the the query results traversal, forEach and map use this method\r\n\t\t\t\t\tvar deferred = new Deferred();\r\n\t\t\t\t\tvar all = [];\r\n\t\t\t\t\tfunction openCursor() {\r\n\t\t\t\t\t\t// get the cursor\r\n\t\t\t\t\t\twhen(store._callOnStore('openCursor', cursorRequestArgs, bestIndex, true), function(cursorRequest) {\r\n\t\t\t\t\t\t\t// this will be called for each iteration in the traversal\r\n\t\t\t\t\t\t\tcursorsRunning++;\r\n\t\t\t\t\t\t\tcursorRequest.onsuccess = function(event) {\r\n\t\t\t\t\t\t\t\tcursorsRunning--;\r\n\t\t\t\t\t\t\t\tvar cursor = event.target.result;\r\n\t\t\t\t\t\t\t\tif (cursor) {\r\n\t\t\t\t\t\t\t\t\tif (advance) {\r\n\t\t\t\t\t\t\t\t\t\t// we can advance through and wait for the completion\r\n\t\t\t\t\t\t\t\t\t\tcursor.advance(advance);\r\n\t\t\t\t\t\t\t\t\t\tcursorsRunning++;\r\n\t\t\t\t\t\t\t\t\t\tadvance = false;\r\n\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tcachedPosition.preFilterOffset++;\r\n\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\tvar item = cursor.value;\r\n\t\t\t\t\t\t\t\t\t\tif (options.join) {\r\n\t\t\t\t\t\t\t\t\t\t\titem = options.join(item);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\treturn when(item, function(item) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (filter.matches(item)) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcachedPosition.offset++;\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (cachedPosition.offset >= start) { // make sure we are after the start\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tall.push(item);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (!callback.call(thisObj, item) || cachedPosition.offset >= start + count - 1) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// finished\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcursorRequest.lastCursor = cursor;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.resolve(all);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tqueueCursor();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t// submit our cursor to the priority queue for continuation, now or when our turn comes up\r\n\t\t\t\t\t\t\t\t\t\t\treturn queueCursor(cursor, options.priority, function() {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// retry function, that we provide to the queue to use if the cursor can't be continued due to interruption\r\n\t\t\t\t\t\t\t\t\t\t\t\t// if called, open the cursor again, and continue from our current position\r\n\t\t\t\t\t\t\t\t\t\t\t\tadvance = cachedPosition.preFilterOffset;\r\n\t\t\t\t\t\t\t\t\t\t\t\topenCursor();\r\n\t\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\t\t} catch(e) {\r\n\t\t\t\t\t\t\t\t\t\tdeferred.reject(e);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tdeferred.resolve(all);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// let any other cursors start executing now\r\n\t\t\t\t\t\t\t\tqueueCursor();\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tcursorRequest.onerror = function(error) {\r\n\t\t\t\t\t\t\t\tcursorsRunning--;\r\n\t\t\t\t\t\t\t\tdeferred.reject(error);\r\n\t\t\t\t\t\t\t\tqueueCursor();\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\topenCursor();\r\n\t\t\t\t\treturn deferred.promise;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tif (postSorting) {\r\n\t\t\t\t// we are using the index to do filtering, so we are going to have to sort the entire list\r\n\t\t\t\tvar sorter = this.queryEngine({}, options);\r\n\t\t\t\tvar sortedResults = lang.delegate(filteredResults.filter(yes).then(function(results) {\r\n\t\t\t\t\treturn sorter(results);\r\n\t\t\t\t}));\r\n\t\t\t\tsortedResults.total = filteredResults.total;\r\n\t\t\t\treturn new QueryResults(sortedResults);\r\n\t\t\t}\r\n\t\t\treturn options.rawResults ? filteredResults : queryFromFilter(filteredResults);\r\n\t\t}\r\n\t});\r\n\r\n});\r\n"]}