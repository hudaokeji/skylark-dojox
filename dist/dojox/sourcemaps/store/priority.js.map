{"version":3,"sources":["store/priority.js"],"names":["define","lang","Deferred","when","queue","running","store","config","priorityStore","delegate","forEach","method","original","first","options","def","executor","deferred","immediate","call","callback","queryResults","resolve","results","promise","total","then","errback","wrapper","thisObj","map","filter","reject","value","error","priority","push","processQueue","length","queueForPriorityLevel","action","pop","e"],"mappings":";;;;;;;AAAAA,QAAQ,kBAAmB,gBAAiB,aAAc,SAASC,EAAMC,EAAUC,GAQlF,IAAIC,KACAC,EAAU,EAuEd,OAAO,SAASC,EAAOC,GACtBA,EAASA,MACT,IAAIC,EAAgBP,EAAKQ,SAASH,GAuDlC,OArDC,MAAO,MAAO,QAAS,SAAU,OAAOI,QAAQ,SAASC,GACzD,IAAIC,EAAWN,EAAMK,GAClBC,IACFJ,EAAcG,GAAU,SAASE,EAAOC,GAEvC,IAAIC,EAAKC,EA/CRC,EAgDD,IAFAH,EAAUA,OAECI,UAEV,OAAON,EAASO,KAAKb,EAAOO,EAAOC,GAIpCA,EAAQI,WAAY,EACN,UAAXP,GAEFK,EAAW,SAASI,GAEnB,IAAIC,EAAeT,EAASO,KAAKb,EAAOO,EAAOC,GAC/CC,EAAIO,SAASC,QAASF,IAEtBlB,EAAKkB,EAAcD,EAAUA,IA9D9BH,EAAW,IAAIf,EAiEfa,GA/DHS,SACCC,OAECC,KAAM,SAASN,EAAUO,GACxB,OAAOV,EAASS,KAAK,SAASE,GAC7B,OAAOA,EAAQL,QAAQE,QACrBC,KAAKN,EAAUO,KAGpBjB,QAAS,SAASU,EAAUS,GAE3B,OAAOZ,EAASS,KAAK,SAASE,GAE7B,OAAOA,EAAQL,QAAQb,QAAQU,EAAUS,MAG3CC,IAAK,SAASV,EAAUS,GACvB,OAAOZ,EAASS,KAAK,SAASE,GAC7B,OAAOA,EAAQL,QAAQO,IAAIV,EAAUS,MAGvCE,OAAQ,SAASX,EAAUS,GAC1B,OAAOZ,EAASS,KAAK,SAASE,GAC7B,OAAOA,EAAQL,QAAQQ,OAAOX,EAAUS,MAG1CH,KAAM,SAASN,EAAUO,GACxB,OAAOV,EAASS,KAAK,SAASE,GAC7B,OAAOzB,EAAKyB,EAAQL,QAASH,EAAUO,OAI1CL,QAASL,EAASK,QAClBU,OAAQf,EAASe,UAgCdhB,EAAW,SAASI,GAEnBjB,EAAKS,EAASO,KAAKb,EAAOO,EAAOC,GAAU,SAASmB,GACnDlB,EAAIO,QAAQW,GACZb,KAED,SAASc,GACRnB,EAAIiB,OAAOE,GACXd,OAKFL,EAAM,IAAIb,GAGX,IAAIiC,EAAWrB,EAAQqB,UAAY,EAClCrB,EAAQqB,SACR5B,EAAO4B,UAAY,EAClB5B,EAAO4B,SAAW,EAKpB,OAJC/B,EAAM+B,KAAc/B,EAAM+B,QAAiBC,MAC1CpB,SAAWA,EAAUD,IAAKA,IAxHhC,SAASsB,IAKR,IAAI,IAAIF,EAAW/B,EAAMkC,OAAS,EAAGH,GAAY9B,EAAS8B,IAAW,CAEpE,IAAII,EAAwBnC,EAAM+B,GAC9BK,EAASD,GAAyBA,EAAsBA,EAAsBD,OAAS,GAC3F,GAAGE,EAAO,CACTD,EAAsBE,MAEtBpC,IACA,IACCmC,EAAOxB,SAAS,WACfX,IAEAgC,MAED,MAAMK,GACNF,EAAOzB,IAAIiB,OAAOU,GAClBL,OAqGAA,GACOtB,EAAIS,YAIPhB","file":"../../store/priority.js","sourcesContent":["define(['dojo/_base/lang', 'dojo/Deferred', 'dojo/when'], function(lang, Deferred, when){\r\n// summary:\r\n//\t\tThis is a store wrapper that provides prioritized operations. One can include a \"priority\" property in the options\r\n//\t\tproperty that is a number representing the priority, for get, put, add, remove, or query calls. The associated\r\n//\t\taction will execute before any other actions in the queue that have a lower priority. The priority queue will also\r\n//\t\tthrottle the execution of actions to limit the number of concurrent actions to the priority number. If you submit\r\n//\t\tan action with a priority of 3, it will not be executed until there are at most 2 other concurrent actions.\r\n\r\n\tvar queue = []; // the main queue\r\n\tvar running = 0; // how many actions are running\r\n\tfunction processQueue(){\r\n\t\t// here we pull actions of the queue and run them\r\n\t\t// each priority level has it's own sub-queue, we go\r\n\t\t// from highest to lowest, stopping if we hit the minimum\r\n\t\t// priority for the currently running operations\r\n\t\tfor(var priority = queue.length - 1; priority >= running; priority--){\r\n\t\t\t// get the sub-queue for this priority\r\n\t\t\tvar queueForPriorityLevel = queue[priority];\r\n\t\t\tvar action = queueForPriorityLevel && queueForPriorityLevel[queueForPriorityLevel.length - 1];\r\n\t\t\tif(action){\r\n\t\t\t\tqueueForPriorityLevel.pop();\r\n\t\t\t\t// track the number currently running\r\n\t\t\t\trunning++;\r\n\t\t\t\ttry{\r\n\t\t\t\t\taction.executor(function(){\r\n\t\t\t\t\t\trunning--;\r\n\t\t\t\t\t\t// once finished, process the next one in the queue\r\n\t\t\t\t\t\tprocessQueue();\r\n\t\t\t\t\t});\r\n\t\t\t\t}catch(e){\r\n\t\t\t\t\taction.def.reject(e);\r\n\t\t\t\t\tprocessQueue();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction deferredResults(){\r\n\t\t// because a query result set is not merely a promise that can be piped through, we have\r\n\t\t// to recreate the full result set API to defer the execution of query, within each of the\r\n\t\t// methods we wait for the promise for the query result to finish. We have to wrap this\r\n\t\t// in an object wrapper so that the returned promise doesn't further defer access to the\r\n\t\t// query result set\r\n\t\tvar deferred = new Deferred();\r\n\t\treturn  {\r\n\t\t\tpromise: {\r\n\t\t\t\ttotal: {\r\n\t\t\t\t\t// allow for lazy access to the total\r\n\t\t\t\t\tthen: function(callback, errback){\r\n\t\t\t\t\t\treturn deferred.then(function(wrapper){\r\n\t\t\t\t\t\t\treturn wrapper.results.total;\r\n\t\t\t\t\t\t}).then(callback, errback);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tforEach: function(callback, thisObj){\r\n\t\t\t\t\t// wait for the action to be executed\r\n\t\t\t\t\treturn deferred.then(function(wrapper){\r\n\t\t\t\t\t\t// now run the forEach\r\n\t\t\t\t\t\treturn wrapper.results.forEach(callback, thisObj);\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\tmap: function(callback, thisObj){\r\n\t\t\t\t\treturn deferred.then(function(wrapper){\r\n\t\t\t\t\t\treturn wrapper.results.map(callback, thisObj);\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\tfilter: function(callback, thisObj){\r\n\t\t\t\t\treturn deferred.then(function(wrapper){\r\n\t\t\t\t\t\treturn wrapper.results.filter(callback, thisObj);\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\tthen: function(callback, errback){\r\n\t\t\t\t\treturn deferred.then(function(wrapper){\r\n\t\t\t\t\t\treturn when(wrapper.results, callback, errback);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tresolve: deferred.resolve,\r\n\t\t\treject: deferred.reject\r\n\t\t};\r\n\t}\r\n\treturn function(store, config){\r\n\t\tconfig = config || {};\r\n\t\tvar priorityStore = lang.delegate(store);\r\n\t\t// setup the handling for each of these methods\r\n\t\t['add', 'put', 'query', 'remove', 'get'].forEach(function(method){\r\n\t\t\tvar original = store[method];\r\n\t\t\tif(original){\r\n\t\t\t\tpriorityStore[method] = function(first, options){\r\n\t\t\t\t\toptions = options || {};\r\n\t\t\t\t\tvar def, executor;\r\n\t\t\t\t\tif(options.immediate){\r\n\t\t\t\t\t\t// if immediate is set, skip the queue\r\n\t\t\t\t\t\treturn original.call(store, first, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// just in case a method calls another method with the same args,\r\n\t\t\t\t\t// default to doing the second call immediately.\r\n\t\t\t\t\toptions.immediate = true;\r\n\t\t\t\t\tif(method === 'query'){\r\n\t\t\t\t\t\t// use the special query result deferral\r\n\t\t\t\t\t\texecutor = function(callback){\r\n\t\t\t\t\t\t\t// execute and resolve the wrapper\r\n\t\t\t\t\t\t\tvar queryResults = original.call(store, first, options);\r\n\t\t\t\t\t\t\tdef.resolve({results: queryResults});\r\n\t\t\t\t\t\t\t// wait until the query results are done before performing the next action\r\n\t\t\t\t\t\t\twhen(queryResults, callback, callback);\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\t// the special query deferred\r\n\t\t\t\t\t\tdef = deferredResults();\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\texecutor = function(callback){\r\n\t\t\t\t\t\t\t// execute the main action (for get, put, add, remove)\r\n\t\t\t\t\t\t\twhen(original.call(store, first, options), function(value){\r\n\t\t\t\t\t\t\t\tdef.resolve(value);\r\n\t\t\t\t\t\t\t\tcallback(); // done\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tfunction(error){\r\n\t\t\t\t\t\t\t\tdef.reject(error);\r\n\t\t\t\t\t\t\t\tcallback();\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\t// can use a standard deferred\r\n\t\t\t\t\t\tdef = new Deferred();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// add to the queue\r\n\t\t\t\t\tvar priority = options.priority > -1 ?\r\n\t\t\t\t\t\toptions.priority :\r\n\t\t\t\t\t\tconfig.priority > -1 ?\r\n\t\t\t\t\t\t\tconfig.priority : 4;\r\n\t\t\t\t\t(queue[priority] || (queue[priority] = [])).push(\r\n\t\t\t\t\t\t{executor:  executor, def: def});\r\n\t\t\t\t\t// get the next one off the queue\r\n\t\t\t\t\tprocessQueue();\r\n\t\t\t\t\treturn def.promise;\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn priorityStore;\r\n\t};\r\n});"]}